<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>E. Other Operators</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="app05">E. Other Operators</h2>
<p><a id="page_1235"/>To avoid terminal obesity, the main text of this book doesn&#8217;t cover three groups of operators. The first group consists of the bitwise operators, which let you manipulate individual bits in a value; these operators were inherited from C. The second group consists of two-member dereferencing operators; they are C++ additions. The third group includes operators added by C++11: <code>alignof</code> and <code>noexcept</code>. This appendix briefly summarizes these operators.</p>
<h3 id="app05lev1sec1">Bitwise Operators</h3>
<p>The bitwise operators operate on the bits of integer values. For example, the left-shift operator moves bits to the left, and the bitwise negation operator turns each <code>1</code> to a <code>0</code> and each <code>0</code> to a <code>1</code>. Altogether, C++ has six such operators: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>~</code>, <code>&#38;</code>, <code>|</code>, and <code>^</code>.</p>
<h4 id="app05lev2sec1">The Shift Operators</h4>
<p>The left-shift operator has the following syntax:</p>
<p class="programlisting"><span class="EmpItalic">value</span> &lt;&lt; <span class="EmpItalic">shift</span></p>
<p>Here <em><code>value</code></em> is the integer value to be shifted, and <em><code>shift</code></em> is the number of bits to shift. For example, the following shifts all the bits in the value <code>13</code> three places to the left:</p>
<p class="programlisting">13 &lt;&lt; 3</p>
<p>The vacated places are filled with zeros, and bits shifted past the end are discarded (see <a href="#app05fig01">Figure E.1</a>).</p>
<p class="caption"><a id="app05fig01"/><strong>Figure E.1. The left-shift operator.</strong></p>
<p class="image"><img src="graphics/xefig01.jpg" alt="Image"/></p>
<p>Because each bit position represents a value twice that of the bit to the right (see <a href="app01.html#app01">Appendix A</a>, &#8220;<a href="app01.html#app01">Number Bases</a>&#8221;), shifting one bit position is equivalent to multiplying the value by 2. Similarly, shifting two bit positions is equivalent to multiplying by 2<sup>2</sup>, and shifting n positions is equivalent to multiplying by 2<sup>n</sup>. Thus, the value of <code>13 &lt;&lt; 3</code> is 13&#215;2<sup>3</sup>, or 104.</p>
<p><a id="page_1236"/>The left-shift operator provides a capability often found in assembly languages. However, an assembly language left-shift operator directly alters the contents of a register, whereas the C++ left-shift operator produces a new value without altering existing values. For example, consider the following:</p>
<p class="programlisting">int x = 20;<br/>int y = x &lt;&lt; 3;</p>
<p>This code doesn&#8217;t change the value of <code>x</code>. The expression <code>x &lt;&lt; 3</code> uses the value of <code>x</code> to produce a new value, much as <code>x + 3</code> produces a new value without altering <code>x</code>.</p>
<p>If you want to use the left-shift operator to change the value of a variable, you must also use assignment. You can use regular assignment or the <code>&lt;&lt;=</code> operator, which combines shifting with assignment:</p>
<p class="programlisting">x = x &lt;&lt; 4;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// regular assignment<br/>y &lt;&lt;= 2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// shift and assign</p>
<p>The right-shift operator (<code>&gt;&gt;</code>), as you might expect, shifts bits to the right. It has the following syntax:</p>
<p class="programlisting"><span class="EmpItalic">value</span> &gt;&gt; <span class="EmpItalic">shift</span></p>
<p>Here <em><code>value</code></em> is the integer value to be shifted, and <em><code>shift</code></em> is the number of bits to shift. For example, the following shifts all the bits in the value <code>17</code> two places to the right:</p>
<p class="programlisting">17 &gt;&gt; 2</p>
<p>For unsigned integers, the vacated places are filled with zeros, and bits shifted past the end are discarded. For signed integers, vacated places may be filled with zeros or else with the value of the original leftmost bit. The choice depends on the C++ implementation. (<a href="#app05fig02">Figure E.2</a> shows an example that illustrates filling with zeros.)</p>
<p class="caption"><a id="app05fig02"/><strong>Figure E.2. The right-shift operator.</strong></p>
<p class="image"><img src="graphics/xefig02.jpg" alt="Image"/></p>
<p>The right-shift operator. Shifting one place to the right is equivalent to integer division by 2. In general, shifting n places to the right is equivalent to integer division by 2<sup>n</sup>.</p>
<p><a id="page_1237"/>C++ also defines a right-shift-and-assign operator that you can use to replace the value of a variable by the shifted value:</p>
<p class="programlisting">int q = 43;<br/>q &gt;&gt;= 2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// replace 43 by 43 &gt;&gt; 2, or 10</p>
<p>On some systems, using left- and right-shift operators may produce faster integer multiplication and division by 2 than using the division operator, but as compilers get better at optimizing code, such differences are fading.</p>
<h4 id="app05lev2sec2">The Logical Bitwise Operators</h4>
<p>The logical bitwise operators are analogous to the regular logical operators, except they apply to a value on a bit-by-bit basis rather than to the whole. For example, consider the regular negation operator (<code>!</code>) and the bitwise negation (or complement) operator (<code>~</code>). The <code>!</code> operator converts a <code>true</code> (or nonzero) value to <code>false</code> and a <code>false</code> value to <code>true</code>. The <code>~</code> operator converts each individual bit to its opposite (<code>1</code> to <code>0</code> and <code>0</code> to <code>1</code>). For example, consider the <code>unsigned char</code> value of <code>3</code>:</p>
<p class="programlisting">unsigned char x = 3;</p>
<p>The expression <code>!x</code> has the value <code>0</code>. To see the value of <code>~x</code>, you write it in binary form: <code>00000011</code>. Then you convert each <code>0</code> to <code>1</code> and each <code>1</code> to <code>0</code>. This produces the value <code>11111100</code>, which in base 10 is the value <code>252</code>. (<a href="#app05fig03">Figure E.3</a> shows a 16-bit example.) The new value is termed the <em>complement</em> of the original value.</p>
<p class="caption"><a id="app05fig03"/><strong>Figure E.3. The bitwise negation operator.</strong></p>
<p class="image"><img src="graphics/xefig03.jpg" alt="Image"/></p>
<p>The bitwise OR operator (<code>|</code>) combines two integer values to produce a new integer value. Each bit in the new value is set to <code>1</code> if one or the other, or both, of the corresponding bits in the original values is set to <code>1</code>. If both corresponding bits are <code>0</code>, then the final bit is set to <code>0</code> (see <a href="#app05fig04">Figure E.4</a>).</p>
<p class="caption"><a id="page_1238"/><a id="app05fig04"/><strong>Figure E.4. The bitwise OR operator.</strong></p>
<p class="image"><img src="graphics/xefig04.jpg" alt="Image"/></p>
<p><a href="#app05table01">Table E.1</a> summarizes how the <code>|</code> operator combines bits.</p>
<p class="caption"><a id="app05table01"/><strong>Table E.1. The Value of <code>b1 | b2</code></strong></p>
<p class="image"><img src="graphics/app-e-tab01.jpg" alt="Image"/></p>
<p>The <code>|=</code> operator combines the bitwise OR operator with assignment:</p>
<p class="programlisting">a |= b;&#160;&#160;// set a to a | b</p>
<p>The bitwise XOR operator (<code>^</code>) combines two integer values to produce a new integer value. Each bit in the new value is set to <code>1</code> if one or the other, but not both, of the corresponding bits in the original values is set to <code>1</code>. If both corresponding bits are <code>0</code> or both are <code>1</code>, the final bit is set to <code>0</code> (see <a href="#app05fig05">Figure E.5</a>).</p>
<p class="caption"><a id="page_1239"/><a id="app05fig05"/><strong>Figure E.5. The bitwise XOR operator.</strong></p>
<p class="image"><img src="graphics/xefig05.jpg" alt="Image"/></p>
<p><a href="#app05table02">Table E.2</a> summarizes how the <code>^</code> operator combines bits.</p>
<p class="caption"><a id="app05table02"/><strong>Table E.2. The Value of <code>b1 ^ b2</code></strong></p>
<p class="image"><img src="graphics/app-e-tab02.jpg" alt="Image"/></p>
<p>The <code>^=</code> operator combines the bitwise XOR operator with assignment:</p>
<p class="programlisting">a ^= b;&#160;&#160;// set a to a ^ b</p>
<p>The bitwise AND operator (<code>&#38;</code>) combines two integer values to produce a new integer value. Each bit in the new value is set to <code>1</code> only if both of the corresponding bits in the original values are set to <code>1</code>. If either or both corresponding bits are <code>0</code>, the final bit is set to <code>0</code> (see <a href="#app05fig06">Figure E.6</a>).</p>
<p class="caption"><a id="app05fig06"/><strong>Figure E.6. The bitwise AND operator.</strong></p>
<p class="image"><img src="graphics/xefig06.jpg" alt="Image"/></p>
<p><a id="page_1240"/><a href="#app05table03">Table E.3</a> summarizes how the <code>&#38;</code> operator combines bits.</p>
<p class="caption"><a id="app05table03"/><strong>Table E.3. The Value of <code>b1 &#38; b2</code></strong></p>
<p class="image"><img src="graphics/app-e-tab03.jpg" alt="Image"/></p>
<p>The <code>&#38;=</code> operator combines the bitwise AND operator with assignment:</p>
<p class="programlisting">a &#38;= b;&#160;&#160;// set a to a &#38; b</p>
<h4 id="app05lev2sec3">Alternative Representations of Bitwise Operators</h4>
<p>C++ provides alternative representations of several bitwise operators, as shown in <a href="#app05table04">Table E.4</a>. They are provided for locales that do not have the traditional bitwise operators as part of their character sets.</p>
<p class="caption"><a id="app05table04"/><strong>Table E.4. Bitwise Operator Representations</strong></p>
<p class="image"><img src="graphics/app-e-tab04.jpg" alt="Image"/></p>
<p>These alternative forms let you write statements like the following:</p>
<p class="programlisting">b = compl a bitand b;&#160;&#160;// same as b = ~a &#38; b;<br/>c = a xor b;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// same as c = a ^ c;</p>
<h4 id="app05lev2sec4">A Few Common Bitwise Operator Techniques</h4>
<p>Often controlling hardware involves turning particular bits on or off or checking their status. The bitwise operators provide the means to perform such actions. We&#8217;ll go through the methods quickly.</p>
<p>In the following examples, <code>lottabits</code> represents a general value, and <code>bit</code> represents the value corresponding to a particular bit. Bits are numbered from right to left, beginning with bit 0, so the value corresponding to bit position n is 2<sup>n</sup>. For example, an integer <a id="page_1241"/>with only bit number 3 set to <code>1</code> has the value 2<sup>3</sup> or <code>8</code>. In general, each individual bit corresponds to a power of 2, as described for binary numbers in <a href="app01.html#app01">Appendix A</a>. So we&#8217;ll use the term <em>bit</em> to represent a power of 2; this corresponds to a particular bit being set to <code>1</code> and all other bits being set to <code>0</code>.</p>
<h5 id="app05lev3sec1">Turning a Bit On</h5>
<p>The following two operations each turn on the bit in <code>lottabits</code> that corresponds to the bit represented by <code>bit</code>:</p>
<p class="programlisting">lottabits = lottabits | bit;<br/>lottabits |= bit;</p>
<p>Each sets the corresponding bit to <code>1</code>, regardless of the former value of the bit. That&#8217;s because ORing <code>1</code> with either <code>0</code> or <code>1</code> produces <code>1</code>. All other bits in <code>lottabits</code> remain unaltered. That&#8217;s because ORing <code>0</code> with <code>0</code> produces <code>0</code>, and ORing <code>0</code> with <code>1</code> produces <code>1</code>.</p>
<h5 id="app05lev3sec2">Toggling a Bit</h5>
<p>The following two operations each toggle the bit in <code>lottabits</code> that corresponds to the bit represented by <code>bit</code>. That is, they turn the bit on if it is off, and they turn it off if it is on:</p>
<p class="programlisting">lottabits = lottabits ^ bit;<br/>lottabits ^= bit;</p>
<p>XORing <code>1</code> with <code>0</code> produces <code>1</code>, turning an off bit on, and XORing <code>1</code> with <code>1</code> produces <code>0</code>, turning an on bit off. All other bits in <code>lottabits</code> remain unaltered. That&#8217;s because XORing <code>0</code> with <code>0</code> produces <code>0</code>, and XORing <code>0</code> with <code>1</code> produces <code>1</code>.</p>
<h5 id="app05lev3sec3">Turning a Bit Off</h5>
<p>The following operation turns off the bit in <code>lottabits</code> that corresponds to the bit represented by <code>bit</code>:</p>
<p class="programlisting">lottabits = lottabits &#38; ~bit;</p>
<p>These statements turn the bit off, regardless of its prior state. First, the operator <code>~bit</code> produces an integer with all its bits set to <code>1</code> <em>except</em> the bit that originally was set to <code>1</code>; that bit becomes <code>0</code>. ANDing a <code>0</code> with any bit results in <code>0</code>, thus turning that bit off. All other bits in <code>lottabits</code> are unchanged. That&#8217;s because ANDing a <code>1</code> with any bit produces the value that bit had before.</p>
<p>Here&#8217;s a briefer way of doing the same thing:</p>
<p class="programlisting">lottabits &#38;= ~bit;</p>
<h5 id="app05lev3sec4">Testing a Bit Value</h5>
<p>Suppose you want to determine whether the bit corresponding to <code>bit</code> is set to <code>1</code> in <code>lottabits</code>. The following test does not necessarily work:</p>
<p class="programlisting">if (lottabits == bit)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no good</p>
<p><a id="page_1242"/>That&#8217;s because even if the corresponding bit in <code>lottabits</code> is set to <code>1</code>, other bits might also be set to <code>1</code>. The equality above is true <em>only</em> when the corresponding bit is <code>1</code>. The fix is to first AND <code>lottabits</code> with <code>bit</code>. This produces a value that is <code>0</code> in all the other bit positions because <code>0</code> AND any value is <code>0</code>. Only the bit corresponding to the bit value is left unchanged because <code>1</code> AND any value is that value. Thus the proper test is this:</p>
<p class="programlisting">if (lottabits &#38; bit == bit)&#160;&#160;&#160;&#160;&#160;&#160;&#160;// testing a bit</p>
<p>Real-world programmers often simplify this test to the following:</p>
<p class="programlisting">if (lottabits &#38; bit)&#160;&#160;&#160;&#160;&#160;&#160;&#160;// testing a bit</p>
<p>Because <code>bit</code> consists of one bit set to <code>1</code> and the rest set to <code>0</code>, the value of <code>lottabits &#38; bit</code> is either <code>0</code> (which tests as <code>false</code>) or <code>bit</code>, which, being nonzero, tests as <code>true</code>.</p>
<h3 id="app05lev1sec2">Member Dereferencing Operators</h3>
<p>C++ lets you define pointers to members of a class. These pointers involve special notations to declare them and to dereference them. To see what&#8217;s involved, let&#8217;s start with a sample class:</p>
<p class="programlisting">class Example<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int feet;<br/>&#160;&#160;&#160;&#160;int inches;<br/>public:<br/>&#160;&#160;&#160;&#160;Example();<br/>&#160;&#160;&#160;&#160;Example(int ft);<br/>&#160;&#160;&#160;&#160;~Example();<br/>&#160;&#160;&#160;&#160;void show_in() const;<br/>&#160;&#160;&#160;&#160;void show_ft() const;<br/>&#160;&#160;&#160;&#160;void use_ptr() const;<br/>};</p>
<p>Consider the <code>inches</code> member. Without a specific object, <code>inches</code> is a label. That is, the class defines <code>inches</code> as a member identifier, but you need an object before you actually have memory allocated:</p>
<p class="programlisting">Example ob;&#160;&#160;// now ob.inches exists</p>
<p>Thus, you specify an actual memory location by using the identifier <code>inches</code> in conjunction with a specific object. (In a member function, you can omit the name of the object, but then the object is understood to be the one pointed to by the pointer.)</p>
<p>C++ lets you define a member pointer to the identifier <code>inches</code> like this:</p>
<p class="programlisting">int Example::*pt = &#38;Example::inches;</p>
<p>This pointer is a bit different from a regular pointer. A regular pointer points to a specific memory location. But the <code>pt</code> pointer doesn&#8217;t point to a specific memory location <a id="page_1243"/>because the declaration doesn&#8217;t identify a specific object. Instead, the pointer <code>pt</code> identifies the location of <code>inches</code> member within any <code>Example</code> object. Like the identifier <code>inches</code>, <code>pt</code> is designed to be used in conjunction with an object identifier. In essence, the expression <code>*pt</code> assumes the role of the identifier <code>inches</code>. Therefore, you can use an object identifier to specify which object to access and the <code>pt</code> pointer to specify the <code>inches</code> member of that object. For example, a class method could use this code:</p>
<p class="programlisting">int Example::*pt = &#38;Example::inches;<br/>Example ob1;<br/>Example ob2;<br/>Example *pq = new Example;<br/>cout &lt;&lt; ob1.*pt &lt;&lt; endl; // display inches member of ob1<br/>cout &lt;&lt; ob2.*pt &lt;&lt; endl; // display inches member of ob2<br/>cout &lt;&lt; po-&gt;*pt &lt;&lt; endl; // display inches member of *po</p>
<p>Here <code>.*</code> and <code>-&gt;*</code> are <em>member dereferencing operators</em>. When you have a particular object, such as <code>ob1</code>, then <code>ob1.*pi</code> identifies the <code>inches</code> member of the <code>ob1</code> object. Similarly, <code>pq-&gt;*pt</code> identifies the <code>inches</code> member of an object pointed to by <code>pq</code>.</p>
<p>Changing the object in the preceding example changes which <code>inches</code> member is used. But you can also change the <code>pt</code> pointer itself. Because <code>feet</code> is of the same type as <code>inches</code>, you can reset <code>pt</code> to point to the <code>feet</code> member instead of the <code>inches</code> member; then <code>ob1.*pt</code> will refer to the feet member of <code>ob1</code>:</p>
<p class="programlisting">pt = &#38;Example::feet;&#160;&#160;&#160;&#160;&#160;&#160;// reset pt<br/>cout &lt;&lt; ob1.*pt &lt;&lt; endl;&#160;&#160;// display feet member of ob1</p>
<p>In essence, the combination <code>*pt</code> takes the place of a member name and can be used to identify different member names (of the same type).</p>
<p>You can also use member pointers to identify member functions. The syntax for this is relatively involved. Recall that declaring a pointer to an ordinary type <code>void</code> function with no arguments looks like this:</p>
<p class="programlisting">void (*pf)();&#160;&#160;// pf points to a function</p>
<p>Declaring a pointer to a member function has to indicate that the function belongs to a particular class. Here, for instance, is how to declare a pointer to an <code>Example</code> class method:</p>
<p class="programlisting">void (Example::*pf)() const;&#160;&#160;// pf points to an Example member function</p>
<p>This indicates that <code>pf</code> can be used the same places that <code>Example</code> method can be used. Note that the term <code>Example:</code> <strong><code>:</code></strong><code>*pf</code> has to be in parentheses. You can assign the address of a particular member function to this pointer:</p>
<p class="programlisting">pf = &#38;Example::show_inches;</p>
<p>Note that unlike in the case of ordinary function pointer assignment, here you can and must use the address operator. Having made this assignment, you can then use an object to invoke the member function:</p>
<p class="programlisting">Example ob3(20);<br/>(ob3.*pf)();&#160;&#160;&#160;&#160;&#160;// invoke show_inches() using the ob3 object</p>
<p><a id="page_1244"/>You need to enclose the entire <code>ob3.*pf</code> construction in parentheses in order to clearly identify the expression as representing a function name.</p>
<p>Because <code>show_feet()</code> has the same prototype form as <code>show_inches()</code>, you can use <code>pf</code> to access the <code>show_feet()</code> method, too:</p>
<p class="programlisting">pf = &#38;Example::show_feet;<br/>(ob3.*pf)();&#160;&#160;&#160;&#160;&#160;// apply show_feet() to the ob3 object</p>
<p>The class definition presented in <a href="#app05ex01">Listing E.1</a> has a <code>use_ptr()</code> method that uses member pointers to access both data members and function members of the <code>Example</code> class.</p>
<p class="caption1"><a id="app05ex01"/><strong>Listing E.1. <code>memb_pt.cpp</code></strong></p><hr/>
<p class="programlisting1">// memb_pt.cpp -- dereferencing pointers to class members<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class Example<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int feet;<br/>&#160;&#160;&#160;&#160;int inches;<br/>public:<br/>&#160;&#160;&#160;&#160;Example();<br/>&#160;&#160;&#160;&#160;Example(int ft);<br/>&#160;&#160;&#160;&#160;~Example();<br/>&#160;&#160;&#160;&#160;void show_in() const;<br/>&#160;&#160;&#160;&#160;void show_ft() const;<br/>&#160;&#160;&#160;&#160;void use_ptr() const;<br/>};<br/><br/>Example::Example()<br/>{<br/>&#160;&#160;&#160;&#160;feet = 0;<br/>&#160;&#160;&#160;&#160;inches = 0;<br/>}<br/><br/>Example::Example(int ft)<br/>{<br/>&#160;&#160;&#160;&#160;feet = ft;<br/>&#160;&#160;&#160;&#160;inches = 12 * feet;<br/>}<br/><br/>Example::~Example()<br/>{<br/>}<br/><br/><a id="page_1245"/>void Example::show_in() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; inches &lt;&lt; " inches\n";<br/>}<br/><br/>void Example::show_ft() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; feet &lt;&lt; " feet\n";<br/>}<br/><br/>void Example::use_ptr() const<br/>{<br/>&#160;&#160;&#160;&#160;Example yard(3);<br/>&#160;&#160;&#160;&#160;int Example::*pt;<br/>&#160;&#160;&#160;&#160;pt = &#38;Example::inches;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set pt to &#38;Example::inches:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "this-&gt;pt: " &lt;&lt; this-&gt;*pt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "yard.*pt: " &lt;&lt; yard.*pt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;pt = &#38;Example::feet;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set pt to &#38;Example::feet:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "this-&gt;pt: " &lt;&lt; this-&gt;*pt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "yard.*pt: " &lt;&lt; yard.*pt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;void (Example::*pf)() const;<br/>&#160;&#160;&#160;&#160;pf = &#38;Example::show_in;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set pf to &#38;Example::show_in:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using (this-&gt;*pf)(): ";<br/>&#160;&#160;&#160;&#160;(this-&gt;*pf)();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using (yard.*pf)(): ";<br/>&#160;&#160;&#160;&#160;(yard.*pf)();<br/>}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Example car(15);<br/>&#160;&#160;&#160;&#160;Example van(20);<br/>&#160;&#160;&#160;&#160;Example garage;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "car.use_ptr() output:\n";<br/>&#160;&#160;&#160;&#160;car.use_ptr();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nvan.use_ptr() output:\n";<br/>&#160;&#160;&#160;&#160;van.use_ptr();<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1246"/>Here is a sample run of the program in <a href="#app05ex01">Listing E.1</a>:</p>
<p class="programlisting">car.use_ptr() output:<br/>Set pt to &#38;Example::inches:<br/>this-&gt;pt: 180<br/>yard.*pt: 36<br/>Set pt to &#38;Example::feet:<br/>this-&gt;pt: 15<br/>yard.*pt: 3<br/>Set pf to &#38;Example::show_in:<br/>Using (this-&gt;*pf)(): 180 inches<br/>Using (yard.*pf)(): 36 inches<br/><br/>van.use_ptr() output:<br/>Set pt to &#38;Example::inches:<br/>this-&gt;pt: 240<br/>yard.*pt: 36<br/>Set pt to &#38;Example::feet:<br/>this-&gt;pt: 20<br/>yard.*pt: 3<br/>Set pf to &#38;Example::show_in:<br/>Using (this-&gt;*pf)(): 240 inches<br/>Using (yard.*pf)(): 36 inches</p>
<p>This example assigned pointer values at compile time. In a more sophisticated class, you can use member pointers to data members and methods for which the exact member associated with the pointer is determined at runtime.</p>
<h3 id="app05lev1sec3"><code>alignof</code> (C++11)</h3>
<p>Computer systems can have restrictions on how data is stored in memory. For example, one system might require that a <code>double</code> value be stored at an even-numbered memory location, whereas another might require the storage to begin at a location that is a multiple of eight. The <code>alignof</code> operator takes a type as an argument and returns an integer indicating the required alignment type. Alignment requirements can, for example, determine how information is arranged within a structure, as <a href="#app05ex02">Listing E.2</a> shows.</p>
<p class="caption1"><a id="app05ex02"/><strong>Listing E.2. <code>align.cpp</code></strong></p><hr/>
<p class="programlisting1">// align.cpp -- checking alignment<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>struct things1<br/>{<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;int a;<br/>&#160;&#160;&#160;&#160;double x;<br/>};<br/>struct things2<br/>{<br/><br/>&#160;&#160;&#160;&#160;int a;<br/>&#160;&#160;&#160;&#160;double x;<br/>&#160;&#160;&#160;&#160;char ch;<br/>};<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;things1 th1;<br/>&#160;&#160;&#160;&#160;things2 th2;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "char alignment: " &lt;&lt; alignof(char) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "int alignment: " &lt;&lt; alignof(int) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "double alignment: " &lt;&lt; alignof(double) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "things1 alignment: " &lt;&lt; alignof(things1) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "things2 alignment: " &lt;&lt; alignof(things2) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "things1 size: " &lt;&lt; sizeof(things1) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "things2 size: " &lt;&lt; sizeof(things2) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1247"/>Here is the output on one system:</p>
<p class="programlisting">char alignment: 1<br/>int alignment: 4<br/>double alignment: 8<br/>things1 alignment: 8<br/>things2 alignment: 8<br/>things1 size: 16<br/>things2 size: 24</p>
<p>Both structures have an alignment requirement of eight. One implication is that the structure size should be a multiple of eight so that one can create arrays of structures with each element adjacent to the next and also starting on an alignment boundary that&#8217;s a multiple of eight. The individual members of each structure in <a href="#app05ex02">Listing E.2</a> use only a total of 13 bits, but the requirement of using a multiple of eight bits means each structure needs some padding in it. Next, within each structure, the <code>double</code> member needs to align on a multiple of eight. The different arrangement of members within <code>things1</code> and <code>things2</code> results in <code>things2</code> needing more internal padding to make the boundaries come out right.</p>
<h3 id="app05lev1sec4"><code>noexcept</code> (C++11)</h3>
<p><a id="page_1248"/>The <code>noexcept</code> keyword is used to indicate that a function doesn&#8217;t throw an exception. It also can be used as an operator that determines whether its operand (an expression) potentially could throw an exception. It returns <code>false</code> if the operand could throw an exception and <code>true</code> otherwise. For example, consider the following declarations:</p>
<p class="programlisting">int hilt(int);<br/>int halt(int) noexcept;</p>
<p>The expression <code>noexcept(hilt)</code> would evaluate as <code>false</code>, as the declaration of <code>hilt()</code> doesn&#8217;t guarantee that an exception won&#8217;t be thrown. But <code>noexcept(halt)</code> will evaluate as <code>true</code>.</p>
</body>
</html>
