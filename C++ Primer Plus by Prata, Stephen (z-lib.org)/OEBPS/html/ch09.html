<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>9. Memory Models and Namespaces</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch09">9. Memory Models and Namespaces</h2>
<p><a id="page_447"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Separate compilation of programs</p>
<p class="indenthandingB">&#8226; Storage duration, scope, and linkage</p>
<p class="indenthandingB">&#8226; Placement <code>new</code></p>
<p class="indenthandingB">&#8226; Namespaces</p>
<p>C++ offers many choices for storing data in memory. You have choices for how long data remains in memory (storage duration) and choices for which parts of a program have access to data (scope and linkage). You can allocate memory dynamically by using <code>new</code>, and placement <code>new</code> offers a variation on that technique. The C++ namespace facility provides additional control over access. Larger programs typically consist of several source code files that may share some data in common. Such programs involve the separate compilation of the program files, and this chapter begins with that topic.</p>
<h3 id="ch09lev1sec1">Separate Compilation</h3>
<p>C++, like C, allows and even encourages you to locate the component functions of a program in separate files. As <a href="ch01.html#ch01">Chapter 1</a>, &#8220;<a href="ch01.html#ch01">Getting Started with C++</a>,&#8221; describes, you can compile the files separately and then link them into the final executable program. (A C++ compiler typically compiles programs and also manages the linker program.) If you modify just one file, you can recompile just that one file and then link it to the previously compiled versions of the other files. This facility makes it easier to manage large programs. Furthermore, most C++ environments provide additional facilities to help with the management. Unix and Linux systems, for example, have <code>make</code> programs, which keep track of which files a program depends on and when they were last modified. If you run <code>make</code>, and it detects that you&#8217;ve changed one or more source files since the last compilation, <code>make</code> remembers the proper steps needed to reconstitute the program. Most integrated development environments (IDEs), including Embarcadero C++ Builder, Microsoft Visual <a id="page_448"/>C++, Apple Xcode, and Freescale CodeWarrior, provide similar facilities with their Project menus.</p>
<p>Let&#8217;s look at a simple example. Instead of looking at compilation details, which depend on the implementation, let&#8217;s concentrate on more general aspects, such as design.</p>
<p>Suppose, for example, that you decide to break up the program in <a href="ch07.html#ch07ex12">Listing 7.12</a> by placing the two supporting functions in a separate file. Recall that <a href="ch07.html#ch07ex12">Listing 7.12</a> converts rectangular coordinates to polar coordinates and then displays the result. You can&#8217;t simply cut the original file on a dotted line after the end of <code>main()</code>. The problem is that <code>main()</code> and the other two functions use the same structure declarations, so you need to put the declarations in both files. Simply typing them in is an invitation to error. Even if you copy the structure declarations correctly, you have to remember to modify both sets of declarations if you make changes later. In short, spreading a program over multiple files creates new problems.</p>
<p>Who wants more problems? The developers of C and C++ didn&#8217;t, so they&#8217;ve provided the <code>#include</code> facility to deal with this situation. Instead of placing the structure declarations in each file, you can place them in a header file and then include that header file in each source code file. That way, if you modify the structure declaration, you can do so just once, in the header file. Also you can place the function prototypes in the header file. Thus, you can divide the original program into three parts:</p>
<p class="indenthandingB">&#8226; A header file that contains the structure declarations and prototypes for functions that use those structures</p>
<p class="indenthandingB">&#8226; A source code file that contains the code for the structure-related functions</p>
<p class="indenthandingB">&#8226; A source code file that contains the code that calls the structure-related functions</p>
<p>This is a useful strategy for organizing a program. If, for example, you write another program that uses those same functions, you can just include the header file and add the functions file to the project or <code>make</code> list. Also this organization is consistent with the OOP approach. One file, the header file, contains the definition of the user-defined types. A second file contains the function code for manipulating the user-defined types. Together, they form a package you can use for a variety of programs.</p>
<p>You shouldn&#8217;t put function definitions or variable declarations into a header file. That might work for a simple setup but usually it leads to trouble. For example, if you had a function definition in a header file and then included the header file in two other files that are part of a single program, you&#8217;d wind up with two definitions of the same function in a single program, which is an error, unless the function is inline. Here are some things commonly found in header files:</p>
<p class="indenthandingB">&#8226; Function prototypes</p>
<p class="indenthandingB">&#8226; Symbolic constants defined using <code>#define</code> or <code>const</code></p>
<p class="indenthandingB">&#8226; Structure declarations</p>
<p class="indenthandingB">&#8226; Class declarations</p>
<p class="indenthandingB">&#8226; <a id="page_449"/>Template declarations</p>
<p class="indenthandingB">&#8226; Inline functions</p>
<p>It&#8217;s okay to put structure declarations in a header file because they don&#8217;t create variables; they just tell the compiler how to create a structure variable when you declare one in a source code file. Similarly, template declarations aren&#8217;t code to be compiled; they are instructions to the compiler on how to generate function definitions to match function calls found in the source code. Data declared <code>const</code> and inline functions have special linkage properties (described shortly) that allow them to be placed in header files without causing problems.</p>
<p><a href="#ch09ex01">Listings 9.1</a>, <a href="#ch09ex02">9.2</a>, and <a href="#ch09ex03">9.3</a> show the result of dividing <a href="ch07.html#ch07ex12">Listing 7.12</a> into separate parts. Note that you use <code>"coordin.h"</code> instead of <code>&lt;coordin.h&gt;</code> when including the header file. If the filename is enclosed in angle brackets, the C++ compiler looks at the part of the host system&#8217;s file system that holds the standard header files. But if the filename is enclosed in double quotation marks, the compiler first looks at the current working directory or at the source code directory (or some such choice, depending on the compiler). If it doesn&#8217;t find the header file there, it then looks in the standard location. So you should use quotation marks, not angle brackets, when including your own header files.</p>
<p><a href="#ch09fig01">Figure 9.1</a> outlines the steps for putting this program together on a Unix system. Note that you just give the <code>CC</code> compile command, and the other steps follow automatically. The g++ and gpp command-line compilers and the Borland C++ command-line compiler (<code>bcc32.exe</code>) also behave that way. Apple Xcode, Embarcadero C++ Builder, and Microsoft Visual C++ go through essentially the same steps, but, as outlined in <a href="ch01.html#ch01">Chapter 1</a>, you initiate the process differently, using menus that let you create a project and associate source code files with it. Note that you only add source code files, not header files, to projects. That&#8217;s because the <code>#include</code> directive manages the header files. Also you shouldn&#8217;t use <code>#include</code> to include source code files because that can lead to multiple declarations.</p>
<p class="caption"><a id="ch09fig01"/><strong>Figure 9.1. Compiling a multifile C++ program on a Unix system.</strong></p>
<p class="image"><img src="graphics/09fig01.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch09note01"/>Caution</p>
<p class="notepara">In IDEs, don&#8217;t add header files to the project list and don&#8217;t use <code>#include</code> to include source code files in other source code files.</p>
<hr/></div>
<p class="caption1"><a id="ch09ex01"/><strong>Listing 9.1. <code>coordin.h</code></strong></p><hr/>
<p class="programlisting1">// coordin.h -- structure templates and function prototypes<br/>// structure templates<br/>#ifndef COORDIN_H_<br/>#define COORDIN_H_<br/><br/>struct polar<br/>{<br/>&#160;&#160;&#160;&#160;double distance;&#160;&#160;&#160;&#160;// distance from origin<br/>&#160;&#160;&#160;&#160;double angle;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// direction from origin<br/>};<br/><a id="page_450"/>struct rect<br/>{<br/>&#160;&#160;&#160;&#160;double x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// horizontal distance from origin<br/>&#160;&#160;&#160;&#160;double y;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// vertical distance from origin<br/>};<br/><br/>// prototypes<br/>polar rect_to_polar(rect xypos);<br/>void show_polar(polar dapos);<br/><br/>#endif</p><hr/>
<div class="sidebar"><hr/>
<p class="title"><a id="ch09sb01"/><a id="page_451"/>Header File Management</p>
<p class="sidebarpara">You should include a header file just once in a file. That might seem to be an easy thing to remember, but it&#8217;s possible to include a header file several times without knowing you did so. For example, you might use a header file that includes another header file. There&#8217;s a standard C/C++ technique for avoiding multiple inclusions of header files. It&#8217;s based on the preprocessor <code>#ifndef</code> (for <em>if n</em>ot <em>def</em>ined) directive. A code segment like the following means &#8220;process the statements between the <code>#ifndef</code> and <code>#endif</code> only if the name <code>COORDIN_H_</code> has not been defined previously by the preprocessor <code>#define</code> directive&#8221;:</p>
<p class="programlistingB">#ifndef COORDIN_H_<br/>...<br/>#endif</p>
<p class="sidebarpara">Normally, you use the <code>#define</code> statement to create symbolic constants, as in the following:</p>
<p class="programlistingB">#define MAXIMUM 4096</p>
<p class="sidebarpara">But simply using <code>#define</code> with a name is enough to establish that a name is defined, as in the following:</p>
<p class="programlistingB">#define COORDIN_H_</p>
<p class="sidebarpara">The technique that <a href="#ch09ex01">Listing 9.1</a> uses is to wrap the file contents in an <code>#ifndef</code>:</p>
<p class="programlistingB">#ifndef COORDIN_H_<br/>#define COORDIN_H_<br/>// place include file contents here<br/>#endif</p>
<p class="sidebarpara">The first time the compiler encounters the file, the name <code>COORDIN_H_</code> should be undefined. (I chose a name based on the <code>include</code> filename, with a few underscore characters tossed in to create a name that is unlikely to be defined elsewhere.) That being the case, the compiler looks at the material between the <code>#ifndef</code> and the <code>#endif</code>, which is what you want. In the process of looking at the material, the compiler reads the line defining <code>COORDIN_H_</code>. If it then encounters a second inclusion of <code>coordin.h</code> in the same file, the compiler notes that <code>COORDIN_H_</code> is defined and skips to the line following the <code>#endif</code>. Note that this method doesn&#8217;t keep the compiler from including a file twice. Instead, it makes the compiler ignore the contents of all but the first inclusion. Most of the standard C and C++ header files use this guarding scheme. Otherwise you might get the same structure defined twice in one file, and that will produce a compile error.</p>
<hr/></div>
<p class="caption1"><a id="ch09ex02"/><strong>Listing 9.2. <code>file1.cpp</code></strong></p><hr/>
<p class="programlisting1">// file1.cpp -- example of a three-file program<br/>#include &lt;iostream&gt;<br/>#include "coordin.h" // structure templates, function prototypes<br/>using namespace std;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;rect rplace;<br/>&#160;&#160;&#160;&#160;polar pplace;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the x and y values: ";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)&#160;&#160;// slick use of cin<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pplace = rect_to_polar(rplace);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;show_polar(pplace);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Next two numbers (q to quit): ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p class="caption1"><a id="page_452"/><a id="ch09ex03"/><strong>Listing 9.3. <code>file2.cpp</code></strong></p><hr/>
<p class="programlisting1">// file2.cpp -- contains functions called in file1.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;cmath&gt;<br/>#include "coordin.h" // structure templates, function prototypes<br/><br/>// convert rectangular to polar coordinates<br/>polar rect_to_polar(rect xypos)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;polar answer;<br/><br/>&#160;&#160;&#160;&#160;answer.distance =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sqrt( xypos.x * xypos.x + xypos.y * xypos.y);<br/>&#160;&#160;&#160;&#160;answer.angle = atan2(xypos.y, xypos.x);<br/>&#160;&#160;&#160;&#160;return answer;&#160;&#160;&#160;&#160;&#160;&#160;// returns a polar structure<br/>}<br/><br/>// show polar coordinates, converting angle to degrees<br/>void show_polar (polar dapos)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const double Rad_to_deg = 57.29577951;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "distance = " &lt;&lt; dapos.distance;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", angle = " &lt;&lt; dapos.angle * Rad_to_deg;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " degrees\n";<br/>}</p><hr/>
<p><a id="page_453"/>Compiling and linking these two source code files along with the new header file produces an executable program. Here is a sample run:</p>
<p class="programlisting">Enter the x and y values: <span class="EmpStrong">120 80</span><br/>distance = 144.222, angle = 33.6901 degrees<br/>Next two numbers (q to quit): 1<span class="EmpStrong">20 50</span><br/>distance = 130, angle = 22.6199 degrees<br/>Next two numbers (q to quit): <span class="EmpStrong">q</span></p>
<p>By the way, although we&#8217;ve discussed separate compilation in terms of files, the C++ Standard uses the term <em>translation unit</em> instead of <em>file</em> in order to preserve greater generality; the file metaphor is not the only possible way to organize information for a computer. For simplicity, this book will use the term <em>file</em>, but feel free to translate that to <em>translation unit</em>.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch09sb02"/>Multiple Library Linking</p>
<p class="sidebarpara">The C++ Standard allows each compiler designer the latitude to implement name decoration or mangling (see the sidebar &#8220;<a href="ch08.html#ch08sb05">What Is Name Decoration?</a>&#8221; in <a href="ch08.html#ch08">Chapter 8</a>, &#8220;<a href="ch08.html#ch08">Adventures in Functions</a>&#8221;) as it sees fit, so you should be aware that binary modules (object-code files) created with different compilers will, most likely, not link properly. That is, the two compilers will generate different decorated names for the same function. This name difference will prevent the linker from matching the function call generated by one compiler with the function definition generated by a second compiler. When attempting to link compiled modules, you should make sure that each object file or library was generated with the same compiler. If you are provided with the source code, you can usually resolve link errors by recompiling the source with your compiler.</p>
<hr/></div>
<h3 id="ch09lev1sec2">Storage Duration, Scope, and Linkage</h3>
<p>Now that you&#8217;ve seen a multifile program, it&#8217;s a good time to extend the discussion of memory schemes in <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; because storage categories affect how information can be shared across files. It might have been a while since you last read <a href="ch04.html#ch04">Chapter 4</a>, so let&#8217;s review what it says about memory. C++ uses three separate schemes (four under C++11) for storing data, and the schemes differ in how long they preserve data in memory:</p>
<p class="indenthandingB">&#8226; <strong>Automatic storage duration&#8212;</strong> Variables declared inside a function definition&#8212;including function parameters&#8212;have automatic storage duration. They are created when program execution enters the function or block in which they are defined, and the memory used for them is freed when execution leaves the function or block. C++ has two kinds of automatic storage duration variables.</p>
<p class="indenthandingB">&#8226; <strong>Static storage duration&#8212;</strong> Variables defined outside a function definition or else by using the keyword <code>static</code> have static storage duration. They persist for the entire time a program is running. C++ has three kinds of static storage duration variables.</p>
<p class="indenthandingB">&#8226; <strong>Thread storage duration (C++11)&#8212;</strong> These days multicore processors are common. These are CPUs that can handle several execution tasks simultaneously. This allows a program to split computations into separate <em>threads</em> that can be processed <a id="page_454"/>concurrently. Variables declared with the <code>thread_local</code> keyword have storage that persists for as long as the containing thread lasts. This book does not venture into concurrent programming.</p>
<p class="indenthandingB">&#8226; <strong>Dynamic storage duration&#8212;</strong> Memory allocated by the <code>new</code> operator persists until it is freed with the <code>delete</code> operator or until the program ends, whichever comes first. This memory has dynamic storage duration and sometimes is termed the <em>free store</em> or the <em>heap</em>.</p>
<p>You&#8217;ll get the rest of the story now, including fascinating details about when variables of different types are in scope, or visible (that is, usable by the program), and about linkage, which determines what information is shared across files.</p>
<h4 id="ch09lev2sec1">Scope and Linkage</h4>
<p><em>Scope</em> describes how widely visible a name is in a file (translation unit). For example, a variable defined in a function can be used in that function but not in another, whereas a variable defined in a file above the function definitions can be used in all the functions. <em>Linkage</em> describes how a name can be shared in different units. A name with <em>external linkage</em> can be shared across files, and a name with <em>internal linkage</em> can be shared by functions within a single file. Names of automatic variables have no linkage because they are not shared.</p>
<p>A C++ variable can have one of several scopes. A variable that has <em>local scope</em> (also termed <em>block scope</em>) is known only within the block in which it is defined. Recall that a block is a series of statements enclosed in braces. A function body, for example, is a block, but you can have other blocks nested within the function body. A variable that has <em>global scope</em> (also termed <em>file scope</em>) is known throughout the file after the point where it is defined. Automatic variables have local scope, and a static variable can have either scope, depending on how it is defined. Names used in a <em>function prototype scope</em> are known just within the parentheses enclosing the argument list. (That&#8217;s why it doesn&#8217;t really matter what they are or if they are even present.) Members declared in a class have <em>class scope</em> (see <a href="ch10.html#ch10">Chapter 10</a>, &#8220;<a href="ch10.html#ch10">Objects and Classes</a>&#8221;). Variables declared in a namespace have <em>namespace scope</em>. (Now that namespaces have been added to the C++ language, the global scope has become a special case of namespace scope.)</p>
<p>C++ functions can have class scope or namespace scope, including global scope, but they can&#8217;t have local scope. (Because a function can&#8217;t be defined inside a block, if a function were to have local scope, it could only be known to itself and hence couldn&#8217;t be called by another function. Such a function couldn&#8217;t function.)</p>
<p>The various C++ storage choices are characterized by their storage duration, their scope, and their linkage. Let&#8217;s look at C++&#8217;s storage classes in terms of these properties. We begin by examining the situation before namespaces were added to the mix and then see how namespaces modify the picture.</p>
<h4 id="ch09lev2sec2">Automatic Storage Duration</h4>
<p><a id="page_455"/>Function parameters and variables declared inside a function have, by default, automatic storage duration. They also have local scope and no linkage. That is, if you declare a variable called <code>texas</code> in <code>main()</code> and you declare another variable with the same name in a function called <code>oil()</code>, you&#8217;ve created two independent variables, each known only in the function in which it&#8217;s defined. Anything you do to the <code>texas</code> in <code>oil()</code> has no effect on the <code>texas</code> in <code>main()</code>, and vice versa. Also each variable is allocated when program execution enters the innermost block containing the definition, and each fades from existence when execution leaves that block. (Note that the variable is allocated when execution enters the block, but the scope begins only after the point of declaration.)</p>
<p>If you define a variable inside a block, the variable&#8217;s persistence and scope are confined to that block. Suppose, for example, that you define a variable called <code>teledeli</code> at the beginning of <code>main()</code>. Now suppose you start a new block within <code>main()</code> and define a new variable, called <code>websight</code>, in the block. Then, <code>teledeli</code> is visible in both the outer and inner blocks, whereas <code>websight</code> exists only in the inner block and is in scope only from its point of definition until program execution passes the end of the block:</p>
<p class="programlisting">int main()<br/>{<br/>&#160;&#160;&#160;&#160;int teledeli = 5;<br/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// websight allocated<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Hello\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int websight = -2;&#160;&#160;&#160;&#160;// websight scope begins<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; websight &lt;&lt; ' ' &lt;&lt; teledeli &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// websight expires<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; teledeli &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;...<br/>}&#160;&#160;// teledeli expires</p>
<p>But what if you name the variable in the inner block <code>teledeli</code> instead of <code>websight</code> so that you have two variables of the same name, with one in the outer block and one in the inner block? In this case, the program interprets the <code>teledeli</code> name to mean the local block variable while the program executes statements within the block. We say the new definition <em>hides</em> the prior definition. The new definition is in scope, and the old definition is temporarily out of scope. When the program leaves the block, the original definition comes back into scope (see <a href="#ch09fig02">Figure 9.2</a>).</p>
<p class="caption"><a id="ch09fig02"/><strong>Figure 9.2. Blocks and scope.</strong></p>
<p class="image"><img src="graphics/09fig02.jpg" alt="Image"/></p>
<p><a href="#ch09ex04">Listing 9.4</a> illustrates how automatic variables are localized to the functions or blocks that contain them.</p>
<p class="caption1"><a id="page_456"/><a id="ch09ex04"/><strong>Listing 9.4. <code>autoscp.cpp</code></strong></p><hr/>
<p class="programlisting1">// autoscp.cpp -- illustrating scope of automatic variables<br/>#include &lt;iostream&gt;<br/>void oil(int x);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/><br/>&#160;&#160;&#160;&#160;int texas = 31;<br/>&#160;&#160;&#160;&#160;int year = 2011;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "In main(), texas = " &lt;&lt; texas &lt;&lt; ", &#38;texas = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;texas &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "In main(), year = " &lt;&lt; year &lt;&lt; ", &#38;year = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;year &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;oil(texas);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "In main(), texas = " &lt;&lt; texas &lt;&lt; ", &#38;texas = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;texas &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "In main(), year = " &lt;&lt; year &lt;&lt; ", &#38;year = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;year &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void oil(int x)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int texas = 5;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "In oil(), texas = " &lt;&lt; texas &lt;&lt; ", &#38;texas = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;texas &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "In oil(), x = " &lt;&lt; x &lt;&lt; ", &#38;x = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start a block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int texas = 113;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "In block, texas = " &lt;&lt; texas;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ", &#38;texas = " &lt;&lt; &#38;texas &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "In block, x = " &lt;&lt; x &lt;&lt; ", &#38;x = ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// end a block<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Post-block texas = " &lt;&lt; texas;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", &#38;texas = " &lt;&lt; &#38;texas &lt;&lt; endl;<br/>}</p><hr/>
<p><a id="page_457"/>Here is the output from the program in <a href="#ch09ex04">Listing 9.4</a>:</p>
<p class="programlisting">In main(), texas = 31, &#38;texas = 0012FED4<br/>In main(), year = 2011, &#38;year = 0012FEC8<br/>In oil(), texas = 5, &#38;texas = 0012FDE4<br/>In oil(), x = 31, &#38;x = 0012FDF4<br/>In block, texas = 113, &#38;texas = 0012FDD8<br/>In block, x = 31, &#38;x = 0012FDF4<br/>Post-block texas = 5, &#38;texas = 0012FDE4<br/>In main(), texas = 31, &#38;texas = 0012FED4<br/>In main(), year = 2011, &#38;year = 0012FEC8</p>
<p>Notice that each of the three <code>texas</code> variables in <a href="#ch09ex04">Listing 9.4</a> has its own distinct address and that the program uses only the particular variable in scope at the moment, so assigning the value <code>113</code> to the <code>texas</code> in the inner block in <code>oil()</code> has no effect on the other variables of the same name. (As usual, the actual address values and address format will differ from system to system.)</p>
<p>Let&#8217;s summarize the sequence of events. When <code>main()</code> starts, the program allocates space for <code>texas</code> and <code>year</code>, and these variables come into scope. When the program calls <code>oil()</code>, these variables remain in memory but pass out of scope. Two new variables, <code>x</code> and <code>texas</code>, are allocated and come into scope. When program execution reaches the inner block in <code>oil()</code>, the new <code>texas</code> passes out of scope (is hidden) because it is superseded by an even newer definition. The variable <code>x</code>, however, stays in scope because the block doesn&#8217;t define a new <code>x</code>. When execution exits the block, the memory for the newest <code>texas</code> is freed, and <code>texas</code> #2 comes back into scope. When the <code>oil()</code> function terminates, that <code>texas</code> and <code>x</code> expire, and the original <code>texas</code> and <code>year</code> come back into scope.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch09sb03"/><a id="page_458"/>Changes to <code>auto</code> in C++11</p>
<p class="sidebarpara">In C++11, the keyword <code>auto</code> is used for automatic type deduction, as you have seen in <a href="ch03.html#ch03">Chapters 3</a>, <a href="ch07.html#ch07">7</a>, and <a href="ch08.html#ch08">8</a>. But in C and in prior versions of C++, <code>auto</code> has an entirely different meaning. It&#8217;s used to explicitly identify a variable as having automatic storage:</p>
<p class="programlistingB">int froob(int n)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;auto float ford;&#160;&#160;// ford has automatic storage<br/>&#160;&#160;&#160;&#160;&#160;...<br/>}</p>
<p class="sidebarpara">Because programmers can use the <code>auto</code> keyword only with variables that are already automatic by default, they rarely bother using it. Its main function is to document that you really wanted to use a local automatic variable.</p>
<p class="sidebarpara">In C++11, this usage no longer is valid. The people who prepare standards are reluctant to introduce new keywords because doing so might invalidate existing code that already uses that word for other purposes. In this case, it was felt that the old use of <code>auto</code> was rare enough that it was better to repurpose this keyword rather than introduce a new one.</p>
<hr/></div>
<h5 id="ch09lev3sec1">Initialization of Automatic Variables</h5>
<p>You can initialize an automatic variable with any expression whose value will be known when the declaration is reached. The following example shows the variables <code>x</code>, <code>big</code>, <code>y</code>, and <code>z</code> being initialized:</p>
<p class="programlisting">int w;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// value of w is indeterminate<br/>int x = 5;&#160;&#160;&#160;&#160;&#160;&#160;// initialized with a numeric literal<br/>int big = INT_MAX &#8211; 1; // initialized with a constant expression<br/>int y = 2 * x;&#160;&#160;// use previously determined value of x<br/>cin &gt;&gt; w;<br/>int z = 3 * w;&#160;&#160;// use new value of w</p>
<h5 id="ch09lev3sec2">Automatic Variables and the Stack</h5>
<p>You might gain a better understanding of automatic variables if you look at how a typical C++ compiler implements them. Because the number of automatic variables grows and shrinks as functions start and terminate, the program has to manage automatic variables as it runs. The usual means is to set aside a section of memory and treat it as a stack for managing the flow and ebb of variables. It&#8217;s called a <em>stack</em> because new data is figuratively stacked atop old data (that is, at an adjacent location, not at the same location) and then removed from the stack when a program is finished with it. The default size of the stack depends on the implementation, but a compiler typically provides the option of changing the size. The program keeps track of the stack by using two pointers. One points to the base of the stack, where the memory set aside for the stack begins, and one points to the top of the stack, which is the next free memory location. When a function is called, its automatic variables are added to the stack, and the pointer to the top points to the next available free space following the variables. When the function terminates, the top pointer <a id="page_459"/>is reset to the value it had before the function was called, effectively freeing the memory that had been used for the new variables.</p>
<p>A stack is a LIFO (last-in, first-out) design, meaning the last variables added to the stack are the first to go. The design simplifies argument passing. The function call places the values of its arguments on top of the stack and resets the top pointer. The called function uses the description of its formal parameters to determine the addresses of each argument. For example, <a href="#ch09fig03">Figure 9.3</a> shows a <code>fib()</code> function that, when called, passes a 2-byte <code>int</code> and a 4-byte <code>long</code>. These values go on the stack. When <code>fib()</code> begins execution, it associates the names <code>real</code> and <code>tell</code> with the two values. When <code>fib()</code> terminates, the top-of-stack pointer is relocated to its former position. The new values aren&#8217;t erased, but they are no longer labeled, and the space they occupy will be used by the next process that places values on the stack. (<a href="#ch09fig03">Figure 9.3</a> is somewhat simplified because function calls may pass additional information, such as a return address.)</p>
<p class="caption"><a id="ch09fig03"/><strong>Figure 9.3. Passing arguments by using a stack.</strong></p>
<p class="image"><img src="graphics/09fig03.jpg" alt="Image"/></p>
<h5 id="ch09lev3sec3">Register Variables</h5>
<p>C originally introduced the <code>register</code> keyword to suggest that the compiler use a CPU register to store an automatic variable:</p>
<p class="programlisting">register int count_fast;&#160;&#160;// request for a register variable</p>
<p>The idea was that this would allow faster access to the variable.</p>
<p>Prior to C++11, C++ used the keyword in the same fashion, except that as hardware and compilers developed in sophistication, the hint was generalized to mean that the variable was heavily used and perhaps the compiler could provide some sort of special treatment. With C++11, even that hint is being deprecated, leaving <code>register</code> as just a way to explicitly identify a variable as being automatic. Given that <code>register</code> can only be used with variables that would be automatic anyway, one reason to use this keyword is to indicate that you really do want to use an automatic variable, perhaps one with the same name as an external variable. This is the same purpose the original use of <code>auto</code> served. The more important reason for retaining <code>register</code>, however, is to avoid invalidating existing code that uses that keyword.</p>
<h4 id="ch09lev2sec3">Static Duration Variables</h4>
<p>C++, like C, provides static storage duration variables with three kinds of linkage: external linkage (accessible across files), internal linkage (accessible to functions within a single file), and no linkage (accessible to just one function or to one block within a function). All three last for the duration of the program; they are less ephemeral than automatic variables. Because the number of static variables doesn&#8217;t change as the program runs, the program doesn&#8217;t need a special device such as a stack to manage them. Instead, the compiler allocates a fixed block of memory to hold all the static variables, and those variables stay present as long as the program executes. Also if you don&#8217;t explicitly initialize a static variable, the compiler sets it to <code>0</code>. Static arrays and structures have all the bits of each element or member set to <code>0</code> by default.</p>
<div class="note"><hr/>
<p class="title"><a id="ch09note02"/><a id="page_460"/>Note</p>
<p class="notepara">Classic K&#38;R C does not allow you to initialize automatic arrays and structures, but it does allow you to initialize static arrays and structures. ANSI C and C++ allow you to initialize both kinds. But some older C++ translators use C compilers that are not fully ANSI C-compliant. If you are using such an implementation, you might need to use one of the three varieties of static storage classes for initializing arrays and structures.</p>
<hr/></div>
<p><a id="page_461"/>Let&#8217;s look at how to create the three different kinds of static duration variables; then we can go on to examine their properties. To create a static duration variable with external linkage, you declare it outside any block. To create a static duration variable with internal linkage, you declare it outside any block and use the <code>static</code> storage class modifier. To create a static duration variable with no linkage, you declare it inside a block, using the <code>static</code> modifier. The following code fragment shows these three variations:</p>
<p class="programlisting">...<br/>int global = 1000;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// static duration, external linkage<br/>static int one_file = 50;&#160;&#160;&#160;&#160;// static duration, internal linkage<br/>int main()<br/>{<br/>...<br/>}<br/>void funct1(int n)<br/>{<br/>&#160;&#160;&#160;&#160;static int count = 0;&#160;&#160;// static duration, no linkage<br/>&#160;&#160;&#160;&#160;int llama = 0;<br/>...<br/>}<br/>void funct2(int q)<br/>{<br/>...<br/>}</p>
<p>As stated previously, all the static duration variables (<code>global</code>, <code>one_file</code>, and <code>count</code>, in this example) persist from the time the program begins execution until it terminates. The variable <code>count</code>, which is declared inside <code>funct1()</code>, has local scope and no linkage, which means it can be used only inside the <code>funct1()</code> function, just like the automatic variable <code>llama</code>. But unlike <code>llama</code>, <code>count</code> remains in memory even when the <code>funct1()</code> function is not being executed. Both <code>global</code> and <code>one_file</code> have file scope, meaning they can be used from the point of declaration until the end of the file. In particular, both can be used in <code>main()</code>, <code>funct1()</code>, and <code>funct2()</code>. Because <code>one_file</code> has internal linkage, it can be used only in the file containing this code. Because <code>global</code> has external linkage, it also can be used in other files that are part of the program.</p>
<p>All static duration variables share the following initialization feature: An uninitialized static variable has all its bits set to <code>0</code>. Such a variable is said to be <em>zero-initialized</em>.</p>
<p><a href="#ch09table01">Table 9.1</a> summarizes the storage class features as used in the pre-namespace era. Next, we&#8217;ll examine the static duration varieties in more detail.</p>
<p class="caption"><a id="ch09table01"/><strong>Table 9.1. The Five Kinds of Variable Storage</strong></p>
<p class="image"><img src="graphics/09tab01.jpg" alt="Image"/></p>
<p>Note that the keyword <code>static</code> has somewhat different meanings in the two uses shown in <a href="#ch09table01">Table 9.1</a>. When used with a local declaration to indicate a static variable with no linkage, <code>static</code> indicates the kind of storage duration. When used with a declaration outside of a block, <code>static</code> indicates internal linkage; the variable already has static duration. One might term this <em>keyword overloading,</em> with the precise meaning determined by context.</p>
<h5 id="ch09lev3sec4">Initializing Static Variables</h5>
<p><a id="page_462"/>Static variables may be <em>zero-initialized</em>, they may undergo <em>constant expression initialization</em>, and they may undergo <em>dynamic initialization</em>. As you may have surmised, zero-initialization means setting the variable to the value zero. For scalar types, the zero is type cast to the appropriate type. For example, the null pointer, which is represented by 0 in C++ code, may have a nonzero internal representation, so a pointer variable would be initialized to that value. Structure members are zero-initialized, and any padding bits are set to zero.</p>
<p>Zero-initialization and constant-expression initialization collectively are called <em>static initialization</em>. This means the variable is initialized when the compiler processes the file (or translation unit). Dynamic initialization means the variable is initialized later.</p>
<p>So what determines which form of initialization takes place? First of all, all static variables are zero-initialized, whether or not any initialization is indicated. Next, if the variable is initialized using a constant expression that the compiler can evaluate solely from the file contents (including included header files), it can perform constant-expression initialization. The compiler is prepared to do simple calculations if needed. If there&#8217;s not enough information at this time, the variable will be dynamically initialized. Consider the following:</p>
<p class="programlisting">#include &lt;cmath&gt;<br/>int x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// zero-initialization<br/>int y = 5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// constant-expression initialization<br/>long z = 13 * 13;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// constant-expression initialization<br/>const double pi = 4.0 * atan(1.0);&#160;&#160;// dynamic initialization</p>
<p>First, <code>x</code>, <code>y</code>, <code>z</code>, and <code>pi</code> are zero-initialized. Then the compiler evaluates the constant expressions and initializes <code>y</code> and <code>z</code> to <code>5</code> and <code>169</code>, respectively. But initializing <code>pi</code> requires <a id="page_463"/>calling the <code>atan()</code> function, and this has to wait until the function is linked and the program executes.</p>
<p>A constant expression is not limited to arithmetic expressions using literal constants. It can, for example, use the <code>sizeof</code> operator:</p>
<p class="programlisting">int enough = 2 * sizeof (long) + 1;&#160;&#160;// constant expression initialization</p>
<p>C++11 introduces a new keyword, <code>constexpr</code>, to expand the options for creating constant expressions; this is one of the new C++11 features that this book does not pursue further.</p>
<h4 id="ch09lev2sec4">Static Duration, External Linkage</h4>
<p>Variables with external linkage are often simply called <em>external variables</em>. They necessarily have static storage duration and file scope. External variables are defined outside, and hence external to, any function. For example, they could be declared above the <code>main()</code> function or in a header file. You can use an external variable in any function that follows the external variable&#8217;s definition in the file. Thus, external variables are also termed <em>global variables</em>, in contrast to automatic variables, which are local variables.</p>
<h5 id="ch09lev3sec5">The One Definition Rule</h5>
<p>On the one hand, an external variable has to be declared in each file that uses the variable. On the other hand, C++ has the &#8220;one definition rule&#8221; (also known as <em>odr</em>), which states that there can be only one definition of a variable. To satisfy these requirements, C++ has two kinds of variable declarations. One is the <em>defining declaration</em> or, simply, a <em>definition</em>. It causes storage for the variable to be allocated. The second is the <em>referencing declaration</em> or, simply, a <em>declaration</em>. It does not cause storage to be allocated because it refers to an existing variable.</p>
<p>A referencing declaration uses the keyword <code>extern</code> and does not provide initialization. Otherwise, a declaration is a definition and causes storage to be allocated:</p>
<p class="programlisting">double up;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// definition, up is 0<br/>extern int blem;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// blem defined elsewhere<br/>extern char gr = 'z';&#160;&#160;// definition because initialized</p>
<p>If you use an external variable in several files, only one file can contain a definition for that variable (per the one definition rule). But every other file using the variable needs to declare that variable using the keyword <code>extern</code>:</p>
<p class="programlisting">// file01.cpp<br/>extern int cats = 20;&#160;&#160;// definition because of initialization<br/>int dogs = 22;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// also a definition<br/>int fleas;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// also a definition<br/>...<br/>// file02.cpp<br/>// use cats and dogs from file01.cpp<br/>extern int cats;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not definitions because they use<br/><a id="page_464"/>extern int dogs;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// extern and have no initialization<br/>...<br/>// file98.cpp<br/>// use cats, dogs, and fleas from file01.cpp<br/>extern int cats;<br/>extern int dogs;<br/>extern int fleas;<br/>...</p>
<p>In this case, all the files use the <code>cats</code> and <code>dogs</code> variables defined in <code>file01.cpp</code>. However, <code>file02.cpp</code> doesn&#8217;t re-declare the <code>fleas</code> variable, so it can&#8217;t access it. The <code>extern</code> in <code>file01.cpp</code> isn&#8217;t really needed because the effect is the same if it is omitted (also see <a href="#ch09fig04">Figure 9.4</a>).</p>
<p class="caption"><a id="ch09fig04"/><strong>Figure 9.4. Defining declaration and referencing declaration.</strong></p>
<p class="image"><img src="graphics/09fig04.jpg" alt="Image"/></p>
<p>Note that the one definition rule doesn&#8217;t mean that there can be only one variable with a given name. For example, automatic variables sharing the same name but defined in different functions are separate variables, independent of one another, and each having its own address. Also as later examples show, a local variable can hide a global variable of the same name. However, although a program can have different variables of the same name, each version can have only one definition.</p>
<p><a id="page_465"/>What if you define an external variable and then declare a variable by the same name inside a function? The second declaration is interpreted as a definition for an automatic variable. The automatic variable is the one that is in scope when the program executes that particular function. <a href="#ch09ex05">Listings 9.5</a> and <a href="#ch09ex06">9.6</a>, to be compiled together, illustrate using an external variable in two files and how an automatic variable hides a global variable of the same name. The program also shows how you can use the keyword <code>extern</code> to re-declare an external variable defined earlier and how you can use C++&#8217;s scope-resolution operator to access an otherwise hidden external variable.</p>
<p class="caption1"><a id="ch09ex05"/><strong>Listing 9.5. <code>external.cpp</code></strong></p><hr/>
<p class="programlisting1">// external.cpp -- external variables<br/>// compile with support.cpp<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>// external variable<br/>double warming = 0.3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// warming defined<br/>// function prototypes<br/>void update(double dt);<br/>void local();<br/><br/>int main()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// uses global variable<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Global warming is " &lt;&lt; warming &lt;&lt; " degrees.\n";<br/>&#160;&#160;&#160;&#160;update(0.1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// call function to change warming<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Global warming is " &lt;&lt; warming &lt;&lt; " degrees.\n";<br/>&#160;&#160;&#160;&#160;local();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// call function with local warming<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Global warming is " &lt;&lt; warming &lt;&lt; " degrees.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p class="caption1"><a id="ch09ex06"/><strong>Listing 9.6. <code>support.cpp</code></strong></p><hr/>
<p class="programlisting1">// support.cpp -- use external variable<br/>// compile with external.cpp<br/>#include &lt;iostream&gt;<br/>extern double warming;&#160;&#160;// use warming from another file<br/><br/>// function prototypes<br/>void update(double dt);<br/>void local();<br/><br/>using std::cout;<br/>void update(double dt)&#160;&#160;&#160;&#160;&#160;&#160;// modifies global variable<br/>{<br/>&#160;&#160;&#160;&#160;extern double warming;&#160;&#160;// optional redeclaration<br/>&#160;&#160;&#160;&#160;warming += dt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// uses global warming<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Updating global warming to " &lt;&lt; warming;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " degrees.\n";<br/>}<br/><br/>void local()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// uses local variable<br/>{<br/>&#160;&#160;&#160;&#160;double warming = 0.8;&#160;&#160;&#160;// new variable hides external one<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Local warming = " &lt;&lt; warming &lt;&lt; " degrees.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Access global variable with the<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// scope resolution operator<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "But global warming = " &lt;&lt; ::warming;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " degrees.\n";<br/>}</p><hr/>
<p><a id="page_466"/>Here is the output from the program:</p>
<p class="programlisting">Global warming is 0.3 degrees.<br/>Updating global warming to 0.4 degrees.<br/>Global warming is 0.4 degrees.<br/>Local warming = 0.8 degrees.<br/>But global warming = 0.4 degrees.<br/>Global warming is 0.4 degrees.</p>
<h5 id="ch09lev3sec6">Program Notes</h5>
<p>The output of the program in <a href="#ch09ex05">Listings 9.5</a> and <a href="#ch09ex06">9.6</a> illustrates that both <code>main()</code> and <code>update()</code> can access the external variable <code>warming</code>. Note that the change that <code>update()</code> makes to <code>warming</code> shows up in subsequent uses of the variable.</p>
<p>The definition for <code>warming</code> is in <a href="#ch09ex05">Listing 9.5</a>:</p>
<p class="programlisting">double warming = 0.3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// warming defined</p>
<p><a href="#ch09ex06">Listing 9.6</a> uses <code>extern</code> to make the <code>warming</code> variable available to the functions in that file:</p>
<p class="programlisting">extern double warming;&#160;&#160;// use warming from another file</p>
<p>As the comment indicates, this declaration says, &#8220;Use the <code>warming</code> variable defined externally elsewhere.&#8221;</p>
<p>In addition, the <code>update()</code> function re-declares the <code>warming</code> variable by using the keyword <code>extern</code>. This keyword means &#8220;Use the variable by this name previously defined externally.&#8221; Because that is what <code>update()</code> would do anyway if you omitted the entire declaration, this declaration is optional. It serves to document that the function is designed to use the external variable.</p>
<p>The <code>local()</code> function demonstrates that when you define a local variable that has the same name as a global variable, the local version hides the global version. The <code>local()</code> <a id="page_467"/>function, for example, uses the local definition of <code>warming</code> when it displays the value of <code>warming</code>.</p>
<p>C++ goes a step beyond C by offering the <em>scope-resolution operator</em> (<code>::</code>). When it is prefixed to the name of a variable, this operator means to use the global version of that variable. Thus, <code>local()</code> displays <code>warming</code> as <code>0.8</code>, but it displays <code>::warming</code> as <code>0.4</code>. You&#8217;ll encounter this operator again in namespaces and classes. In terms of clarity and error-avoidance, it would have been better and safer to use <code>::warming</code> in the <code>update()</code> function instead of using just <code>warming</code> and relying on scope rules.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch09sb04"/>Global Versus Local Variables</p>
<p class="sidebarpara">Now that you have a choice of using global or local variables, which should you use? At first, global variables have a seductive appeal&#8212;because all functions have access to a global variable, you don&#8217;t have to bother passing arguments. But this easy access has a heavy price: unreliable programs. Computing experience has shown that the better job your program does of isolating data from unnecessary access, the better job the program does in preserving the integrity of the data. Most often, you should use local variables and pass data to functions on a need-to-know basis rather than make data available indiscriminately by using global variables. As you will see, OOP takes this data isolation a step further.</p>
<p class="sidebarpara">Global variables do have their uses, however. For example, you might have a block of data that&#8217;s to be used by several functions, such as an array of month names or the atomic weights of the elements. The external storage class is particularly suited to representing constant data because you can use the keyword <code>const</code> to protect the data from change:</p>
<p class="programlistingB">const char * const months[12] =<br/>{<br/>&#160;&#160;&#160;&#160;"January", "February", "March", "April", "May",<br/>&#160;&#160;&#160;&#160;"June", "July", "August", "September", "October",<br/>&#160;&#160;&#160;&#160;"November", "December"<br/>};</p>
<p class="sidebarpara">In this example, the first <code>const</code> protects the strings from change, and the second <code>const</code> makes sure that each pointer in the array remains pointing to the same string to which it pointed initially.</p>
<hr/></div>
<h4 id="ch09lev2sec5">Static Duration, Internal Linkage</h4>
<p>Applying the <code>static</code> modifier to a file-scope variable gives it internal linkage. The difference between internal linkage and external linkage becomes meaningful in multifile programs. In that context, a variable with internal linkage is local to the file that contains it. But a regular external variable has external linkage, meaning that it can be used in different files, as the previous example showed.</p>
<p>What if you want to use the same name to denote different variables in different files? Can you just omit the <code>extern</code>?</p>
<p class="programlisting"><a id="page_468"/>// file1<br/>int errors = 20;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// external declaration<br/>...<br/>---------------------------------------------<br/>// file2<br/>int errors = 5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ??known to file2 only??<br/>void froobish()<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; errors;&#160;&#160;&#160;// fails<br/>&#160;&#160;&#160;&#160;&#160;&#160;...</p>
<p>No, this attempt fails because it violates the one definition rule. The <code>file2</code> definition attempts to create an external variable, so the program winds up with two definitions of <code>errors</code>, which is an error.</p>
<p>But if a file declares a static external variable that has the same name as an ordinary external variable declared in another file, the static version is the one in scope for that file:</p>
<p class="programlisting">// file1<br/>int errors = 20;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// external declaration<br/>...<br/>---------------------------------------------<br/>// file2<br/>static int errors = 5;&#160;&#160;// known to file2 only<br/>void froobish()<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; errors;&#160;&#160;&#160;// uses errors defined in file2<br/>&#160;&#160;&#160;&#160;&#160;&#160;...</p>
<p>This doesn&#8217;t violate the one definition rule because the keyword <code>static</code> establishes that the identifier <code>errors</code> has internal linkage, so no attempt is made to bring in an external definition.</p>
<div class="note"><hr/>
<p class="title"><a id="ch09note03"/>Note</p>
<p class="notepara">In a multifile program, you can define an external variable in one and only one file. All other files using that variable have to declare that variable with the <code>extern</code> keyword.</p>
<hr/></div>
<p>You can use an external variable to share data among different parts of a multifile program. You can use a static variable with internal linkage to share data among functions found in just one file. (Namespaces offer an alternative method for this.) Also if you make a file-scope variable static, you needn&#8217;t worry about its name conflicting with file-scope variables found in other files.</p>
<p><a href="#ch09ex07">Listings 9.7</a> and <a href="#ch09ex08">9.8</a> show how C++ handles variables with external and internal linkage. <a href="#ch09ex07">Listing 9.7</a> (<code>twofile1.cpp</code>) defines the external variables <code>tom</code> and <code>dick</code> and the static external variable <code>harry</code>. The <code>main()</code> function in that file displays the addresses of the three variables and then calls the <code>remote_access()</code> function, which is defined in a second file. <a href="#ch09ex08">Listing 9.8</a> (<code>twofile2.cpp</code>) shows that file. In addition to defining <code>remote_access()</code>, the file uses the <code>extern</code> keyword to share <code>tom</code> with the first file. Next, the file defines a static <a id="page_469"/>variable called <code>dick</code>. The <code>static</code> modifier makes this variable local to the file and overrides the global definition. Then the file defines an external variable called <code>harry</code>. It can do so without conflicting with the <code>harry</code> of the first file because the first <code>harry</code> has internal linkage only. Then the <code>remote_access()</code> function displays the addresses of these three variables so that you can compare them with the addresses of the corresponding variables in the first file. Remember that you need to compile both files and link them to get the complete program.</p>
<p class="caption1"><a id="ch09ex07"/><strong>Listing 9.7. <code>twofile1.cpp</code></strong></p><hr/>
<p class="programlisting1">// twofile1.cpp -- variables with external and internal linkage<br/>#include &lt;iostream&gt;&#160;&#160;&#160;&#160;&#160;// to be compiled with two file2.cpp<br/>int tom = 3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// external variable definition<br/>int dick = 30;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// external variable definition<br/>static int harry = 300; // static, internal linkage<br/><br/>// function prototype<br/>void remote_access();<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "main() reports the following addresses:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;tom &lt;&lt; " = &#38;tom, " &lt;&lt; &#38;dick &lt;&lt; " = &#38;dick, ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;harry &lt;&lt; " = &#38;harry\n";<br/>&#160;&#160;&#160;&#160;remote_access();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p class="caption1"><a id="ch09ex08"/><strong>Listing 9.8. <code>twofile2.cpp</code></strong></p><hr/>
<p class="programlisting1">// twofile2.cpp -- variables with internal and external linkage<br/>#include &lt;iostream&gt;<br/>extern int tom;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// tom defined elsewhere<br/>static int dick = 10;&#160;&#160;&#160;// overrides external dick<br/>int harry = 200;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// external variable definition,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no conflict with twofile1 harry<br/><br/>void remote_access()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "remote_access() reports the following addresses:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;tom &lt;&lt; " = &#38;tom, " &lt;&lt; &#38;dick &lt;&lt; " = &#38;dick, ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; &#38;harry &lt;&lt; " = &#38;harry\n";<br/>}</p><hr/>
<p><a id="page_470"/>Here is the output from the program produced by compiling <a href="#ch09ex07">Listings 9.7</a> and <a href="#ch09ex08">9.8</a> together:</p>
<p class="programlisting">main() reports the following addresses:<br/>0x0041a020 = &#38;tom, 0x0041a024 = &#38;dick, 0x0041a028 = &#38;harry<br/>remote_access() reports the following addresses:<br/>0x0041a020 = &#38;tom, 0x0041a450 = &#38;dick, 0x0041a454 = &#38;harry</p>
<p>As you can see from the addresses, both files use the same <code>tom</code> variable but different <code>dick</code> and <code>harry</code> variables. (The particular address values and formatting may be different on your system, but the <code>tom</code> addresses will match each other, and the <code>dick</code> and <code>harry</code> addresses won&#8217;t.)</p>
<h4 id="ch09lev2sec6">Static Storage Duration, No Linkage</h4>
<p>So far, we&#8217;ve looked at a file-scope variable with external linkage and a file-scope variable with internal linkage. Now let&#8217;s look at the third member of the static duration family: local variables with no linkage. You create such a variable by applying the <code>static</code> modifier to a variable defined inside a block. When you use it inside a block, <code>static</code> causes a local variable to have static storage duration. This means that even though the variable is known within that block, it exists even while the block is inactive. Thus a static local variable can preserve its value between function calls. (Static variables would be useful for reincarnation&#8212;you could use them to pass secret account numbers for a Swiss bank to your next appearance.) Also if you initialize a static local variable, the program initializes the variable once, when the program starts up. Subsequent calls to the function don&#8217;t reinitialize the variable the way they do for automatic variables. <a href="#ch09ex09">Listing 9.9</a> illustrates these points.</p>
<p class="caption1"><a id="ch09ex09"/><strong>Listing 9.9. <code>static.cpp</code></strong></p><hr/>
<p class="programlisting1">// static.cpp -- using a static local variable<br/>#include &lt;iostream&gt;<br/>// constants<br/>const int ArSize = 10;<br/><br/>// function prototype<br/>void strcount(const char * str);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char input[ArSize];<br/>&#160;&#160;&#160;&#160;char next;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a line:\n";<br/>&#160;&#160;&#160;&#160;cin.get(input, ArSize);<br/>&#160;&#160;&#160;&#160;while (cin)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(next);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (next != '\n')&#160;&#160;&#160;&#160;// string didn't fit!<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(next);&#160;&#160;&#160;&#160;&#160;&#160;// dispose of remainder<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;strcount(input);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter next line (empty line to quit):\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(input, ArSize);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void strcount(const char * str)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;static int total = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// static local variable<br/>&#160;&#160;&#160;&#160;int count = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// automatic local variable<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt;"\" contains ";<br/>&#160;&#160;&#160;&#160;while (*str++)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// go to end of string<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count++;<br/>&#160;&#160;&#160;&#160;total += count;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; count &lt;&lt; " characters\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; total &lt;&lt; " characters total\n";<br/>}</p><hr/>
<p><a id="page_471"/>Incidentally, the program in <a href="#ch09ex09">Listing 9.9</a> shows one way to deal with line input that may exceed the size of the destination array. Recall that the <code>cin.get(input,ArSize)</code> input method reads up to the end of the line or up to <code>ArSize - 1</code> characters, whichever comes first. It leaves the newline character in the input queue. This program uses <code>cin.get(next)</code> to read the character that follows the line input. If <code>next</code> is a newline character, then the preceding call to <code>cin.get(input, ArSize)</code> must have read the whole line. If <code>next</code> isn&#8217;t a newline character, there are more characters left on the line. This program then uses a loop to reject the rest of the line, but you can modify the code to use the rest of the line for the next input cycle. The program also uses the fact that attempting to read an empty line with <code>get(char *, int)</code> causes <code>cin</code> to test as <code>false</code>.</p>
<p>Here is the output of the program in <a href="#ch09ex09">Listing 9.9</a>:</p>
<p class="programlisting">Enter a line:<br/><span class="EmpStrong">nice pants</span><br/>"nice pant" contains 9 characters<br/>9 characters total<br/>Enter next line (empty line to quit):<br/><span class="EmpStrong">thanks</span><br/>"thanks" contains 6 characters<br/>15 characters total<br/><a id="page_472"/>Enter next line (empty line to quit):<br/><span class="EmpStrong">parting is such sweet sorrow</span><br/>"parting i" contains 9 characters<br/>24 characters total<br/>Enter next line (empty line to quit):<br/><span class="EmpStrong">ok</span><br/>"ok" contains 2 characters<br/>26 characters total<br/>Enter next line (empty line to quit):<br/><br/>Bye</p>
<p>Note that because the array size is <code>10</code>, the program does not read more than nine characters per line. Also note that the automatic variable <code>count</code> is reset to <code>0</code> each time the function is called. However, the static variable <code>total</code> is set to <code>0</code> once at the beginning. After that, <code>total</code> retains its value between function calls, so it&#8217;s able to maintain a running total.</p>
<h4 id="ch09lev2sec7">Specifiers and Qualifiers</h4>
<p>Certain C++ keywords, called <em>storage class specifiers</em> and <em>cv-qualifiers</em>, provide additional information about storage. Here&#8217;s a list of the storage class specifiers:</p>
<p class="programlisting">auto (eliminated as a specifier in C++11)<br/>register<br/>static<br/>extern<br/>thread_local (added by C++11)<br/>mutable</p>
<p>You&#8217;ve already seen most of these, and you can use no more than one of them in a single declaration, except that <code>thread_local</code> can be used with <code>static</code> or <code>extern</code>. To review, prior to C++11, the keyword <code>auto</code> could be used in a declaration to document that the variable is an automatic variable. (In C++11, <code>auto</code> is used for automatic type deduction.) The keyword <code>register</code> is used in a declaration to indicate the register storage class, which, in C++11, simply is an explicit way of saying the variable is automatic. The keyword <code>static</code>, when used with a file-scope declaration, indicates internal linkage. When used with a local declaration, it indicates static storage duration for a local variable. The keyword <code>extern</code> indicates a reference declaration&#8212;that is, that the declaration refers to a variable defined elsewhere. The keyword <code>thread_local</code> indicates that the duration of the variable is the duration of the containing thread. A <code>thread_local</code> variable is to a thread much as a regular static variable is to the whole program. The keyword <code>mutable</code> is explained in terms of <code>const</code>, so let&#8217;s look at the cv-qualifiers first before returning to <code>mutable</code>.</p>
<h5 id="ch09lev3sec7">Cv-Qualifiers</h5>
<p>Here are the cv-qualifiers:</p>
<p class="programlisting">const<br/>volatile</p>
<p><a id="page_473"/>(As you may have guessed, <em>cv</em> stands for <code>const</code> and <code>volatile</code>.) The most commonly used cv-qualifier is <code>const</code>, and you&#8217;ve already seen its purpose: It indicates that memory, after initialized, should not be altered by a program. We&#8217;ll come back to <code>const</code> in a moment.</p>
<p>The <code>volatile</code> keyword indicates that the value in a memory location can be altered even though nothing in the program code modifies the contents. This is less mysterious than it sounds. For example, you could have a pointer to a hardware location that contains the time or information from a port. In this case, the hardware, not the program, changes the contents. Or two programs may interact, sharing data. The intent of this keyword is to improve the optimization abilities of compilers. For example, suppose the compiler notices that a program uses the value of a particular variable twice within a few statements. Rather than have the program look up the value twice, the compiler might cache the value in a register. This optimization assumes that the value of the variable doesn&#8217;t change between the two uses. If you don&#8217;t declare a variable as <code>volatile</code>, then the compiler can feel free to make this optimization. If you do declare a variable as <code>volatile</code>, you&#8217;re telling the compiler not to make that sort of optimization.</p>
<h5 id="ch09lev3sec8"><code>mutable</code></h5>
<p>Now let&#8217;s return to <code>mutable</code>. You can use it to indicate that a particular member of a structure (or class) can be altered even if a particular structure (or class) variable is a <code>const</code>. For example, consider the following code:</p>
<p class="programlisting">struct data<br/>{<br/>&#160;&#160;&#160;&#160;char name[30];<br/>&#160;&#160;&#160;&#160;mutable int accesses;<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>const data veep = {"Claybourne Clodde", 0, ... };<br/>strcpy(veep.name, "Joye Joux");&#160;&#160;&#160;// not allowed<br/>veep.accesses++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// allowed</p>
<p>The <code>const</code> qualifier to <code>veep</code> prevents a program from changing <code>veep</code>&#8217;s members, but the <code>mutable</code> specifier to the <code>accesses</code> member shields <code>accesses</code> from that restriction.</p>
<p>This book doesn&#8217;t use <code>volatile</code> or <code>mutable</code>, but there is more to learn about <code>const</code>.</p>
<h5 id="ch09lev3sec9">More About <code>const</code></h5>
<p>In C++ (but not C), the <code>const</code> modifier alters the default storage classes slightly. Whereas a global variable has external linkage by default, a <code>const</code> global variable has internal linkage by default. That is, C++ treats a global <code>const</code> definition, such as in the following code fragment, as if the <code>static</code> specifier had been used:</p>
<p class="programlisting">const int fingers = 10;&#160;&#160;&#160;&#160;// same as static const int fingers = 10;<br/>int main(void)<br/>{<br/>&#160;&#160;&#160;&#160;...</p>
<p><a id="page_474"/>C++ has altered the rules for constant types to make life easier for you. Suppose, for example, that you have a set of constants that you&#8217;d like to place in a header file and that you use this header file in several files in the same program. After the preprocessor includes the header file contents in each source file, each source file will contain definitions like this:</p>
<p class="programlisting">const int fingers = 10;<br/>const char * warning = "Wak!";</p>
<p>If global <code>const</code> declarations had external linkage as regular variables do, this would be an error because of the one definition rule. That is, only one file can contain the preceding declaration, and the other files have to provide reference declarations using the <code>extern</code> keyword. Moreover, only the declarations without the <code>extern</code> keyword would be able to initialize values:</p>
<p class="programlisting">// extern would be required if const had external linkage<br/>extern const int fingers;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// can't be initialized<br/>extern const char * warning;</p>
<p>So you would need one set of definitions for one file and a different set of declarations for the other files. Instead, because externally defined <code>const</code> data has internal linkage, you can use the same declarations in all files.</p>
<p>Internal linkage also means that each file gets its own set of constants rather than sharing them. Each definition is private to the file that contains it. This is why it&#8217;s a good idea to put constant definitions in a header file. That way, as long as you include the same header file in two source code files, they receive the same set of constants.</p>
<p>If, for some reason, you want to make a constant have external linkage, you can use the <code>extern</code> keyword to override the default internal linkage:</p>
<p class="programlisting">extern const int states = 50;&#160;&#160;&#160;// definition with external linkage</p>
<p>You then must use the <code>extern</code> keyword to declare the constant in all files that use the constant. This differs from regular external variables, in which you don&#8217;t have to use the keyword <code>extern</code> when you define a variable, but you use <code>extern</code> in other files using that variable. Keep in mind, however, now that a single <code>const</code> is being shared among files, only one file can use initialization.</p>
<p>When you declare a <code>const</code> within a function or block, it has block scope, which means the constant is usable only when the program is executing code within the block. This means that you can create constants within a function or block and not have to worry about the names conflicting with constants defined elsewhere.</p>
<h4 id="ch09lev2sec8">Functions and Linkage</h4>
<p>Like variables, functions have linkage properties, although the selection is more limited than for variables. C++, like C, does not allow you to define one function inside another, so all functions automatically have static storage duration, meaning they are all present as long as the program is running. By default, functions have external linkage, meaning they can be shared across files. You can, in fact, use the keyword <code>extern</code> in a function prototype <a id="page_475"/>to indicate that the function is defined in another file, but that is optional. (For the program to find the function in another file, that file must be one of the files being compiled as part of the program or a library file searched by the linker.) You can also use the keyword <code>static</code> to give a function internal linkage, confining its use to a single file. You would apply this keyword to the prototype and to the function definition:</p>
<p class="programlisting">static int private(double x);<br/>...<br/>static int private(double x)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>This means the function is known only in that file. It also means you can use the same name for another function in a different file. As with variables, a static function overrides an external definition for the file containing the static declaration, so a file containing a static function definition will use that version of the function even if there is an external definition of a function that has the same name.</p>
<p>The one definition rule extends to non-inline functions, too. Therefore, every program shall contain exactly one definition of every non-inline function. For functions with external linkage, this means that only one file of a multifile program can contain the function definition. (This file could be a library file rather than one you supply.) However, each file that uses the function should have the function prototype.</p>
<p>Inline functions are excepted from this rule to allow you to place inline function definitions in a header file. Thus, each file that includes the header file ends up having the inline function definition. However, C++ does require that all the inline definitions for a particular function be identical.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch09sb05"/>Where C++ Finds Functions</p>
<p class="sidebarpara">Suppose you call a function in a particular file in a program. Where does C++ look for the function definition? If the function prototype in that file indicates that the function is static, the compiler looks only in that file for the function definition. Otherwise, the compiler (and the linker, too) looks in all the program files. If it finds two definitions, the compiler sends you an error message because you can have only one definition for an external function. If it fails to find any definition in the files, the function then searches the libraries. This implies that if you define a function that has the same name as a library function, the compiler uses your version rather than the library version. (However, C++ reserves the names of the standard library functions, so you shouldn&#8217;t reuse them.) Some compiler-linkers need explicit instructions to identify which libraries to search.</p>
<hr/></div>
<h4 id="ch09lev2sec9">Language Linking</h4>
<p>Another form of linking, called <em>language linking</em>, affects functions. First, a little background. A linker needs a different symbolic name for each distinct function. In C, this is simple to implement because there can be only one C function with a given name. So for internal purposes, a C compiler might translate a C function name such as <code>spiff</code> to <code>_spiff</code>. The <a id="page_476"/>C approach is termed <em>C language linkage</em>. However, C++ can have several functions with the same C++ name that have to be translated to separate symbolic names. Thus, the C++ compiler indulges in the process of name mangling or name decoration (as discussed in <a href="ch08.html#ch08">Chapter 8</a>) to generate different symbolic names for overloaded functions. For example, it could convert <code>spiff(int)</code> to, say, <code>_spiff_i</code>, and <code>spiff(double, double)</code> to <code>_spiff_d_d</code>. The C++ approach is <em>C++ language linkage</em>.</p>
<p>When the linker looks for a function to match a C++ function call, it uses a different look-up method than it does to match a C function call. But suppose you want to use a precompiled function from a C library in a C++ program? For example, suppose you have this code:</p>
<p class="programlisting">spiff(22); // want spiff(int) from a C library</p>
<p>Its hypothetical symbolic name in the C library file is <code>_spiff</code>, but for our hypothetical linker, the C++ look-up convention is to look for the symbolic name <code>_spiff_i</code>. To get around this problem, you can use the function prototype to indicate which protocol to use:</p>
<p class="programlisting">extern "C" void spiff(int);&#160;&#160;&#160;// use C protocol for name look-up<br/>extern void spoff(int);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use C++ protocol for name look-up<br/>extern "C++" void spaff(int); // use C++ protocol for name look-up</p>
<p>The first example here uses C language linkage. The second and third examples use C++ language linkage; the second does so by default, and the third does so explicitly.</p>
<p>C and C++ language linkage are the only specifiers required by the C++ Standard. But implementations have the option of providing additional language linkage specifiers.</p>
<h4 id="ch09lev2sec10">Storage Schemes and Dynamic Allocation</h4>
<p>You&#8217;ve seen the five schemes, excluding threaded memory, C++ uses to allocate memory for variables (including arrays and structures). They don&#8217;t apply to memory allocated by using the C++ <code>new</code> operator (or by using the older C <code>malloc()</code> function). We call that kind of memory <em>dynamic memory</em>. As you saw in <a href="ch04.html#ch04">Chapter 4</a>, dynamic memory is controlled by the <code>new</code> and <code>delete</code> operators, not by scope and linkage rules. Thus, dynamic memory can be allocated from one function and freed from another function. Unlike automatic memory, dynamic memory is not LIFO; the order of allocation and freeing depends on when and how <code>new</code> and <code>delete</code> are used. Typically, the compiler uses three separate memory chunks: one for static variables (this chunk might be subdivided), one for automatic variables, and one for dynamic storage.</p>
<p>Although the storage scheme concepts don&#8217;t apply to dynamic memory, they do apply to automatic and static pointer variables used to keep track of dynamic memory. For example, suppose you have the following statement inside a function:</p>
<p class="programlisting">float * p_fees = new float [20];</p>
<p>The 80 bytes (assuming that a <code>float</code> is 4 bytes) of memory allocated by <code>new</code> remains in memory until the <code>delete</code> operator frees it. But the <code>p_fees</code> pointer passes from existence when program execution exits the block containing this declaration. If you want to have <a id="page_477"/>the 80 bytes of allocated memory available to another function, you need to pass or return its address to that function. On the other hand, if you declare <code>p_fees</code> with external linkage, the <code>p_fees</code> pointer will be available to all the functions following that declaration in the file. And by using the following in a second file, you make that same pointer available in the second file:</p>
<p class="programlisting">extern float * p_fees;</p>
<div class="note"><hr/>
<p class="title"><a id="ch09note04"/>Note</p>
<p class="notepara">Memory allocated by <code>new</code> is typically freed when the program terminates. However, this is not always true. Under some less robust operating systems, for example, in some circumstances a request for a large block of memory can result in a block that is not deleted automatically when the program terminates. The best practice is to use <code>delete</code> to free memory allocated by <code>new</code>.</p>
<hr/></div>
<h5 id="ch09lev3sec10">Initialization with the <code>new</code> Operator</h5>
<p>What if you want to initialize a variable as part of the dynamic memory allocation? With C++98, you can do so in some instances. C++11 expands what is possible. Let&#8217;s look first at what has been possible.</p>
<p>If you wish to create and initialize storage for one of the scalar built-in types, such as <code>int</code> or <code>double</code>, you can do so by following the desired type with an initialization value enclosed in parentheses:</p>
<p class="programlisting">int *pi = new int (6);&#160;&#160;&#160;// *pi set to 6<br/>double * pd = new double (99.99);&#160;&#160;// *pd set to 99.99</p>
<p>The parentheses syntax also can be used with classes having suitable constructors, but we haven&#8217;t got that far yet.</p>
<p>To initialize an ordinary structure or an array, however, you need C++11 and list-initialization using braces. The new standard allows the following:</p>
<p class="programlisting">struct where {double x; double y; double z;};<br/>where * one = new where {2.5, 5.3, 7.2};&#160;&#160;// C++11<br/>int * ar = new int [4] {2,4,6,7};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C++11</p>
<p>With C++11, you also can use the brace initialization for single-valued variables:</p>
<p class="programlisting">int *pin = new int {});&#160;&#160;&#160;// *pi set to 6<br/>double * pdo = new double {99.99};&#160;&#160;// *pd set to 99.99</p>
<h5 id="ch09lev3sec11">When <code>new</code> Fails</h5>
<p>It may be that <code>new</code> can&#8217;t find the requested amount of memory. For its first decade, C++ handled that eventuality by having <code>new</code> return a null pointer. Currently, however, <code>new</code> throws a <code>std::bad_alloc</code> exception. <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>,&#8221; provides some short examples showing how each approach works.</p>
<h5 id="ch09lev3sec12"><code>new</code>: Operators, Functions, and Replacement Functions</h5>
<p><a id="page_478"/>The <code>new</code> and <code>new[]</code> operators call upon two functions:</p>
<p class="programlisting">void * operator new(std::size_t);&#160;&#160;&#160;&#160;&#160;// used by new<br/>void * operator new[](std::size_t);&#160;&#160;&#160;// used by new[]</p>
<p>These are termed <em>allocation functions</em>, and they are part of the global namespace. Similarly, there are deallocation functions used by <code>delete</code> and <code>delete []</code>:</p>
<p class="programlisting">void operator delete(void&#160;&#160;*);<br/>void operator delete[](void *);</p>
<p>They use the operator-overloading syntax discussed in <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>.&#8221; The <code>std::size_t</code> is a <code>typedef</code> for some suitable integer type. A basic statement such as</p>
<p class="programlisting">int * pi = new int;</p>
<p>gets translated into something like this:</p>
<p class="programlisting">int * pi = new(sizeof(int));</p>
<p>And the statement</p>
<p class="programlisting">int * pa = new int{40];</p>
<p>gets translated into something like this:</p>
<p class="programlisting">int * pa = new(40 * sizeof(int));</p>
<p>As you&#8217;ve seen, a statement with a <code>new</code> operator can also provide initialization values, so, in general, using the <code>new</code> operator may do more than just call the <code>new()</code> function.</p>
<p>Similarly,</p>
<p class="programlisting">delete pi;</p>
<p>invokes the following function call:</p>
<p class="programlisting">delete (pi);</p>
<p>Interestingly, C++ terms these functions <em>replaceable</em>. That means if you have sufficient expertise and desire, you can supply replacement functions for <code>new</code> and <code>delete</code> and tailor them to meet your specific requirements. One option, for instance, is to define replacement functions with class scope so that they can be tailored to fit the allocation needs of a particular class. Your code would use the <code>new</code> operator as usual, but the <code>new</code> operator would call upon the replacement <code>new()</code> function.</p>
<h5 id="ch09lev3sec13">The Placement <code>new</code> Operator</h5>
<p>Normally, the <code>new</code> operator has the responsibility of finding in the heap a block of memory that is large enough to handle the amount of memory you request. The <code>new</code> operator has a variation, called <em>placement</em> <code>new</code>, that allows you to specify the location to be used. A programmer might use this feature to set up his or her own memory-management <a id="page_479"/>procedures or to deal with hardware that is accessed via a particular address or to construct objects in a particular memory location.</p>
<p>To use the placement <code>new</code> feature, you first include the <code>new</code> header file, which provides a prototype for this version of <code>new</code>. Then you use <code>new</code> with an argument that provides the intended address. Aside from this argument, the syntax is the same as for regular <code>new</code>. In particular, you can use placement <code>new</code> either without or with brackets. The following code fragment shows the syntax for using these four forms of <code>new</code>:</p>
<p class="programlisting">#include &lt;new&gt;<br/>struct chaff<br/>{<br/>&#160;&#160;&#160;&#160;char dross[20];<br/>&#160;&#160;&#160;&#160;int slag;<br/>};<br/>char buffer1[50];<br/>char buffer2[500];<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;chaff *p1, *p2;<br/>&#160;&#160;&#160;&#160;int *p3, *p4;<br/>// first, the regular forms of new<br/>&#160;&#160;&#160;&#160;p1 = new chaff;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// place structure in heap<br/>&#160;&#160;&#160;&#160;p3 = new int[20];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// place int array in heap<br/>// now, the two forms of placement new<br/>&#160;&#160;&#160;&#160;p2 = new (buffer1) chaff;&#160;&#160;&#160;&#160;// place structure in buffer1<br/>&#160;&#160;&#160;&#160;p4 = new (buffer2) int[20];&#160;&#160;// place int array in buffer2<br/>...</p>
<p>For simplicity, this example uses two static arrays to provide memory space for placement <code>new</code>. So this code allocates space for a <code>chaff</code> structure in <code>buffer1</code> and space for an array of 20 <code>int</code>s in <code>buffer2</code>.</p>
<p>Now that you&#8217;ve made your acquaintance with placement <code>new</code>, let&#8217;s look at a sample program. <a href="#ch09ex10">Listing 9.10</a> uses both <code>new</code> and placement <code>new</code> to create dynamically allocated arrays. This program illustrates some important differences between <code>new</code> and placement <code>new</code> that we&#8217;ll discuss after seeing the output.</p>
<p class="caption1"><a id="ch09ex10"/><strong>Listing 9.10. <code>newplace.cpp</code></strong></p><hr/>
<p class="programlisting1">// newplace.cpp -- using placement new<br/>#include &lt;iostream&gt;<br/>#include &lt;new&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// for placement new<br/>const int BUF = 512;<br/>const int N = 5;<br/>char buffer[BUF];&#160;&#160;&#160;&#160;&#160;&#160;// chunk of memory<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/><a id="page_480"/>&#160;&#160;&#160;&#160;double *pd1, *pd2;<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Calling new and placement new:\n";<br/>&#160;&#160;&#160;&#160;pd1 = new double[N];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use heap<br/>&#160;&#160;&#160;&#160;pd2 = new (buffer) double[N];&#160;&#160;// use buffer array<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; N; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pd2[i] = pd1[i] = 1000 + 20.0 * i;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory addresses:\n" &lt;&lt; "&#160;&#160;heap: " &lt;&lt; pd1<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;static: " &lt;&lt; (void *) buffer&#160;&#160;&lt;&lt;endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory contents:\n";<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; N; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pd1[i] &lt;&lt; " at " &lt;&lt; &#38;pd1[i] &lt;&lt; "; ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pd2[i] &lt;&lt; " at " &lt;&lt; &#38;pd2[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nCalling new and placement new a second time:\n";<br/>&#160;&#160;&#160;&#160;double *pd3, *pd4;<br/>&#160;&#160;&#160;&#160;pd3= new double[N];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// find new address<br/>&#160;&#160;&#160;&#160;pd4 = new (buffer) double[N];&#160;&#160;// overwrite old data<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; N; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pd4[i] = pd3[i] = 1000 + 40.0 * i;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory contents:\n";<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; N; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pd3[i] &lt;&lt; " at " &lt;&lt; &#38;pd3[i] &lt;&lt; "; ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pd4[i] &lt;&lt; " at " &lt;&lt; &#38;pd4[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nCalling new and placement new a third time:\n";<br/>&#160;&#160;&#160;&#160;delete [] pd1;<br/>&#160;&#160;&#160;&#160;pd1= new double[N];<br/>&#160;&#160;&#160;&#160;pd2 = new (buffer + N * sizeof(double)) double[N];<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; N; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pd2[i] = pd1[i] = 1000 + 60.0 * i;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory contents:\n";<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; N; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pd1[i] &lt;&lt; " at " &lt;&lt; &#38;pd1[i] &lt;&lt; "; ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pd2[i] &lt;&lt; " at " &lt;&lt; &#38;pd2[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;delete [] pd1;<br/>&#160;&#160;&#160;&#160;delete [] pd3;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_481"/>Here is the output from the program in <a href="#ch09ex10">Listing 9.10</a> on one system:</p>
<p class="programlisting">Calling new and placement new:<br/>Memory addresses:<br/>&#160;&#160;heap: 006E4AB0&#160;&#160;static: 00FD9138<br/>Memory contents:<br/>1000 at 006E4AB0; 1000 at 00FD9138<br/>1020 at 006E4AB8; 1020 at 00FD9140<br/>1040 at 006E4AC0; 1040 at 00FD9148<br/>1060 at 006E4AC8; 1060 at 00FD9150<br/>1080 at 006E4AD0; 1080 at 00FD9158<br/><br/>Calling new and placement new a second time:<br/>Memory contents:<br/>1000 at 006E4B68; 1000 at 00FD9138<br/>1040 at 006E4B70; 1040 at 00FD9140<br/>1080 at 006E4B78; 1080 at 00FD9148<br/>1120 at 006E4B80; 1120 at 00FD9150<br/>1160 at 006E4B88; 1160 at 00FD9158<br/><br/>Calling new and placement new a third time:<br/>Memory contents:<br/>1000 at 006E4AB0; 1000 at 00FD9160<br/>1060 at 006E4AB8; 1060 at 00FD9168<br/>1120 at 006E4AC0; 1120 at 00FD9170<br/>1180 at 006E4AC8; 1180 at 00FD9178<br/>1240 at 006E4AD0; 1240 at 00FD9180</p>
<h5 id="ch09lev3sec14">Program Notes</h5>
<p>The first thing to note about <a href="#ch09ex10">Listing 9.10</a> is that placement <code>new</code> does, indeed, place the <code>p2</code> array in the <code>buffer</code> array; both <code>p2</code> and <code>buffer</code> have the value <code>00FD9138</code>. They are, however, of different types; <code>p1</code> is pointer-to-<code>double</code>, whereas <code>buffer</code> is pointer-to-<code>char</code>. (By the way, that&#8217;s why the program uses a <code>(void *)</code> cast for <code>buffer</code>; otherwise, <code>cout</code> would try to display a string.) Meanwhile, regular <code>new</code> locates the <code>p1</code> array rather far away in memory, at location <code>006E4AB0</code>, which is part of the dynamically managed heap.</p>
<p>The second point to note is that the second call to regular <code>new</code> results in <code>new</code> finding a new block of memory&#8212;one beginning at <code>006E4B68</code>. But the second call to placement <code>new</code> results in the same block of memory being used as before&#8212;that is, the block beginning at <code>00FD9138</code>. The important fact here is that placement <code>new</code> simply uses the address that is passed to it; it doesn&#8217;t keep track of whether that location has already been used, and it doesn&#8217;t search the block for unused memory. This shifts some of the burden of memory management to the programmer. For example, the third call to placement <code>new</code> provides an offset into the buffer array so that new memory is used:</p>
<p class="programlisting">pd2 = new (buffer + N * sizeof(double)) double[N]; // offset of 40 bytes</p>
<p><a id="page_482"/>The third point has to do with the use and nonuse of <code>delete</code>. For regular <code>new</code>, the following statement frees up the block of memory beginning at <code>006E4AB0</code>, and as a result, the next call to <code>new</code> is able to reuse that block:</p>
<p class="programlisting">delete [] pd1;</p>
<p>In contrast, the program in <a href="#ch09ex10">Listing 9.10</a> does not use <code>delete</code> to free the memory used by placement <code>new</code>. In fact, in this case, it can&#8217;t. The memory specified by <code>buffer</code> is static memory, and <code>delete</code> can be used only with a pointer to heap memory allocated by regular <code>new</code>. That is, the <code>buffer</code> array is outside the jurisdiction of <code>delete</code>, and the following statement will produce a runtime error:</p>
<p class="programlisting">delete [] pd2;&#160;&#160;&#160;// won't work</p>
<p>On the other hand, if you use regular <code>new</code> to create a buffer in the first place, you use regular <code>delete</code> to free that entire block.</p>
<p>Another way you can use placement <code>new</code> is to combine it with <code>new</code> initialization to place information at a specific hardware address.</p>
<p>You may wonder exactly what the placement <code>new</code> function does. Basically, it does nothing other than return the address passed to it, type casting it to <code>void *</code> so that it can be assigned to any pointer type. But that&#8217;s the default placement <code>new</code>. C++ allows programmers to overload placement <code>new</code>.</p>
<p>The situation becomes more involved when you use placement <code>new</code> with class objects. <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; continues this story.</p>
<h5 id="ch09lev3sec15">Other Forms of Placement <code>new</code></h5>
<p>Just as regular <code>new</code> invokes a new function with one argument, the standard placement <code>new</code> invokes a new function with two arguments:</p>
<p class="programlisting">int * pi = new int;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invokes new(sizeof(int))<br/>int * p2 = new(buffer) int;&#160;&#160;&#160;&#160;&#160;// invokes new(sizeof(int), buffer)<br/>int * p3 = new(buffer) int[40]; // invokes new(40*sizeof(int), buffer)</p>
<p>The placement <code>new</code> function is not replaceable, but it can be overloaded. It needs at least two parameters, the first of which always is a <code>std::size_t</code> parameter designating the number of bytes requested. Any such overloaded function is termed a placement <code>new</code>, even if the additional parameters don&#8217;t specify a location.</p>
<h3 id="ch09lev1sec3">Namespaces</h3>
<p>Names in C++ can refer to variables, functions, structures, enumerations, classes, and class and structure members. When programming projects grow large, the potential for name conflicts increases. When you use class libraries from more than one source, you can get name conflicts. For example, two libraries might both define classes named <code>List</code>, <code>Tree</code>, and <code>Node</code>, but in incompatible ways. You might want the <code>List</code> class from one library and the <code>Tree</code> from the other, and each might expect its own version of <code>Node</code>. Such conflicts are termed <em>namespace problems</em>.</p>
<p><a id="page_483"/>The C++ Standard provides namespace facilities to provide greater control over the scope of names. It took a while for compilers to incorporate namespaces, but, by now, support has become common.</p>
<h4 id="ch09lev2sec11">Traditional C++ Namespaces</h4>
<p>Before looking at the new namespace facilities in C++, let&#8217;s review the namespace properties that already exist in C++ and introduce some terminology. This can help make the idea of namespaces seem more familiar.</p>
<p>One term you need to be aware of is <em>declarative region</em>. A declarative region is a region in which declarations can be made. For example, you can declare a global variable outside any function. The declarative region for that variable is the file in which it is declared. If you declare a variable inside a function, its declarative region is the innermost block in which it is declared.</p>
<p>A second term you need to be aware of is <em>potential scope</em>. The potential scope for a variable begins at its point of declaration and extends to the end of its declarative region. So the potential scope is more limited than the declarative region because you can&#8217;t use a variable above the point where it is first defined.</p>
<p>However, a variable might not be visible everywhere in its potential scope. For instance, it might be hidden by another variable of the same name declared in a nested declarative region. For example, a local variable declared in a function (for this variable, the declarative region is the function) hides a global variable declared in the same file (for this variable, the declarative region is the file). The portion of the program that can actually see the variable is termed the <em>scope</em>, which is the way we&#8217;ve been using the term all along. <a href="#ch09fig05">Figures 9.5</a> and <a href="#ch09fig06">9.6</a> illustrate the terms <em>declarative region</em>, <em>potential scope</em>, and <em>scope</em>.</p>
<p class="caption"><a id="ch09fig05"/><strong>Figure 9.5. Declarative regions.</strong></p>
<p class="image"><img src="graphics/09fig05.jpg" alt="Image"/></p>
<p class="caption"><a id="ch09fig06"/><strong>Figure 9.6. Potential scope and scope.</strong></p>
<p class="image"><img src="graphics/09fig06.jpg" alt="Image"/></p>
<p>C++&#8217;s rules about global and local variables define a kind of namespace hierarchy. Each declarative region can declare names that are independent of names declared in other declarative regions. A local variable declared in one function doesn&#8217;t conflict with a local variable declared in a second function.</p>
<h4 id="ch09lev2sec12">New Namespace Features</h4>
<p>C++ now adds the ability to create named namespaces by defining a new kind of declarative region, one whose main purpose is to provide an area in which to declare names. The names in one namespace don&#8217;t conflict with the same names declared in other namespaces, and there are mechanisms for letting other parts of a program use items declared in a namespace. The following code, for example, uses the new keyword <code>namespace</code> to create two namespaces, <code>Jack</code> and <code>Jill</code>:</p>
<p class="programlisting">namespace Jack {<br/>&#160;&#160;&#160;&#160;double pail;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// variable declaration<br/>&#160;&#160;&#160;&#160;void fetch();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// function prototype<br/>&#160;&#160;&#160;&#160;int pal;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// variable declaration<br/>&#160;&#160;&#160;&#160;struct Well { ... };&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// structure declaration<br/>}<br/>namespace Jill {<br/><a id="page_484"/>&#160;&#160;&#160;&#160;double bucket(double n) { ... }&#160;&#160;&#160;// function definition<br/>&#160;&#160;&#160;&#160;double fetch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// variable declaration<br/>&#160;&#160;&#160;&#160;int pal;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// variable declaration<br/>&#160;&#160;&#160;&#160;struct Hill { ... };&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// structure declaration<br/>}</p>
<p>Namespaces can be located at the global level or inside other namespaces, but they cannot be placed in a block. Thus, a name declared in a namespace has external linkage by default (unless it refers to a constant).</p>
<p>In addition to user-defined namespaces, there is one more namespace, the <em>global namespace</em>. This corresponds to the file-level declarative region, so what used to be termed <em>global variables</em> are now described as being part of the global namespace.</p>
<p>The names in any one namespace don&#8217;t conflict with names in another namespace. Thus, the <code>fetch</code> in <code>Jack</code> can coexist with the <code>fetch</code> in <code>Jill</code>, and the <code>Hill</code> in <code>Jill</code> can coexist with an external <code>Hill</code>. The rules governing declarations and definitions in a namespace are the same as the rules for global declarations and definitions.</p>
<p><a id="page_485"/>Namespaces are <em>open</em>, meaning that you can add names to existing namespaces. For example, the following statement adds the name <code>goose</code> to the existing list of names in <code>Jill</code>:</p>
<p class="programlisting">namespace Jill {<br/>&#160;&#160;&#160;&#160;char * goose(const char *);<br/>}</p>
<p>Similarly, the original <code>Jack</code> namespace provides a prototype for a <code>fetch()</code> function. You can provide the code for the function later in the file (or in another file) by using the <code>Jack</code> namespace again:</p>
<p class="programlisting">namespace Jack {<br/>&#160;&#160;&#160;&#160;void fetch()<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<p><a id="page_486"/>Of course, you need a way to access names in a given namespace. The simplest way is to use <code>::</code>, the scope-resolution operator, to <em>qualify</em> a name with its namespace:</p>
<p class="programlisting">Jack::pail = 12.34;&#160;&#160;// use a variable<br/>Jill::Hill mole;&#160;&#160;&#160;&#160;&#160;// create a type Hill structure<br/>Jack::fetch();&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use a function</p>
<p>An unadorned name, such as <code>pail</code>, is termed the <em>unqualified name</em>, whereas a name with the namespace, as in <code>Jack::pail</code>, is termed a <em>qualified name</em>.</p>
<h5 id="ch09lev3sec16"><code>using</code> Declarations and <code>using</code> Directives</h5>
<p>Having to qualify names every time they are used is not always an appealing prospect, so C++ provides two mechanisms&#8212;the <code>using</code> <em>declaration</em> and the <code>using</code> <em>directive</em>&#8212;to simplify using namespace names. The <code>using</code> declaration lets you make particular identifiers available, and the <code>using</code> directive makes the entire namespace accessible.</p>
<p>The <code>using</code> declaration involves preceding a qualified name with the keyword <code>using</code>:</p>
<p class="programlisting">using Jill::fetch;&#160;&#160;&#160;&#160;// a using declaration</p>
<p>A <code>using</code> declaration adds a particular name to the declarative region in which it occurs. For example, the <code>using</code> declaration of <code>Jill::fetch</code> in <code>main()</code> adds <code>fetch</code> to the declarative region defined by <code>main()</code>. After making this declaration, you can use the name <code>fetch</code> instead of <code>Jill::fetch</code>. The following code fragment illustrates these points:</p>
<p class="programlisting">namespace Jill {<br/>&#160;&#160;&#160;&#160;double bucket(double n) { ... }<br/>&#160;&#160;&#160;&#160;double fetch;<br/>&#160;&#160;&#160;&#160;struct Hill { ... };<br/>}<br/>char fetch;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using Jill::fetch;&#160;&#160;&#160;// put fetch into local namespace<br/>&#160;&#160;&#160;&#160;double fetch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Error! Already have a local fetch<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; fetch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a value into Jill::fetch<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ::fetch;&#160;&#160;&#160;&#160;&#160;&#160;// read a value into global fetch<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>Because a <code>using</code> declaration adds the name to the local declarative region, this example precludes creating another local variable by the name of <code>fetch</code>. Also like any other local variable, <code>fetch</code> would override a global variable by the same name.</p>
<p>Placing a <code>using</code> declaration at the external level adds the name to the global namespace:</p>
<p class="programlisting">void other();<br/>namespace Jill {<br/>&#160;&#160;&#160;&#160;double bucket(double n) { ... }<br/>&#160;&#160;&#160;&#160;double fetch;<br/>&#160;&#160;&#160;&#160;struct Hill { ... };<br/>}<br/><a id="page_487"/>using Jill::fetch;&#160;&#160;&#160;// put fetch into global namespace<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; fetch;&#160;&#160;&#160;&#160;// read a value into Jill::fetch<br/>&#160;&#160;&#160;&#160;other()<br/>...<br/>}<br/><br/>void other()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; fetch;&#160;&#160;&#160;// display Jill::fetch<br/>...<br/>}</p>
<p>A <code>using</code> declaration, then, makes a single name available. In contrast, the <code>using</code> directive makes <em>all</em> the names available. A <code>using</code> directive involves preceding a namespace name with the keywords <code>using namespace</code>, and it makes all the names in the namespace available without the use of the scope-resolution operator:</p>
<p class="programlisting">using namespace Jack;&#160;&#160;// make all the names in Jack available</p>
<p>Placing a <code>using</code> directive at the global level makes the namespace names available globally. You&#8217;ve seen this in action a few times in this book in the following form:</p>
<p class="programlisting">#include &lt;iostream&gt;&#160;&#160;&#160;&#160;// places names in namespace std<br/>using namespace std;&#160;&#160;&#160;// make names available globally</p>
<p>Placing a <code>using</code> directive in a particular function makes the names available just in that function. Here&#8217;s an example:</p>
<p class="programlisting">int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace jack; // make names available in vorn()<br/>...<br/>}</p>
<p>You&#8217;ve seen this form often in this book with the <code>std</code> namespace.</p>
<p>One thing to keep in mind about <code>using</code> directives and <code>using</code> declarations is that they increase the possibility of name conflicts. That is, if you have both namespace <code>jack</code> and namespace <code>jill</code> available, and you use the scope-resolution operator, there is no ambiguity:</p>
<p class="programlisting">jack::pal = 3;<br/>jill::pal =10;</p>
<p>The variables <code>jack::pal</code> and <code>jill::pal</code> are distinct identifiers for distinct memory locations. However, if you employ <code>using</code> declarations, the situation changes:</p>
<p class="programlisting">using jack::pal;<br/>using jill::pal;<br/>pal = 4;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// which one? now have a conflict</p>
<p><a id="page_488"/>In fact, the compiler won&#8217;t let you use both of these <code>using</code> declarations because of the ambiguity that would be created.</p>
<h5 id="ch09lev3sec17"><code>using</code> Directives Versus <code>using</code> Declarations</h5>
<p>Using a <code>using</code> directive to import all the names from a namespace wholesale is <em>not</em> the same as using multiple <code>using</code> declarations. It&#8217;s more like the mass application of a scope-resolution operator. When you use a <code>using</code> declaration, it is as if the name is declared at the location of the <code>using</code> declaration. If a particular name is already declared in a function, you can&#8217;t import the same name with a <code>using</code> declaration. When you use a <code>using</code> directive, however, name resolution takes place as if you declared the names in the smallest declarative region containing both the <code>using</code> declaration and the namespace itself. For the following example, that would be the global namespace. If you use a <code>using</code> directive to import a name that is already declared in a function, the local name will hide the namespace name, just as it would hide a global variable of the same name. However, you can still use the scope-resolution operator, as in the following example:</p>
<p class="programlisting">namespace Jill {<br/>&#160;&#160;&#160;&#160;double bucket(double n) { ... }<br/>&#160;&#160;&#160;&#160;double fetch;<br/>&#160;&#160;&#160;&#160;struct Hill { ... };<br/>}<br/>char fetch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// global namespace<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace Jill;&#160;&#160;&#160;&#160;&#160;&#160;// import all namespace names<br/>&#160;&#160;&#160;&#160;Hill Thrill;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create a type Jill::Hill structure<br/>&#160;&#160;&#160;&#160;double water = bucket(2);&#160;&#160;// use Jill::bucket();<br/>&#160;&#160;&#160;&#160;double fetch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not an error; hides Jill::fetch<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; fetch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a value into the local fetch<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ::fetch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a value into global fetch<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; Jill::fetch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a value into Jill::fetch<br/>&#160;&#160;&#160;&#160;...<br/>}<br/><br/>int foom()<br/>{<br/>&#160;&#160;&#160;&#160;Hill top;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ERROR<br/>&#160;&#160;&#160;&#160;Jill::Hill crest;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid<br/>}</p>
<p>Here, in <code>main()</code>, the name <code>Jill::fetch</code> is placed in the local namespace. It doesn&#8217;t have local scope, so it doesn&#8217;t override the global <code>fetch</code>. But the locally declared <code>fetch</code> hides both <code>Jill::fetch</code> and the global <code>fetch</code>. However, both of the last two <code>fetch</code> variables are available if you use the scope-resolution operator. You might want to compare this example to the preceding one, which uses a <code>using</code> declaration.</p>
<p><a id="page_489"/>One other point of note is that although a <code>using</code> directive in a function treats the namespace names as being declared outside the function, it doesn&#8217;t make those names available to other functions in the file. Hence in the preceding example, the <code>foom()</code> function can&#8217;t use the unqualified <code>Hill</code> identifier.</p>
<div class="note"><hr/>
<p class="title"><a id="ch09note05"/>Note</p>
<p class="notepara">Suppose a namespace and a declarative region both define the same name. If you attempt to use a <code>using</code> declaration to bring the namespace name into the declarative region, the two names conflict, and you get an error. If you use a <code>using</code> directive to bring the namespace name into the declarative region, the local version of the name hides the namespace version.</p>
<hr/></div>
<p>Generally speaking, the <code>using</code> declaration is safer to use than a <code>using</code> directive because it shows exactly what names you are making available. And if the name conflicts with a local name, the compiler lets you know. The <code>using</code> directive adds all names, even ones you might not need. If a local name conflicts, it overrides the namespace version, and you aren&#8217;t warned. Also the open nature of namespaces means that the complete list of names in a namespace might be spread over several locations, making it difficult to know exactly which names you are adding.</p>
<p>This is the approach used for most of this book&#8217;s examples:</p>
<p class="programlisting">#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;</p>
<p>First, the <code>iostream</code> header file puts everything in the <code>std</code> namespace. Then, the <code>using</code> directive makes the names available within <code>main()</code>. Some examples do this instead:</p>
<p class="programlisting">#include &lt;iostream&gt;<br/>using namespace std;<br/>int main()<br/>{</p>
<p>This exports everything from the <code>std</code> namespace into the global namespace. The main rationale for this approach is expediency. It&#8217;s easy to do, and if your system doesn&#8217;t have namespaces, you can replace the first two of the preceding code lines with the original form:</p>
<p class="programlisting">#include &lt;iostream.h&gt;</p>
<p>However, namespace proponents hope that you will be more selective and use either the scope-resolution operator or the <code>using</code> declaration. That is, you shouldn&#8217;t use the following:</p>
<p class="programlisting">using namespace std;&#160;&#160;// avoid as too indiscriminate</p>
<p><a id="page_490"/>Instead, you should use this:</p>
<p class="programlisting">int x;<br/>std::cin &gt;&gt; x;<br/>std::cout &lt;&lt; x &lt;&lt; std::endl;</p>
<p>Or you could use this:</p>
<p class="programlisting">using std::cin;<br/>using std::cout;<br/>using std::endl;<br/>int x;<br/>cin &gt;&gt; x;<br/>cout &lt;&lt; x &lt;&lt; endl;</p>
<p>You can use nested namespaces, as described in the following section, to create a namespace that holds the <code>using</code> declarations you commonly use.</p>
<h5 id="ch09lev3sec18">More Namespace Features</h5>
<p>You can nest namespace declarations, like this:</p>
<p class="programlisting">namespace elements<br/>{<br/>&#160;&#160;&#160;&#160;namespace fire<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int flame;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;float water;<br/>}</p>
<p>In this case, you refer to the <code>flame</code> variable as <code>elements::fire::flame</code>. Similarly, you can make the inner names available with this <code>using</code> directive:</p>
<p class="programlisting">using namespace elements::fire;</p>
<p>Also you can use <code>using</code> directives and <code>using</code> declarations inside namespaces, like this:</p>
<p class="programlisting">namespace myth<br/>{<br/>&#160;&#160;&#160;&#160;using Jill::fetch;<br/>&#160;&#160;&#160;&#160;using namespace elements;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>}</p>
<p>Suppose you want to access <code>Jill::fetch</code>. Because <code>Jill::fetch</code> is now part of the <code>myth</code> namespace, where it can be called <code>fetch</code>, you can access it this way:</p>
<p class="programlisting">std::cin &gt;&gt; myth::fetch;</p>
<p><a id="page_491"/>Of course, because it is also part of the <code>Jill</code> namespace, you still can call it <code>Jill::fetch</code>:</p>
<p class="programlisting">std::cout &lt;&lt; Jill::fetch;&#160;&#160;// display value read into myth::fetch</p>
<p>Or you can do this, provided that no local variables conflict:</p>
<p class="programlisting">using namespace myth;<br/>cin &gt;&gt; fetch;&#160;&#160;&#160;&#160;&#160;&#160;// really std::cin and Jill::fetch</p>
<p>Now consider applying a <code>using</code> directive to the <em>myth</em> namespace. The <code>using</code> directive is <em>transitive</em>. We say that an operation <em>op</em> is transitive if A <em>op</em> B and B <em>op</em> C implies A <em>op</em> C. For example, the <code>&gt;</code> operator is transitive. (That is, A bigger than B and B bigger than C implies A bigger than C.) In this context, the upshot is that the following statement places both the <code>myth</code> and the <code>elements</code> namespaces in scope:</p>
<p class="programlisting">using namespace myth;</p>
<p>This single directive has the same effect as the following two directives:</p>
<p class="programlisting">using namespace myth;<br/>using namespace elements;</p>
<p>You can create an alias for a namespace. For example, suppose you have a namespace defined as follows:</p>
<p class="programlisting">namespace my_very_favorite_things { ... };</p>
<p>You can make <code>mvft</code> an alias for <code>my_very_favorite_things</code> by using the following statement:</p>
<p class="programlisting">namespace mvft = my_very_favorite_things;</p>
<p>You can use this technique to simplify using nested namespaces:</p>
<p class="programlisting">namespace MEF = myth::elements::fire;<br/>using MEF::flame;</p>
<h5 id="ch09lev3sec19">Unnamed Namespaces</h5>
<p>You can create an <em>unnamed namespace</em> by omitting the namespace name:</p>
<p class="programlisting">namespace&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// unnamed namespace<br/>{<br/>&#160;&#160;&#160;&#160;int ice;<br/>&#160;&#160;&#160;&#160;int bandycoot;<br/>}</p>
<p>This code behaves as if it were followed by a <code>using</code> directive; that is, the names declared in this namespace are in potential scope until the end of the declarative region that contains the unnamed namespace. In this respect, names in an unnamed namespace are like global variables. However, if a namespace has no name, you can&#8217;t explicitly use a <code>using</code> directive or <code>using</code> declaration to make the names available elsewhere. In particular, <a id="page_492"/>you can&#8217;t use names from an unnamed namespace in a file other than the one that contains the namespace declaration. This provides an alternative to using static variables with internal linkage. Suppose, for example, you have this code:</p>
<p class="programlisting">static int counts;&#160;&#160;&#160;// static storage, internal linkage<br/>int other();<br/>int main()<br/>{<br/>...<br/>}<br/><br/>int other()<br/>{<br/>...<br/>}</p>
<p>The namespace approach is to do this instead:</p>
<p class="programlisting">namespace<br/>{<br/>&#160;&#160;&#160;&#160;int counts;&#160;&#160;&#160;// static storage, internal linkage<br/>}<br/>int other();<br/>int main()<br/>{<br/>...<br/>}<br/><br/>int other()<br/>{<br/>...<br/>}</p>
<h4 id="ch09lev2sec13">A Namespace Example</h4>
<p>Let&#8217;s take a look at a multifile example that demonstrates some of the features of namespaces. The first file in this example (see <a href="#ch09ex11">Listing 9.11</a>) is a header file that contains some items normally found in header files&#8212;constants, structure definitions, and function prototypes. In this case, the items are placed in two namespaces. The first namespace, <code>pers</code>, contains a definition of a <code>Person</code> structure, plus prototypes for a function that fills a structure with a person&#8217;s name and a function that displays the structure&#8217;s contents. The second namespace, <code>debts</code>, defines a structure for storing the name of a person and the amount of money owed to that person. This structure uses the <code>Person</code> structure, so the <code>debts</code> namespace has a <code>using</code> directive to make the names in the <code>pers</code> namespace available in the <code>debts</code> namespace. The <code>debts</code> namespace also contains some prototypes.</p>
<p class="caption1"><a id="page_493"/><a id="ch09ex11"/><strong>Listing 9.11. <code>namesp.h</code>.</strong></p><hr/>
<p class="programlisting1">// namesp.h<br/>#include &lt;string&gt;<br/>// create the pers and debts namespaces<br/>namespace pers<br/>{<br/>&#160;&#160;&#160;&#160;struct Person<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::string fname;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::string lname;<br/>&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;void getPerson(Person &#38;);<br/>&#160;&#160;&#160;&#160;void showPerson(const Person &#38;);<br/>}<br/><br/>namespace debts<br/>{<br/>&#160;&#160;&#160;&#160;using namespace pers;<br/>&#160;&#160;&#160;&#160;struct Debt<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Person name;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double amount;<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;void getDebt(Debt &#38;);<br/>&#160;&#160;&#160;&#160;void showDebt(const Debt &#38;);<br/>&#160;&#160;&#160;&#160;double sumDebts(const Debt ar[], int n);<br/>}</p><hr/>
<p>The second file in this example (see <a href="#ch09ex12">Listing 9.12</a>) follows the usual pattern of having a source code file provide definitions for functions prototyped in a header file. The function names, which are declared in a namespace, have namespace scope, so the definitions need to be in the same namespace as the declarations. This is where the open nature of namespaces comes in handy. The original namespaces are brought in by including <code>namesp.h</code> (refer to <a href="#ch09ex11">Listing 9.11</a>). The file then adds the function definitions to the two namespaces, as shown in <a href="#ch09ex12">Listing 9.12</a>. Also the <code>namesp.cpp</code> file illustrates bringing in elements of the <code>std</code> namespace with the <code>using</code> declaration and the scope-resolution operator.</p>
<p class="caption1"><a id="ch09ex12"/><strong>Listing 9.12. <code>namesp.cpp</code></strong></p><hr/>
<p class="programlisting1">// namesp.cpp -- namespaces<br/>#include &lt;iostream&gt;<br/>#include "namesp.h"<br/>namespace pers<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;void getPerson(Person &#38; rp)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter first name: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; rp.fname;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter last name: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; rp.lname;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;void showPerson(const Person &#38; rp)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; rp.lname &lt;&lt; ", " &lt;&lt; rp.fname;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>namespace debts<br/>{<br/>&#160;&#160;&#160;&#160;void getDebt(Debt &#38; rd)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getPerson(rd.name);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter debt: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cin &gt;&gt; rd.amount;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;void showDebt(const Debt &#38; rd)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;showPerson(rd.name);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt;": $" &lt;&lt; rd.amount &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;double sumDebts(const Debt ar[], int n)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double total = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;total += ar[i].amount;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return total;<br/>&#160;&#160;&#160;&#160;}<br/>}</p><hr/>
<p><a id="page_494"/>Finally, the third file of this program (see <a href="#ch09ex13">Listing 9.13</a>) is a source code file that uses the structures and functions declared and defined in the namespaces. <a href="#ch09ex13">Listing 9.13</a> shows several methods of making the namespace identifiers available.</p>
<p class="caption1"><a id="ch09ex13"/><strong>Listing 9.13. <code>usenmsp.cpp</code></strong></p><hr/>
<p class="programlisting1">// usenmsp.cpp -- using namespaces<br/>#include &lt;iostream&gt;<br/>#include "namesp.h"<br/>void other(void);<br/>void another(void);<br/>int main(void)<br/>{<br/>&#160;&#160;&#160;&#160;using debts::Debt;<br/><br/>&#160;&#160;&#160;&#160;using debts::showDebt;<br/>&#160;&#160;&#160;&#160;Debt golf = { {"Benny", "Goatsniff"}, 120.0 };<br/>&#160;&#160;&#160;&#160;showDebt(golf);<br/>&#160;&#160;&#160;&#160;other();<br/>&#160;&#160;&#160;&#160;another();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void other(void)<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;using namespace debts;<br/>&#160;&#160;&#160;&#160;Person dg = {"Doodles", "Glister"};<br/>&#160;&#160;&#160;&#160;showPerson(dg);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;Debt zippy[3];<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; 3; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getDebt(zippy[i]);<br/><br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; 3; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;showDebt(zippy[i]);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Total debt: $" &lt;&lt; sumDebts(zippy, 3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return;<br/>}<br/><br/>void another(void)<br/>{<br/>&#160;&#160;&#160;&#160;using pers::Person;<br/>&#160;&#160;&#160;&#160;Person collector = { "Milo", "Rightshift" };<br/>&#160;&#160;&#160;&#160;pers::showPerson(collector);<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; std::endl;<br/>}</p><hr/>
<p><a id="page_495"/>In <a href="#ch09ex13">Listing 9.13</a>, <code>main()</code> begins by using two <code>using</code> declarations:</p>
<p class="programlisting">using debts::Debt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// makes the Debt structure definition available<br/>using debts::showDebt;&#160;&#160;&#160;// makes the showDebt function available</p>
<p><a id="page_496"/>Note that <code>using</code> declarations just use the name; for example, the second example here doesn&#8217;t describe the return type or function signature for <code>showDebt</code>; it just gives the name. (Thus, if a function were overloaded, a single <code>using</code> declaration would import all the versions.) Also although both <code>Debt</code> and <code>showDebt()</code> use the <code>Person</code> type, it isn&#8217;t necessary to import any of the <code>Person</code> names because the <code>debt</code> namespace already has a <code>using</code> directive that includes the <code>pers</code> namespace.</p>
<p>Next, the <code>other()</code> function takes the less desirable approach of importing the entire namespace with a <code>using</code> directive:</p>
<p class="programlisting">using namespace debts;&#160;&#160;&#160;// make all debts and pers names available to other()</p>
<p>Because the <code>using</code> directive in <code>debts</code> imports the <code>pers</code> namespace, the <code>other()</code> function can use the <code>Person</code> type and the <code>showPerson()</code> function.</p>
<p>Finally, the <code>another()</code> function uses a <code>using</code> declaration and the scope-resolution operator to access specific names:</p>
<p class="programlisting">using pers::Person;;<br/>pers::showPerson(collector);</p>
<p>Here is a sample run of the program built from <a href="#ch09ex11">Listings 9.11</a>, <a href="#ch09ex12">9.12</a>, and <a href="#ch09ex13">9.13</a>:</p>
<p class="programlisting">Goatsniff, Benny: $120<br/>Glister, Doodles<br/>Enter first name: <span class="EmpStrong">Arabella</span><br/>Enter last name: <span class="EmpStrong">Binx</span><br/>Enter debt: <span class="EmpStrong">100</span><br/>Enter first name: <span class="EmpStrong">Cleve</span><br/>Enter last name: <span class="EmpStrong">Delaproux</span><br/>Enter debt: <span class="EmpStrong">120</span><br/>Enter first name: <span class="EmpStrong">Eddie</span><br/>Enter last name: <span class="EmpStrong">Fiotox</span><br/>Enter debt: <span class="EmpStrong">200</span><br/>Binx, Arabella: $100<br/>Delaproux, Cleve: $120<br/>Fiotox, Eddie: $200<br/>Total debt: $420<br/>Rightshift, Milo</p>
<h4 id="ch09lev2sec14">Namespaces and the Future</h4>
<p>As programmers become more familiar with namespaces, common programming idioms will emerge. Here are some current guidelines:</p>
<p class="indenthandingB">&#8226; Use variables in a named namespace instead of using external global variables.</p>
<p class="indenthandingB">&#8226; Use variables in an unnamed namespace instead of using static global variables.</p>
<p class="indenthandingB">&#8226; If you develop a library of functions or classes, place them in a namespace. Indeed, C++ currently already calls for placing standard library functions in a namespace <a id="page_497"/>called <code>std</code>. This extends to functions brought in from C. For example, the <code>math.c</code> header file, which is C-compatible, doesn&#8217;t use namespaces, but the C++ <code>cmath</code> header file should place the various math library functions in the <code>std</code> namespace.</p>
<p class="indenthandingB">&#8226; Use the <code>using</code> directive only as a temporary means of converting old code to namespace usage.</p>
<p class="indenthandingB">&#8226; Don&#8217;t use <code>using</code> directives in header files; for one thing, doing so conceals which names are being made available. Also the ordering of header files may affect behavior. If you use a <code>using</code> directive, place it after all the preprocessor <code>#include</code> directives.</p>
<p class="indenthandingB">&#8226; Preferentially import names by using the scope-resolution operator or a <code>using</code> declaration.</p>
<p class="indenthandingB">&#8226; Preferentially use local scope instead of global scope for <code>using</code> declarations.</p>
<p>Bear in mind that the main motivation for using namespaces is to simplify management of large programming projects. For simple, one-file programs, using a <code>using</code> directive is no great sin.</p>
<p>As mentioned earlier, changes in the header filenames reflect namespace changes. The older-style header files, such as <code>iostream.h</code>, do not use namespaces, but the newer <code>iostream</code> header file should use the <code>std</code> namespace.</p>
<h3 id="ch09lev1sec4">Summary</h3>
<p>C++ encourages the use of multiple files in developing programs. An effective organizational strategy is to use a header file to define user types and provide function prototypes for functions to manipulate the user types. You should use a separate source code file for the function definitions. Together, the header file and the source file define and implement the user-defined type and how it can be used. Then, <code>main()</code> and other functions using those functions can go into a third file.</p>
<p>C++&#8217;s storage schemes determine how long variables remain in memory (storage duration) and what parts of a program have access to them (scope and linkage). Automatic variables are variables that are defined within a block, such as a function body or a block within the body. They exist and are known only while the program executes statements in the block that contains the definition. Automatic variables may be declared by using the storage class specifier <code>register</code> or with no specifier at all, in which case the variable is automatically automatic. The <code>register</code> specifier was a hint to the compiler that the variable is heavily used, but that use is deprecated under C++11.</p>
<p>Static variables exist for the duration of a program. A variable defined outside any function is known to all functions in the file following its definition (file scope) and is made available to other files in the program (external linkage). For another file to use such a variable, that file must declare it by using the <code>extern</code> keyword. A variable that is shared across files should have a defining declaration in one file (<code>extern</code> needn&#8217;t be used but it can be used if combined with initialization) and reference declarations in the other <a id="page_498"/>files (<code>extern</code> is used with no initialization.). A variable defined outside any function but qualified with the keyword <code>static</code> has file scope but is not made available to other files (internal linkage). A variable defined inside a block but qualified with the keyword <code>static</code> is local to that block (local scope, no linkage) but retains its value for the duration of the program.</p>
<p>By default, C++ functions have external linkage, so they can be shared across files. But functions qualified with the keyword <code>static</code> have internal linkage and are confined to the defining file.</p>
<p>Dynamic memory allocation and deallocation, using <code>new</code> and <code>delete</code>, uses the free store, or heap, for data. The memory comes into use when <code>new</code> is called and is freed when <code>delete</code> is called. The program uses pointers to keep track of these memory locations.</p>
<p>Namespaces let you define named regions in which you can declare identifiers. The intent is to reduce name conflicts, particularly in large programs that use code from several vendors. You can make available identifiers in a namespace by using the scope-resolution operator, by using a <code>using</code> declaration, or by using a <code>using</code> directive.</p>
<h3 id="ch09lev1sec5">Chapter Review</h3>
<p class="question"><a id="ch09qa1q1" href="app10.html#ch09qa1a1"><strong>1.</strong></a> What storage scheme would you use for the following situations?</p>
<p class="indenthandinga"><strong>a.</strong> <code>homer</code> is a formal argument (parameter) to a function.</p>
<p class="indenthandinga"><strong>b.</strong> The <code>secret</code> variable is to be shared by two files.</p>
<p class="indenthandinga"><strong>c.</strong> The <code>topsecret</code> variable is to be shared by the functions in one file but hidden from other files.</p>
<p class="indenthandinga"><strong>d.</strong> <code>beencalled</code> keeps track of how many times the function containing it has been called.</p>
<p class="question"><a id="ch09qa1q2" href="app10.html#ch09qa1a2"><strong>2.</strong></a> Describe the differences between a <code>using</code> declaration and a <code>using</code> directive.</p>
<p class="question"><a id="ch09qa1q3" href="app10.html#ch09qa1a3"><strong>3.</strong></a> Rewrite the following so that it doesn&#8217;t use <code>using</code> declarations or <code>using</code> directives:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double x;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter value: ";<br/>&#160;&#160;&#160;&#160;while (! (cin &gt;&gt; x) )<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bad input. Please enter a number: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.clear();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/><a id="page_499"/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Value = " &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="question"><a id="ch09qa1q4" href="app10.html#ch09qa1a4"><strong>4.</strong></a> Rewrite the following so that it uses <code>using</code> declarations instead of the <code>using</code> directive:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double x;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter value: ";<br/>&#160;&#160;&#160;&#160;while (! (cin &gt;&gt; x) )<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bad input. Please enter a number: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.clear();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Value = " &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="question"><a id="ch09qa1q5" href="app10.html#ch09qa1a5"><strong>5.</strong></a> Suppose you want the <code>average(3,6)</code> function to return an <code>int</code> average of the two <code>int</code> arguments when it is called in one file, and you want it to return a <code>double</code> average of the two <code>int</code> arguments when it is called in a second file in the same program. How could you set this up?</p>
<p class="question"><a id="ch09qa1q6" href="app10.html#ch09qa1a6"><strong>6.</strong></a> What will the following two-file program display?</p>
<p class="programlistingB">// file1.cpp<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>void other();<br/>void another();<br/>int x = 10;<br/>int y;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int x = 4;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; y &lt;&lt; endl;<br/><a id="page_500"/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;other();<br/>&#160;&#160;&#160;&#160;another();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void other()<br/>{<br/>&#160;&#160;&#160;&#160;int y = 1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Other: " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; endl;<br/>}<br/><br/>// file 2.cpp<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>extern int x;<br/>namespace<br/>{<br/>&#160;&#160;&#160;&#160;int y = -4;<br/>}<br/><br/>void another()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "another(): " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; endl;<br/>}</p>
<p class="question"><a id="ch09qa1q7" href="app10.html#ch09qa1a7"><strong>7.</strong></a> What will the following program display?</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/>void other();<br/>namespace n1<br/>{<br/>&#160;&#160;&#160;&#160;int x = 1;<br/>}<br/><br/>namespace n2<br/>{<br/>&#160;&#160;&#160;&#160;int x = 2;<br/>}<br/><br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;using namespace n1;<br/>&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;{<br/><a id="page_501"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int x = 4;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; n1::x &lt;&lt; ", " &lt;&lt; n2::x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;using n2::x;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;other();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void other()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace n2;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int x = 4;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; n1::x &lt;&lt; ", " &lt;&lt; n2::x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;using n2::x;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;<br/>}</p>
<h3 id="ch09lev1sec6">Programming Exercises</h3>
<p class="question"><a id="ch09qa2q1"/><strong>1.</strong> Here is a header file:</p>
<p class="programlistingB">// golf.h -- for pe9-1.cpp<br/><br/>const int Len = 40;<br/>struct golf<br/>{<br/>&#160;&#160;&#160;&#160;char fullname[Len];<br/>&#160;&#160;&#160;&#160;int handicap;<br/>};<br/><br/>// non-interactive version:<br/>//&#160;&#160;function sets golf structure to provided name, handicap<br/>//&#160;&#160;using values passed as arguments to the function<br/>void setgolf(golf &#38; g, const char * name, int hc);<br/><br/>// interactive version:<br/>//&#160;&#160;function solicits name and handicap from user<br/>//&#160;&#160;and sets the members of g to the values entered<br/>//&#160;&#160;returns 1 if name is entered, 0 if name is empty string<br/>int setgolf(golf &#38; g);<br/><br/><a id="page_502"/>// function resets handicap to new value<br/>void handicap(golf &#38; g, int hc);<br/><br/>// function displays contents of golf structure<br/>void showgolf(const golf &#38; g);</p>
<p class="questionp">Note that <code>setgolf()</code> is overloaded. Using the first version of <code>setgolf()</code> would look like this:</p>
<p class="programlistingB">golf ann;<br/>setgolf(ann, "Ann Birdfree", 24);</p>
<p class="questionp">The function call provides the information that&#8217;s stored in the <code>ann</code> structure. Using the second version of <code>setgolf()</code> would look like this:</p>
<p class="programlistingB">golf andy;<br/>setgolf(andy);</p>
<p class="questionp">The function would prompt the user to enter the name and handicap and store them in the <code>andy</code> structure. This function could (but doesn&#8217;t need to) use the first version internally.</p>
<p class="questionp">Put together a multifile program based on this header. One file, named <code>golf.cpp</code>, should provide suitable function definitions to match the prototypes in the header file. A second file should contain <code>main()</code> and demonstrate all the features of the prototyped functions. For example, a loop should solicit input for an array of golf structures and terminate when the array is full or the user enters an empty string for the golfer&#8217;s name. The <code>main()</code> function should use only the prototyped functions to access the golf structures.</p>
<p class="question"><a id="ch09qa2q2"/><strong>2.</strong> Redo <a href="#ch09ex09">Listing 9.9</a>, replacing the character array with a <code>string</code> object. The program should no longer have to check whether the input string fits, and it can compare the input string to <code>""</code> to check for an empty line.</p>
<p class="question"><a id="ch09qa2q3"/><strong>3.</strong> Begin with the following structure declaration:</p>
<p class="programlistingB">struct chaff<br/>{<br/>&#160;&#160;&#160;&#160;char dross[20];<br/>&#160;&#160;&#160;&#160;int slag;<br/>};</p>
<p class="questionp">Write a program that uses placement <code>new</code> to place an array of two such structures in a buffer. Then assign values to the structure members (remembering to use <code>strcpy()</code> for the <code>char</code> array) and use a loop to display the contents. Option 1 is to use a static array, like that in <a href="#ch09ex10">Listing 9.10</a>, for the buffer. Option 2 is to use regular <code>new</code> to allocate the buffer.</p>
<p class="question"><a id="page_503"/><a id="ch09qa2q4"/><strong>4.</strong> Write a three-file program based on the following namespace:</p>
<p class="programlistingB">namespace SALES<br/>{<br/>&#160;&#160;&#160;&#160;const int QUARTERS = 4;<br/>&#160;&#160;&#160;&#160;struct Sales<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double sales[QUARTERS];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double average;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double max;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double min;<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;// copies the lesser of 4 or n items from the array ar<br/>&#160;&#160;&#160;&#160;// to the sales member of s and computes and stores the<br/>&#160;&#160;&#160;&#160;// average, maximum, and minimum values of the entered items;<br/>&#160;&#160;&#160;&#160;// remaining elements of sales, if any, set to 0<br/>&#160;&#160;&#160;&#160;void setSales(Sales &#38; s, const double ar[], int n);<br/>&#160;&#160;&#160;&#160;// gathers sales for 4 quarters interactively, stores them<br/>&#160;&#160;&#160;&#160;// in the sales member of s and computes and stores the<br/>&#160;&#160;&#160;&#160;// average, maximum, and minimum values<br/>&#160;&#160;&#160;&#160;void setSales(Sales &#38; s);<br/>&#160;&#160;&#160;&#160;// display all information in structure s<br/>&#160;&#160;&#160;&#160;void showSales(const Sales &#38; s);<br/>}</p>
<p class="questionp">The first file should be a header file that contains the namespace. The second file should be a source code file that extends the namespace to provide definitions for the three prototyped functions. The third file should declare two <code>Sales</code> objects. It should use the interactive version of <code>setSales()</code> to provide values for one structure and the non-interactive version of <code>setSales()</code> to provide values for the second structure. It should display the contents of both structures by using <code>showSales()</code>.</p>
</body>
</html>
