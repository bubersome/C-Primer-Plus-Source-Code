<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>F. The string Template Class</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="app06">F. The <code>string</code> Template Class</h2>
<p><a id="page_1249"/>Much of this appendix is a bit technical. However, if you just want to know the capabilities of the <code>string</code> template class, you can concentrate on the descriptions of the various <code>string</code> methods.</p>
<p>The <code>string</code> class is based on a template definition:</p>
<p class="programlisting">template&lt;class charT, class traits = char_traits&lt;charT&gt;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class Allocator = allocator&lt;charT&gt; &gt;<br/>class basic_string {...};</p>
<p>Here <code>charT</code> represents the type stored in the string. The <code>traits</code> parameter represents a class that defines necessary properties that a type must possess to be represented as a string. For example, it should have a <code>length()</code> method that returns the length of a string, represented as an array of type <code>charT</code>. The end of such an array is indicated by the value <code>charT(0)</code>, the generalization of the null character. (The expression <code>charT(0)</code> is a type cast of <code>0</code> to type <code>charT</code>. It could be just <code>0</code>, as it is for type <code>char</code>, or more generally, it could be an object created by a <code>charT</code> constructor.) The class also includes methods for comparing values, and so on. The <code>Allocator</code> parameter represents a class to handle memory allocation for the string. The default <code>allocator&lt;charT&gt;</code> template uses <code>new</code> and <code>delete</code> in the standard ways.</p>
<p>There are four predefined specializations:</p>
<p class="programlisting">typedef basic_string&lt;char&gt; string;<br/>typedef basic_string&lt;char16_t&gt; u16string;<br/>typedef basic_string&lt;char32_t&gt; u32string;<br/>typedef basic_string&lt;wchar_t&gt; wstring;</p>
<p>These specializations, in turn, use the following specializations:</p>
<p class="programlisting">char_traits&lt;char&gt;<br/>allocator&lt;char&gt;<br/>char_traits&lt;char16_t&gt;<br/>allocator&lt;char_16&gt;<br/>char_traits&lt;char_32&gt;<br/>allocator&lt;char_32&gt;<br/>char_traits&lt;wchar_t&gt;<br/>allocator&lt;wchar_t&gt;</p>
<p><a id="page_1250"/>You can create a <code>string</code> class for some type other than <code>char</code> or <code>wchar_t</code> by defining a <code>traits</code> class and using the <code>basic_string</code> template.</p>
<h3 id="app06lev1sec1">Thirteen Types and a Constant</h3>
<p>The <code>basic_string</code> template defines several types that are used later in defining the methods:</p>
<p class="programlisting">typedef traits&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;traits_type;<br/>typedef typename traits::char_type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value_type;<br/>typedef Allocator&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allocator_type;<br/>typedef typename Allocator::size_type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type;<br/>typedef typename Allocator::difference_type&#160;&#160;&#160;difference_type;<br/>typedef typename Allocator::reference&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reference;<br/>typedef typename Allocator::const_reference&#160;&#160;&#160;const_reference;<br/>typedef typename Allocator::pointer&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pointer;<br/>typedef typename Allocator::const_pointer&#160;&#160;&#160;&#160;&#160;const_pointer;</p>
<p>Note that <code>traits</code> is a template parameter that corresponds to some specific type, such as <code>char_traits&lt;char&gt;</code>; <code>traits_type</code> becomes a <code>typedef</code> for that specific type. The following notation means that <code>char_type</code> is a type name defined in the class represented by <code>traits</code>:</p>
<p class="programlisting">typedef typename traits::char_type&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value_type;</p>
<p>The keyword <code>typename</code> is used to tell the compiler that the expression <code>traits::char_type</code> is a type. For the <code>string</code> specialization, for example, <code>value_type</code> is <code>char</code>.</p>
<p><code>size_type</code> is used like <code>size_of</code>, except that it returns the size of a string in terms of the stored type. For the <code>string</code> specialization, that would be in terms of <code>char</code>, in which case <code>size_type</code> is the same as <code>size_of</code>. It is an unsigned type.</p>
<p><code>difference_type</code> is used to measure the distance between two elements of a string, again in units corresponding to the size of a single element. Typically, it would be a signed version of the type underlying <code>size_type</code>.</p>
<p>For the <code>char</code> specialization, <code>pointer</code> is type <code>char *</code>, and <code>reference</code> is type <code>char &#38;</code>. However, if you create a specialization for a type of your own design, these types (<code>pointer</code> and <code>reference</code>) could refer to classes that have the same properties as the more basic pointers and references.</p>
<p>To allow Standard Template Library (STL) algorithms to be used with strings, the template defines some iterator types:</p>
<p class="programlisting">typedef (models random access iterator)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iterator;<br/>typedef (models random access iterator)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const_iterator;<br/>typedef std::reverse_iterator&lt;iterator&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reverse_iterator;<br/>typedef std::reverse_iterator&lt;const_iterator&gt;&#160;&#160;&#160;const_reverse_iterator;</p>
<p><a id="page_1251"/>The template defines a static constant:</p>
<p class="programlisting">static const size_type npos = -1;</p>
<p>Because <code>size_type</code> is unsigned, assigning the value <code>-1</code> actually amounts to assigning the largest possible unsigned value to <code>npos</code>. This value corresponds to one greater than the largest possible array index.</p>
<h3 id="app06lev1sec2">Data Information, Constructors, and Odds and Ends</h3>
<p>Constructors can be described in terms of the effects they have. Because the private portions of a class can be implementation dependent, these effects should be described in terms of information available as part of the public interface. <a href="#app06table01">Table F.1</a> lists several methods whose return values can be used to describe the effects of constructors and of other methods. Note that much of the terminology is from the STL.</p>
<p class="caption"><a id="app06table01"/><strong>Table F.1. Some <code>string</code> Data Methods</strong></p>
<p class="image"><img src="graphics/app-f-tab01.jpg" alt="Image"/></p>
<p><a id="page_1252"/>Be careful of the differences among <code>begin()</code>, <code>rend()</code>, <code>data()</code>, and <code>c_str()</code>. All relate to the first character in a string, but in different ways. The <code>begin()</code> and <code>rend()</code> methods return iterators, which are generalizations of pointers, as described in <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library.&#8221; In particular, <code>begin()</code> returns a model of a forward iterator, and <code>rend()</code> returns a copy of a reverse iterator. Both refer to the actual string managed by the <code>string</code> object. (Because the <code>string</code> class uses dynamic memory allocation, the actual string contents need not be inside the object, so we use the term <em>manage</em> to describe the relationship between object and string.) You can use the methods that return iterators with the iterator-based algorithms of the STL. For example, you can use the STL <code>reverse()</code> function to reverse the contents of a string:</p>
<p class="programlisting">string word;<br/>cin &gt;&gt; word;<br/>reverse(word.begin(), word.end());</p>
<p>The <code>data()</code> and <code>c_str()</code> methods, on the other hand, do return ordinary pointers. Furthermore, the returned pointers point to the first element of an <em>array</em> that holds the string characters. This array can but need not be a copy of the original string managed by the <code>string</code> object. (The internal representation used by the <code>string</code> object can be an array, but it doesn&#8217;t have to be.) Because it is possible that the returned pointers point to the original data, they are <code>const</code>, so they can&#8217;t be used to alter the data. Also the pointers are not guaranteed to be valid after the string is modified; this reflects that they may point to the original data. The difference between <code>data()</code> and <code>c_str()</code> is that the array <code>c_str()</code> points to is terminated with a null character (or equivalent), whereas <code>data()</code> just guarantees that the actual string characters are present. Thus, the <code>c_str()</code> method can be used, for example, as an argument to a function that expects to receive a C-style string:</p>
<p class="programlisting">string file("tofu.man");<br/>ofstream outFile(file.c_str());</p>
<p>Similarly, <code>data()</code> and <code>size()</code> could be used with a function that expects to receive a pointer to an array element and a value that represents the number of elements to process:</p>
<p class="programlisting"><a id="page_1253"/>string vampire("Do not stake me, oh my darling!");<br/>int vlad = byte_check(vampire.data(), vampire.size());</p>
<p>A C++ implementation could choose to represent a <code>string</code> object&#8217;s string as a dynamically allocated C-style string and to implement the forward iterator as a <code>char *</code> pointer. In that case, the implementation could choose to have <code>begin()</code>, <code>data()</code>, and <code>c_str()</code> all return the same pointer. But it could just as legitimately (if not as easily) return references to three different data objects.</p>
<p>C++11 has 11 constructors for the <code>basic_string</code> template class, up from the six of C++98, and one destructor:</p>
<p class="programlisting">explicit basic_string(const Allocator&#38; a = Allocator());<br/>basic_string(const charT* s, const Allocator&#38; a = Allocator());<br/>basic_string(const charT* s, size_type n, const Allocator&#38; a = Allocator());<br/>basic_string(const basic_string&#38; str);<br/>basic_string(const basic_string&#38; str, const Allocator&#38;);<br/>basic_string(const basic_string&#38; str, size_type pos,<br/>&#160;&#160;&#160;&#160;size_type n = npos, const Allocator&#38; a = Allocator());<br/>basic_string(basic_string&#38;&#38; str) noexcept;<br/>basic_string(const basic_string&#38;&#38; str, const Allocator&#38;);<br/>basic_string(size_type n, charT c, const Allocator&#38; a = Allocator());<br/>template&lt;class InputIterator&gt;<br/>basic_string(InputIterator begin, InputIterator end,<br/>&#160;&#160;&#160;&#160;const Allocator&#38; a = Allocator());<br/>basic_string(initializer_list&lt;charT&gt;, const Allocator&#38; = Allocator());<br/>~basic_string();</p>
<p>Some of the increase in constructors comes from handling arguments differently. For example, C++98 had this copy constructor:</p>
<p class="programlisting">basic_string(const basic_string&#38; str, size_type pos = 0,<br/>&#160;&#160;&#160;&#160;size_type n = npos, const Allocator&#38; a = Allocator());</p>
<p>C++11 replaces it with three constructors&#8212;the second, third, and fourth items in the preceding list. This allows the most common uses of the C++98 version to be coded more efficiently. The really new additions are the move constructors (those with rvalue references, as discussed in <a href="ch18.html#ch18">Chapter 18</a>, &#8220;<a href="ch18.html#ch18">Visiting with the New C++ Standard</a>&#8221;) and the constructor with the <code>initializer_list</code> parameter.</p>
<p>Note that most of the constructors have an argument of the following form:</p>
<p class="programlisting">const Allocator&#38; a = Allocator()</p>
<p>Recall that the term <code>Allocator</code> is the template parameter name for an <code>allocator</code> class to manage memory. The term <code>Allocator()</code> is the default constructor for that class. Thus, the constructors, by default, use the default version of the <code>allocator</code> object, but they give you the option of using some other version of the <code>allocator</code> object. The following sections examine the constructors individually.</p>
<h4 id="app06lev2sec1">Default Constructor</h4>
<p><a id="page_1254"/>This is the prototype for the default constructor:</p>
<p class="programlisting">explicit basic_string(const Allocator&#38; a = Allocator());</p>
<p>Typically, you would accept the default argument for the <code>allocator</code> class and would use the constructor to create empty strings:</p>
<p class="programlisting">string bean;<br/>wstring theory;</p>
<p>The following relationships hold after the default constructor is called:</p>
<p class="indenthandingB">&#8226; The <code>data()</code> method returns a non-null pointer to which <code>0</code> can be added.</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns <code>0</code>.</p>
<p class="indenthandingB">&#8226; The return value for <code>capacity()</code> is not specified.</p>
<p>Suppose you assign the value returned by <code>data()</code> to the pointer <code>str</code>. In this case, the first condition means <code>str + 0</code> is valid.</p>
<h4 id="app06lev2sec2">Constructors That Use C-Style Strings</h4>
<p>Constructors that use C-style strings let you initialize a <code>string</code> object from a C-style string; more generally, they let you initialize a <code>charT</code> specialization from an array of <code>charT</code> values:</p>
<p class="programlisting">basic_string(const charT* s, const Allocator&#38; a = Allocator());</p>
<p>To determine how many characters to copy, the constructor applies the <code>traits::length()</code> method to the array pointed to by <code>s</code>. (The pointer <code>s</code> should not be a null pointer.) For example, the following statement initializes the <code>toast</code> object, using the indicated character string:</p>
<p class="programlisting">string toast("Here's looking at you, kid.");</p>
<p>The <code>traits::length()</code> method for type <code>char</code> uses the null character to determine how many characters to copy.</p>
<p>The following relationships hold after the constructor is called:</p>
<p class="indenthandingB">&#8226; The <code>data()</code> method returns a pointer to the first element of a copy of the array <code>s</code>.</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns a value equal to <code>traits::length()</code>.</p>
<p class="indenthandingB">&#8226; The <code>capacity()</code> method returns a value at least as large as <code>size()</code>.</p>
<h4 id="app06lev2sec3">Constructors That Use Part of a C-Style String</h4>
<p>Constructors that use part of a C-style string let you initialize a <code>string</code> object from part of a C-style string; more generally, they let you initialize a <code>charT</code> specialization from part of an array of <code>charT</code> values:</p>
<p class="programlisting">basic_string(const charT* s, size_type n, const Allocator&#38; a = Allocator());</p>
<p><a id="page_1255"/>This constructor copies to the constructed object a total of <code>n</code> characters from the array pointed to by <code>s</code>. Note that it doesn&#8217;t stop copying if <code>s</code> has fewer characters than <code>n</code>. If <code>n</code> exceeds the length of <code>s</code>, the constructor interprets the contents of memory following the string as if they held data of type <code>charT</code>.</p>
<p>This constructor requires that <code>s</code> is not a null pointer and that <code>n &lt; npos</code>. (Recall that <code>npos</code> is a static class constant equal to the maximum possible number of elements in a string.) If <code>n</code> equals <code>npos</code>, the constructor throws an <code>out_of_range</code> exception. (Because <code>n</code> is of type <code>size_type</code> and <code>npos</code> is the maximum <code>size_type</code> value, <code>n</code> cannot be greater than <code>npos</code>.) Otherwise, the following relationships hold after the constructor is called:</p>
<p class="indenthandingB">&#8226; The <code>data()</code> method returns a pointer to the first element of a copy of the array <code>s</code>.</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns <code>n</code>.</p>
<p class="indenthandingB">&#8226; The <code>capacity()</code> method returns a value at least as large as <code>size(</code>).</p>
<h4 id="app06lev2sec4">Constructors That Use an Lvalue Reference</h4>
<p>The copy constructor looks like this:</p>
<p class="programlisting">basic_string(const basic_string&#38; str);</p>
<p>It initializes a new <code>string</code> object using a <code>string</code> argument:</p>
<p class="programlisting">string mel("I'm ok!");<br/>string ida(mel);</p>
<p>Here, <code>ida</code> would get a copy of the string managed by <code>mel</code>.</p>
<p>The next constructor additionally requires that you specify an allocator:</p>
<p class="programlisting">basic_string(const basic_string&#38; str, const Allocator&#38;);</p>
<p>The following relationships hold after either of these two constructors is called:</p>
<p class="indenthandingB">&#8226; The <code>data()</code> method returns a pointer to an allocated copy of the array whose first element is pointed to by <code>str.data()</code>.</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns the value of <code>str.size()</code>.</p>
<p class="indenthandingB">&#8226; The <code>capacity()</code> method returns a value at least as large as <code>size()</code>.</p>
<p>Moving along, the next constructor lets you set several items:</p>
<p class="programlisting">basic_string(const basic_string&#38; str, size_type pos, size_type n = npos,<br/>&#160;&#160;&#160;&#160;const Allocator&#38; a = Allocator());</p>
<p>The second argument <code>pos</code> specifies a location in the source string from which to begin the copying:</p>
<p class="programlisting">string att("Telephone home.");<br/>string et(att, 4);</p>
<p>Position numbers begin with <code>0</code>, so position <code>4</code> is the <code>p</code> character. Thus, <code>et</code> is initialized to <code>"phone home."</code>.</p>
<p><a id="page_1256"/>The optional third argument <code>n</code> specifies the maximum number of characters to copy. Thus, this initializes <code>pt</code> to the string <code>"phone"</code>:</p>
<p class="programlisting">string att("Telephone home.");<br/>string pt(att, 4, 5);</p>
<p>However, this constructor does not go past the end of the source string; for example, the following stops after copying the period:</p>
<p class="programlisting">string pt(att, 4, 200)</p>
<p>Thus, the constructor actually copies a number of characters equal to the lesser of <code>n</code> and <code>str.size() - pos</code>.</p>
<p>This constructor requires that <code>pos &lt;= str.size()</code>&#8212;that is, that the initial position copied to is inside the source string; if this is not the case, the constructor throws an <code>out_of_range</code> exception. Otherwise, if <code>copy_len</code> represents the lesser of <code>n</code> and <code>str.size() - pos</code>, the following relationships hold after the constructor is called:</p>
<p class="indenthandingB">&#8226; The <code>data()</code> method returns a pointer to a copy of <code>copy_len</code> elements copied from the string <code>str</code>, starting with position <code>pos</code> in <code>str</code>.</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns <code>copy_len</code>.</p>
<p class="indenthandingB">&#8226; The <code>capacity()</code> method returns a value at least as large as <code>size()</code>.</p>
<h4 id="app06lev2sec5">Constructors That Use an Rvalue Reference (C++11)</h4>
<p>C++11 adds move semantics to the <code>string</code> class. As described in <a href="ch18.html#ch18">Chapter 18</a>, this involves adding a move constructor, which uses an rvalue reference instead of an lvalue reference:</p>
<p class="programlisting">basic_string(basic_string&#38;&#38; str) noexcept;</p>
<p>This constructor is invoked when the actual argument is a temporary object:</p>
<p class="programlisting">string one("din");&#160;&#160;&#160;&#160;&#160;// C-style string constructor<br/>string two(one);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// copy constructor &#8211; one is an lvalue<br/>string three(one+two); // move constructor, sum is an rvalue</p>
<p>As discussed in <a href="ch18.html#ch18">Chapter 18</a>, the intent is that string <code>three</code> takes ownership of the object constructed by <code>operator+()</code> rather than copying the object and then letting the original be destroyed.</p>
<p>The second rvalue constructor additionally allows you to specify an allocator:</p>
<p class="programlisting">basic_string(const basic_string&#38;&#38; str, const Allocator&#38;);</p>
<p>The following relationships hold after either of these two constructors is called:</p>
<p class="indenthandingB">&#8226; The <code>data()</code> method returns a pointer to an allocated copy of the array whose first element is pointed to by <code>str.data()</code>.</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns the value of <code>str.size()</code>.</p>
<p class="indenthandingB">&#8226; The <code>capacity()</code> method returns a value at least as large as <code>size()</code>.</p>
<h4 id="app06lev2sec6">Constructor That Uses <code>n</code> Copies of a Character</h4>
<p><a id="page_1257"/>A constructor that uses <code>n</code> copies of a character creates a <code>string</code> object that consists of <code>n</code> consecutive characters, all having the value <code>c</code>:</p>
<p class="programlisting">basic_string(size_type n, charT c, const Allocator&#38; a = Allocator());</p>
<p>This constructor requires that <code>n &lt; npos</code>. If <code>n</code> equals <code>npos</code>, the constructor throws an <code>out_of_range</code> exception. Otherwise, the following relationships hold after the constructor is called:</p>
<p class="indenthandingB">&#8226; The <code>data()</code> method returns a pointer to the first element of a string of <code>n</code> elements, each set to <code>c</code>.</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns <code>n</code>.</p>
<p class="indenthandingB">&#8226; The <code>capacity()</code> method returns a value at least as large as <code>size(</code>).</p>
<h4 id="app06lev2sec7">Constructor That Uses a Range</h4>
<p>A constructor that uses a range uses an iterator-defined range in the style of the STL:</p>
<p class="programlisting">template&lt;class InputIterator&gt;<br/>basic_string(InputIterator begin, InputIterator end,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const Allocator&#38; a = Allocator());</p>
<p>The <code>begin</code> iterator points to the element in the source at which copying begins, and <code>end</code> points to one past the last location to be copied.</p>
<p>You can use this form with arrays, strings, or STL containers:</p>
<p class="programlisting">char cole[40] = "Old King Cole was a merry old soul.";<br/>string title(cole + 4, cole + 8);<br/>vector&lt;char&gt; input;<br/>char ch;<br/>while (cin.get(ch) &#38;&#38; ch != '\n')<br/>&#160;&#160;&#160;&#160;input.push_back(ch);<br/>string str_input(input.begin(), input.end());</p>
<p>In the first use, <code>InputIterator</code> is evaluated to type <code>const char *</code>. In the second use, <code>InputIterator</code> is evaluated to type <code>vector&lt;char&gt;::iterator</code>.</p>
<p>The following relationships hold after the constructor is called:</p>
<p class="indenthandingB">&#8226; The <code>data()</code> method returns a pointer to the first element of a string formed by copying elements from the range [<code>begin</code>, <code>end</code>).</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns the distance between <code>begin</code> and <code>end</code>. (The distance is measured in units equal to the size of data type obtained when the iterator is dereferenced.)</p>
<p class="indenthandingB">&#8226; The <code>capacity()</code> method returns a value at least as large as <code>size()</code>.</p>
<h4 id="app06lev2sec8">Constructor That Uses an Initialization List (C++11)</h4>
<p><a id="page_1258"/>This constructor takes an <code>initializer_list&lt;charT&gt;</code> parameter:</p>
<p class="programlisting">basic_string(initializer_list&lt;charT&gt; il, const Allocator&#38; a = Allocator());</p>
<p>You can use it with a braced list of characters:</p>
<p class="programlisting">string slow({'s', 'n', 'a', 'i', 'l'});</p>
<p>This isn&#8217;t the most convenient way to initialize a <code>string</code>, but it keeps the <code>string</code> interface similar to that of the STL container classes.</p>
<p>The <code>initializer_list</code> class has <code>begin()</code> and <code>end()</code> members, and the effect of using this constructor is the same using the range constructor:</p>
<p class="programlisting">basic_string(il.begin(), il.end(), a);</p>
<h4 id="app06lev2sec9">Memory Miscellany</h4>
<p>Several methods deal with memory&#8212;for example, clearing memory contents, resizing a string, or adjusting the capacity of a string. <a href="#app06table02">Table F.2</a> lists some memory-related methods.</p>
<p class="caption"><a id="app06table02"/><strong>Table F.2. Some Memory-Related Methods</strong></p>
<p class="image"><img src="graphics/app-f-tab02.jpg" alt="Image"/></p>
<h3 id="app06lev1sec3">String Access</h3>
<p><a id="page_1259"/>There are four methods for accessing individual characters, two of which use the <code>[]</code> operator and two of which use the <code>at()</code> method:</p>
<p class="programlisting">reference operator[](size_type pos);<br/>const_reference operator[](size_type pos) const;<br/>reference at(size_type n);<br/>const_reference at(size_type n) const;</p>
<p>The first <code>operator[]()</code> method allows you to access an individual element of a string by using array notation; it can be used to retrieve or alter the value. The second <code>operator[]()</code> method can be used with <code>const</code> objects, and it can be used only to retrieve the value:</p>
<p class="programlisting">string word("tack");<br/>cout &lt;&lt; word[0];&#160;&#160;&#160;&#160;// display the t<br/>word[3] = 't';&#160;&#160;&#160;&#160;&#160;&#160;// overwrite the k with a t<br/>const ward("garlic");<br/>cout &lt;&lt; ward[2];&#160;&#160;&#160;&#160;// display the r</p>
<p>The <code>at()</code> methods provide similar access, except that the index is provided in function argument notation:</p>
<p class="programlisting">string word("tack");<br/>cout &lt;&lt; word.at(0);&#160;&#160;&#160;&#160;// display the t</p>
<p>The difference (besides the syntax difference) is that the <code>at()</code> methods provide bounds checking and throw an <code>out_of_range</code> exception if <code>pos &gt;= size()</code>. Note that <code>pos</code> is type <code>size_type</code>, which is unsigned; therefore, a negative value is impossible for <code>pos</code>. The <code>operator[]()</code> methods don&#8217;t do bounds checking, so the behavior is undefined if <code>pos &gt;= size()</code>, except that the <code>const</code> version returns the null character equivalent if <code>pos == size()</code>.</p>
<p>Thus, you get a choice between safety (using <code>at()</code> and testing for exceptions) and execution speed (using array notation).</p>
<p>There is also a function that returns a new string that is a substring of the original:</p>
<p class="programlisting">basic_string substr(size_type pos = 0, size_type n = npos) const;</p>
<p>It returns a string that&#8217;s a copy of the string starting at position <code>pos</code> and going for <code>n</code> characters or to the end of the string, whichever comes first. For example, the following initializes <code>pet</code> to <code>"donkey"</code>:</p>
<p class="programlisting">string message("Maybe the donkey will learn to sing.");<br/>string pet(message.substr(10, 6));</p>
<p>C++11 adds these four access methods:</p>
<p class="programlisting">const charT&#38; front() const;<br/>charT&#38; front();<br/>const charT&#38; back() const;<br/>charT&#38; back();</p>
<p><a id="page_1260"/>The <code>front()</code> methods access the first element of a <code>string</code>, acting like <code>operator[](0)</code>. The <code>back()</code> methods access the last element of a <code>string</code>, acting like <code>operator[](size() - 1)</code>.</p>
<h3 id="app06lev1sec4">Basic Assignment</h3>
<p>C++11 has five overloaded assignment methods, up two from C++98:</p>
<p class="programlisting">basic_string&#38; operator=(const basic_string&#38; str);<br/>basic_string&#38; operator=(const charT* s);<br/>basic_string&#38; operator=(charT c);<br/>basic_string&#38; operator=(basic_string&#38;&#38; str) noexcept;&#160;&#160;// C++11<br/>basic_string&#38; operator=(initializer_list&lt;charT&gt;);&#160;&#160;&#160;&#160;&#160;&#160;// C++11</p>
<p>The first assigns one <code>string</code> object to another, the second assigns a C-style string to a <code>string</code> object, the third assigns a single character to a <code>string</code> object, the fourth uses move semantics to assign an rvalue <code>string</code> object to a <code>string</code> object, and the fifth allows assignment of an initializer list. Thus, all the following operations are possible:</p>
<p class="programlisting">string name("George Wash");<br/>string pres, veep, source, join, awkward;<br/>pres = name;<br/>veep = "Road Runner";<br/>source = 'X';<br/>join = name + source;&#160;&#160;&#160;// now with move semantics!<br/>awkward = {'C','l','o','u','s','e','a','u'};</p>
<h3 id="app06lev1sec5">String Searching</h3>
<p>The <code>string</code> class provides six search functions, each with four prototypes. The following sections describe them briefly.</p>
<h4 id="app06lev2sec10">The <code>find()</code> Family</h4>
<p>Here are the <code>find()</code> prototypes as provided by C++11:</p>
<p class="programlisting">size_type find (const basic_string&#38; str, size_type pos = 0) const noexcept;<br/>size_type find (const charT* s, size_type pos = 0) const;<br/>size_type find (const charT* s, size_type pos, size_type n) const;<br/>size_type find (charT c, size_type pos = 0) const noexcept;</p>
<p>The first member returns the beginning position of the <code>str</code> substring&#8217;s first occurrence in the invoking object, with the search beginning at position <code>pos</code>. If the substring is not found, the method returns <code>npos</code>.</p>
<p>Here&#8217;s code for finding the location of the substring <code>"hat"</code> in a longer string:</p>
<p class="programlisting">string longer("That is a funny hat.");<br/>string shorter("hat");<br/><a id="page_1261"/>size_type loc1 = longer.find(shorter);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// sets loc1 to 1<br/>size_type loc2 = longer.find(shorter, loc1 + 1); // sets loc2 to 16</p>
<p>Because the second search begins at position 2 (the <code>a</code> in <code>That</code>), the first occurrence of <code>hat</code> it finds is near the end of the string. To test for failure, you use the <code>string::npos</code> value:</p>
<p class="programlisting">if (loc1 == string::npos)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Not found\n";</p>
<p>The second method does the same thing, except that it uses an array of characters instead of a <code>string</code> object as the substring:</p>
<p class="programlisting">size_type loc3 = longer.find("is");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//sets loc3 to 5</p>
<p>The third method does the same as the second, except that it uses only the first <code>n</code> characters of the string <code>s</code>. The effect is the same as using the <code>basic_string(const charT* s, size_type n)</code> constructor and using the resulting object as the <code>string</code> argument to the first form of <code>find()</code>. For example, the following searches for the substring <code>"fun"</code>:</p>
<p class="programlisting">size_type loc4 = longer.find("funds", 3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//sets loc4 to 10</p>
<p>The fourth method does the same thing as the first, except that it uses a single character instead of a <code>string</code> object as the substring:</p>
<p class="programlisting">size_type loc5 = longer.find('a');&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//sets loc5 to 2</p>
<h4 id="app06lev2sec11">The <code>rfind()</code> Family</h4>
<p>The <code>rfind()</code> methods have these prototypes:</p>
<p class="programlisting">size_type rfind(const basic_string&#38; str,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos = npos) const noexcept;<br/>size_type rfind(const charT* s, size_type pos = npos) const;<br/>size_type rfind(const charT* s, size_type pos, size_type n) const;<br/>size_type rfind(charT c, size_type pos = npos) const noexcept;</p>
<p>These methods work like the analogous <code>find()</code> methods, except that they find the last occurrence of a string or character that starts at or before position <code>pos</code>. If the substring is not found, the method returns <code>npos</code>.</p>
<p>Here&#8217;s code for finding the location of the substring <code>"hat"</code> in a longer string, starting at the end of the longer string:</p>
<p class="programlisting">string longer("That is a funny hat.");<br/>string shorter("hat");<br/>size_type loc1 = longer.rfind(shorter);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// sets loc1 to 16<br/>size_type loc2 = longer.rfind(shorter, loc1 - 1); // sets loc2 to 1</p>
<h4 id="app06lev2sec12">The <code>find_first_of()</code> Family</h4>
<p><a id="page_1262"/>The <code>find_first_of()</code> methods have these prototypes:</p>
<p class="programlisting">size_type find_first_of(const basic_string&#38; str,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos = 0) const noexcept;<br/>size_type find_first_of(const charT* s, size_type pos, size_type n) const;<br/>size_type find_first_of(const charT* s, size_type pos = 0) const;<br/>size_type find_first_of(charT c, size_type pos = 0) const noexcept;</p>
<p>These methods work like the corresponding <code>find()</code> methods, except that instead of looking for a match of the entire substring, they look for the first match for any single character in the substring:</p>
<p class="programlisting">string longer("That is a funny hat.");<br/>string shorter("fluke");<br/>size_type loc1 = longer.find_first_of(shorter);&#160;&#160;// sets loc1 to 10<br/>size_type loc2 = longer.find_first_of("fat");&#160;&#160;&#160;&#160;// sets loc2 to 2</p>
<p>The first occurrence of any of the five characters of <code>fluke</code> in <code>longer</code> is the <code>f</code> in <code>funny</code>. The first occurrence of any of three characters of <code>fat</code> in <code>longer</code> is the <code>a</code> in <code>That</code>.</p>
<h4 id="app06lev2sec13">The <code>find_last_of()</code> Family</h4>
<p>The <code>find_last_of()</code> methods have these prototypes:</p>
<p class="programlisting">size_type find_last_of (const basic_string&#38; str,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos = npos) const noexcept;<br/>size_type find_last_of (const charT* s, size_type pos, size_type n) const;<br/>size_type find_last_of (const charT* s, size_type pos = npos) const;<br/>size_type find_last_of (charT c, size_type pos = npos) const noexcept;</p>
<p>These methods work like the corresponding <code>rfind()</code> methods, except that instead of looking for a match of the entire substring, they look for the last match for any single character in the substring.</p>
<p>Here&#8217;s code for finding the location of the last and next to last occurrences of any of the letters in <code>"fluke"</code> in a longer string:</p>
<p class="programlisting">string longer("That is a funny hat.");<br/>string shorter("hat");<br/>size_type loc1 = longer.find_last_of(shorter);&#160;&#160;// sets loc1 to 18<br/>size_type loc2 = longer.find_last_of("any");&#160;&#160;&#160;&#160;// sets loc2 to 17</p>
<p>The last occurrence of any of the three letters of <code>hat</code> in <code>longer</code> is the <code>t</code> in <code>hat</code>. The last occurrence of any of the three characters of <code>any</code> in <code>longer</code> is the <code>a</code> in <code>hat</code>.</p>
<h4 id="app06lev2sec14">The <code>find_first_not_of()</code> Family</h4>
<p>The <code>find_first_not_of()</code> methods have these prototypes:</p>
<p class="programlisting">size_type find_first_not_of(const basic_string&#38; str,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos = 0) const noexcept;<br/><a id="page_1263"/>size_type find_first_not_of(const charT* s, size_type pos,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type n) const;<br/>size_type find_first_not_of(const charT* s, size_type pos = 0) const;<br/>size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;</p>
<p>These methods work like the corresponding <code>find_first_of()</code> methods, except that they search for the first occurrence of any character not in the substring.</p>
<p>Here&#8217;s code for finding the location of the first two occurrences of any of the letters not in <code>"This"</code> in a longer string:</p>
<p class="programlisting">string longer("That is a funny hat.");<br/>string shorter("This");<br/>size_type loc1 = longer.find_first_not_of(shorter);&#160;&#160;// sets loc1 to 2<br/>size_type loc2 = longer.find_first_not_of("Thatch"); // sets loc2 to 4</p>
<p>The <code>a</code> in <code>That</code> is the first character in <code>longer</code> that does not appear in <code>This</code>. The first space in the <code>longer</code> string is the first character not present in <code>Thatch</code>.</p>
<h4 id="app06lev2sec15">The <code>find_last_not_of()</code> Family</h4>
<p>The <code>find_last_not_of()</code> methods have these prototypes:</p>
<p class="programlisting">size_type find_last_not_of (const basic_string&#38; str,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos = npos) const noexcept;<br/>size_type find_last_not_of (const charT* s, size_type pos,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type n) const;<br/>size_type find_last_not_of (const charT* s,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos = npos) const;<br/>size_type find_last_not_of (charT c, size_type pos = npos) const noexcept;</p>
<p>These methods work like the corresponding <code>find_last_of()</code> methods, except that they search for the last occurrence of any character not in the substring.</p>
<p>Here&#8217;s code for finding the location of the last two occurrences of any of the letters not in <code>"This"</code> in a longer string:</p>
<p class="programlisting">string longer("That is a funny hat.");<br/>string shorter("That.");<br/>size_type loc1 = longer.find_last_not_of(shorter);&#160;&#160;&#160;&#160;&#160;// sets loc1 to 15<br/>size_type loc2 = longer.find_last_not_of(shorter, 10); // sets loc2 to 10</p>
<p>The last space in <code>longer</code> is the last character in <code>longer</code> that does not appear in <code>shorter</code>. The <code>f</code> in the <code>longer</code> string is the last character not present in <code>shorter</code> found up through position 10.</p>
<h3 id="app06lev1sec6">Comparison Methods and Functions</h3>
<p>The <code>string</code> class offers methods and functions for comparing two strings. First, here are the method prototypes:</p>
<p class="programlisting"><a id="page_1264"/>int compare(const basic_string&#38; str) const noexcept;<br/><br/>int compare(size_type pos1, size_type n1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const basic_string&#38; str) const;<br/>int compare(size_type pos1, size_type n1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const basic_string&#38; str,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos2, size_type n2) const;<br/>int compare(const charT* s) const;<br/>int compare(size_type pos1, size_type n1, const charT* s) const;<br/>int compare(size_type pos1, size_type n1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const charT* s, size_type n2 ) const;</p>
<p>These methods use a <code>traits::compare()</code> method that is defined for the particular character type used for the string. The first method returns a value less than 0 if the first string precedes the second string according to the ordering supplied by <code>traits::compare()</code>. It returns <code>0</code> if the two strings are the same, and it returns a value greater than 0 if the first string follows the second. If two strings are identical to the end of the shorter of the two strings, the shorter string precedes the longer string.</p>
<p>The following examples compare strings <code>s1</code> with <code>s3</code> and <code>s1</code> with <code>s2</code>:</p>
<p class="programlisting">string s1("bellflower");<br/>string s2("bell");<br/>string s3("cat");<br/>int a13 = s1.compare(s3); // a13 is &lt; 0<br/>int a12 = s1.compare(s2); // a12 is &gt; 0</p>
<p>The second method is like the first, except that it just uses <code>n1</code> characters, starting from position <code>pos1</code> in the first string for the comparison.</p>
<p>The following example compares the first four characters in <code>s1</code> with <code>s2</code>:</p>
<p class="programlisting">string s1("bellflower");<br/>string s2("bell");<br/>int a2 = s1.compare(0, 4, s2); // a2 is 0</p>
<p>The third method is like the first, except that it just uses <code>n1</code> characters, starting from position <code>pos1</code> in the first string, and <code>n2</code> characters, starting from position <code>pos2</code> in the second string, for the comparison. For example, the following compares the <code>out</code> in <code>stout</code> to the <code>out</code> in <code>about</code>:</p>
<p class="programlisting">string st1("stout boar");<br/>string st2("mad about ewe");<br/>int a3 = st1.compare(2, 3, st2, 6, 3);&#160;&#160;// a3 is 0</p>
<p>The fourth method is like the first, except that it uses a character array instead of a <code>string</code> object for the second string.</p>
<p>The fifth and sixth methods essentially are like the third, except that they use a character array instead of a <code>string</code> object for the second string.</p>
<p><a id="page_1265"/>The non-member comparison functions are overloaded relational operators:</p>
<p class="programlisting">operator==()<br/>operator&lt;()<br/>operator&lt;=()<br/>operator&gt;()<br/>operator&gt;=()<br/>operator!=()</p>
<p>Each operator is overloaded so that it can compare a <code>string</code> object to a <code>string</code> object, a <code>string</code> object to a C-style string, and a C-style string to a <code>string</code> object. These operators are defined in terms of the <code>compare()</code> method, so they provide a notationally more convenient way of making comparisons.</p>
<h3 id="app06lev1sec7">String Modifiers</h3>
<p>The <code>string</code> class provides several methods for modifying strings. Most come with an abundance of overloaded versions so that they can be used with <code>string</code> objects, string arrays, individual characters, and iterator ranges.</p>
<h4 id="app06lev2sec16">Methods for Appending and Adding</h4>
<p>You can append one string to another by using the overloaded <code>+=</code> operator or by using an <code>append()</code> method. All throw a <code>length_error</code> exception if the result would be longer than the maximum string size. The <code>+=</code> operators let you append a <code>string</code> object, a string array, or an individual character to another string:</p>
<p class="programlisting">basic_string&#38; operator+=(const basic_string&#38; str);<br/>basic_string&#38; operator+=(const charT* s);<br/>basic_string&#38; operator+=(charT c);</p>
<p>The <code>append()</code> methods also let you append a <code>string</code> object, a string array, or an individual character to another string. In addition, they let you append part of a <code>string</code> object by specifying an initial position and a number of characters to append or else by specifying a range. You can append part of a string by specifying how many characters of the string to use. The version for appending a character lets you specify how many instances of that character to copy. Here are the prototypes for the various <code>append()</code> methods:</p>
<p class="programlisting">basic_string&#38; append(const basic_string&#38; str);<br/>basic_string&#38; append(const basic_string&#38; str, size_type pos,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type n);<br/>template&lt;class InputIterator&gt;<br/>&#160;&#160;basic_string&#38; append(InputIterator first, InputIterator last);<br/>basic_string&#38; append(const charT* s);<br/>basic_string&#38; append(const charT* s, size_type n);<br/>basic_string&#38; append(size_type n, charT c);&#160;&#160;// append n copies of c<br/>void push_back(charT c);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// appends 1 copy of c</p>
<p><a id="page_1266"/>Here are a couple examples:</p>
<p class="programlisting">string test("The");<br/>test.append("ory");&#160;&#160;// test is "Theory"<br/>test.append(3,'!');&#160;&#160;// test is "Theory!!!"</p>
<p>The <code>operator+()</code> function is overloaded to enable string concatenation. The overloaded functions don&#8217;t modify a string; instead, they create a new string that consists of one string appended to a second. The addition functions are not member functions, and they allow you to add a <code>string</code> object to a <code>string</code> object, a string array to a <code>string</code> object, a <code>string</code> object to a string array, a character to a <code>string</code> object, and a <code>string</code> object to a character. Here are some examples:</p>
<p class="programlisting">string st1("red");<br/>string st2("rain");<br/>string st3 = st1 + "uce";&#160;&#160;// st3 is "reduce"<br/>string st4 = 't' + st2;&#160;&#160;&#160;&#160;// st4 is "train"<br/>string st5 = st1 + st2;&#160;&#160;&#160;&#160;// st5 is "redrain"</p>
<h4 id="app06lev2sec17">More Assignment Methods</h4>
<p>In addition to the basic assignment operator, the <code>string</code> class provides <code>assign()</code> methods, which allow you to assign a whole string or a part of a string or a sequence of identical characters to a <code>string</code> object. Here are the prototypes for the various <code>assign()</code> methods:</p>
<p class="programlisting">basic_string&#38; assign(const basic_string&#38; str);<br/>basic string&#38; assign(basic_string&#38;&#38; str) noexcept;&#160;&#160;&#160;// C++11<br/>basic_string&#38; assign(const basic_string&#38; str, size_type pos,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type n);<br/>basic_string&#38; assign(const charT* s, size_type n);<br/>basic_string&#38; assign(const charT* s);<br/>basic_string&#38; assign(size_type n, charT c); // assign n copies of c<br/>template&lt;class InputIterator&gt;<br/>&#160;&#160;basic_string&#38; assign(InputIterator first, InputIterator last);<br/>basic_string&#38; assign(initializer_list&lt;charT&gt;);&#160;&#160;// C++11</p>
<p>Here are a couple examples:</p>
<p class="programlisting">string test;<br/>string stuff("set tubs clones ducks");<br/>test.assign(stuff, 1, 5);&#160;&#160;&#160;// test is "et tu"<br/>test.assign(6, '#");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// test is "######"</p>
<p><a id="page_1267"/>The <code>assign()</code> method with an rvalue reference (added by C++11) allows for move semantics, and the second new <code>assign()</code> method allows one to assign an <code>initializer_list</code> to a <code>string</code> object.</p>
<h4 id="app06lev2sec18">Insertion Methods</h4>
<p>The <code>insert()</code> methods let you insert a <code>string</code> object, a string array, a character, or several characters into a <code>string</code> object. The methods are similar to the <code>append()</code> methods, except that they take an additional argument, indicating where to insert the new material. This argument may be a position or an iterator. The material is inserted before the insertion point. Several of the methods return a reference to the resulting string. If <code>pos1</code> is beyond the end of the target string or if <code>pos2</code> is beyond the end of the string to be inserted, a method throws an <code>out_of_range</code> exception. If the resulting string will be larger than the maximum size, a method throws a <code>length_error</code> exception. Here are the prototypes for the various <code>insert()</code> methods:</p>
<p class="programlisting">basic_string&#38; insert(size_type pos1, const basic_string&#38; str);<br/>basic_string&#38; insert(size_type pos1, const basic_string&#38; str,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos2, size_type n);<br/>basic_string&#38; insert(size_type pos, const charT* s, size_type n);<br/>basic_string&#38; insert(size_type pos, const charT* s);<br/>basic_string&#38; insert(size_type pos, size_type n, charT c);<br/>iterator insert(const_iterator p, charT c);<br/>iterator insert(const_iterator p, size_type n, charT c);<br/>template&lt;class InputIterator&gt;<br/>&#160;&#160;void insert(iterator p, InputIterator first, InputIterator last);<br/>iterator insert(const_iterator p, initializer_list&lt;charT&gt;); // C++11</p>
<p>For example, the following code inserts the string <code>"former "</code> before the <code>b</code> in <code>"The banker."</code>:</p>
<p class="programlisting">string st3("The banker.");<br/>st3.insert(4, "former ");</p>
<p>Then the following code inserts the string <code>" waltzed"</code> (not including the <code>!</code>, which would be the ninth character) just before the period at the end of <code>"The former banker."</code>:</p>
<p class="programlisting">st3.insert(st3.size() - 1, " waltzed!", 8);</p>
<h4 id="app06lev2sec19">Erase Methods</h4>
<p>The <code>erase()</code> methods remove characters from a string. Here are their prototypes:</p>
<p class="programlisting">basic_string&#38; erase(size_type pos = 0, size_type n = npos);<br/>iterator erase(const_iterator position);<br/>iterator erase(const_iterator first, iterator last);<br/>void pop_back();</p>
<p><a id="page_1268"/>The first form removes the character from position <code>pos</code> to <code>n</code> characters later or the end of the string, whichever comes first. The second removes the single character referenced by the iterator position and returns an iterator to the next element or if there are no more elements, returns <code>end()</code>. The third removes the characters in the range [<code>first</code>, <code>last</code>); that is, including <code>first</code> and up to but not including <code>last</code>. The method returns an iterator to the element following the last element erased. Finally, the <code>pop_back()</code> method removes the last character in the string.</p>
<h4 id="app06lev2sec20">Replacement Methods</h4>
<p>The various <code>replace()</code> methods identify part of a string to be replaced and identify the replacement. The part to be replaced can be identified by an initial position and a character count or by an iterator range. The replacement can be a <code>string</code> object, a string array, or a particular character duplicated several times. Replacement <code>string</code> objects and arrays can further be modified by indicating a particular portion, using a position and a count, just a count, or an iterator range. Here are the prototypes for the various <code>replace()</code> methods:</p>
<p class="programlisting">basic_string&#38; replace(size_type pos1, size_type n1, const basic_string&#38; str);<br/>basic_string&#38; replace(size_type pos1, size_type n1, const basic_string&#38; str,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type pos2, size_type n2);<br/>basic_string&#38; replace(size_type pos, size_type n1, const charT* s,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type n2);<br/>basic_string&#38; replace(size_type pos, size_type n1, const charT* s);<br/>basic_string&#38; replace(size_type pos, size_type n1, size_type n2, charT c);<br/>basic_string&#38; replace(const_iterator i1, const_iterator i2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const basic_string&#38; str);<br/>basic_string&#38; replace(const_iterator i1, const_iterator i2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const charT* s, size_type n);<br/>basic_string&#38; replace(const_iterator i1, const_iterator i2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const charT* s);<br/>basic_string&#38; replace(const_iterator i1, const_iterator i2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size_type n, charT c);<br/>template&lt;class InputIterator&gt;<br/>&#160;&#160;basic_string&#38; replace(const_iterator i1, const_iterator i2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator j1, InputIterator j2);<br/>basic_string&#38; replace(const_iteraor i1, const_iteator i2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;initializer)list&lt;charT&gt; il);</p>
<p>Here is an example:</p>
<p class="programlisting">string test("Take a right turn at Main Street.");<br/>test.replace(7,5,"left"); // replace right with left</p>
<p><a id="page_1269"/>Note that you can use <code>find()</code> to find the positions used in <code>replace</code>:</p>
<p class="programlisting">string s1 = "old";<br/>string s2 = "mature";<br/>string s3 = "The old man and the sea";<br/>string::size_type pos = s3.find(s1);<br/>if (pos != string::npos)<br/>&#160;&#160;&#160;&#160;s3.replace(pos, s1.size(), s2);</p>
<p>This example would replace <code>old</code> with <code>mature</code>.</p>
<h4 id="app06lev2sec21">Other Modifying Methods: <code>copy()</code> and <code>swap()</code></h4>
<p>The <code>copy()</code> method copies a <code>string</code> object, or part thereof, to a designated character array:</p>
<p class="programlisting">size_type copy(charT* s, size_type n, size_type pos = 0) const;</p>
<p>In this case, <code>s</code> points to the destination array, <code>n</code> indicates the number of characters to copy, and <code>pos</code> indicates the position in the <code>string</code> object from which copying begins. Copying proceeds for <code>n</code> characters or until the last character in the <code>string</code> object, whichever comes first. The function returns the number of characters copied. The method does not append a null character, and it is up to the programmer to see that the array is large enough to hold the copy.</p>
<div class="note"><hr/>
<p class="title"><a id="app06note01"/>Caution</p>
<p class="notepara">The <code>copy()</code> method does not append a null character, nor does it check whether the destination array is large enough.</p>
<hr/></div>
<p>The <code>swap()</code> method swaps the contents of two <code>string</code> objects by using a constant time algorithm:</p>
<p class="programlisting">void swap(basic_string&#38; str);</p>
<h3 id="app06lev1sec8">Output and Input</h3>
<p>The <code>string</code> class overloads the <code>&lt;&lt;</code> operator to display <code>string</code> objects. It returns a reference to the <code>istream</code> object so that output can be concatenated:</p>
<p class="programlisting">string claim("The string class has many features.");<br/>cout &lt;&lt; claim &lt;&lt; endl;</p>
<p>The <code>string</code> class overloads the <code>&gt;&gt;</code> operator so that you can read input into a string:</p>
<p class="programlisting">string who;<br/>cin &gt;&gt; who;</p>
<p>Input terminates on the end-of-file, on reading the maximum number of characters allowed in a string, or on reaching a white-space character. (The definition of white space depends on the character set and on the type that <code>charT</code> represents.)</p>
<p><a id="page_1270"/>There are two <code>getline()</code> functions. The first has this prototype:</p>
<p class="programlisting">template&lt;class charT, class traits, class Allocator&gt;<br/>&#160;&#160;basic_istream&lt;charT,traits&gt;&#38; getline(basic_istream&lt;charT,traits&gt;&#38; is,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;basic_string&lt;charT,traits,Allocator&gt;&#38; str, charT delim);</p>
<p>It reads characters from the input stream <code>is</code> into the string <code>str</code> until it encounters the <code>delim</code> delimiter character, reaches the maximum size of the string, or encounters the end-of-file. The <code>delim</code> character is read (that is, removed from the input stream) but not stored. The second version lacks the third argument and uses the newline character (or its generalization) instead of <code>delim</code>:</p>
<p class="programlisting">string str1, str2;<br/>getline(cin, str1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read to end-of-line<br/>getline(cin, str2, '.');&#160;&#160;// read to period</p>
</body>
</html>
