<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>16. The string Class and the Standard Template Library</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h3 id="ch16lev1sec4"><a id="ch16a"/>Generic Programming</h3>
<p>Now that you have some experience using the STL, let&#8217;s look at the underlying philosophy. The STL is an example of <em>generic programming</em>. Object-oriented programming concentrates on the data aspect of programming, whereas generic programming concentrates on algorithms. The main things the two approaches have in common are abstraction and the creation of reusable code, but the philosophies are quite different.</p>
<p>A goal of generic programming is to write code that is independent of data types. Templates are the C++ tools for creating generic programs. Templates, of course, let you define a function or class in terms of a generic type. The STL goes further by providing a generic representation of algorithms. Templates make this possible, but not without the added element of careful and conscious design. To see how this mixture of templates and design works, let&#8217;s look at why iterators are needed.</p>
<h4 id="ch16lev2sec14">Why Iterators?</h4>
<p>Understanding iterators is perhaps the key to understanding the STL. Just as templates make algorithms independent of the type of data stored, iterators make the algorithms independent of the type of container used. Thus, they are an essential component of the STL&#8217;s generic approach.</p>
<p>To see why iterators are needed, let&#8217;s look at how you might implement a <code>find</code> function for two different data representations and then see how you could generalize the approach. First, let&#8217;s consider a function that searches an ordinary array of <code>double</code> for a particular value. You could write the function like this:</p>
<p class="programlisting">double * find_ar(double * ar, int n, const double &#38; val)<br/>{<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ar[i] == val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return &#38;ar[i];<br/>&#160;&#160;&#160;&#160;return 0;&#160;&#160;// or, in C++11, return nullptr;<br/>}</p>
<p>If the function finds the value in the array, it returns the address in the array where the value is found; otherwise, it returns the null pointer. It uses subscript notation to move through the array. You could use a template to generalize to arrays of any type having an <code>==</code> operator. Nonetheless, this algorithm is still tied to one particular data structure&#8212;the array.</p>
<p><a id="page_993"/>So let&#8217;s look at searching another kind of data structure, the linked list. (<a href="ch12.html#ch12">Chapter 12</a> uses a linked list to implement a <code>Queue</code> class.) The list consists of linked <code>Node</code> structures:</p>
<p class="programlisting">struct Node<br/>{<br/>&#160;&#160;&#160;&#160;double item;<br/>&#160;&#160;&#160;&#160;Node * p_next;<br/>};</p>
<p>Suppose you have a pointer that points to the first node in the list. The <code>p_next</code> pointer in each node points to the next node, and the <code>p_next</code> pointer for the last node in the list is set to <code>0</code>. You could write a <code>find_ll()</code> function this way:</p>
<p class="programlisting">Node* find_ll(Node * head, const double &#38; val)<br/>{<br/>&#160;&#160;&#160;&#160;Node * start;<br/>&#160;&#160;&#160;&#160;for (start = head; start!= 0; start = start-&gt;p_next)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (start-&gt;item == val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return start;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p>Again, you could use a template to generalize this to lists of any data type supporting the <code>==</code> operator. Nonetheless, this algorithm is still tied to one particular data structure&#8212;the linked list.</p>
<p>If you consider details of implementation, the two <code>find</code> functions use different algorithms: One uses array indexing to move through a list of items, and the other resets <code>start</code> to <code>start-&gt;p_next</code>. But broadly, the two algorithms are the same: Compare the value with each value in the container in sequence until you find a match.</p>
<p>The goal of generic programming in this case would be to have a single <code>find</code> function that would work with arrays or linked lists or any other container type. That is, not only should the function be independent of the data type stored in the container, it should be independent of the data structure of the container itself. Templates provide a generic representation for the data type stored in a container. What&#8217;s needed is a generic representation of the process of moving through the values in a container. The iterator is that generalized representation.</p>
<p>What properties should an iterator have in order to implement a <code>find</code> function? Here&#8217;s a short list:</p>
<p class="indenthandingB">&#8226; You should be able to dereference an iterator in order to access the value to which it refers. That is, if <code>p</code> is an iterator, <code>*p</code> should be defined.</p>
<p class="indenthandingB">&#8226; You should be able to assign one iterator to another. That is, if <code>p</code> and <code>q</code> are iterators, the expression <code>p = q</code> should be defined.</p>
<p class="indenthandingB">&#8226; You should be able to compare one iterator to another for equality. That is, if <code>p</code> and <code>q</code> are iterators, the expressions <code>p == q</code> and <code>p != q</code> should be defined.</p>
<p class="indenthandingB">&#8226; <a id="page_994"/>You should be able to move an iterator through all the elements of a container. This can be satisfied by defining <code>++p</code> and <code>p++</code> for an iterator <code>p</code>.</p>
<p>There are more things an iterator could do, but nothing more it need do&#8212;at least, not for the purposes of a <code>find</code> function. Actually, the STL defines several levels of iterators of increasing capabilities, and we&#8217;ll return to that matter later. Note, by the way, that an ordinary pointer meets the requirements of an iterator. Hence, you can rewrite the <code>find_arr()</code> function like this:</p>
<p class="programlisting">typedef double * iterator;<br/>iterator find_ar(iterator ar, int n, const double &#38; val)<br/>{<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++, ar++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*ar == val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ar;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p>Then you can alter the function parameter list so that it takes a pointer to the beginning of the array and a pointer to one past-the-end of the array as arguments to indicate a range. (<a href="ch07.html#ch07ex08">Listing 7.8</a> in <a href="ch07.html#ch07">Chapter 7</a>, &#8220;<a href="ch07.html#ch07">Functions: C++&#8217;s Programming Modules</a>,&#8221; does something similar.) And the function can return the end pointer as a sign the value was not found. The following version of <code>find_ar()</code> makes these changes:</p>
<p class="programlisting">typedef double * iterator;<br/>iterator find_ar(iterator begin, iterator end, const double &#38; val)<br/>{<br/>&#160;&#160;&#160;&#160;iterator ar;<br/>&#160;&#160;&#160;&#160;for (ar = begin; ar != end;&#160;&#160;ar++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*ar == val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ar;<br/>&#160;&#160;&#160;&#160;return end;&#160;&#160;&#160;// indicates val not found<br/>}</p>
<p>For the <code>find_ll()</code> function, you can define an iterator class that defines the <code>*</code> and <code>++</code> operators:</p>
<p class="programlisting">struct Node<br/>{<br/>&#160;&#160;&#160;&#160;double item;<br/>&#160;&#160;&#160;&#160;Node * p_next;<br/>};<br/><br/>class iterator<br/>{<br/>&#160;&#160;&#160;&#160;Node * pt;<br/>public:<br/>&#160;&#160;&#160;&#160;iterator() : pt(0) {}<br/>&#160;&#160;&#160;&#160;iterator (Node * pn) : pt(pn) {}<br/><a id="page_995"/>&#160;&#160;&#160;&#160;double operator*() { return pt-&gt;item;}<br/>&#160;&#160;&#160;&#160;iterator&#38; operator++()&#160;&#160;&#160;&#160;&#160;// for ++it<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pt = pt-&gt;p_next;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;iterator operator++(int)&#160;&#160;// for it++<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iterator tmp = *this;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pt = pt-&gt;p_next;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return tmp;<br/>&#160;&#160;&#160;&#160;}<br/>// ... operator==(), operator!=(), etc.<br/>};</p>
<p>(To distinguish between the prefix and postfix versions of the <code>++</code> operator, C++ adopted the convention of letting <code>operator++()</code> be the prefix version and <code>operator++(int)</code> be the suffix version; the argument is never used and hence needn&#8217;t be given a name.)</p>
<p>The main point here is not how, in detail, to define the <code>iterator</code> class, but that with such a class, the second <code>find</code> function can be written like this:</p>
<p class="programlisting">iterator find_ll(iterator head, const double &#38; val)<br/>{<br/>&#160;&#160;&#160;&#160;iterator start;<br/>&#160;&#160;&#160;&#160;for (start = head; start!= 0; ++start)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*start == val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return start;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p>This is very nearly the same as <code>find_ar()</code>. The point of difference is in how the two functions determine whether they&#8217;ve reached the end of the values being searched. The <code>find_ar()</code> function uses an iterator to one-past-the-end, whereas <code>find_ll()</code> uses a null value stored in the final node. Remove that difference, and you can make the two functions identical. For example, you could require that the linked list have one additional element after the last official element. That is, you could have both the array and the linked list have a past-the-end element, and you could end the search when the iterator reaches the past-the-end position. Then <code>find_ar()</code> and <code>find_ll()</code> would have the same way of detecting the end of data and become identical algorithms. Note that requiring a past-the-end element moves from making requirements on iterators to making requirements on the container class.</p>
<p>The STL follows the approach just outlined. First, each container class (<code>vector</code>, <code>list</code>, <code>deque</code>, and so on) defines an iterator type appropriate to the class. For one class, the iterator might be a pointer; for another, it might be an object. Whatever the implementation, the iterator will provide the needed operations, such as <code>*</code> and <code>++</code>. (Some classes may need <a id="page_996"/>more operations than others.) Next, each container class will have a past-the-end marker, which is the value assigned to an iterator when it has been incremented one past the last value in the container. Each container class will have <code>begin()</code> and <code>end()</code> methods that return iterators to the first element in a container and to the past-the-end position. And each container class will have the <code>++</code> operation take an iterator from the first element to past-the-end, visiting every container element en route.</p>
<p>To use a container class, you don&#8217;t need to know how its iterators are implemented nor how past-the-end is implemented. It&#8217;s enough to know that it does have iterators, that <code>begin()</code> returns an iterator to the first element, and that <code>end()</code> returns an iterator to past-the-end. For example, suppose you want to print the values in a <code>vector&lt;double&gt;</code> object. In that case, you can use this:</p>
<p class="programlisting">vector&lt;double&gt;::iterator pr;<br/>for (pr = scores.begin(); pr != scores.end(); pr++)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; *pr &lt;&lt; endl;</p>
<p>Here the following line identifies <code>pr</code> as the iterator type defined for the <code>vector&lt;double&gt;</code> class:</p>
<p class="programlisting">vector&lt;double&gt;::iterator pr;</p>
<p>If you used the <code>list&lt;double&gt;</code> class template instead to store scores, you could use this code:</p>
<p class="programlisting">list&lt;double&gt;::iterator pr;<br/>for (pr = scores.begin(); pr != scores.end(); pr++)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; *pr &lt;&lt; endl;</p>
<p>The only change is in the type declared for <code>pr</code>. Thus, by having each class define appropriate iterators and designing the classes in a uniform fashion, the STL lets you write the same code for containers that have quite dissimilar internal representations.</p>
<p>With C++ automatic type deduction, you can simplify further and use the following code with either the vector or the list:</p>
<p class="programlisting">for (auto pr = scores.begin(); pr != scores.end(); pr++)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; *pr &lt;&lt; endl;</p>
<p>Actually, as a matter of style, it&#8217;s better to avoid using the iterators directly; instead, if possible, you should use an STL function, such as <code>for_each()</code>, that takes care of the details for you. Alternatively, use the C++11 range-based <code>for</code> loop:</p>
<p class="programlisting">for (auto x : scores) cout &lt;&lt; x &lt;&lt; endl;</p>
<p>So to summarize the STL approach, you start with an algorithm for processing a container. You express it in as general terms as possible, making it independent of data type and container type. To make the general algorithm work with specific cases, you define iterators that meet the needs of the algorithm and place requirements on the container design. That is, basic iterator properties and container properties stem from requirements placed on the algorithm.</p>
<h4 id="ch16lev2sec15">Kinds of Iterators</h4>
<p><a id="page_997"/>Different algorithms have different requirements for iterators. For example, a find algorithm needs the <code>++</code> operator to be defined so the iterator can step through the entire container. It needs read access to data but not write access. (It just looks at data and doesn&#8217;t change it.) The usual sorting algorithm, on the other hand, requires random access so that it can swap two non-adjacent elements. If <code>iter</code> is an iterator, you can get random access by defining the <code>+</code> operator so that you can use expressions such as <code>iter + 10</code>. Also a sort algorithm needs to be able to both read and write data.</p>
<p>The STL defines five kinds of iterators and describes its algorithms in terms of which kinds of iterators it needs. The five kinds are the input iterator, output iterator, forward iterator, bidirectional iterator, and random access iterator. For example, the <code>find()</code> prototype looks like this:</p>
<p class="programlisting">template&lt;class InputIterator, class T&gt;<br/>InputIterator find(InputIterator first, InputIterator last, const T&#38; value);</p>
<p>This tells you that this algorithm requires an input iterator. Similarly, the following prototype tells you that the sort algorithm requires a random access iterator:</p>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void sort(RandomAccessIterator first, RandomAccessIterator last);</p>
<p>All five kinds of iterators can be dereferenced (that is, the <code>*</code> operator is defined for them) and can be compared for equality (using the <code>==</code> operator, possibly overloaded) and inequality (using the <code>!=</code> operator, possibly overloaded). If two iterators test as equal, then dereferencing one should produce the same value as dereferencing the second. That is, if</p>
<p class="programlisting">iter1 == iter2</p>
<p>is true, then the following is also true:</p>
<p class="programlisting">*iter1 == *iter2</p>
<p>Of course, these properties hold true for built-in operators and pointers, so these requirements are guides for what you must do when overloading these operators for an iterator class. Now let&#8217;s look at other iterator properties.</p>
<h5 id="ch16lev3sec4">Input Iterators</h5>
<p>The term <em>input</em> is used from the viewpoint of a program. That is, information going from the container to the program is considered input, just as information from a keyboard to the program is considered input. So an <em>input iterator</em> is one that a program can use to read values from a container. In particular, dereferencing an input iterator must allow a program to read a value from a container, but it needn&#8217;t allow a program to alter that value. So algorithms that require an input iterator are algorithms that don&#8217;t change values held in a container.</p>
<p>An input iterator has to allow you to access all the values in a container. It does so by supporting the <code>++</code> operator, both in prefix and suffix form. If you set an input operator to the first element in a container and increment it until it reaches past-the-end, it will point <a id="page_998"/>to every container item once en route. Incidentally, there is no guarantee that traversing a container a second time with an input iterator will move through the values in the same order. Also after an input iterator has been incremented, there is no guarantee that its prior value can still be dereferenced. Any algorithm based on an input iterator, then, should be a single-pass algorithm that doesn&#8217;t rely on iterator values from a previous pass or on earlier iterator values from the same pass.</p>
<p>Note that an input iterator is a one-way iterator; it can increment, but it can&#8217;t back up.</p>
<h5 id="ch16lev3sec5">Output Iterators</h5>
<p>In STL usage, the term <em>output</em> indicates that the iterator is used for transferring information from a program to a container. (Thus the output for the program is input for the container.) An output iterator is similar to an input iterator, except that dereferencing is guaranteed to allow a program to alter a container value but not to read it. If the ability to write without reading seems strange, keep in mind that this property also applies to output sent to your display; <code>cout</code> can modify the stream of characters sent to the display, but it can&#8217;t read what&#8217;s onscreen. The STL is general enough that its containers can represent output devices, so you can run into the same situation with containers. Also if an algorithm modifies the contents of a container (for example, by generating new values to be stored) without reading the contents, there&#8217;s no reason to require that it use an iterator that can read the contents.</p>
<p>In short, you can use an input iterator for single-pass, read-only algorithms and an output operator for single-pass, write-only algorithms.</p>
<h5 id="ch16lev3sec6">Forward Iterators</h5>
<p>Like input and output iterators, forward iterators use only the <code>++</code> operators for navigating through a container. So a forward iterator can only go forward through a container one element at a time. However, unlike input and output iterators, it necessarily goes through a sequence of values in the same order each time you use it. Also after you increment a forward iterator, you can still dereference the prior iterator value, if you&#8217;ve saved it, and get the same value. These properties make multiple-pass algorithms possible.</p>
<p>A forward iterator can allow you to both read and modify data, or it can allow you just to read it:</p>
<p class="programlisting">int * pirw;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read-write iterator<br/>const int * pir;&#160;&#160;// read-only iterator</p>
<h5 id="ch16lev3sec7">Bidirectional Iterators</h5>
<p>Suppose you have an algorithm that needs to be able to traverse a container in both directions. For example, a reverse function could swap the first and last elements, increment the pointer to the first element, decrement the pointer to a second element, and repeat the process. A bidirectional iterator has all the features of a forward iterator and adds support for the two decrement operators (prefix and postfix).</p>
<h5 id="ch16lev3sec8">Random Access Iterators</h5>
<p><a id="page_999"/>Some algorithms, such as standard sort and binary search, require the ability to jump directly to an arbitrary element of a container. This is termed <em>random access</em>, and it requires a random access iterator. This type of iterator has all the features of a bidirectional iterator, plus it adds operations (such as pointer addition) that support random access and relational operators for ordering the elements. <a href="#ch16table03">Table 16.3</a> lists the operations a random access iterator has beyond those of a bidirectional iterator. In this table, <code>X</code> represents a random iterator type, <code>T</code> represents the type pointed to, <code>a</code> and <code>b</code> are iterator values, <code>n</code> is an integer, and <code>r</code> is a random iterator variable or reference.</p>
<p class="caption"><a id="ch16table03"/><strong>Table 16.3. Random Access Iterator Operations</strong></p>
<p class="image"><img src="graphics/16tab03.jpg" alt="Image"/></p>
<p>Expressions such as <code>a + n</code> are valid only if both <code>a</code> and <code>a + n</code> lie within the range of the container (including past-the-end).</p>
<h4 id="ch16lev2sec16">Iterator Hierarchy</h4>
<p>You have probably noticed that the iterator kinds form a hierarchy. A forward iterator has all the capabilities of an input iterator and of an output iterator, plus its own capabilities. A bidirectional iterator has all the capabilities of a forward iterator, plus its own capabilities. And a random access iterator has all the capabilities of a forward iterator, plus its own capabilities. <a href="#ch16table04">Table 16.4</a> summarizes the main iterator capabilities. In it, <code>i</code> is an iterator, and <code>n</code> is an integer.</p>
<p class="caption"><a id="ch16table04"/><strong>Table 16.4. Iterator Capabilities</strong></p>
<p class="image"><img src="graphics/16tab04.jpg" alt="Image"/></p>
<p><a id="page_1000"/>An algorithm written in terms of a particular kind of iterator can use that kind of iterator or any other iterator that has the required capabilities. So a container with, say, a random access iterator can use an algorithm written for an input iterator.</p>
<p>Why all these different kinds of iterators? The idea is to write an algorithm using the iterator with the fewest requirements possible, allowing it to be used with the largest range of containers. Thus, the <code>find()</code> function, by using a lowly input iterator, can be used with any container that contains readable values. The <code>sort()</code> function, however, by requiring a random access iterator, can be used just with containers that support that kind of iterator.</p>
<p>Note that the various iterator kinds are not defined types; rather, they are conceptual characterizations. As mentioned earlier, each container class defines a class scope <code>typedef</code> name called <code>iterator</code>. So the <code>vector&lt;int&gt;</code> class has iterators of type <code>vector&lt;int&gt;::iterator</code>. But the documentation for this class would tell you that vector iterators are random access iterators. That, in turn, allows you to use algorithms based on any iterator type because a random access iterator has all the iterator capabilities. Similarly, a <code>list&lt;int&gt;</code> class has iterators of type <code>list&lt;int&gt;::iterator</code>. The STL implements a doubly linked list, so it uses a bidirectional iterator. Thus, it can&#8217;t use algorithms based on random access iterators, but it can use algorithms based on less demanding iterators.</p>
<h4 id="ch16lev2sec17">Concepts, Refinements, and Models</h4>
<p>The STL has several features, such as kinds of iterators, that aren&#8217;t expressible in the C++ language. That is, although you can design, say, a class that has the properties of a forward iterator, you can&#8217;t have the compiler restrict an algorithm to using only that class. The reason is that the forward iterator is a set of requirements, not a type. The requirements could be satisfied by an iterator class you&#8217;ve designed, but they could also be satisfied by an ordinary pointer. An STL algorithm works with any iterator implementation that meets its requirements. STL literature uses the word <em>concept</em> to describe a set of requirements. Thus, there is an input iterator concept, a forward iterator concept, and so on. By the way, if you do need iterators for, say, a container class you&#8217;re designing, you can look to the STL, which include iterator templates for the standard varieties.</p>
<p><a id="page_1001"/>Concepts can have an inheritance-like relationship. For example, a bidirectional iterator inherits the capabilities of a forward iterator. However, you can&#8217;t apply the C++ inheritance mechanism to iterators. For example, you might implement a forward iterator as a class and a bidirectional iterator as a regular pointer. So in terms of the C++ language, this particular bidirectional iterator, being a built-in type, couldn&#8217;t be derived from a class. Conceptually, however, it does inherit. Some STL literature uses the term <em>refinement</em> to indicate this conceptual inheritance. Thus, a bidirectional iterator is a refinement of the forward iterator concept.</p>
<p>A particular implementation of a concept is termed a <em>model</em>. Thus, an ordinary pointer-to-<code>int</code> is a model of the concept random access iterator. It&#8217;s also a model of a forward iterator, for it satisfies all the requirements of that concept.</p>
<h5 id="ch16lev3sec9">The Pointer As Iterator</h5>
<p>Iterators are generalizations of pointers, and a pointer satisfies all the iterator requirements. Iterators form the interface for STL algorithms, and pointers are iterators, so STL algorithms can use pointers to operate on non-STL containers that are based on pointers. For example, you can use STL algorithms with arrays. Suppose <code>Receipts</code> is an array of <code>double</code> values, and you would like to sort in ascending order:</p>
<p class="programlisting">const int SIZE = 100;<br/>double Receipts[SIZE];</p>
<p>The STL <code>sort()</code> function, recall, takes as arguments an iterator pointing to the first element in a container and an iterator pointing to past-the-end. Well, <code>&#38;Receipts[0]</code> (or just <code>Receipts</code>) is the address of the first element, and <code>&#38;Receipts[SIZE]</code> (or just <code>Receipts + SIZE</code>) is the address of the element following the last element in the array. Thus, the following function call sorts the array:</p>
<p class="programlisting">sort(Receipts, Receipts + SIZE);</p>
<p>C++ guarantees that the expression <code>Receipts + n</code> is defined as long as the result lies in the array or one past-the-end. Thus, C++ supports the &#8220;one-past-the-end&#8221; concept for pointers into an array, and this makes it possible to apply STL algorithms to ordinary arrays. Thus, the fact that pointers are iterators and that algorithms are iterator based makes it possible to apply STL algorithms to ordinary arrays. Similarly, you can apply STL algorithms to data forms of your own design, provided that you supply suitable iterators (which may be pointers or objects) and past-the-end indicators.</p>
<h5 id="ch16lev3sec10"><code>copy()</code>, <code>ostream_iterator</code>, and <code>istream_iterator</code></h5>
<p>The STL provides some predefined iterators. To see why, let&#8217;s establish some background. There is an algorithm called <code>copy()</code> for copying data from one container to another. This algorithm is expressed in terms of iterators, so it can copy from one kind of container to another or even from or to an array, because you can use pointers into an array as iterators. For example, the following copies an array into a vector:</p>
<p class="programlisting"><a id="page_1002"/>int casts[10] = {6, 7, 2, 9 ,4 , 11, 8, 7, 10, 5};<br/>vector&lt;int&gt; dice[10];<br/>copy(casts, casts + 10, dice.begin());&#160;&#160;&#160;// copy array to vector</p>
<p>The first two iterator arguments to <code>copy()</code> represent a range to be copied, and the final iterator argument represents the location to which the first item is copied. The first two arguments must be input iterators (or better), and the final argument must be an output iterator (or better). The <code>copy()</code> function overwrites existing data in the destination container, and the container has to be large enough to hold the copied elements. So you can&#8217;t use <code>copy()</code> to place data in an empty vector&#8212;at least not without resorting to a trick that is revealed later in this chapter.</p>
<p>Now suppose you want to copy information to the display. You could use <code>copy()</code> if there was an iterator representing the output stream. The STL provides such an iterator with the <code>ostream_iterator</code> template. Using STL terminology, this template is a <em>model</em> of the output iterator concept. It is also an example of an <em>adapter</em>&#8212;a class or function that converts some other interface to an interface used by the STL. You can create an iterator of this kind by including the <code>iterator</code> (formerly <code>iterator.h</code>) header file and making a declaration:</p>
<p class="programlisting">#include &lt;iterator&gt;<br/>...<br/>ostream_iterator&lt;int, char&gt; out_iter(cout, " ");</p>
<p>The <code>out_iter</code> iterator now becomes an interface that allows you to use <code>cout</code> to display information. The first template argument (<code>int</code>, in this case) indicates the data type being sent to the output stream. The second template argument (<code>char</code>, in this case) indicates the character type used by the output stream. (Another possible value would be <code>wchar_t</code>.) The first constructor argument (<code>cout</code>, in this case) identifies the output stream being used. It could also be a stream used for file output. The final character string argument is a separator to be displayed after each item sent to the output stream.</p>
<p>You could use the iterator like this:</p>
<p class="programlisting">*out_iter++ = 15;&#160;&#160;&#160;// works like cout &lt;&lt; 15 &lt;&lt; " ";</p>
<p>For a regular pointer, this would mean assigning the value <code>15</code> to the pointed-to location and then incrementing the pointer. For this <code>ostream_iterator</code>, however, the statement means send <code>15</code> and then a string consisting of a space to the output stream managed by <code>cout</code>. Then it should get ready for the next output operation. You could use the iterator with <code>copy()</code> as follows:</p>
<p class="programlisting">copy(dice.begin(), dice.end(), out_iter);&#160;&#160;&#160;&#160;// copy vector to output stream</p>
<p>This would mean to copy the entire range of the <code>dice</code> container to the output stream&#8212;that is, to display the contents of the container.</p>
<p>Or you could skip creating a named iterator and construct an anonymous iterator instead. That is, you could use the adapter like this:</p>
<p class="programlisting">copy(dice.begin(), dice.end(), ostream_iterator&lt;int, char&gt;(cout, " ") );</p>
<p><a id="page_1003"/>Similarly, the <code>iterator</code> header file defines an <code>istream_iterator</code> template for adapting <code>istream</code> input to the iterator interface. It is a model of the input iterator concept. You could use two <code>istream_iterator</code> objects to define an input range for <code>copy()</code>:</p>
<p class="programlisting">copy(istream_iterator&lt;int, char&gt;(cin),<br/>&#160;&#160;&#160;&#160;&#160;istream_iterator&lt;int, char&gt;(), dice.begin());</p>
<p>Like <code>ostream_iterator</code>, <code>istream_iterator</code> uses two template arguments. The first indicates the data type to be read, and the second indicates the character type used by the input stream. Using a constructor argument of <code>cin</code> means to use the input stream managed by <code>cin</code>. Omitting the constructor argument indicates input failure, so the previous code means to read from the input stream until end-of-file, type mismatch, or some other input failure.</p>
<h5 id="ch16lev3sec11">Other Useful Iterators</h5>
<p>The <code>iterator</code> header file provides some other special-purpose predefined iterator types in addition to <code>ostream_iterator</code> and <code>istream_iterator</code>. They are <code>reverse_iterator</code>, <code>back_insert_iterator</code>, <code>front_insert_iterator</code>, and <code>insert_iterator</code>.</p>
<p>Let&#8217;s start with seeing what a reverse iterator does. In essence, incrementing a reverse iterator causes it to decrement. Why not just decrement a regular iterator? The main reason is to simplify using existing functions. Suppose you want to display the contents of the <code>dice</code> container. As you just saw, you can use <code>copy()</code> and <code>ostream_iterator</code> to copy the contents to the output stream:</p>
<p class="programlisting">ostream_iterator&lt;int, char&gt; out_iter(cout, " ");<br/>copy(dice.begin(), dice.end(), out_iter);&#160;&#160;// display in forward order</p>
<p>Now suppose you want to print the contents in reverse order. (Perhaps you are performing time-reversal studies.) There are several approaches that don&#8217;t work, but rather than wallow in them, let&#8217;s go to one that does. The <code>vector</code> class has a member function called <code>rbegin()</code> that returns a reverse iterator pointing to past-the-end and a member <code>rend()</code> that returns a reverse iterator pointing to the first element. Because incrementing a reverse iterator makes it decrement, you can use the following statement to display the contents backward:</p>
<p class="programlisting">copy(dice.rbegin(), dice.rend(), out_iter); // display in reverse order</p>
<p>You don&#8217;t even have to declare a reverse iterator.</p>
<div class="note"><hr/>
<p class="title"><a id="ch16note03"/>Note</p>
<p class="notepara">Both <code>rbegin()</code> and <code>end()</code> return the same value (past-the-end), but as a different type (<code>reverse_iterator</code> versus <code>iterator</code>). Similarly, both <code>rend()</code> and <code>begin()</code> return the same value (an iterator to the first element), but as a different type.</p>
<hr/></div>
<p>Reverse pointers have to make a special compensation. Suppose <code>rp</code> is a reverse pointer initialized to <code>dice.rbegin()</code>. What should <code>*rp</code> be? Because <code>rbegin()</code> returns past-the-end, you shouldn&#8217;t try to dereference that address. Similarly, if <code>rend()</code> is really the location of the first element, <code>copy()</code> stops one location earlier because the end of the range is not <a id="page_1004"/>in a range. Reverse pointers solve both problems by decrementing first and then dereferencing. That is, <code>*rp</code> dereferences the iterator value immediately preceding the current value of <code>*rp</code>. If <code>rp</code> points to position six, <code>*rp</code> is the value of position five, and so on. <a href="#ch16ex10">Listing 16.10</a> illustrates using <code>copy()</code>, an <code>ostream</code> iterator, and a reverse iterator.</p>
<p class="caption1"><a id="ch16ex10"/><strong>Listing 16.10. <code>copyit.cpp</code></strong></p><hr/>
<p class="programlisting1">// copyit.cpp -- copy() and iterators<br/>#include &lt;iostream&gt;<br/>#include &lt;iterator&gt;<br/>#include &lt;vector&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/><br/>&#160;&#160;&#160;&#160;int casts[10] = {6, 7, 2, 9 ,4 , 11, 8, 7, 10, 5};<br/>&#160;&#160;&#160;&#160;vector&lt;int&gt; dice(10);<br/>&#160;&#160;&#160;&#160;// copy from array to vector<br/>&#160;&#160;&#160;&#160;copy(casts, casts + 10, dice.begin());<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Let the dice be cast!\n";<br/>&#160;&#160;&#160;&#160;// create an ostream iterator<br/>&#160;&#160;&#160;&#160;ostream_iterator&lt;int, char&gt; out_iter(cout, " ");<br/>&#160;&#160;&#160;&#160;// copy from vector to output<br/>&#160;&#160;&#160;&#160;copy(dice.begin(), dice.end(), out_iter);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;"Implicit use of reverse iterator.\n";<br/>&#160;&#160;&#160;&#160;copy(dice.rbegin(), dice.rend(), out_iter);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;"Explicit use of reverse iterator.\n";<br/>&#160;&#160;&#160;&#160;vector&lt;int&gt;::reverse_iterator ri;<br/>&#160;&#160;&#160;&#160;for (ri = dice.rbegin(); ri != dice.rend(); ++ri)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; *ri &lt;&lt; ' ';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch16ex10">Listing 16.10</a>:</p>
<p class="programlisting">Let the dice be cast!<br/>6 7 2 9 4 11 8 7 10 5<br/>Implicit use of reverse iterator.<br/>5 10 7 8 11 4 9 2 7 6<br/>Explicit use of reverse iterator.<br/>5 10 7 8 11 4 9 2 7 6</p>
<p><a id="page_1005"/>If you have the choice of explicitly declaring iterators or using STL functions to handle the matter internally, for example, by passing an <code>rbegin()</code> return value to a function, you should take the latter course. It&#8217;s one less thing to do and one less opportunity to experience human fallibility.</p>
<p>The other three iterators (<code>back_insert_iterator</code>, <code>front_insert_iterator</code>, and <code>insert_iterator</code>) also increase the generality of the STL algorithms. Many STL functions are like <code>copy()</code> in that they send their results to a location indicated by an output iterator. Recall that the following copies values to the location beginning at <code>dice.begin()</code>:</p>
<p class="programlisting">copy(casts, casts + 10, dice.begin());</p>
<p>These values overwrite the prior contents in <code>dice</code>, and the function assumes that <code>dice</code> has enough room to hold the values. That is, <code>copy()</code> does not automatically adjust the size of the destination to fit the information sent to it. <a href="#ch16ex10">Listing 16.10</a> takes care of that situation by declaring <code>dice</code> to have 10 elements, but suppose you don&#8217;t know in advance how big <code>dice</code> should be. Or suppose you want to add elements to <code>dice</code> rather than overwrite existing ones.</p>
<p>The three insert iterators solve these problems by converting the copying process to an insertion process. Insertion adds new elements without overwriting existing data, and it uses automatic memory allocation to ensure that the new information fits. A <code>back_insert_iterator</code> inserts items at the end of the container, and a <code>front_insert_iterator</code> inserts items at the front. Finally, the <code>insert_iterator</code> inserts items in front of the location specified as an argument to the <code>insert_iterator</code> constructor. All three of these iterators are models of the output container concept.</p>
<p>There are restrictions. A <code>back_insert_iterator</code> can be used only with container types that allow rapid insertion at the end. (<em>Rapid</em> refers to a constant time algorithm; the section &#8220;<a href="#ch16lev3sec12">Container Concepts</a>,&#8221; later in this chapter, discusses the constant time concept further.) The <code>vector</code> class qualifies. A <code>front_insert_iterator</code> can be used only with container types that allow constant time insertion at the beginning. Here the <code>vector</code> class doesn&#8217;t qualify, but the <code>queue</code> class does. The <code>insert_iterator</code> doesn&#8217;t have these restrictions. Thus, you can use it to insert material at the front of a vector. However, a <code>front_insert_iterator</code> does so faster for the container types that support it.</p>
<div class="note"><hr/>
<p class="title"><a id="ch16note04"/>Tip</p>
<p class="notepara">You can use an <code>insert_iterator</code> to convert an algorithm that copies data into one that inserts data.</p>
<hr/></div>
<p>These iterators take the container type as a template argument and the actual container identifier as a constructor argument. That is, to create a <code>back_insert_iterator</code> for a <code>vector&lt;int&gt;</code> container called <code>dice</code>, you use this:</p>
<p class="programlisting">back_insert_iterator&lt;vector&lt;int&gt; &gt; back_iter(dice);</p>
<p>The reason you have to declare the container type is that the iterator has to make use of the appropriate container method. The code for the <code>back_insert_iterator</code> <a id="page_1006"/>constructor will assume that a <code>push_back()</code> method exists for the type passed to it. The <code>copy()</code> function, being a standalone function, doesn&#8217;t have the access rights to resize a container. But the declaration just shown allows <code>back_iter</code> to use the <code>vector&lt;int&gt;::push_back()</code> method, which does have access rights.</p>
<p>Declaring a <code>front_insert_iterator</code> has the same form. An <code>insert_iterator</code> declaration has an additional constructor argument to identify the insertion location:</p>
<p class="programlisting">insert_iterator&lt;vector&lt;int&gt; &gt; insert_iter(dice, dice.begin() );</p>
<p><a href="#ch16ex11">Listing 16.11</a> illustrates using two of these iterators. Also it uses <code>for_each()</code> instead of an <code>ostream</code> iterator for output.</p>
<p class="caption1"><a id="ch16ex11"/><strong>Listing 16.11. <code>inserts.cpp</code></strong></p><hr/>
<p class="programlisting1">// inserts.cpp -- copy() and insert iterators<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;iterator&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/><br/>void output(const std::string &#38; s) {std::cout &lt;&lt; s &lt;&lt; " ";}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;string s1[4] = {"fine", "fish", "fashion", "fate"};<br/>&#160;&#160;&#160;&#160;string s2[2] = {"busy", "bats"};<br/>&#160;&#160;&#160;&#160;string s3[2] = {"silly", "singers"};<br/>&#160;&#160;&#160;&#160;vector&lt;string&gt; words(4);<br/>&#160;&#160;&#160;&#160;copy(s1, s1 + 4, words.begin());<br/>&#160;&#160;&#160;&#160;for_each(words.begin(), words.end(), output);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>// construct anonymous back_insert_iterator object<br/>&#160;&#160;&#160;&#160;copy(s2, s2 + 2, back_insert_iterator&lt;vector&lt;string&gt; &gt;(words));<br/>&#160;&#160;&#160;&#160;for_each(words.begin(), words.end(), output);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>// construct anonymous insert_iterator object<br/>&#160;&#160;&#160;&#160;copy(s3, s3 + 2, insert_iterator&lt;vector&lt;string&gt; &gt;(words,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;words.begin()));<br/>&#160;&#160;&#160;&#160;for_each(words.begin(), words.end(), output);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1007"/>Here is the output of the program in <a href="#ch16ex11">Listing 16.11</a>:</p>
<p class="programlisting">fine fish fashion fate<br/>fine fish fashion fate busy bats<br/>silly singers fine fish fashion fate busy bats</p>
<p>The first <code>copy()</code>copies the four strings from <code>s1</code> into <code>words</code>. This works in part because <code>words</code> is declared to hold four strings, which equals the number of strings being copied. Then the <code>back_insert_iterator</code> inserts the strings from <code>s2</code> just in front of the end of the <code>words</code> array, expanding the size of <code>words</code> to six elements. Finally, the <code>insert_iterator</code> inserts the two strings from <code>s3</code> just in front of the first element of <code>words</code>, expanding the size of <code>words</code> to eight elements. If the program attempted to copy <code>s2</code> and <code>s3</code> into <code>words</code> by using <code>words.end()</code> and <code>words.begin()</code> as iterators, there would be no room in <code>words</code> for the new data, and the program would probably abort because of memory violations.</p>
<p>If you&#8217;re feeling overwhelmed by all the iterator varieties, keep in mind that using them will make them familiar. Also keep in mind that these predefined iterators expand the generality of the STL algorithms. Thus, not only can <code>copy()</code> copy information from one container to another, it can copy information from a container to the output stream and from the input stream to a container. And you can also use <code>copy()</code> to insert material into another container. So you wind up with a single function doing the work of many. And because <code>copy()</code> is just one of several STL functions that use an output iterator, these predefined iterators multiply the capabilities of those functions, too.</p>
<h4 id="ch16lev2sec18">Kinds of Containers</h4>
<p>The STL has both container concepts and container types. The concepts are general categories with names such as container, sequence container, and associative container. The container types are templates you can use to create specific container objects. The original 11 container types are <code>deque</code>, <code>list</code>, <code>queue</code>, <code>priority_queue</code>, <code>stack</code>, <code>vector</code>, <code>map</code>, <code>multimap</code>, <code>set</code>, <code>multiset</code>, and <code>bitset</code>. (This chapter doesn&#8217;t discuss <code>bitset</code>, which is a container for dealing with data at the bit level.) C++11 adds <code>forward_list</code>, <code>unordered_map</code>, <code>unordered_multimap</code>, <code>unordered_set</code>, and <code>unordered_multiset</code>, and it moves <code>bitset</code> from the container category into its own separate category. Because the concepts categorize the types, let&#8217;s start with them.</p>
<h5 id="ch16lev3sec12">Container Concepts</h5>
<p>No type corresponds to the basic container concept, but the concept describes elements common to all the container classes. It&#8217;s sort of a conceptual abstract base class&#8212;conceptual because the container classes don&#8217;t actually use the inheritance mechanism. Or to put it another way, the container concept lays down a set of requirements that all STL container classes must satisfy.</p>
<p>A <em>container</em> is an object that stores other objects, which are all of a single type. The stored objects may be objects in the OOP sense, or they may be values of built-in types. Data stored in a container is <em>owned</em> by the container. That means when a container <a id="page_1008"/>expires, so does the data stored in the container. (However, if the data are pointers, the pointed-to data does not necessarily expire.)</p>
<p>You can&#8217;t store just any kind of object in a container. In particular, the type has to be <em>copy constructable</em> and <em>assignable</em>. Basic types satisfy these requirements, as do class types&#8212;unless the class definition makes one or both of the copy constructor and the assignment operator private or protected. (C++11 refines the concepts, adding terms such as <em>CopyInsertable</em> and <em>MoveInsertable</em>, but we&#8217;ll take a more simplified, if less precise, overview.)</p>
<p>The basic container doesn&#8217;t guarantee that its elements are stored in any particular order or that the order doesn&#8217;t change, but refinements to the concept may add such guarantees. All containers provide certain features and operations. <a href="#ch16table05">Table 16.5</a> summarizes several of these common features. In the table, <code>X</code> represents a container type (such as <code>vector</code>), <code>T</code> represents the type of object stored in the container, <code>a</code> and <code>b</code> represent values of type <code>X</code>, <code>r</code> is a value of type <code>X&#38;</code>, and <code>u</code> represents an identifier of type <code>X</code> (that is, if <code>X</code> represents <code>vector&lt;int&gt;</code>, then <code>u</code> is a <code>vector&lt;int&gt;</code> object).</p>
<p class="caption"><a id="ch16table05"/><strong>Table 16.5. Some Basic Container Properties</strong></p>
<p class="image"><img src="graphics/16tab05.jpg" alt="Image"/></p>
<p><a id="page_1009"/>The Complexity column in <a href="#ch16table05">Table 16.5</a> describes the time needed to perform an operation. This table lists three possibilities, which, from fastest to slowest, are as follows:</p>
<p class="indenthandingB">&#8226; Compile time</p>
<p class="indenthandingB">&#8226; Constant time</p>
<p class="indenthandingB">&#8226; Linear time</p>
<p>If the complexity is compile time, the action is performed during compilation and uses no execution time. A constant complexity means the operation takes place during runtime but doesn&#8217;t depend on the number of elements in an object. A linear complexity means the time is proportional to the number of elements. Thus, if <code>a</code> and <code>b</code> are containers, <code>a == b</code> has linear complexity because the <code>==</code> operation may have to be applied to each element of the container. Actually, that is a worst-case scenario. If two containers have different sizes, no individual comparisons need to be made.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch16sb02"/>Constant-Time and Linear-Time Complexity</p>
<p class="sidebarpara">Imagine a long, narrow box filled with large packages arranged in a line, and suppose the box is open at just one end. Suppose your task is to unload the package at the open end. This is a constant time task. Whether there are 10 packages or 1,000 packages behind the one at the end makes no difference.</p>
<p class="sidebarpara">Now suppose your task is to fetch the package at the closed end of the box. This is a linear time task. If there are 10 packages altogether, you have to unload 10 packages to get the one at the closed end. If there are 100 packages, you have to unload 100 packages at the end. Assuming that you are a tireless worker who can move only 1 package at a time, this task will take 10 times longer than the first one.</p>
<p class="sidebarpara">Now suppose your task is to fetch an arbitrary package. It might happen that the package you are supposed to get is the first one at hand. However, on the average, the number of packages you have to move is still proportional to the number of packages in the container, so the task still has linear-time complexity.</p>
<p class="sidebarpara">Replacing the long, narrow box with a similar box having open sides would change the task to constant-time complexity because then you could move directly to the desired package and remove it without moving the others.</p>
<p class="sidebarpara">The idea of time complexity describes the effect of container size on execution time but ignores other factors. If a superhero can unload packages from a box with one open end 1,000 times faster than you can, the task as executed by her still has linear-time complexity. In this case, the super hero&#8217;s linear time performance with a closed box (open end) would be faster than your constant time performance with an open box, as long as the boxes didn&#8217;t have too many packages.</p>
<hr/></div>
<p><a id="page_1010"/>Complexity requirements are characteristic of the STL. Although the details of an implementation may be hidden, the performance specifications should be public so that you know the computing cost of doing a particular operation.</p>
<h5 id="ch16lev3sec13">C++11 Additions to Container Requirements</h5>
<p><a href="#ch16table06">Table 16.6</a> shows some additions C++11 has made to the general container requirements. The table uses the notation <code>rv</code> to denote a non-constant rvalue of type <code>X</code> (for example, the return value of a function). Also the requirement in <a href="#ch16table06">Table 16.6</a> that <code>X::iterator</code> satisfy the requirements for a forward iterator is a change from the former requirement that it just not be an output iterator.</p>
<p class="caption"><a id="ch16table06"/><strong>Table 16.6. Some Added Basic Container Requirements (C++11)</strong></p>
<p class="image"><img src="graphics/16tab06.jpg" alt="Image"/></p>
<p>The difference between copy construction and copy assignment on the one hand and move construction and move assignment on the other hand is that a copy operation leaves the original unchanged, whereas a move operation can alter the original, perhaps transferring ownership without doing any copying When the source object is temporary, move operations can provide more efficient code than does regular copying. <a href="ch18.html#ch18">Chapter 18</a> discusses move semantics further.</p>
<h5 id="ch16lev3sec14">Sequences</h5>
<p><a id="page_1011"/>You can refine the basic container concept by adding requirements. The <em>sequence</em> is an important refinement because several of the STL container types&#8212;<code>deque</code>, <code>forward_list</code> (C++11), <code>list</code>, <code>queue</code>, <code>priority_queue</code>, <code>stack</code>, and <code>vector</code>&#8212;are sequences. (Recall that a queue allows elements to be added at the rear end and removed from the front. A double-ended queue, represented by <code>deque</code>, allows addition and removal at both ends.) The requirement that the iterator be at least a forward iterator guarantees that the elements are arranged in a definite order that doesn&#8217;t change from one cycle of iteration to the next. The <code>array</code> class also is classified as a sequence container, although it doesn&#8217;t satisfy all the requirements.</p>
<p>The sequence also requires that its elements be arranged in strict linear order. That is, there is a first element, there is a last element, and each element but the first and last has exactly one element immediately ahead of it and one element immediately after it. An array and a linked list are examples of sequences, whereas a branching structure (in which each node points to two daughter nodes) is not.</p>
<p>Because elements in sequence have a definite order, operations such as inserting values at a particular location and erasing a particular range become possible. <a href="#ch16table07">Table 16.7</a> lists these and other operations required of a sequence. The table uses the same notation as <a href="#ch16table05">Table 16.5</a>, with the addition of <code>t</code> representing a value of type <code>T</code>&#8212;that is, the type of value stored in the container, of <code>n</code>, an integer, and of <code>p</code>, <code>q</code>, <code>i</code>, and <code>j</code>, representing iterators.</p>
<p class="caption"><a id="ch16table07"/><strong>Table 16.7. Sequence Requirements</strong></p>
<p class="image"><img src="graphics/16tab07.jpg" alt="Image"/></p>
<p>Because the <code>deque</code>, <code>list</code>, <code>queue</code>, <code>priority_queue</code>, <code>stack</code>, and <code>vector</code> template classes are all models of the sequence concept, they all support the operators in <a href="#ch16table07">Table 16.7</a>. In <a id="page_1012"/>addition, there are operations that are available to some of these six models. When allowed, they have constant-time complexity. <a href="#ch16table08">Table 16.8</a> lists these additional operations.</p>
<p class="caption"><a id="ch16table08"/><strong>Table 16.8. Optional Sequence Requirements</strong></p>
<p class="image"><img src="graphics/16tab08.jpg" alt="Image"/></p>
<p><a href="#ch16table08">Table 16.8</a> merits a comment or two. First, notice that <code>a[n]</code> and <code>a.at(n)</code> both return a reference to the <code>n</code>th element (numbering from 0) in a container. The difference between the two is that <code>a.at(n)</code> does bounds checking and throws an <code>out_of_range</code> exception if <code>n</code> is outside the valid range for the container. Next, you might wonder why, say, <code>push_front()</code> is defined for <code>list</code> and <code>deque</code> and not for <code>vector</code>. Suppose you want to insert a new value at the front of a vector of 100 elements. To make room, you have to move element 99 to position 100, and then you have to move element 98 to position 99, and so on. This is an operation with linear-time complexity because moving 100 elements would take 100 times as long as moving a single element. But the operations in <a href="#ch16table08">Table 16.8</a> are supposed to be implemented only if they can be performed with constant-time complexity. The design for lists and double-ended queues, however, allows an element to be added to the front without moving the other elements to new locations, so they can implement <code>push_front()</code> with constant-time complexity. <a href="#ch16fig04">Figure 16.4</a> illustrates <code>push_front()</code> and <code>push_back()</code>.</p>
<p class="caption"><a id="ch16fig04"/><strong>Figure 16.4. <code>push_front()</code> and <code>push_back()</code>.</strong></p>
<p class="image"><img src="graphics/16fig04.jpg" alt="Image"/></p>
<p>Let&#8217;s take a closer look at the six sequence container types.</p>
<h6 id="ch16lev4sec1"><code>vector</code></h6>
<p>You&#8217;ve already seen several examples using the <code>vector</code> template, which is declared in the <code>vector</code> header file. In brief, <code>vector</code> is a class representation of an array. The class provides automatic memory management that allows the size of a <code>vector</code> object to vary dynamically, growing and shrinking as elements are added or removed. It provides random access to elements. Elements can be added to or removed from the end in constant time, but insertion and removal from the beginning and the middle are linear-time operations.</p>
<p>In addition to being a sequence, a <code>vector</code> container is also a model of the <em>reversible container</em> concept. This adds two more class methods: <code>rbegin()</code> returns an iterator to the first element of the reversed sequence, and <code>rend()</code> returns a past-the-end iterator for the <a id="page_1013"/>reversed sequence. So if <code>dice</code> is a <code>vector&lt;int&gt;</code> container and <code>Show(int)</code> is a function that displays an integer, the following code displays the contents of <code>dice</code> first in forward order and then in reverse order:</p>
<p class="programlisting">for_each(dice.begin(), dice.end(), Show);&#160;&#160;&#160;&#160;// display in order<br/>cout &lt;&lt; endl;<br/>for_each(dice.rbegin(), dice.rend(), Show);&#160;&#160;// display in reversed order<br/>cout &lt;&lt; endl;</p>
<p>The iterator returned by the two methods is of a class scope type <code>reverse_iterator</code>. Recall that incrementing such an iterator causes it to move through a reversible container in reverse order.</p>
<p>The <code>vector</code> template class is the simplest of the sequence types and is considered the type that should be used by default unless the program requirements are better satisfied by the particular virtues of the other types.</p>
<h6 id="ch16lev4sec2"><code>deque</code></h6>
<p>The <code>deque</code> template class (declared in the <code>deque</code> header file) represents a double-ended queue, a type often called a <em>deque</em> (pronounced &#8220;deck&#8221;), for short. As implemented in the STL, it&#8217;s a lot like a <code>vector</code> container, supporting random access. The main difference is that inserting and removing items from the beginning of a <code>deque</code> object are constant-time operations instead of being linear-time operations the way they are for <code>vector</code>. So if most operations take place at the beginning and ends of a sequence, you should consider using a <code>deque</code> data structure.</p>
<p>The goal of constant-time insertion and removal at both ends of a <code>deque</code> makes the design of a <code>deque</code> object more complex than that of a <code>vector</code> object. Thus, although both offer random access to elements and linear-time insertion and removal from the middle of a sequence, the <code>vector</code> container should allow faster execution of these operations.</p>
<h6 id="ch16lev4sec3"><code>list</code></h6>
<p><a id="page_1014"/>The <code>list</code> template class (declared in the <code>list</code> header file) represents a doubly linked list. Each element, other than the first and last, is linked to the item before it and the item following it, implying that a list can be traversed in both directions. The crucial difference between <code>list</code> and <code>vector</code> is that <code>list</code> provides for constant-time insertion and removal of elements at any location in the list. (Recall that the <code>vector</code> template provides linear-time insertion and removal except at the end, where it provides constant-time insertion and removal.) Thus, <code>vector</code> emphasizes rapid access via random access, whereas <code>list</code> emphasizes rapid insertion and removal of elements.</p>
<p>Like <code>vector</code>, <code>list</code> is a reversible container. Unlike <code>vector</code>, <code>list</code> does not support array notation and random access. Unlike a <code>vector</code> iterator, a <code>list</code> iterator remains pointing to the same element even after items are inserted into or removed from a container. For example, suppose you have an iterator pointing to the fifth element of a <code>vector</code> container. Then suppose you insert an element at the beginning of the container. All the other elements have to be moved to make room, so after the insertion, the fifth element now contains the value that used to be in the fourth element. Thus, the iterator points to the same location but to different data. Inserting a new element into a list, however, doesn&#8217;t move the existing elements; it just alters the link information. An iterator pointing to a certain item still points to the same item, but it may be linked to different items than before.</p>
<p>The <code>list</code> template class has some list-oriented member functions in addition to those that come with sequences and reversible containers. <a href="#ch16table09">Table 16.9</a> lists many of them. (For a complete list of STL methods and functions, see <a href="app07.html#app07">Appendix G</a>.) The <code>Alloc</code> template parameter is one you normally don&#8217;t have to worry about because it has a default value.</p>
<p class="caption"><a id="ch16table09"/><strong>Table 16.9. Some <code>list</code> Member Functions</strong></p>
<p class="image"><img src="graphics/16tab09.jpg" alt="Image"/></p>
<p><a id="page_1015"/><a href="#ch16ex12">Listing 16.12</a> illustrates these methods, along with the <code>insert()</code> method, which comes with all STL classes that model sequences.</p>
<p class="caption1"><a id="ch16ex12"/><strong>Listing 16.12. <code>list.cpp</code></strong></p><hr/>
<p class="programlisting1">// list.cpp -- using a list<br/>#include &lt;iostream&gt;<br/>#include &lt;list&gt;<br/>#include &lt;iterator&gt;<br/>#include &lt;algorithm&gt;<br/><br/>void outint(int n) {std::cout &lt;&lt; n &lt;&lt; " ";}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;list&lt;int&gt; one(5, 2); // list of 5 2s<br/>&#160;&#160;&#160;&#160;int stuff[5] = {1,2,4,8, 6};<br/>&#160;&#160;&#160;&#160;list&lt;int&gt; two;<br/>&#160;&#160;&#160;&#160;two.insert(two.begin(),stuff, stuff + 5 );<br/>&#160;&#160;&#160;&#160;int more[6] = {6, 4, 2, 4, 6, 5};<br/>&#160;&#160;&#160;&#160;list&lt;int&gt; three(two);<br/>&#160;&#160;&#160;&#160;three.insert(three.end(), more, more + 6);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "List one: ";<br/>&#160;&#160;&#160;&#160;for_each(one.begin(),one.end(), outint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "List two: ";<br/>&#160;&#160;&#160;&#160;for_each(two.begin(), two.end(), outint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "List three: ";<br/>&#160;&#160;&#160;&#160;for_each(three.begin(), three.end(), outint);<br/>&#160;&#160;&#160;&#160;three.remove(2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "List three minus 2s: ";<br/>&#160;&#160;&#160;&#160;for_each(three.begin(), three.end(), outint);<br/>&#160;&#160;&#160;&#160;three.splice(three.begin(), one);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "List three after splice: ";<br/>&#160;&#160;&#160;&#160;for_each(three.begin(), three.end(), outint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "List one: ";<br/>&#160;&#160;&#160;&#160;for_each(one.begin(), one.end(), outint);<br/>&#160;&#160;&#160;&#160;three.unique();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "List three after unique: ";<br/>&#160;&#160;&#160;&#160;for_each(three.begin(), three.end(), outint);<br/>&#160;&#160;&#160;&#160;three.sort();<br/>&#160;&#160;&#160;&#160;three.unique();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "List three after sort &#38; unique: ";<br/>&#160;&#160;&#160;&#160;for_each(three.begin(), three.end(), outint);<br/>&#160;&#160;&#160;&#160;two.sort();<br/>&#160;&#160;&#160;&#160;three.merge(two);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "Sorted two merged into three: ";<br/>&#160;&#160;&#160;&#160;for_each(three.begin(), three.end(), outint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1016"/>Here is the output of the program in <a href="#ch16ex12">Listing 16.12</a>:</p>
<p class="programlisting">List one: 2 2 2 2 2<br/>List two: 1 2 4 8 6<br/>List three: 1 2 4 8 6 6 4 2 4 6 5<br/>List three minus 2s: 1 4 8 6 6 4 4 6 5<br/>List three after splice: 2 2 2 2 2 1 4 8 6 6 4 4 6 5<br/>List one:<br/>List three after unique: 2 1 4 8 6 4 6 5<br/>List three after sort &#38; unique: 1 2 4 5 6 8<br/>Sorted two merged into three: 1 1 2 2 4 4 5 6 6 8 8</p>
<h6 id="ch16lev4sec4">Program Notes</h6>
<p>The program in <a href="#ch16ex12">Listing 16.12</a> uses the <code>for_each()</code> algorithm and an <code>outint()</code> function to display the lists. With C++11, you could use the range-based <code>for</code> loop instead:</p>
<p class="programlisting">for (auto x : three) cout &lt;&lt; x &lt;&lt; " ";</p>
<p>The main difference between <code>insert()</code> and <code>splice()</code> is that <code>insert()</code> inserts a copy of the original range into the destination, whereas <code>splice()</code> moves the original range into the destination. Thus, after the contents of <code>one</code> are spliced to <code>three</code>, <code>one</code> is left empty. (The <code>splice()</code> method has additional prototypes for moving single elements and a range of elements.) The <code>splice()</code> method leaves iterators valid. That is, if you set a particular iterator to point to an element in <code>one</code>, that iterator still points to the same element after <code>splice()</code> relocates it in <code>three</code>.</p>
<p>Notice that <code>unique()</code> only reduces adjacent equal values to a single value. After the program executes <code>three.unique()</code>, <code>three</code> still contains two fours and two sixes that weren&#8217;t adjacent. But applying <code>sort()</code> and then <code>unique()</code> does limit each value to a single appearance.</p>
<p>There is a nonmember <code>sort()</code> function (<a href="ch16.html#ch16ex09">Listing 16.9</a>), but it requires random access iterators. Because the trade-off for rapid insertion is to give up random access, you can&#8217;t use the nonmember <code>sort()</code> function with a list. Therefore, the class includes a member version that works within the restrictions of the class.</p>
<h6 id="ch16lev4sec5">The <code>list</code> Toolbox</h6>
<p>The <code>list</code> methods form a handy toolbox. Suppose, for example, that you have two mailing lists to organize. You could sort each list, merge them, and then use <code>unique()</code> to remove multiple entries.</p>
<p><a id="page_1017"/>The <code>sort()</code>, <code>merge()</code>, and <code>unique()</code> methods also each have a version that accepts an additional argument to specify an alternative function to be used for comparing elements. Similarly, the <code>remove()</code> method has a version with an additional argument that specifies a function used to determine whether an element is removed. These arguments are examples of predicate functions, a topic to which we&#8217;ll return later.</p>
<h6 id="ch16lev4sec6"><code>forward_list</code> (C++11)</h6>
<p>C++11 adds <code>forward_list</code> as a container class. This class implements a singly linked list. In this kind of list, each item is linked just to the next item, but not to the preceding item. Therefore, the class requires just a forward iterator, not a bidirectional one. Thus, unlike <code>vector</code> and <code>list</code>, <code>forward_list</code> isn&#8217;t a reversible container. Compared to <code>list</code>, <code>forward_list</code> is simpler, more compact, but with fewer features.</p>
<h6 id="ch16lev4sec7"><code>queue</code></h6>
<p>The <code>queue</code> template class (declared in the <code>queue</code>&#8212;formerly <code>queue.h</code>&#8212;header file) is an adapter class. Recall that the <code>ostream_iterator</code> template is an adapter that allows an output stream to use the iterator interface. Similarly, the <code>queue</code> template allows an underlying class (<code>deque</code>, by default) to exhibit the typical queue interface.</p>
<p>The <code>queue</code> template is more restrictive than <code>deque</code>. Not only does it not permit random access to elements of a queue, the <code>queue</code> class doesn&#8217;t even allow you to iterate through a queue. Instead, it limits you to the basic operations that define a queue. You can add an element to the rear of a queue, remove an element from the front of a queue, view the values of the front and rear elements, check the number of elements, and test to see if a queue is empty. <a href="#ch16table10">Table 16.10</a> lists these operations.</p>
<p>Note that <code>pop()</code> is a data removal method, not a data retrieval method. If you want to use a value from a queue, you first use <code>front()</code> to retrieve the value and then use <code>pop()</code> to remove it from the queue.</p>
<p class="caption"><a id="ch16table10"/><strong>Table 16.10. <code>queue</code> Operations</strong></p>
<p class="image"><img src="graphics/16tab10.jpg" alt="Image"/></p>
<h6 id="ch16lev4sec8"><code>priority_queue</code></h6>
<p>The <code>priority_queue</code> template class (declared in the <code>queue</code> header file) is another adapter class. It supports the same operations as <code>queue</code>. The main difference between the two is that with <code>priority_queue</code>, the largest item gets moved to the front of the queue. (Life is <a id="page_1018"/>not always fair, and neither are queues.) An internal difference is that the default underlying class is <code>vector</code>. You can alter the comparison used to determine what gets to the head of the queue by providing an optional constructor argument:</p>
<p class="programlisting">priority_queue&lt;int&gt; pq1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default version<br/>priority_queue&lt;int&gt; pq2(greater&lt;int&gt;);&#160;&#160;// use greater&lt;int&gt; to order</p>
<p>The <code>greater&lt;&gt;()</code> function is a predefined function object, and it is discussed later in this chapter.</p>
<h6 id="ch16lev4sec9"><code>stack</code></h6>
<p>Like <code>queue</code>, <code>stack</code> (declared in the <code>stack</code>&#8212;formerly <code>stack.h</code>&#8212;header file) is an adapter class. It gives an underlying class (<code>vector</code>, by default) the typical stack interface.</p>
<p>The <code>stack</code> template is more restrictive than <code>vector</code>. Not only does it not permit random access to elements of a stack, the <code>stack</code> class doesn&#8217;t even allow you to iterate through a stack. Instead, it limits you to the basic operations that define a stack. You can push a value onto the top of a stack, pop an element from the top of a stack, view the value at the top of a stack, check the number of elements, and test whether the stack is empty. <a href="#ch16table11">Table 16.11</a> lists these operations.</p>
<p class="caption"><a id="ch16table11"/><strong>Table 16.11. <code>stack</code> Operations</strong></p>
<p class="image"><img src="graphics/16tab11.jpg" alt="Image"/></p>
<p>Much as with <code>queue</code>, if you want to use a value from a stack, you first use <code>top()</code> to retrieve the value, and then you use <code>pop()</code> to remove it from the stack.</p>
<h6 id="ch16lev4sec10"><code>array</code> (C++11)</h6>
<p>The <code>array</code> template class, introduced in <a href="ch04.html#ch04">Chapter 4</a> and defined in the <code>array</code> header file, is not an STL container because it has a fixed size. Thus, operations that would resize a container, such as <code>push_back()</code> and <code>insert()</code>, are not defined for <code>array</code>. But those member functions that do make sense, such as <code>operator[]()</code> and <code>at()</code>, are provided. And you can use many standard STL algorithms, such as <code>copy()</code> and <code>for_each()</code>, with array objects.</p>
<h4 id="ch16lev2sec19">Associative Containers</h4>
<p>An <em>associative container</em> is another refinement of the container concept. An associative container associates a value with a key and uses the key to find the value. For example, the values could be structures representing employee information, such as name, address, office number, home and work phones, health plan, and so on, and the key could be a <a id="page_1019"/>unique employee number. To fetch the employee information, a program would use the key to locate the employee structure. Recall that for a container <code>X</code>, in general, the expression <code>X::value_type</code> indicates the type of value stored in the container. For an associative container, the expression <code>X::key_type</code> indicates the type used for the key.</p>
<p>The strength of an associative container is that it provides rapid access to its elements. Like a sequence, an associative container allows you to insert new elements; however, you can&#8217;t specify a particular location for the inserted elements. The reason is that an associative container usually has a particular algorithm for determining where to place data so that it can retrieve information quickly.</p>
<p>Associative containers typically are implemented using some form of tree. A <em>tree</em> is a data structure in which a root node is linked to one or two other nodes, each of which is linked to one or two nodes, thus forming a branching structure. The node aspect makes it relatively simple to add or remove a new data item, much as with a linked list. But compared to a list, a tree offers much faster search times.</p>
<p>The STL provides four associative containers: <code>set</code>, <code>multiset</code>, <code>map</code>, and <code>multimap</code>. The first two types are defined in the <code>set</code> header file (formerly separately in <code>set.h</code> and <code>multiset.h</code>), and the second two types are defined in the <code>map</code> header file (formerly separately in <code>map.h</code> and <code>multimap.h</code>).</p>
<p>The simplest of the bunch is <code>set</code>; the value type is the same as the key type, and the keys are unique, meaning there is no more than one instance of a key in a set. Indeed, for <code>set</code>, the value is the key. The <code>multiset</code> type is like the <code>set</code> type except that it can have more than one value with the same key. For example, if the key and value type are <code>int</code>, a <code>multiset</code> object could hold, say <code>1</code>, <code>2</code>, <code>2</code>, <code>2</code>, <code>3</code>, <code>5</code>, <code>7</code>, and <code>7</code>.</p>
<p>For the <code>map</code> type, the value type is different from the key type, and the keys are unique, with only one value per key. The <code>multimap</code> type is similar to <code>map</code>, except one key can be associated with multiple values.</p>
<p>There&#8217;s too much information about these types to cover in this chapter (but <a href="app07.html#app07">Appendix G</a> does list the methods), so let&#8217;s just look at a simple example that uses <code>set</code> and a simple example that uses <code>multimap</code>.</p>
<h5 id="ch16lev3sec15">A <code>set</code> Example</h5>
<p>The STL <code>set</code> models several concepts. It is an associative set, it is reversible, it is sorted, and the keys are unique, so it can hold no more than one of any given value. Like <code>vector</code> and <code>list</code>, <code>set</code> uses a template parameter to provide the type stored:</p>
<p class="programlisting">set&lt;string&gt; A;&#160;&#160;// a set of string objects</p>
<p>An optional second template argument can be used to indicate a comparison function or object to be used to order the key. By default, the <code>less&lt;&gt;</code> template (discussed later) is used. Older C++ implementations may not provide a default value and thus require an explicit template parameter:</p>
<p class="programlisting">set&lt;string, less&lt;string&gt; &gt; A;&#160;&#160;// older implementation</p>
<p><a id="page_1020"/>Consider the following code:</p>
<p class="programlisting">const int N = 6;<br/>string s1[N] = {"buffoon", "thinkers", "for", "heavy", "can", "for"};<br/>set&lt;string&gt; A(s1, s1 + N); // initialize set A using a range from array<br/>ostream_iterator&lt;string, char&gt; out(cout, " ");<br/>copy(A.begin(), A.end(), out);</p>
<p>Like other containers, <code>set</code> has a constructor (refer to <a href="#ch16table06">Table 16.6</a>) that takes a range of iterators as arguments. This provides a simple way to initialize a set to the contents of an array. Remember that the last element of a range is one past-the-end, and <code>s1 + N</code> points to one position past-the-end of array <code>s1</code>. The output for this code fragment illustrates that keys are unique (the string <code>"for"</code> appears twice in the array but once in the set) and that the set is sorted:</p>
<p class="programlisting">buffoon can for heavy thinkers</p>
<p>Mathematics defines some standard operations for sets. For example, the union of two sets is a set that combines the contents of the two sets. If a particular value is common to both sets, it appears just once in the union because of the unique key feature. The intersection of two sets is a set that consists of the elements that are common to both sets. The difference between two sets is the first set minus the elements common to both sets.</p>
<p>The STL provides algorithms that support these operations. They are general functions rather than methods, so they aren&#8217;t restricted to <code>set</code> objects. However, all <code>set</code> objects automatically satisfy the precondition for using these algorithms&#8212;namely, that the container be sorted. The <code>set_union()</code> function takes five iterators as arguments. The first two define a range in one set, the second two define a range in a second set, and the final iterator is an output iterator that identifies a location to which to copy the resultant set. For example, to display the union of sets <code>A</code> and <code>B</code>, you can use this:</p>
<p class="programlisting">set_union(A.begin(), A.end(), B.begin(), B.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ostream_iterator&lt;string, char&gt; out(cout, " "));</p>
<p>Suppose you want to place the result into a set <code>C</code> instead of displaying it. In this case, you would want the last argument to be an iterator into <code>C</code>. The obvious choice is <code>C.begin()</code>, but that doesn&#8217;t work for two reasons. The first reason is that associative sets treat keys as constant values, so the iterator returned by <code>C.begin()</code> is a constant iterator and can&#8217;t be used as an output iterator. The second reason not to use <code>C.begin()</code> directly is that <code>set_union()</code>, like <code>copy()</code>, overwrites existing data in a container and requires the container to have sufficient space to hold the new information. <code>C</code>, being empty, does not satisfy that requirement. But the <code>insert_iterator</code> template discussed earlier solves both problems. Earlier you saw that it converts copying to insertion. Also it models the output iterator concept, so you can use it to write to a container. So you can construct an anonymous <code>insert_iterator</code> to copy information to <code>C</code>. The constructor, recall, takes the name of the container and an iterator as arguments:</p>
<p class="programlisting">set_union(A.begin(), A.end(), B.begin(), B.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;insert_iterator&lt;set&lt;string&gt; &gt;(C, C.begin()));</p>
<p><a id="page_1021"/>The <code>set_intersection()</code> and <code>set_difference()</code> functions find the set intersection and set difference of two sets, and they have the same interface as <code>set_union()</code>.</p>
<p>Two useful <code>set</code> methods are <code>lower_bound()</code> and <code>upper_bound()</code>. The <code>lower_bound()</code> method takes a key-type value as its argument and returns an iterator that points to the first member of the set that is not less than the key argument. Similarly, the <code>upper_bound()</code> method takes a key as its argument and returns an iterator that points to the first member of the set that is greater than the key argument. For example, if you had a set of strings, you could use these methods to identify a range encompassing all strings from <code>"b"</code> up to <code>"f"</code> in the set.</p>
<p>Because sorting determines where additions to a set go, the class has insertion methods that just specify the material to be inserted, without specifying a position. If <code>A</code> and <code>B</code> are sets of strings, for example, you can use this:</p>
<p class="programlisting">string s("tennis");<br/>A.insert(s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// insert a value<br/>B.insert(A.begin(), A.end());&#160;&#160;&#160;// insert a range</p>
<p><a href="#ch16ex13">Listing 16.13</a> illustrates these uses of sets.</p>
<p class="caption1"><a id="ch16ex13"/><strong>Listing 16.13. <code>setops.cpp</code></strong></p><hr/>
<p class="programlisting1">// setops.cpp -- some set operations<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;set&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;iterator&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const int N = 6;<br/>&#160;&#160;&#160;&#160;string s1[N] = {"buffoon", "thinkers", "for", "heavy", "can", "for"};<br/>&#160;&#160;&#160;&#160;string s2[N] = {"metal", "any", "food", "elegant", "deliver","for"};<br/><br/>&#160;&#160;&#160;&#160;set&lt;string&gt; A(s1, s1 + N);<br/>&#160;&#160;&#160;&#160;set&lt;string&gt; B(s2, s2 + N);<br/><br/>&#160;&#160;&#160;&#160;ostream_iterator&lt;string, char&gt; out(cout, " ");<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set A: ";<br/>&#160;&#160;&#160;&#160;copy(A.begin(), A.end(), out);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set B: ";<br/>&#160;&#160;&#160;&#160;copy(B.begin(), B.end(), out);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Union of A and B:\n";<br/>&#160;&#160;&#160;&#160;set_union(A.begin(), A.end(), B.begin(), B.end(), out);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Intersection of A and B:\n";<br/>&#160;&#160;&#160;&#160;set_intersection(A.begin(), A.end(), B.begin(), B.end(), out);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Difference of A and B:\n";<br/>&#160;&#160;&#160;&#160;set_difference(A.begin(), A.end(), B.begin(), B.end(), out);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;set&lt;string&gt; C;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set C:\n";<br/>&#160;&#160;&#160;&#160;set_union(A.begin(), A.end(), B.begin(), B.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;insert_iterator&lt;set&lt;string&gt; &gt;(C, C.begin()));<br/>&#160;&#160;&#160;&#160;copy(C.begin(), C.end(), out);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;string s3("grungy");<br/>&#160;&#160;&#160;&#160;C.insert(s3);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set C after insertion:\n";<br/>&#160;&#160;&#160;&#160;copy(C.begin(), C.end(),out);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Showing a range:\n";<br/>&#160;&#160;&#160;&#160;copy(C.lower_bound("ghost"),C.upper_bound("spook"), out);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1022"/>Here is the output of the program in <a href="#ch16ex13">Listing 16.13</a>:</p>
<p class="programlisting">Set A: buffoon can for heavy thinkers<br/>Set B: any deliver elegant food for metal<br/>Union of A and B:<br/>any buffoon can deliver elegant food for heavy metal thinkers<br/>Intersection of A and B:<br/>for<br/>Difference of A and B:<br/>buffoon can heavy thinkers<br/>Set C:<br/>any buffoon can deliver elegant food for heavy metal thinkers<br/>Set C after insertion:<br/>any buffoon can deliver elegant food for grungy heavy metal thinkers<br/>Showing a range:<br/>grungy heavy metal</p>
<p><a id="page_1023"/>Like most of the examples in this chapter, the code in <a href="#ch16ex13">Listing 16.13</a> takes the lazy route for handling the <code>std</code> namespace:</p>
<p class="programlisting">using namespace std;</p>
<p>It does so in order to simplify the presentation. The examples use so many elements of the <code>std</code> namespace that using directives or the scope-resolution operators would tend to make the code look a bit fussy:</p>
<p class="programlisting">std::set&lt;std::string&gt; B(s2, s2 + N);<br/>std::ostream_iterator&lt;std::string, char&gt; out(std::cout, " ");<br/>std::cout &lt;&lt; "Set A: ";<br/>std::copy(A.begin(), A.end(), out);</p>
<h5 id="ch16lev3sec16">A <code>multimap</code> Example</h5>
<p>Like <code>set</code>, <code>multimap</code> is a reversible, sorted, associative container. However, with <code>multimap</code>, the key type is different from the value type, and a <code>multimap</code> object can have more than one value associated with a particular key.</p>
<p>The basic <code>multimap</code> declaration specifies the key type and the type of value, stored as template arguments. For example, the following declaration creates a <code>multimap</code> object that uses <code>int</code> as the key type and <code>string</code> as the type of value stored:</p>
<p class="programlisting">multimap&lt;int,string&gt; codes;</p>
<p>An optional third template argument can be used to indicate a comparison function or an object to be used to order the key. By default, the <code>less&lt;&gt;</code> template (discussed later) is used with the key type as its parameter. Older C++ implementations may require this template parameter explicitly.</p>
<p>To keep information together, the actual value type combines the key type and the data type into a single pair. To do this, the STL uses a <code>pair&lt;class T, class U&gt;</code> template class for storing two kinds of values in a single object. If <code>keytype</code> is the key type and <code>datatype</code> is the type of the stored data, the value type is <code>pair&lt;const keytype, datatype&gt;</code>. For example, the value type for the <code>codes</code> object declared earlier is <code>pair&lt;const int, string&gt;</code>.</p>
<p>Suppose that you want to store city names, using the area code as a key. This happens to fit the <code>codes</code> declaration, which uses an <code>int</code> for a key and a <code>string</code> as a data type. One approach is to create a pair and then insert it into the <code>multimap</code> object:</p>
<p class="programlisting">pair&lt;const int, string&gt; item(213, "Los Angeles");<br/>codes.insert(item);</p>
<p>Or you can create an anonymous <code>pair</code> object and insert it in a single statement:</p>
<p class="programlisting">codes.insert(pair&lt;const int, string&gt; (213, "Los Angeles"));</p>
<p>Because items are sorted by key, there&#8217;s no need to identify an insertion location.</p>
<p><a id="page_1024"/>Given a <code>pair</code> object, you can access the two components by using the <code>first</code> and <code>second</code> members:</p>
<p class="programlisting">pair&lt;const int, string&gt; item(213, "Los Angeles");<br/>cout &lt;&lt; item.first &lt;&lt; ' ' &lt;&lt; item.second &lt;&lt; endl;</p>
<p>What about getting information about a <code>multimap</code> object? The <code>count()</code> member function takes a key as its argument and returns the number of items that have that key. The <code>lower_bound()</code> and <code>upper_bound()</code> member functions take a key and work as they do for <code>set</code>. Also the <code>equal_range()</code> member function takes a key as its argument and returns iterators representing the range matching that key. In order to return two values, the method packages them into a <code>pair</code> object, this time with both template arguments being the iterator type. For example, the following would print a list of cities in the <code>codes</code> object with area code 718:</p>
<p class="programlisting">pair&lt;multimap&lt;KeyType, string&gt;::iterator,<br/>&#160;&#160;&#160;&#160;&#160;multimap&lt;KeyType, string&gt;::iterator&gt; range<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= codes.equal_range(718);<br/>cout &lt;&lt; "Cities with area code 718:\n";<br/>std::multimap&lt;KeyType, std::string&gt;::iterator it;<br/>for (it = range.first; it != range.second; ++it)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;&#160;&#160;(*it).second&#160;&#160;&#160;&#160;&lt;&lt; endl;</p>
<p>Declarations like those just listed helped motivate the C++11 automatic type deduction feature, which allows you to simplify the code as follows:</p>
<p class="programlisting">auto range = codes.equal_range(718);<br/>cout &lt;&lt; "Cities with area code 718:\n";<br/>for (auto it = range.first; it != range.second; ++it)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;&#160;&#160;(*it).second&#160;&#160;&#160;&#160;&lt;&lt; endl;</p>
<p><a href="#ch16ex14">Listing 16.14</a> demonstrates most of these techniques. It also uses <code>typedef</code> to simplify some of the code writing.</p>
<p class="caption1"><a id="ch16ex14"/><strong>Listing 16.14. <code>multmap.cpp</code></strong></p><hr/>
<p class="programlisting1">// multmap.cpp -- use a multimap<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;map&gt;<br/>#include &lt;algorithm&gt;<br/><br/>typedef int KeyType;<br/>typedef std::pair&lt;const KeyType, std::string&gt; Pair;<br/>typedef std::multimap&lt;KeyType, std::string&gt; MapCode;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;MapCode codes;<br/><br/>&#160;&#160;&#160;&#160;codes.insert(Pair(415, "San Francisco"));<br/>&#160;&#160;&#160;&#160;codes.insert(Pair(510, "Oakland"));<br/>&#160;&#160;&#160;&#160;codes.insert(Pair(718, "Brooklyn"));<br/>&#160;&#160;&#160;&#160;codes.insert(Pair(718, "Staten Island"));<br/>&#160;&#160;&#160;&#160;codes.insert(Pair(415, "San Rafael"));<br/>&#160;&#160;&#160;&#160;codes.insert(Pair(510, "Berkeley"));<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Number of cities with area code 415: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; codes.count(415) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Number of cities with area code 718: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; codes.count(718) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Number of cities with area code 510: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; codes.count(510) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Area Code&#160;&#160;&#160;City\n";<br/>&#160;&#160;&#160;&#160;MapCode::iterator it;<br/>&#160;&#160;&#160;&#160;for (it = codes.begin(); it != codes.end(); ++it)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;&#160;&#160;" &lt;&lt; (*it).first &lt;&lt; "&#160;&#160;&#160;&#160;&#160;"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; (*it).second&#160;&#160;&#160;&#160;&lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;pair&lt;MapCode::iterator, MapCode::iterator&gt; range<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= codes.equal_range(718);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Cities with area code 718:\n";<br/>&#160;&#160;&#160;&#160;for (it = range.first; it != range.second; ++it)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt;&#160;&#160;(*it).second&#160;&#160;&#160;&#160;&lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1025"/>Here is the output of the program in <a href="#ch16ex14">Listing 16.14</a>:</p>
<p class="programlisting">Number of cities with area code 415: 2<br/>Number of cities with area code 718: 2<br/>Number of cities with area code 510: 2<br/>Area Code&#160;&#160;&#160;City<br/>&#160;&#160;&#160;&#160;415&#160;&#160;&#160;&#160;&#160;San Francisco<br/>&#160;&#160;&#160;&#160;415&#160;&#160;&#160;&#160;&#160;San Rafael<br/>&#160;&#160;&#160;&#160;510&#160;&#160;&#160;&#160;&#160;Oakland<br/>&#160;&#160;&#160;&#160;510&#160;&#160;&#160;&#160;&#160;Berkeley<br/>&#160;&#160;&#160;&#160;718&#160;&#160;&#160;&#160;&#160;Brooklyn<br/>&#160;&#160;&#160;&#160;718&#160;&#160;&#160;&#160;&#160;Staten Island<br/>Cities with area code 718:<br/>Brooklyn<br/>Staten Island</p>
<h4 id="ch16lev2sec20">Unordered Associative Containers (C++11)</h4>
<p><a id="page_1026"/>An <em>unordered associative container</em> is yet another refinement of the container concept. Like an associative container, an unordered associative container associates a value with a key and uses the key to find the value. The underlying difference is that associative containers are based on tree structures, whereas unordered associative containers are based on another form of data structure called a <em>hash table</em>. The intent is to provide containers for which adding and deleting elements is relatively quick and for which there are efficient search algorithms. The four unordered associative containers are called <code>unordered_set</code>, <code>unordered_multiset</code>, <code>unordered_map</code>, and <code>unordered_multimap</code>. <a href="app07.html#app07">Appendix G</a> looks a bit further at these additions.</p>
<h3 id="ch16lev1sec5">Function Objects (a.k.a. Functors)</h3>
<p>Many STL algorithms use <em>function objects</em>, also known as <em>functors</em>. A <em>functor</em> is any object that can be used with <code>()</code> in the manner of a function. This includes normal function names, pointers to functions, and class objects for which the <code>()</code> operator is overloaded&#8212;that is, classes for which the peculiar-looking function <code>operator()()</code> is defined. For example, you could define a class like this:</p>
<p class="programlisting">class Linear<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double slope;<br/>&#160;&#160;&#160;&#160;double y0;<br/>public:<br/>&#160;&#160;&#160;&#160;Linear(double sl_ = 1, double y_ = 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: slope(sl_), y0(y_) {}<br/>&#160;&#160;&#160;&#160;double operator()(double x) {return y0 + slope * x; }<br/>};</p>
<p>The overloaded <code>()</code> operator then allows you to use <code>Linear</code> objects like functions:</p>
<p class="programlisting">Linear f1;<br/>Linear f2(2.5, 10.0);<br/>double y1 = f1(12.5);&#160;&#160;&#160;// right-hand side is f1.operator()(12.5)<br/>double y2 = f2(0.4);</p>
<p>Here <code>y1</code> is calculated using the expression <code>0 + 1 * 12.5</code>, and <code>y2</code> is calculated using the expression <code>10.0 + 2.5 * 0.4</code>. In the expression <code>y0 + slope * x</code>, the values for <code>y0</code> and <code>slope</code> come from the constructor for the object, and the value of <code>x</code> comes from the argument to <code>operator()()</code>.</p>
<p>Remember the <code>for_each</code> function? It applied a specified function to each member of a range:</p>
<p class="programlisting">for_each(books.begin(), books.end(), ShowReview);</p>
<p><a id="page_1027"/>In general, the third argument could be a functor, not just a regular function. Actually, this raises a question: How do you declare the third argument? You can&#8217;t declare it as a function pointer because a function pointer specifies the argument type. Because a container can contain just about any type, you don&#8217;t know in advance what particular argument type should be used. The STL solves that problem by using templates. The <code>for_each</code> prototype looks like this:</p>
<p class="programlistingB">template&lt;class InputIterator, class Function&gt;<br/>Function for_each(InputIterator first, InputIterator last, Function f);</p>
<p>The <code>ShowReview()</code> prototype is this:</p>
<p class="programlisting">void ShowReview(const Review &#38;);</p>
<p>This makes the identifier <code>ShowReview</code> have the type <code>void (*)(const Review &#38;)</code>, so that is the type assigned to the template argument <code>Function</code>. With a different function call, the <code>Function</code> argument could represent a class type that has an overloaded <code>()</code> operator. Ultimately, the <code>for_each()</code> code will have an expression using <code>f()</code>. In the <code>ShowReview()</code> example, <code>f</code> is a pointer to a function, and <code>f()</code> invokes the function. If the final <code>for_each()</code> argument is an object, then <code>f()</code> becomes the object that invokes its overloaded <code>()</code> operator.</p>
<h4 id="ch16lev2sec21">Functor Concepts</h4>
<p>Just as the STL defines concepts for containers and iterators, it defines functor concepts:</p>
<p class="indenthandingB">&#8226; A <em>generator</em> is a functor that can be called with no arguments.</p>
<p class="indenthandingB">&#8226; A <em>unary function</em> is a functor that can be called with one argument.</p>
<p class="indenthandingB">&#8226; A <em>binary function</em> is a functor that can be called with two arguments.</p>
<p>For example, the functor supplied to <code>for_each()</code> should be a unary function because it is applied to one container element at a time.</p>
<p>Of course, these concepts come with refinements:</p>
<p class="indenthandingB">&#8226; A unary function that returns a <code>bool</code> value is a <em>predicate</em>.</p>
<p class="indenthandingB">&#8226; A binary function that returns a <code>bool</code> value is a <em>binary predicate</em>.</p>
<p>Several STL functions require predicate or binary predicate arguments. For example, <a href="ch16.html#ch16ex09">Listing 16.9</a> uses a version of <code>sort()</code> that takes a binary predicate as its third argument:</p>
<p class="programlisting">bool WorseThan(const Review &#38; r1, const Review &#38; r2);<br/>...<br/>sort(books.begin(), books.end(), WorseThan);</p>
<p>The <code>list</code> template has a <code>remove_if()</code> member that takes a predicate as an argument. It applies the predicate to each member in the indicated range, removing those elements for which the predicate returns <code>true</code>. For example, the following code would remove all elements greater than 100 from the list <code>three</code>:</p>
<p class="programlisting"><a id="page_1028"/>bool tooBig(int n){ return n &gt; 100; }<br/>list&lt;int&gt; scores;<br/>...<br/>scores.remove_if(tooBig);</p>
<p>Incidentally, this last example shows where a class functor might be useful. Suppose you want to remove every value greater than 200 from a second list. It would be nice if you could pass the cut-off value to <code>tooBig()</code> as a second argument so you could use the function with different values, but a predicate can have but one argument. If, however, you design a <code>TooBig</code> class, you can use class members instead of function arguments to convey additional information:</p>
<p class="programlisting">template&lt;class T&gt;<br/>class TooBig<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;T cutoff;<br/>public:<br/>&#160;&#160;&#160;&#160;TooBig(const T &#38; t) : cutoff(t) {}<br/>&#160;&#160;&#160;&#160;bool operator()(const T &#38; v) { return v &gt; cutoff; }<br/>};</p>
<p>Here one value (<code>v</code>) is passed as a function argument, and the second argument (<code>cutoff</code>) is set by the class constructor. Given this definition, you can initialize different <code>TooBig</code> objects to different cut-off values to be used in calls to <code>remove_if()</code>. <a href="#ch16ex15">Listing 16.15</a> illustrates the technique.</p>
<p class="caption1"><a id="ch16ex15"/><strong>Listing 16.15. <code>functor.cpp</code></strong></p><hr/>
<p class="programlisting1">// functor.cpp -- using a functor<br/>#include &lt;iostream&gt;<br/>#include &lt;list&gt;<br/>#include &lt;iterator&gt;<br/>#include &lt;algorithm&gt;<br/><br/>template&lt;class T&gt;&#160;&#160;// functor class defines operator()()<br/>class TooBig<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;T cutoff;<br/>public:<br/>&#160;&#160;&#160;&#160;TooBig(const T &#38; t) : cutoff(t) {}<br/>&#160;&#160;&#160;&#160;bool operator()(const T &#38; v) { return v &gt; cutoff; }<br/>};<br/><br/>void outint(int n) {std::cout &lt;&lt; n &lt;&lt; " ";}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::list;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;TooBig&lt;int&gt; f100(100); // limit = 100<br/>&#160;&#160;&#160;&#160;int vals[10] = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};<br/>&#160;&#160;&#160;&#160;list&lt;int&gt; yadayada(vals, vals + 10); // range constructor<br/>&#160;&#160;&#160;&#160;list&lt;int&gt; etcetera(vals, vals + 10);<br/>&#160;// C++11 can use the following instead<br/>//&#160;&#160;list&lt;int&gt; yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};<br/>//&#160;&#160;list&lt;int&gt; etcetera {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Original lists:\n";<br/>&#160;&#160;&#160;&#160;for_each(yadayada.begin(), yadayada.end(), outint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;for_each(etcetera.begin(), etcetera.end(), outint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;yadayada.remove_if(f100);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use a named function object<br/>&#160;&#160;&#160;&#160;etcetera.remove_if(TooBig&lt;int&gt;(200));&#160;&#160;&#160;// construct a function object<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;"Trimmed lists:\n";<br/>&#160;&#160;&#160;&#160;for_each(yadayada.begin(), yadayada.end(), outint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;for_each(etcetera.begin(), etcetera.end(), outint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1029"/>One functor (<code>f100</code>) is a declared object, and the second (<code>TooBig&lt;int&gt;(200)</code>) is an anonymous object created by a constructor call. Here&#8217;s the output of the program in <a href="#ch16ex15">Listing 16.15</a>:</p>
<p class="programlisting">Original lists:<br/>50 100 90 180 60 210 415 88 188 201<br/>50 100 90 180 60 210 415 88 188 201<br/>Trimmed lists:<br/>50 100 90 60 88<br/>50 100 90 180 60 88 188</p>
<p>Suppose that you already have a template function with two arguments:</p>
<p class="programlisting">template &lt;class T&gt;<br/>bool tooBig(const T &#38; val, const T &#38; lim)<br/>{<br/>&#160;&#160;&#160;&#160;return val &gt; lim;<br/>}</p>
<p><a id="page_1030"/>You can use a class to convert it to a one-argument function object:</p>
<p class="programlisting">template&lt;class T&gt;<br/>class TooBig2<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;T cutoff;<br/>public:<br/>&#160;&#160;&#160;&#160;TooBig2(const T &#38; t) : cutoff(t) {}<br/>&#160;&#160;&#160;&#160;bool operator()(const T &#38; v) { return tooBig&lt;T&gt;(v, cutoff); }<br/>};</p>
<p>That is, you can use the following:</p>
<p class="programlisting">TooBig2&lt;int&gt; tB100(100);<br/>int x;<br/>cin &gt;&gt; x;<br/>if (tB100(x))&#160;&#160;&#160;// same as if (tooBig(x,100))<br/>&#160;&#160;&#160;&#160;...</p>
<p>So the call <code>tB100(x)</code> is the same as <code>tooBig(x,100)</code>, but the two-argument function is converted to a one-argument function object, with the second argument being used to construct the function object. In short, the class functor <code>TooBig2</code> is a function adapter that adapts a function to meet a different interface.</p>
<p>As noted in the listing, C++11&#8217;s initializer-list feature simplifies initialization. You can replace</p>
<p class="programlisting">int vals[10] = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};<br/>list&lt;int&gt; yadayada(vals, vals + 10); // range constructor<br/>list&lt;int&gt; etcetera(vals, vals + 10);</p>
<p>with this:</p>
<p class="programlisting">list&lt;int&gt; yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};<br/>list&lt;int&gt; etcetera {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};</p>
<h4 id="ch16lev2sec22">Predefined Functors</h4>
<p>The STL defines several elementary functors. They perform actions such as adding two values and comparing two values for equality. They are provided to help support STL functions that take functions as arguments. For example, consider the <code>transform()</code> function. It has two versions. The first version takes four arguments. The first two arguments are iterators that specify a range in a container. (By now you must be familiar with that approach.) The third is an iterator that specifies where to copy the result. The final is a functor that is applied to each element in the range to produce each new element in the result. For example, consider the following:</p>
<p class="programlisting">const int LIM = 5;<br/>double arr1[LIM] = {36, 39, 42, 45, 48};<br/><a id="page_1031"/>vector&lt;double&gt; gr8(arr1, arr1 + LIM);<br/>ostream_iterator&lt;double, char&gt; out(cout, " ");<br/>transform(gr8.begin(), gr8.end(), out, sqrt);</p>
<p>This code calculates the square root of each element and sends the resulting values to the output stream. The destination iterator can be in the original range. For example, replacing <code>out</code> in this example with <code>gr8.begin()</code> would copy the new values over the old values. Clearly, the functor used must be one that works with a single argument.</p>
<p>The second version uses a function that takes two arguments, applying the function to one element from each of two ranges. It takes an additional argument, which comes third in order, identifying the start of the second range. For example, if <code>m8</code> were a second <code>vector&lt;double&gt;</code> object and if <code>mean(double, double)</code> returned the mean of two values, the following would output the average of each pair of values from <code>gr8</code> and <code>m8</code>:</p>
<p class="programlisting">transform(gr8.begin(), gr8.end(), m8.begin(), out, mean);</p>
<p>Now suppose you want to add the two arrays. You can&#8217;t use <code>+</code> as an argument because, for type <code>double</code>, <code>+</code> is a built-in operator, not a function. You could define a function to add two numbers and use it:</p>
<p class="programlisting">double add(double x, double y) { return x + y; }<br/>...<br/>transform(gr8.begin(), gr8.end(), m8.begin(), out, add);</p>
<p>But then you&#8217;d have to define a separate function for each type. It would be better to define a template, except that you don&#8217;t have to because the STL already has. The <code>functional</code> (formerly <code>function.h</code>) header defines several template class function objects, including one called <code>plus&lt;&gt;()</code>.</p>
<p>Using the <code>plus&lt;&gt;</code> class for ordinary addition is possible, if awkward:</p>
<p class="programlisting">#include &lt;functional&gt;<br/>...<br/>plus&lt;double&gt; add;&#160;&#160;// create a plus&lt;double&gt; object<br/>double y = add(2.2, 3.4); // using plus&lt;double&gt;::operator()()</p>
<p>But it makes it easy to provide a function object as an argument:</p>
<p class="programlisting">transform(gr8.begin(), gr8.end(), m8.begin(), out, plus&lt;double&gt;() );</p>
<p>Here, rather than create a named object, the code uses the <code>plus&lt;double&gt;</code> constructor to construct a functor to do the adding. (The parentheses indicate calling the default constructor; what&#8217;s passed to <code>transform()</code> is the constructed function object.)</p>
<p>The STL provides functor equivalents for all the built-in arithmetic, relational, and logical operators. <a href="#ch16table12">Table 16.12</a> shows the names for these functor equivalents. They can be used with the C++ built-in types or with any user-defined type that overloads the corresponding operator.</p>
<p class="caption"><a id="page_1032"/><a id="ch16table12"/><strong>Table 16.12. Operators and Functor Equivalents</strong></p>
<p class="image"><img src="graphics/16tab12.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch16note05"/>Caution</p>
<p class="notepara">Older C++ implementations use the functor name <code>times</code> instead of <code>multiplies</code>.</p>
<hr/></div>
<h4 id="ch16lev2sec23">Adaptable Functors and Function Adapters</h4>
<p>The predefined functors in <a href="#ch16table12">Table 16.12</a> are all <em>adaptable</em>. Actually, the STL has five related concepts: adaptable generators, adaptable unary functions, adaptable binary functions, adaptable predicates, and adaptable binary predicates.</p>
<p>What makes a functor adaptable is that it carries <code>typedef</code> members identifying its argument types and return type. The members are called <code>result_type</code>, <code>first_argument_type</code>, and <code>second_argument_type</code>, and they represent what they sound like. For example, the return type of a <code>plus&lt;int&gt;</code> object is identified as <code>plus&lt;int&gt;::result_type</code>, and this would be a <code>typedef</code> for <code>int</code>.</p>
<p>The significance of a functor being adaptable is that it can then be used by function adapter objects, which assume the existence of these <code>typedef</code> members. For example, a function with an argument that is an adaptable functor can use the <code>result_type</code> member to declare a variable that matches the function&#8217;s return type.</p>
<p><a id="page_1033"/>Indeed, the STL provides function adapter classes that use these facilities. For example, suppose you want to multiply each element of the vector <code>gr8</code> by 2.5. That calls for using the <code>transform()</code> version with a unary function argument, like the example shown earlier:</p>
<p class="programlisting">transform(gr8.begin(), gr8.end(), out, sqrt);</p>
<p>The <code>multiplies()</code> functor can do the multiplication, but it&#8217;s a binary function. So you need a function adapter that converts a functor that has two arguments to one that has one argument. The earlier <code>TooBig2</code> example shows one way, but the STL has automated the process with the <code>binder1st</code> and <code>binder2nd</code> classes, which convert adaptable binary functions to adaptable unary functions.</p>
<p>Let&#8217;s look at <code>binder1st</code>. Suppose you have an adaptable binary function object <code>f2()</code>. You can create a <code>binder1st</code> object that binds a particular value, called <code>val</code>, to be used as the first argument to <code>f2()</code>:</p>
<p class="programlisting">binder1st(f2, val) f1;</p>
<p>Then, invoking <code>f1(x)</code> with its single argument returns the same value as invoking <code>f2()</code> with <code>val</code> as its first argument and <code>f1()</code>&#8217;s argument as its second argument. That is, <code>f1(x)</code> is equivalent to <code>f2(val, x)</code>, except that it is a unary function instead of a binary function. The <code>f2()</code> function has been adapted. Again, this is possible only if <code>f2()</code> is an adaptable function.</p>
<p>This might seem a bit awkward. However, the STL provides the <code>bind1st()</code> function to simplify using the <code>binder1st</code> class. You give it the function name and value used to construct a <code>binder1st</code> object, and it returns an object of that type. For example, you can convert the binary function <code>multiplies()</code> to a unary function that multiplies its argument by 2.5. Just do this:</p>
<p class="programlisting">bind1st(multiplies&lt;double&gt;(), 2.5)</p>
<p>Thus, the solution to multiplying every element in <code>gr8</code> by 2.5 and displaying the results is this:</p>
<p class="programlisting">transform(gr8.begin(), gr8.end(), out,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bind1st(multiplies&lt;double&gt;(), 2.5));</p>
<p>The <code>binder2nd</code> class is similar, except that it assigns the constant to the second argument instead of to the first. It has a helper function called <code>bind2nd</code> that works analogously to <code>bind1st</code>.</p>
<p><a id="page_1034"/><a href="#ch16ex16">Listing 16.16</a> incorporates some of the recent examples into a short program.</p>
<p class="caption1"><a id="ch16ex16"/><strong>Listing 16.16. <code>funadap.cpp</code></strong></p><hr/>
<p class="programlisting1">// funadap.cpp -- using function adapters<br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;iterator&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;functional&gt;<br/><br/>void Show(double);<br/>const int LIM = 6;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double arr1[LIM] = {28, 29, 30, 35, 38, 59};<br/>&#160;&#160;&#160;&#160;double arr2[LIM] = {63, 65, 69, 75, 80, 99};<br/>&#160;&#160;&#160;&#160;vector&lt;double&gt; gr8(arr1, arr1 + LIM);<br/>&#160;&#160;&#160;&#160;vector&lt;double&gt; m8(arr2, arr2 + LIM);<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed);<br/>&#160;&#160;&#160;&#160;cout.precision(1);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "gr8:\t";<br/>&#160;&#160;&#160;&#160;for_each(gr8.begin(), gr8.end(), Show);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "m8: \t";<br/>&#160;&#160;&#160;&#160;for_each(m8.begin(), m8.end(), Show);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;vector&lt;double&gt; sum(LIM);<br/>&#160;&#160;&#160;&#160;transform(gr8.begin(), gr8.end(), m8.begin(), sum.begin(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;plus&lt;double&gt;());<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "sum:\t";<br/>&#160;&#160;&#160;&#160;for_each(sum.begin(), sum.end(), Show);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;vector&lt;double&gt; prod(LIM);<br/>&#160;&#160;&#160;&#160;transform(gr8.begin(), gr8.end(), prod.begin(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bind1st(multiplies&lt;double&gt;(), 2.5));<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "prod:\t";<br/>&#160;&#160;&#160;&#160;for_each(prod.begin(), prod.end(), Show);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void Show(double v)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout.width(6);<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; v &lt;&lt; ' ';<br/>}</p><hr/>
<p><a id="page_1035"/>Here is the output of the program in <a href="#ch16ex16">Listing 16.16</a>:</p>
<p class="programlisting">gr8:&#160;&#160;&#160;&#160;&#160;&#160;28.0&#160;&#160;&#160;29.0&#160;&#160;&#160;30.0&#160;&#160;&#160;35.0&#160;&#160;&#160;38.0&#160;&#160;&#160;59.0<br/>m8:&#160;&#160;&#160;&#160;&#160;&#160;&#160;63.0&#160;&#160;&#160;65.0&#160;&#160;&#160;69.0&#160;&#160;&#160;75.0&#160;&#160;&#160;80.0&#160;&#160;&#160;99.0<br/>sum:&#160;&#160;&#160;&#160;&#160;&#160;91.0&#160;&#160;&#160;94.0&#160;&#160;&#160;99.0&#160;&#160;110.0&#160;&#160;118.0&#160;&#160;158.0<br/>prod:&#160;&#160;&#160;&#160;&#160;70.0&#160;&#160;&#160;72.5&#160;&#160;&#160;75.0&#160;&#160;&#160;87.5&#160;&#160;&#160;95.0&#160;&#160;147.5</p>
<p>C++11 provides an alternative to function pointers and functors. It&#8217;s called a <em>lambda expression</em>, another topic discussed in <a href="ch18.html#ch18">Chapter 18</a>.</p>
<h3 id="ch16lev1sec6">Algorithms</h3>
<p>The STL contains many nonmember functions for working with containers. You&#8217;ve seen a few of them already: <code>sort()</code>, <code>copy()</code>, <code>find()</code>, <code>for_each()</code>, <code>random_shuffle()</code>, <code>set_union()</code>, <code>set_intersection()</code>, <code>set_difference()</code>, and <code>transform()</code>. You&#8217;ve probably noticed that they feature the same overall design, using iterators to identify data ranges to be processed and to identify where results are to go. Some also take a function object argument to be used as part of the data processing.</p>
<p>There are two main generic components to the algorithm function designs. First, they use templates to provide generic types. Second, they use iterators to provide a generic representation for accessing data in a container. Thus, the <code>copy()</code> function can work with a container that holds type <code>double</code> values in an array, with a container that holds <code>string</code> values in a linked list, or with a container that stores user-defined objects in a tree structure, such as is used by <code>set</code>. Because pointers are a special case of iterators, STL functions such as <code>copy()</code> can be used with ordinary arrays.</p>
<p>The uniform container design allows meaningful relationships between containers of different kinds. For example, you can use <code>copy()</code> to copy values from an ordinary array to a <code>vector</code> object, from a <code>vector</code> object to a <code>list</code> object, and from a <code>list</code> object to a <code>set</code> object. You can use <code>==</code> to compare different kinds of containers&#8212;for example, <code>deque</code> and <code>vector</code>. This is possible because the overloaded <code>==</code> operator for containers uses iterators to compare contents, so a <code>deque</code> object and a <code>vector</code> object test as equal if they have the same content in the same order.</p>
<h4 id="ch16lev2sec24">Algorithm Groups</h4>
<p>The STL divides the algorithm library into four groups:</p>
<p class="indenthandingB">&#8226; Nonmodifying sequence operations</p>
<p class="indenthandingB">&#8226; Mutating sequence operations</p>
<p class="indenthandingB">&#8226; <a id="page_1036"/>Sorting and related operations</p>
<p class="indenthandingB">&#8226; Generalized numeric operations</p>
<p>The first three groups are described in the <code>algorithm</code> (formerly <code>algo.h</code>) header file, and the fourth group, being specifically oriented toward numeric data, gets its own header file, called <code>numeric</code>. (Formerly, they, too, were in <code>algo.h</code>.)</p>
<p>Nonmodifying sequence operations operate on each element in a range. These operations leave a container unchanged. For example, <code>find()</code> and <code>for_each()</code> belong to this category.</p>
<p>Mutating sequence operations also operate on each element in a range. As the name suggests, however, they can mutate, or change, the contents of a container. The change could be in values or in the order in which the values are stored. The <code>transform()</code>, <code>random_shuffle()</code>, and <code>copy()</code> functions fall into this category.</p>
<p>Sorting and related operations include several sorting functions (including <code>sort()</code>) and a variety of other functions, including the set operations.</p>
<p>The numeric operations include functions to sum the contents of a range, calculate the inner product of two containers, calculate partial sums, and calculate adjacent differences. Typically, these are operations that are characteristic of arrays, so <code>vector</code> is the container most likely to be used with them.</p>
<p><a href="app07.html#app07">Appendix G</a> provides a complete summary of these functions.</p>
<h4 id="ch16lev2sec25">General Properties of Algorithms</h4>
<p>As you&#8217;ve seen again and again in this chapter, STL functions work with iterators and iterator ranges. The function prototype indicates the assumptions made about the iterators. For example, the <code>copy()</code> function has this prototype:</p>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator&gt;<br/>OutputIterator copy(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);</p>
<p>Because the identifiers <code>InputIterator</code> and <code>OutputIterator</code> are template parameters, they just as easily could have been <code>T</code> and <code>U</code>. However, the STL documentation uses the template parameter names to indicate the concept that the parameter models. So this declaration tells you that the range parameters must be input iterators or better and that the iterator indicating where the result goes must be an output parameter or better.</p>
<p>One way of classifying algorithms is on the basis of where the result of the algorithm is placed. Some algorithms do their work in place, and others create copies. For example, when the <code>sort()</code> function is finished, the result occupies the same location that the original data did. So <code>sort()</code> is an <em>in-place algorithm</em>. The <code>copy()</code> function, however, sends the result of its work to another location, so it is a <em>copying algorithm</em>. The <code>transform()</code> function can do both. Like <code>copy()</code>, it uses an output iterator to indicate where the results go. Unlike <code>copy()</code>, <code>transform()</code> allows the output iterator to point to a location in the input range, so it can copy the transformed values over the original values.</p>
<p><a id="page_1037"/>Some algorithms come in two versions: an in-place version and a copying version. The STL convention is to append <code>_copy</code> to the name of the copying version. The latter version takes an additional output iterator parameter to specify the location to which to copy the outcome. For example, there is a <code>replace()</code> function that has this prototype:</p>
<p class="programlisting">template&lt;class ForwardIterator, class T&gt;<br/>void replace(ForwardIterator <span class="EmpItalic">first</span>, ForwardIterator <span class="EmpItalic">last</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; <span class="EmpItalic">old_value</span>, const T&#38; <span class="EmpItalic">new_value</span>);</p>
<p>It replaces each instance of <code>old_value</code> with <code>new_value</code>. This occurs in place. Because this algorithm both reads from and writes to container elements, the iterator type has to be <code>ForwardIterator</code> or better. The copying version has this prototype:</p>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator, class T&gt;<br/>OutputIterator replace_copy(InputIterator <span class="EmpItalic">first</span>, InputIterator <span class="EmpItalic">last</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator <span class="EmpItalic">result</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; <span class="EmpItalic">old_value</span>, const T&#38; <span class="EmpItalic">new_value</span>);</p>
<p>This time the resulting data is copied to a new location, given by <code>result</code>, so the read-only input iterator is sufficient for specifying the range.</p>
<p>Note that <code>replace_copy()</code> has an <code>OutputIterator</code> return type. The convention for copying algorithms is that they return an iterator pointing to the location one past the last value copied.</p>
<p>Another common variation is that some functions have a version that performs an action conditionally, depending on the result of applying a function to a container element. These versions typically append <code>_if</code> to the function name. For example, <code>replace_if()</code> replaces an old value with a new value if applying a function to the old value returns the value <code>true</code>. Here&#8217;s the prototype:</p>
<p class="programlisting">template&lt;class ForwardIterator, class Predicate class T&gt;<br/>void replace_if(ForwardIterator <span class="EmpItalic">first</span>, ForwardIterator <span class="EmpItalic">last</span>,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate <span class="EmpItalic">pred</span>, const T&#38; <span class="EmpItalic">new_value</span>);</p>
<p>(Recall that a predicate is a unary function that returns a <code>bool</code> value.) There&#8217;s also a version called <code>replace_copy_if()</code>. You can probably figure out what it does and what its prototype is like.</p>
<p>As with <code>InputIterator</code>, <code>Predicate</code> is a template parameter name and could just as easily be called <code>T</code> or <code>U</code>. However, the STL chooses to use <code>Predicate</code> to remind the user that the actual argument should be a model of the <code>Predicate</code> concept. Similarly, the STL uses terms such as <code>Generator</code> and <code>BinaryPredicate</code> to identify arguments that should model other function object concepts. Keep in mind that although the documentation can remind you what the iterator or functor requirements are, these names are not something the compiler can check. If you use the wrong sort of iterator, you can expect to see a long list of error messages as the compiler tries to instantiate the template.</p>
<h4 id="ch16lev2sec26">The STL and the <code>string</code> Class</h4>
<p><a id="page_1038"/>The <code>string</code> class, although not part of the STL, is designed with the STL in mind. For example, it has <code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, and <code>rend()</code> members. Thus, it can use the STL interface. <a href="#ch16ex17">Listing 16.17</a> uses the STL to show all the permutations you can form from the letters in a word. A <em>permutation</em> is a rearrangement of the order of the elements in a container. The <code>next_permutation()</code> algorithm transforms the contents of a range to the next permutation; in the case of a string, the permutations are arranged in ascending alphabetical order. The algorithm returns <code>true</code> if it succeeds and <code>false</code> if the range already is in the final sequence. To get all the permutations of a range, you should start with the elements in the earliest possible order, and the program uses the STL <code>sort()</code> algorithm for that purpose.</p>
<p class="caption1"><a id="ch16ex17"/><strong>Listing 16.17. <code>strgstl.cpp</code></strong></p><hr/>
<p class="programlisting1">// strgstl.cpp -- applying the STL to a string<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;algorithm&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;string letters;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the letter grouping (quit to quit): ";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; letters &#38;&#38; letters != "quit")<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Permutations of " &lt;&lt; letters &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sort(letters.begin(), letters.end());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; letters &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (next_permutation(letters.begin(), letters.end()))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; letters &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter next sequence (quit to quit): ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s a sample run of the program in <a href="#ch16ex17">Listing 16.17</a>:</p>
<p class="programlisting">Enter the letter grouping (quit to quit): <span class="EmpStrong">awl</span><br/>Permutations of awl<br/>alw<br/>awl<br/>law<br/>lwa<br/>wal<br/><a id="page_1039"/>wla<br/>Enter next sequence (quit to quit): <span class="EmpStrong">all</span><br/>Permutations of all<br/>all<br/>lal<br/>lla<br/>Enter next sequence (quit to quit): <span class="EmpStrong">quit</span><br/>Done.</p>
<p>Note that the <code>next_permutation()</code> algorithm automatically provides only unique permutations, which is why the output shows more permutations for the word <em>awl</em> than for the word <em>all</em>, which has duplicate letters.</p>
<h4 id="ch16lev2sec27">Functions Versus Container Methods</h4>
<p>Sometimes you have a choice between using an STL method and an STL function. Usually, the method is the better choice. First, it should be better optimized for a particular container. Second, being a member function, it can use a template class&#8217;s memory management facilities and resize a container when needed.</p>
<p>Suppose, for example, that you have a list of numbers and you want to remove all instances of a certain value, say <code>4</code>, from the list. If <code>la</code> is a <code>list&lt;int&gt;</code> object, you can use the list <code>remove()</code> method:</p>
<p class="programlisting">la.remove(4);&#160;&#160;// remove all 4s from the list</p>
<p>After this method call, all elements with the value <code>4</code> are removed from the list, and the list is automatically resized.</p>
<p>There is also an STL algorithm called <code>remove()</code> (see <a href="app07.html#app07">Appendix G</a>). Instead of being invoked by an object, it takes range arguments. So if <code>lb</code> is a <code>list&lt;int&gt;</code> object, a call to the function could look like this:</p>
<p class="programlisting">remove(lb.begin(), lb.end(), 4);</p>
<p>However, because this <code>remove()</code> is not a member, it can&#8217;t adjust the size of the list. Instead, it makes sure all the nonremoved items are at the beginning of the list, and it returns an iterator to the new past-the-end value. You can then use this iterator to fix the list size. For example, you can use the list <code>erase()</code> method to remove a range that describes the part of the list that is no longer needed. <a href="#ch16ex18">Listing 16.18</a> shows how this process works.</p>
<p class="caption1"><a id="ch16ex18"/><strong>Listing 16.18. <code>listrmv.cpp</code></strong></p><hr/>
<p class="programlisting1">// listrmv.cpp -- applying the STL to a string<br/>#include &lt;iostream&gt;<br/>#include &lt;list&gt;<br/>#include &lt;algorithm&gt;<br/><br/>void Show(int);<br/>const int LIM = 10;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int ar[LIM] = {4, 5, 4, 2, 2, 3, 4, 8, 1, 4};<br/>&#160;&#160;&#160;&#160;list&lt;int&gt; la(ar, ar + LIM);<br/>&#160;&#160;&#160;&#160;list&lt;int&gt; lb(la);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Original list contents:\n\t";<br/>&#160;&#160;&#160;&#160;for_each(la.begin(), la.end(), Show);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;la.remove(4);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After using the remove() method:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "la:\t";<br/>&#160;&#160;&#160;&#160;for_each(la.begin(), la.end(), Show);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;list&lt;int&gt;::iterator last;<br/>&#160;&#160;&#160;&#160;last = remove(lb.begin(), lb.end(), 4);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After using the remove() function:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "lb:\t";<br/>&#160;&#160;&#160;&#160;for_each(lb.begin(), lb.end(), Show);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;lb.erase(last, lb.end());<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After using the erase() method:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "lb:\t";<br/>&#160;&#160;&#160;&#160;for_each(lb.begin(), lb.end(), Show);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void Show(int v)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; v &lt;&lt; ' ';<br/>}</p><hr/>
<p><a id="page_1040"/>Here&#8217;s the output of the program in <a href="#ch16ex18">Listing 16.18</a>:</p>
<p class="programlisting">Original list contents:<br/>&#160;&#160;&#160;&#160;4 5 4 2 2 3 4 8 1 4<br/>After using the remove() method:<br/>la: 5 2 2 3 8 1<br/>After using the remove() function:<br/>lb: 5 2 2 3 8 1 4 8 1 4<br/>After using the erase() method:<br/>lb: 5 2 2 3 8 1</p>
<p><a id="page_1041"/>As you can see, the <code>remove()</code> method reduces the list <code>la</code> from 10 elements to 6 elements. However, list <code>lb</code> still contains 10 elements after the <code>remove()</code> function is applied to it. The last 4 elements are disposable because each is either the value <code>4</code> or a duplicate of a value moved farther to the front of the list.</p>
<p>Although the methods are usually better suited, the nonmethod functions are more general. As you&#8217;ve seen, you can use them on arrays and <code>string</code> objects as well as STL containers, and you can use them with mixed container types&#8212;for example, to save data from a vector container to a list or a set.</p>
<h4 id="ch16lev2sec28">Using the STL</h4>
<p>The STL is a library whose parts are designed to work together. The STL components are tools, but they are also building blocks to create other tools. Let&#8217;s illustrate this with an example. Suppose you want to write a program that lets the user enter words. At the end, you&#8217;d like a record of the words as they were entered, an alphabetical list of the words used (capitalization differences ignored), and a record of how many times each word was entered. To keep things simple, let&#8217;s assume that the input contains no numbers or punctuation.</p>
<p>Entering and saving the list of words is simple enough. Following the example of <a href="ch16.html#ch16ex08">Listings 16.8</a> and <a href="ch16.html#ch16ex09">16.9</a>, you can create a <code>vector&lt;string&gt;</code> object and use <code>push_back()</code> to add input words to the vector:</p>
<p class="programlisting">vector&lt;string&gt; words;<br/>string input;<br/>while (cin &gt;&gt; input &#38;&#38; input != "quit")<br/>&#160;&#160;&#160;&#160;words.push_back(input);</p>
<p>What about getting the alphabetic word list? You can use <code>sort()</code> followed by <code>unique()</code>, but that approach overwrites the original data because <code>sort()</code> is an in-place algorithm. There is an easier way that avoids this problem. You can create a <code>set&lt;string&gt;</code> object and copy (using an insert iterator) the words from the vector to the set. A set automatically sorts its contents, which means you don&#8217;t have to call <code>sort()</code>, and a set allows only one copy of a key, so that takes the place of calling <code>unique()</code>. Wait! The specification called for ignoring the case differences. One way to handle that is to use <code>transform()</code> instead of <code>copy()</code> to copy data from the vector to the set. For the transformation function, you can use one that converts a string to lowercase:</p>
<p class="programlisting">set&lt;string&gt; wordset;<br/>transform(words.begin(), words.end(),<br/>&#160;&#160;&#160;&#160;insert_iterator&lt;set&lt;string&gt; &gt; (wordset, wordset.begin()), ToLower);</p>
<p>The <code>ToLower()</code> function is easy to write. You just use <code>transform()</code> to apply the <code>tolower()</code> function to each element in the string, using the string both as source and destination. Remember, <code>string</code> objects, too, can use the STL functions. Passing and returning the string as a reference means the algorithm works on the original string without having to make copies. Here&#8217;s the code for <code>ToLower()</code>:</p>
<p class="programlisting"><a id="page_1042"/>string &#38; ToLower(string &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;transform(st.begin(), st.end(), st.begin(), tolower);<br/>&#160;&#160;&#160;&#160;return st;<br/>}</p>
<p>One possible problem is that the <code>tolower()</code> function is defined as <code>int tolower(int)</code>, and some compilers want the function to match the element type, which is <code>char</code>. One solution is to replace <code>tolower</code> with <code>toLower</code> and to provide the following definition:</p>
<p class="programlisting">char toLower(char ch) { return tolower(ch); }</p>
<p>To get the number of times each word appears in the input, you can use the <code>count()</code> function. It takes a range and a value as arguments, and it returns the number of times the value appears in the range. You can use the <code>vector</code> object to provide the range and the <code>set</code> object to provide the list of words to count. That is, for each word in the set, you can count how many times it appears in the vector. To keep the resulting count associated with the correct word, you can store the word and the count as a <code>pair&lt;const string, int&gt;</code> object in a <code>map</code> object. The word will be the key (just one copy), and the count will be the value. This can be done in a single loop:</p>
<p class="programlisting">map&lt;string, int&gt; wordmap;<br/>set&lt;string&gt;::iterator&#160;&#160;si;<br/>for (si = wordset.begin(); si != wordset.end(); si++)<br/>&#160;&#160;&#160;&#160;wordmap.insert(pair&lt;string, int&gt;(*si, count(words.begin(),<br/>&#160;&#160;&#160;&#160;words.end(), *si)));</p>
<p>The <code>map</code> class has an interesting feature: You can use array notation with keys that serve as indexes to access the stored values. For example, <code>wordmap["the"]</code> would represent the value associated with the key <code>"the"</code>, which in this case is the number of occurrences of the string <code>"the"</code>. Because the <code>wordset</code> container holds all the keys used by <code>wordmap</code>, you can use the following code as an alternative and more attractive way of storing results:</p>
<p class="programlisting">for (si = wordset.begin(); si != wordset.end(); si++)<br/>&#160;&#160;&#160;&#160;wordmap[*si] = count(words.begin(), words.end(), *si);</p>
<p>Because <code>si</code> points to a string in the <code>wordset</code> container, <code>*si</code> is a string and can serve as a key for <code>wordmap</code>. This code places both keys and values into the <code>wordmap</code> map.</p>
<p>Similarly, you can use the array notation to report results:</p>
<p class="programlisting">for (si = wordset.begin(); si != wordset.end(); si++)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; *si &lt;&lt; ": " &lt;&lt; wordmap[*si] &lt;&lt; endl;</p>
<p>If a key is invalid, the corresponding value is <code>0</code>.</p>
<p><a href="#ch16ex19">Listing 16.19</a> puts these ideas together and includes code to display the contents of the three containers (a vector with the input, a set with a word list, and a map with a word count).</p>
<p class="caption1"><a id="page_1043"/><a id="ch16ex19"/><strong>Listing 16.19. <code>usealgo.cpp</code></strong></p><hr/>
<p class="programlisting1">//usealgo.cpp -- using several STL elements<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;set&gt;<br/>#include &lt;map&gt;<br/>#include &lt;iterator&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cctype&gt;<br/>using namespace std;<br/><br/>char toLower(char ch) { return tolower(ch); }<br/>string &#38; ToLower(string &#38; st);<br/>void display(const string &#38; s);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;vector&lt;string&gt; words;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter words (enter quit to quit):\n";<br/>&#160;&#160;&#160;&#160;string input;<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; input &#38;&#38; input != "quit")<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;words.push_back(input);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You entered the following words:\n";<br/>&#160;&#160;&#160;&#160;for_each(words.begin(), words.end(), display);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;// place words in set, converting to lowercase<br/>&#160;&#160;&#160;&#160;set&lt;string&gt; wordset;<br/>&#160;&#160;&#160;&#160;transform(words.begin(), words.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;insert_iterator&lt;set&lt;string&gt; &gt; (wordset, wordset.begin()),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ToLower);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nAlphabetic list of words:\n";<br/>&#160;&#160;&#160;&#160;for_each(wordset.begin(), wordset.end(), display);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;// place word and frequency in map<br/>&#160;&#160;&#160;&#160;map&lt;string, int&gt; wordmap;<br/>&#160;&#160;&#160;&#160;set&lt;string&gt;::iterator si;<br/>&#160;&#160;&#160;&#160;for (si = wordset.begin(); si != wordset.end(); si++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wordmap[*si] = count(words.begin(), words.end(), *si);<br/><br/>&#160;&#160;&#160;&#160;// display map contents<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nWord frequency:\n";<br/>&#160;&#160;&#160;&#160;for (si = wordset.begin(); si != wordset.end(); si++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; *si &lt;&lt; ": " &lt;&lt; wordmap[*si] &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>string &#38; ToLower(string &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;transform(st.begin(), st.end(), st.begin(), toLower);<br/>&#160;&#160;&#160;&#160;return st;<br/>}<br/><br/>void display(const string &#38; s)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; s &lt;&lt; " ";<br/>}</p><hr/>
<p><a id="page_1044"/>Here is a sample run of the program in <a href="#ch16ex19">Listing 16.19</a>:</p>
<p class="programlisting">Enter words (enter quit to quit):<br/><span class="EmpStrong">The dog saw the cat and thought the cat fat</span><br/><span class="EmpStrong">The cat thought the cat perfect</span><br/><span class="EmpStrong">quit</span><br/>You entered the following words:<br/>The dog saw the cat and thought the cat fat The cat thought the cat perfect<br/><br/>Alphabetic list of words:<br/>and cat dog fat perfect saw the thought<br/><br/>Word frequency:<br/>and: 1<br/>cat: 4<br/>dog: 1<br/>fat: 1<br/>perfect: 1<br/>saw: 1<br/>the: 5<br/>thought: 2</p>
<p>The moral here is that your attitude when using the STL should be to avoid writing as much code as possible. STL&#8217;s generic and flexible design should save you lots of work. Also the STL designers are algorithm people who are very much concerned with efficiency. So the algorithms are well chosen and inline.</p>
<h3 id="ch16lev1sec7">Other Libraries</h3>
<p><a id="page_1045"/>C++ provides some other class libraries that are more specialized than the examples covered so far in this chapter. For instance, the <code>complex</code> header file provides a <code>complex</code> class template for complex numbers, with specializations for <code>float</code>, <code>long</code>, and <code>long double</code>. The class provides standard complex number operations, along with standard functions that can be used with complex numbers. The C++11 random header file extends random number functionality.</p>
<p><a href="ch14.html#ch14">Chapter 14</a> introduced another example, the <code>valarray</code> template class, supported by the <code>valarray</code> header file. This class template is designed to represent numeric arrays and provides support for a variety of numeric array operations, such as adding the contents of one array to another, applying math functions to each element of an array and applying linear algebra operations to arrays.</p>
<h4 id="ch16lev2sec29"><code>vector</code>, <code>valarray</code>, and <code>array</code></h4>
<p>Perhaps you are wondering why C++ has three array templates: <code>vector</code>, <code>valarray</code>, and <code>array</code>. These classes were developed by different groups for different purposes. The <code>vector</code> template class is part of a system of container classes and algorithms. The <code>vector</code> class supports container-oriented activities, such as sorting, insertion, rearrangement, searching, transferring data to other containers, and other manipulations. The <code>valarray</code> class template, on the other hand, is oriented toward numeric computation, and it is not part of the STL. It doesn&#8217;t have <code>push_back()</code> and <code>insert()</code> methods, for example, but it does provide a simple, intuitive interface for many mathematical operations. Finally, <code>array</code> is designed as a substitute for the built-in array type, combining the compactness and efficiency of that type with a better, safer interface. Being of fixed size, <code>array</code> doesn&#8217;t support <code>push_back()</code> and <code>insert()</code>, but it does offer several other STL methods. These include <code>begin(</code>), <code>end()</code>, <code>rbegin()</code>, and <code>rend()</code>, making it easy to apply STL algorithms to <code>array</code> objects.</p>
<p>Suppose, for example, that you have these declarations:</p>
<p class="programlisting">vector&lt;double&gt; ved1(10), ved2(10), ved3(10);<br/>array&lt;double, 10&gt; vod1, vod2, vod3;<br/>valarray&lt;double&gt; vad1(10), vad2(10), vad3(10);</p>
<p>Furthermore, assume that <code>ved1</code>, <code>ved2</code>, <code>vod1</code>, <code>vod2</code>, <code>vad1</code>, and <code>vad2</code> all acquire suitable values. Suppose you want to assign the sum of the first elements of two arrays to the first element of a third array, and so on. With the <code>vector</code> class, you would do this:</p>
<p class="programlisting">transform(ved1.begin(), ved1.end(), ved2.begin(), ved3.begin(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;plus&lt;double&gt;());</p>
<p>You can do the same with the <code>array</code> class:</p>
<p class="programlisting">transform(vod1.begin(), vod1.end(), vod2.begin(), vod3.begin(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;plus&lt;double&gt;());</p>
<p><a id="page_1046"/>However, the <code>valarray</code> class overloads all the arithmetic operators to work with <code>valarray</code> objects, so you would use this:</p>
<p class="programlisting">vad3 = vad1 + vad2;&#160;&#160;&#160;&#160;// + overloaded</p>
<p>Similarly, the following would result in each element of <code>vad3</code> being the product of the corresponding elements in <code>vad1</code> and <code>vad2</code>:</p>
<p class="programlisting">vad3 = vad1 * vad2;&#160;&#160;&#160;&#160;// * overloaded</p>
<p>Suppose you want to replace every value in an array with that value multiplied by 2.5. The STL approach is this:</p>
<p class="programlisting">transform(ved3.begin(), ved3.end(), ved3.begin(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bind1st(multiplies&lt;double&gt;(), 2.5));</p>
<p>The <code>valarray</code> class overloads multiplying a <code>valarray</code> object by a single value, and it also overloads the various computed assignment operators, so you could use either of the following:</p>
<p class="programlisting">vad3 = 2.5 * vad3;&#160;&#160;&#160;&#160;&#160;// * overloaded<br/>vad3 *= 2.5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// *= overloaded</p>
<p>Suppose you want to take the natural logarithm of every element of one array and store the result in the corresponding element of a second array. The STL approach is this:</p>
<p class="programlisting">transform(ved1.begin(), ved1.end(), ved3.begin(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;log);</p>
<p>The <code>valarray</code> class overloads the usual math functions to take a <code>valarray</code> argument and to return a <code>valarray</code> object, so you can use this:</p>
<p class="programlisting">vad3 = log(vad1);&#160;&#160;&#160;&#160;&#160;// log() overloaded</p>
<p>Or you could use the <code>apply()</code> method, which also works for non-overloaded functions:</p>
<p class="programlisting">vad3 = vad1.apply(log);</p>
<p>The <code>apply()</code> method doesn&#8217;t alter the invoking object; instead, it returns a new object that contains the resulting values.</p>
<p>The simplicity of the <code>valarray</code> interface is even more apparent when you do a multistep calculation:</p>
<p class="programlisting">vad3 = 10.0* ((vad1 + vad2) / 2.0 + vad1 * cos(vad2));</p>
<p>The <code>vector</code>-STL version is left as an exercise for the motivated reader.</p>
<p>The <code>valarray</code> class also provides a <code>sum()</code> method that sums the contents of a <code>valarray</code> object, a <code>size()</code> method that returns the number of elements, a <code>max()</code> method that returns the largest value in an object, and a <code>min()</code> method that returns the smallest value.</p>
<p>As you can see, <code>valarray</code> has a clear notational advantage over <code>vector</code> for mathematical operations, but it is also much less versatile. The <code>valarray</code> class does have a <code>resize()</code> <a id="page_1047"/>method, but there&#8217;s no automatic resizing of the sort you get when you use the <code>vector push_back()</code> method. There are no methods for inserting values, searching, sorting, and the like. In short, the <code>valarray</code> class is more limited than the <code>vector</code> class, but its narrower focus allows a much simpler interface.</p>
<p>Does the simpler interface that <code>valarray</code> provides translate to better performance? In most cases, no. The simple notation is typically implemented with the same sort of loops you would use with ordinary arrays. However, some hardware designs allow vector operations in which the values in an array are loaded simultaneous into an array of registers and then processed simultaneously. In principle, <code>valarray</code> operations could be implemented to take advantage of such designs.</p>
<p>Can you use the STL with <code>valarray</code> objects? Answering this question provides a quick review of some STL principles. Suppose you have a <code>valarray&lt;double&gt;</code> object that has 10 elements:</p>
<p class="programlistingB">valarray&lt;double&gt; vad(10);</p>
<p>After the array has been filled with numbers, can you, say, use the STL sort function on it? The <code>valarray</code> class doesn&#8217;t have <code>begin()</code> and <code>end()</code> methods, so you can&#8217;t use them as the range arguments:</p>
<p class="programlisting">sort(vad.begin(), vad.end());&#160;&#160;// NO, no begin(), end()</p>
<p>Also <code>vad</code> is an object, not a pointer, so you can&#8217;t imitate ordinary array usage and provide <code>vad</code> and <code>vad + 10</code>, as the following code attempts to do:</p>
<p class="programlisting">sort(vad, vad + 10);&#160;&#160;// NO, vad an object, not an address</p>
<p>You can use the address operator:</p>
<p class="programlisting">sort(&#38;vad[0], &#38;vad[10]);&#160;&#160;// maybe?</p>
<p>But the behavior of using a subscript one past the end is undefined for <code>valarray</code>. This doesn&#8217;t necessarily mean using <code>&#38;vad[10</code>] won&#8217;t work.(In fact, it did work for all six compilers used to test this code.) But it does mean that it might not work. For the code to fail, you probably would need a very unlikely circumstance, such as the array being butted against the end of the block of memory set aside for the heap. But, if a $385-million mission depended on your code, you might not want to risk that failure.</p>
<p>C++11 remedies the situation by providing <code>begin()</code> and <code>end()</code> template functions that take a <code>valarray</code> object as an argument. So you would use <code>begin(vad)</code> instead of <code>vad.begin()</code>. These functions return values that are compatible with STL range requirements:</p>
<p class="programlisting">sort(begin(vad), end(vad)); // C++11 fix!</p>
<p><a href="#ch16ex20">Listing 16.20</a> illustrates some of the relative strengths of the <code>vector</code> and <code>valarray</code> classes. It uses <code>push_back()</code> and the automatic sizing feature of <code>vector</code> to collect data. Then after sorting the numbers, the program copies them from the <code>vector</code> object to a <code>valarray</code> object of the same size and does a few math operations.</p>
<p class="caption1"><a id="page_1048"/><a id="ch16ex20"/><strong>Listing 16.20. <code>valvect.cpp</code></strong></p><hr/>
<p class="programlisting1">// valvect.cpp -- comparing vector and valarray<br/>#include &lt;iostream&gt;<br/>#include &lt;valarray&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;vector&lt;double&gt; data;<br/>&#160;&#160;&#160;&#160;double temp;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter numbers (&lt;=0 to quit):\n";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; temp &#38;&#38; temp &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data.push_back(temp);<br/>&#160;&#160;&#160;&#160;sort(data.begin(), data.end());<br/>&#160;&#160;&#160;&#160;int size = data.size();<br/>&#160;&#160;&#160;&#160;valarray&lt;double&gt; numbers(size);<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; size; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;numbers[i] = data[i];<br/>&#160;&#160;&#160;&#160;valarray&lt;double&gt; sq_rts(size);<br/>&#160;&#160;&#160;&#160;sq_rts = sqrt(numbers);<br/>&#160;&#160;&#160;&#160;valarray&lt;double&gt; results(size);<br/>&#160;&#160;&#160;&#160;results = numbers + 2.0 * sq_rts;<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed);<br/>&#160;&#160;&#160;&#160;cout.precision(4);<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; size; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(8);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; numbers[i] &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(8);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; results[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "done\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch16ex20">Listing 16.20</a>:</p>
<p class="programlisting">Enter numbers (&lt;=0 to quit):<br/><span class="EmpStrong">3.3 1.8 5.2 10 14.4 21.6 26.9 0</span><br/>&#160;&#160;1.8000:&#160;&#160;&#160;4.4833<br/>&#160;&#160;3.3000:&#160;&#160;&#160;6.9332<br/>&#160;&#160;5.2000:&#160;&#160;&#160;9.7607<br/>&#160;10.0000:&#160;&#160;16.3246<br/><a id="page_1049"/>&#160;14.4000:&#160;&#160;21.9895<br/>&#160;21.6000:&#160;&#160;30.8952<br/>&#160;26.9000:&#160;&#160;37.2730<br/>done</p>
<p>The <code>valarray</code> class has many features besides the ones discussed so far. For example, if <code>numbers</code> is a <code>valarray&lt;double&gt;</code> object, the following statement creates an array of <code>bool</code> values, with <code>vbool[i]</code> set to the value of <code>numbers[i] &gt; 9</code>&#8212;that is, to <code>true</code> or <code>false</code>:</p>
<p class="programlisting">valarray&lt;bool&gt; vbool = numbers &gt; 9;</p>
<p>There are extended versions of subscripting. Let&#8217;s look at one&#8212;the <code>slice</code> class. A <code>slice</code> class object can be used as an array index, in which case it represents, in general, not just one value but a subset of values. A <code>slice</code> object is initialized to three integer values: the <em>start</em>, the <em>number</em>, and the <em>stride</em>. The <em>start</em> indicates the index of the first element to be selected, the <em>number</em> indicates the number of elements to be selected, and the <em>stride</em> represents the spacing between elements. For example, the object constructed by <code>slice(1,4,3)</code> means select the four elements whose indexes are 1, 4, 7, and 10. That is, start with the start element, add the stride to get the next element, and so on until four elements are selected. If, say, <code>varint</code> is a <code>vararray&lt;int&gt;</code> object, then the following statement would set elements 1, 4, 7, and 10 to the value <code>10</code>:</p>
<p class="programlisting">varint[slice(1,4,3)] = 10;&#160;&#160;// set selected elements to 10</p>
<p>This special subscripting facility allows you to use a one-dimensional <code>valarray</code> object to represent two-dimensional data. For example, suppose you want to represent an array with 4 rows and 3 columns. You can store the information in a 12-element <code>valarray</code> object. Then a <code>slice(0,3,1)</code> object used as a subscript would represent elements 0, 1, and 2&#8212;that is, the first row. Similarly, a <code>slice(0,4,3)</code> subscript would represent elements 0, 3, 6, and 9&#8212;that is, the first column. <a href="#ch16ex21">Listing 16.21</a> illustrates some features of <code>slice</code>.</p>
<p class="caption1"><a id="ch16ex21"/><strong>Listing 16.21. <code>vslice.cpp</code></strong></p><hr/>
<p class="programlisting1">// vslice.cpp -- using valarray slices<br/>#include &lt;iostream&gt;<br/>#include &lt;valarray&gt;<br/>#include &lt;cstdlib&gt;<br/><br/>const int SIZE = 12;<br/>typedef std::valarray&lt;int&gt; vint;&#160;&#160;&#160;&#160;&#160;// simplify declarations<br/>void show(const vint &#38; v, int cols);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::slice;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// from &lt;valarray&gt;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;vint valint(SIZE);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// think of as 4 rows of 3<br/><br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; SIZE; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;valint[i] = std::rand() % 10;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Original array:\n";<br/>&#160;&#160;&#160;&#160;show(valint, 3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// show in 3 columns<br/>&#160;&#160;&#160;&#160;vint vcol(valint[slice(1,4,3)]); // extract 2nd column<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Second column:\n";<br/>&#160;&#160;&#160;&#160;show(vcol, 1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// show in 1 column<br/>&#160;&#160;&#160;&#160;vint vrow(valint[slice(3,3,1)]); // extract 2nd row<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Second row:\n";<br/>&#160;&#160;&#160;&#160;show(vrow, 3);<br/>&#160;&#160;&#160;&#160;valint[slice(2,4,3)]&#160;&#160;= 10;&#160;&#160;&#160;&#160;&#160;&#160;// assign to 2nd column<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set last column to 10:\n";<br/>&#160;&#160;&#160;&#160;show(valint, 3);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Set first column to sum of next two:\n";<br/>&#160;&#160;&#160;&#160;// + not defined for slices, so convert to valarray&lt;int&gt;<br/>&#160;&#160;&#160;&#160;valint[slice(0,4,3)]&#160;&#160;= vint(valint[slice(1,4,3)])<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+ vint(valint[slice(2,4,3)]);<br/>&#160;&#160;&#160;&#160;show(valint, 3);<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void show(const vint &#38; v, int cols)<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;int lim = v.size();<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; lim; ++i)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(3);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; v[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % cols == cols - 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ' ';<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;if (lim % cols != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}</p><hr/>
<p><a id="page_1050"/>The <code>+</code> operator is defined for <code>valarray</code> objects, such as <code>valint</code>, and it&#8217;s defined for a single <code>int</code> element, such as <code>valint[1]</code>. But as the code in <a href="#ch16ex21">Listing 16.21</a> notes, the <code>+</code> operator isn&#8217;t defined for <code>slice</code>-subscripted <code>valarray</code> units, such as <code>valint[slice(1,4,3)]</code>. Therefore, the program constructs full objects from the slices to enable addition:</p>
<p class="programlisting">vint(valint[slice(1,4,3)])&#160;&#160;&#160;&#160;// calls a slice-based constructor</p>
<p><a id="page_1051"/>The <code>valarray</code> class provides constructors just for this purpose.</p>
<p>Here is a sample run of the program in <a href="#ch16ex21">Listing 16.21</a>:</p>
<p class="programlisting">Original array:<br/>&#160;&#160;0&#160;&#160;&#160;3&#160;&#160;&#160;3<br/>&#160;&#160;2&#160;&#160;&#160;9&#160;&#160;&#160;0<br/>&#160;&#160;8&#160;&#160;&#160;2&#160;&#160;&#160;6<br/>&#160;&#160;6&#160;&#160;&#160;9&#160;&#160;&#160;1<br/>Second column:<br/>&#160;&#160;3<br/>&#160;&#160;9<br/>&#160;&#160;2<br/>&#160;&#160;9<br/>Second row:<br/>&#160;&#160;2&#160;&#160;&#160;9&#160;&#160;&#160;0<br/>Set last column to 10:<br/>&#160;&#160;0&#160;&#160;&#160;3&#160;&#160;10<br/>&#160;&#160;2&#160;&#160;&#160;9&#160;&#160;10<br/>&#160;&#160;8&#160;&#160;&#160;2&#160;&#160;10<br/>&#160;&#160;6&#160;&#160;&#160;9&#160;&#160;10<br/>Set first column to sum of next two:<br/>&#160;13&#160;&#160;&#160;3&#160;&#160;10<br/>&#160;19&#160;&#160;&#160;9&#160;&#160;10<br/>&#160;12&#160;&#160;&#160;2&#160;&#160;10<br/>&#160;19&#160;&#160;&#160;9&#160;&#160;10</p>
<p>Because values are set using <code>rand()</code>, different implementations of <code>rand()</code> will result in different values.</p>
<p>There&#8217;s more, including the <code>gslice</code> class to represent multidimensional slices, but this should be enough to give you a sense of what <code>valarray</code> is about.</p>
<h4 id="ch16lev2sec30">The <code>initializer_list</code> Template (C++11)</h4>
<p>The <code>initializer_list</code> template is another C++11 addition to the C++ library. You can use the initializer-list syntax to initialize an STL container to a list of values:</p>
<p class="programlisting">std::vector&lt;double&gt; payments {45.99, 39.23, 19.95, 89.01};</p>
<p>This would create a container for four elements and initialize the elements to the four values in the list. What makes this possible is that the container classes now have constructors taking an <code>initializer_list&lt;T&gt;</code> argument. A <code>vector&lt;double&gt;</code> object, for example, has a constructor that accepts an <code>initializer_list&lt;double&gt;</code> argument, and the previous declaration is the same as this:</p>
<p class="programlisting">std::vector&lt;double&gt; payments({45.99, 39.23, 19.95, 89.01});</p>
<p><a id="page_1052"/>Here, the list is written explicitly as a constructor argument.</p>
<p>Normally, as part of the C++11 universal initialization syntax, you can invoke a class constructor using <code>{}</code> instead of <code>()</code> notation:</p>
<p class="programlisting">shared_ptr&lt;double&gt; pd {new double}; // ok to use {} instead of ()</p>
<p>But this would create problems if there also is an <code>initializer_list</code> constructor:</p>
<p class="programlisting">std::vector&lt;int&gt; vi{10};&#160;&#160;&#160;&#160;// ??</p>
<p>Which constructor does this invoke?</p>
<p class="programlisting">std::vector&lt;int&gt; vi(10);&#160;&#160;&#160;&#160;// case A: 10 uninitialized elements<br/>std::vector&lt;int&gt; vi({10});&#160;&#160;// case B: 1 element set to 10</p>
<p>The answer is that if the class does have a constructor accepting an <code>initializer_list</code> argument, then using the <code>{}</code> syntax invokes that particular constructor. So in this example, case B applies.</p>
<p>The <code>initializer_list</code> elements should all be of one type. However, the compiler will do conversions to match the type:</p>
<p class="programlisting">std::vector&lt;double&gt; payments {45.99, 39.23, 19, 89};<br/>// same as std::vector&lt;double&gt; payments {45.99, 39.23, 19.0, 89.0};</p>
<p>Here, because the <code>vector</code> element type is <code>double</code>, the list is type <code>initializer_list&lt;double&gt;</code>, and <code>19</code> and <code>89</code> are converted to <code>double</code>.</p>
<p>The usual list restrictions on narrowing apply:</p>
<p class="programlisting">std::vector&lt;int&gt; values = {10, 8, 5.5};&#160;&#160;// narrowing, compile-time error</p>
<p>Here, the element type is <code>int</code>, and the implied conversion of <code>5.5</code> to <code>int</code> is not allowed.</p>
<p>It doesn&#8217;t make sense to provide an <code>initializer_list</code> constructor unless the class is meant to handle lists of varying sizes. For instance, you don&#8217;t want an <code>initializer_list</code> constructor for a class taking a fixed number of values. For example, the following declaration does not provide an <code>initializer_list</code> constructor for the three data members:</p>
<p class="programlisting">class Position<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int x;<br/>&#160;&#160;&#160;&#160;int y;<br/>&#160;&#160;&#160;&#160;int z;<br/>public:<br/>&#160;&#160;&#160;&#160;Position(int xx = 0, int yy&#160;&#160;= 0, int zz = 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: x(xx), y(yy), z(zz) {}<br/>&#160;&#160;&#160;&#160;// no initializer_list constructor<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p><a id="page_1053"/>This allows you to use the <code>{}</code> syntax with the <code>Position(int,int,int)</code> constructor:</p>
<p class="programlisting">Position A = {20, -3};&#160;&#160;// uses Position(20,-3,0)</p>
<h4 id="ch16lev2sec31">Using <code>initializer_list</code></h4>
<p>You can use <code>initializer_list</code> objects in your code by including the <code>initializer_list</code> header file. The template class has <code>begin()</code> and <code>end()</code> members, and you can use them to access list elements. It also has a <code>size()</code> member that returns the number of elements. <a href="#ch16ex22">Listing 16.22</a> shows a simple example using <code>initializer_list</code>. It requires a compiler that supports this C++11 feature.</p>
<p class="caption1"><a id="ch16ex22"/><strong>Listing 16.22. <code>ilist.cpp</code></strong></p><hr/>
<p class="programlisting1">// ilist.cpp -- use initializer_list (C++11 feature)<br/>#include &lt;iostream&gt;<br/>#include &lt;initializer_list&gt;<br/><br/>double sum(std::initializer_list&lt;double&gt; il);<br/>double average(const std::initializer_list&lt;double&gt; &#38; ril);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "List 1: sum = " &lt;&lt; sum({2,3,4})<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt;", ave = " &lt;&lt; average({2,3,4}) &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;std::initializer_list&lt;double&gt; dl = {1.1, 2.2, 3.3, 4.4, 5.5};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "List 2: sum = " &lt;&lt; sum(dl)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt;", ave = " &lt;&lt; average(dl) &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;dl = {16.0, 25.0, 36.0, 40.0, 64.0};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "List 3: sum = " &lt;&lt; sum(dl)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt;", ave = " &lt;&lt; average(dl) &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>double sum(std::initializer_list&lt;double&gt; il)<br/>{<br/>&#160;&#160;&#160;&#160;double tot = 0;<br/>&#160;&#160;&#160;&#160;for (auto p = il.begin(); p !=il.end(); p++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tot += *p;<br/>&#160;&#160;&#160;&#160;return tot;<br/>}<br/><br/>double average(const std::initializer_list&lt;double&gt; &#38; ril)<br/>{<br/>&#160;&#160;&#160;&#160;double tot = 0;<br/>&#160;&#160;&#160;&#160;int n = ril.size();<br/>&#160;&#160;&#160;&#160;double ave = 0.0;<br/>&#160;&#160;&#160;&#160;if (n &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (auto p = ril.begin(); p !=ril.end(); p++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tot += *p;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ave = tot / n;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return ave;<br/>}</p><hr/>
<p><a id="page_1054"/>Here&#8217;s a sample run:</p>
<p class="programlisting">List 1: sum = 9, ave = 3<br/>List 2: sum = 16.5, ave = 3.3<br/>List 3: sum = 181, ave = 36.2</p>
<h4 id="ch16lev2sec32">Program Notes</h4>
<p>You can pass an <code>initializer_list</code> object by value or by reference, as shown by <code>sum()</code> and <code>average()</code>. The object itself is small, typically two pointers (one to the beginning and one past end) or a pointer to the beginning and an integer representing the size, so the choice is not a major performance issue. (The STL passes them by value.)</p>
<p>The function argument can be a list literal, like <code>{2,3,4}</code>, or it can be a list variable, like <code>dl</code>.</p>
<p>The iterator types for <code>initializer_list</code> are <code>const</code>, so you can&#8217;t change the values in a list:</p>
<p class="programlisting">*dl.begin() = 2011.6;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed</p>
<p>But, as <a href="#ch16ex22">Listing 16.22</a> shows, you can attach a list variable to a different list:</p>
<p class="programlisting">dl = {16.0, 25.0, 36.0, 40.0, 64.0};&#160;&#160;// allowed</p>
<p>However, the intended use of the <code>initializer_list</code> class is to pass a list of values to a constructor or some other function.</p>
<h3 id="ch16lev1sec8">Summary</h3>
<p>C++ includes a powerful set of libraries that provide solutions to many common programming problems and the tools to simplify many more problems. The <code>string</code> class provides a convenient means to handle strings as objects as well as automatic memory management and a host of methods and functions for working with strings. For example, these methods and functions allow you to concatenate strings, insert one string into another, reverse a string, search a string for characters or substrings, and perform input and output operations.</p>
<p><a id="page_1055"/>Smart pointer templates such as <code>auto_ptr</code> and C++11&#8217;s <code>shared_ptr</code> and <code>unique_ptr</code> make it easier to manage memory allocated by <code>new</code>. If you use one of these smart pointers instead of a regular pointer to hold the address returned by <code>new</code>, you don&#8217;t have to remember to use the <code>delete</code> operator later. When the smart pointer object expires, its destructor calls the <code>delete</code> operator automatically.</p>
<p>The STL is a collection of container class templates, iterator class templates, function object templates, and algorithm function templates that feature a unified design based on generic programming principles. The algorithms use templates to make them generic in terms of type of stored object and an iterator interface to make them generic in terms of the type of container. Iterators are generalizations of pointers.</p>
<p>The STL uses the term <em>concept</em> to denote a set of requirements. For example, the concept of forward iterators includes the requirements that a forward iterator object can be dereferenced for reading and writing and that it can be incremented. Actual implementations of the concept are said to <em>model</em> the concept. For example, the forward iterator concept could be modeled by an ordinary pointer or by an object designed to navigate a linked list. Concepts based on other concepts are termed <em>refinements</em>. For example, the bidirectional iterator is a refinement of the forward iterator concept.</p>
<p>Container classes, such as <code>vector</code> and <code>set</code>, are models of container concepts, such as containers, sequences, and associative containers. The STL defines several container class templates: <code>vector</code>, <code>deque</code>, <code>list</code>, <code>set</code>, <code>multiset</code>, <code>map</code>, <code>multimap</code>, and <code>bitset</code>. It also defines the adapter class templates <code>queue</code>, <code>priority_queue</code>, and <code>stack</code>; these classes adapt an underlying container class to give it the characteristic interface suggested by the adapter class template name. Thus, <code>stack</code>, although based, by default, on <code>vector</code>, allows insertion and removal only at the top of the stack. C++11 adds <code>forward_list</code>, <code>unordered_set</code>, <code>unordered_multiset</code>, <code>unordered_map</code>, and <code>unordered_multimap</code>.</p>
<p>Some algorithms are expressed as container class methods, but the bulk are expressed as general, nonmember functions. This is made possible by using iterators as the interface between containers and algorithms. One advantage to this approach is that there needs to be just one <code>for_each()</code> or <code>copy()</code> function, and so on, instead of a separate version for each container. A second advantage is that STL algorithms can be used with non-STL containers, such as ordinary arrays, <code>string</code> objects, <code>array</code> objects, and any classes you design consistent with the STL iterator and container idiom.</p>
<p>Both containers and algorithms are characterized by the type of iterator they provide or need. You should check that a container features an iterator concept that supports the algorithm&#8217;s needs. For example, the <code>for_each()</code> algorithm uses an input iterator, whose minimal requirements are met by all the STL container class types. But <code>sort()</code> requires random access iterators, which not all container classes support. A container class may offer a specialized method as an option if it doesn&#8217;t meet the requirements for a particular algorithm. For example, the <code>list</code> class has a <code>sort()</code> method that is based on bidirectional iterators, so it can use that method instead of the general function.</p>
<p>The STL also provides function objects, or functors, that are classes for which the <code>()</code> operator is overloaded&#8212;that is, for which the <code>operator()()</code> method is defined. <a id="page_1056"/>Objects of such classes can be invoked by using function notation but can carry additional information. Adaptable functors, for example, have <code>typedef</code> statements that identify the argument types and the return value type for the functor. This information can be used by other components, such as function adapters.</p>
<p>By representing common container types and providing a variety of common operations implemented with efficient algorithms, all done in a generic manner, the STL provides an excellent source of reusable code. You may be able to solve a programming problem directly with the STL tools, or you may be able to use them as building blocks to construct the solution you need.</p>
<p>The <code>complex</code> and <code>valarray</code> template classes support numeric operations for complex numbers and arrays.</p>
<h3 id="ch16lev1sec9">Chapter Review</h3>
<p class="question"><a id="ch16qa1q1" href="app10.html#ch16qa1a1"><strong>1.</strong></a> Consider the following class declaration:</p>
<p class="programlistingB">class RQ1<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * st;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// points to C-style string<br/>public:<br/>&#160;&#160;&#160;&#160;RQ1() { st = new char [1]; strcpy(st,""); }<br/>&#160;&#160;&#160;&#160;RQ1(const char * s)<br/>&#160;&#160;&#160;&#160;{st = new char [strlen(s) + 1]; strcpy(st, s); }<br/>&#160;&#160;&#160;&#160;RQ1(const RQ1 &#38; rq)<br/>&#160;&#160;&#160;&#160;{st = new char [strlen(rq.st) + 1]; strcpy(st, rq.st); }<br/>&#160;&#160;&#160;&#160;~RQ1() {delete [] st};<br/>&#160;&#160;&#160;&#160;RQ &#38; operator=(const RQ &#38; rq);<br/>&#160;&#160;&#160;&#160;// more stuff<br/>};</p>
<p class="indenthanding1">Convert this to a declaration that uses a <code>string</code> object instead. What methods no longer need explicit definitions?</p>
<p class="question"><a id="ch16qa1q2" href="app10.html#ch16qa1a2"><strong>2.</strong></a> Name at least two advantages <code>string</code> objects have over C-style strings in terms of ease-of-use.</p>
<p class="question"><a id="ch16qa1q3" href="app10.html#ch16qa1a3"><strong>3.</strong></a> Write a function that takes a reference to a <code>string</code> object as an argument and that converts the <code>string</code> object to all uppercase.</p>
<p class="question"><a id="ch16qa1q4" href="app10.html#ch16qa1a4"><strong>4.</strong></a> Which of the following are not examples of correct usage (conceptually or syntactically) of <code>auto_ptr</code>? (Assume that the needed header files have been included.)</p>
<p class="programlistingB">auto_ptr&lt;int&gt; pia(new int[20]);<br/>auto_ptr&lt;string&gt; (new string);<br/>int rigue = 7;<br/>auto_ptr&lt;int&gt;pr(&#38;rigue);<br/>auto_ptr dbl (new double);</p>
<p class="question"><a id="page_1057"/><a id="ch16qa1q5" href="app10.html#ch16qa1a5"><strong>5.</strong></a> If you could make the mechanical equivalent of a stack that held golf clubs instead of numbers, why would it (conceptually) be a bad golf bag?</p>
<p class="question"><a id="ch16qa1q6" href="app10.html#ch16qa1a6"><strong>6.</strong></a> Why would a <code>set</code> container be a poor choice for storing a hole-by-hole record of your golf scores?</p>
<p class="question"><a id="ch16qa1q7" href="app10.html#ch16qa1a7"><strong>7.</strong></a> Because a pointer is an iterator, why didn&#8217;t the STL designers simply use pointers instead of iterators?</p>
<p class="question"><a id="ch16qa1q8" href="app10.html#ch16qa1a8"><strong>8.</strong></a> Why didn&#8217;t the STL designers simply define a base iterator class, use inheritance to derive classes for the other iterator types, and express the algorithms in terms of those iterator classes?</p>
<p class="question"><a id="ch16qa1q9" href="app10.html#ch16qa1a9"><strong>9.</strong></a> Give at least three examples of convenience advantages that a <code>vector</code> object has over an ordinary array.</p>
<p class="question1"><a id="ch16qa1q10" href="app10.html#ch16qa1a10"><strong>10.</strong></a> If <a href="ch16.html#ch16ex09">Listing 16.9</a> were implemented with <code>list</code> instead of <code>vector</code>, what parts of the program would become invalid? Could the invalid part be fixed easily? If so, how?</p>
<p class="question1"><a id="ch16qa1q11"/><strong>11.</strong> Consider the <code>TooBig</code> functor in <a href="#ch16ex15">Listing 16.15</a>. What does the following code do, and what values get assigned to <code>bo</code>?</p>
<p class="programlistingB">bool bo = TooBig&lt;int&gt;(10)(15);</p>
<h3 id="ch16lev1sec10">Programming Exercises</h3>
<p class="question"><a id="ch16qa2q1"/><strong>1.</strong> A <em>palindrome</em> is a string that is the same backward as it is forward. For example, &#8220;tot&#8221; and &#8220;otto&#8221; are rather short palindromes. Write a program that lets a user enter a string and that passes to a <code>bool</code> function a reference to the string. The function should return <code>true</code> if the string is a palindrome and <code>false</code> otherwise. At this point, don&#8217;t worry about complications such as capitalization, spaces, and punctuation. That is, this simple version should reject &#8220;Otto&#8221; and &#8220;Madam, I&#8217;m Adam.&#8221; Feel free to scan the list of string methods in <a href="app06.html#app06">Appendix F</a> for methods to simplify the task.</p>
<p class="question"><a id="ch16qa2q2"/><strong>2.</strong> Do the same problem as given in Programming Exercise 1 but do worry about complications such as capitalization, spaces, and punctuation. That is, &#8220;Madam, I&#8217;m Adam&#8221; should test as a palindrome. For example, the testing function could reduce the string to &#8220;madamimadam&#8221; and then test whether the reverse is the same. Don&#8217;t forget the useful <code>cctype</code> library. You might find an STL function or two useful although not necessary.</p>
<p class="question"><a id="ch16qa2q3"/><strong>3.</strong> Redo <a href="ch16.html#ch16ex03">Listing 16.3</a> so that it gets it words from a file. One approach is to use a <code>vector&lt;string&gt;</code> object instead of an array of <code>string</code>. Then you can use <code>push_back()</code> to copy how ever many words are in your data file into the <code>vector&lt;string&gt;</code> object and use the <code>size()</code> member to determine the length of the word list. Because the program should read one word at a time from the file, you should use the <code>&gt;&gt;</code> operator rather than <code>getline()</code>. The file itself should contain words separated by spaces, tabs, or new lines.</p>
<p class="question"><a id="page_1058"/><a id="ch16qa2q4"/><strong>4.</strong> Write a function with an old-style interface that has this prototype:</p>
<p class="programlistingB">int reduce(long ar[], int n);</p>
<p class="indenthanding1">The actual arguments should be the name of an array and the number of elements in the array. The function should sort an array, remove duplicate values, and return a value equal to the number of elements in the reduced array. Write the function using STL functions. (If you decide to use the general <code>unique()</code> function, note that it returns the end of the resulting range.) Test the function in a short program.</p>
<p class="question"><a id="ch16qa2q5"/><strong>5.</strong> Do the same problem as described in Programming Exercise 4, except make it a template function:</p>
<p class="programlistingB">template &lt;class T&gt;<br/>int reduce(T ar[], int n);</p>
<p class="indenthanding1">Test the function in a short program, using both a <code>long</code> instantiation and a <code>string</code> instantiation.</p>
<p class="question"><a id="ch16qa2q6"/><strong>6.</strong> Redo the example shown in <a href="ch12.html#ch12ex12">Listing 12.12</a>, using the STL <code>queue</code> template class instead of the <code>Queue</code> class described in <a href="ch12.html#ch12">Chapter 12</a>.</p>
<p class="question"><a id="ch16qa2q7"/><strong>7.</strong> A common game is the lottery card. The card has numbered spots of which a certain number are selected at random. Write a <code>Lotto()</code> function that takes two arguments. The first should be the number of spots on a lottery card, and the second should be the number of spots selected at random. The function should return a <code>vector&lt;int&gt;</code> object that contains, in sorted order, the numbers selected at random. For example, you could use the function as follows:</p>
<p class="programlistingB">vector&lt;int&gt; winners;<br/>winners = Lotto(51,6);</p>
<p class="indenthanding1">This would assign to <code>winners</code> a vector that contains six numbers selected randomly from the range 1 through 51. Note that simply using <code>rand()</code> doesn&#8217;t quite do the job because it may produce duplicate values. Suggestion: Have the function create a vector that contains all the possible values, use <code>random_shuffle()</code>, and then use the beginning of the shuffled vector to obtain the values. Also write a short program that lets you test the function.</p>
<p class="question"><a id="ch16qa2q8"/><strong>8.</strong> Mat and Pat want to invite their friends to a party. They ask you to write a program that does the following:</p>
<p class="indenthandingB1">&#8226; Allows Mat to enter a list of his friends&#8217; names. The names are stored in a container and then displayed in sorted order.</p>
<p class="indenthandingB1">&#8226; Allows Pat to enter a list of her friends&#8217; names. The names are stored in a second container and then displayed in sorted order.</p>
<p class="indenthandingB1">&#8226; Creates a third container that merges the two lists, eliminates duplicates, and displays the contents of this container.</p>
<p class="question"><a id="page_1059"/><a id="ch16qa2q9"/><strong>9.</strong> Compared to an array, a linked list features easier addition and removal of elements but is slower to sort. This raises a possibility: Perhaps it might be faster to copy a list to an array, sort the array, and copy the sorted result back to the list than to simply use the list algorithm for sorting. (But it also could use more memory.) Test the speed hypothesis with the following approach:</p>
<p class="indenthandinga"><strong>a.</strong> Create a large <code>vector&lt;int&gt;</code> object <code>vi0</code>, using <code>rand()</code> to provide initial values.</p>
<p class="indenthandinga"><strong>b.</strong> Create a second <code>vector&lt;int&gt;</code> object <code>vi</code> and a <code>list&lt;int&gt;</code> object <code>li</code> of the same size as the original and initialize them to values in the original vector.</p>
<p class="indenthandinga"><strong>c.</strong> Time how long the program takes to sort <code>vi</code> using the STL <code>sort()</code> algorithm, then time how long it takes to sort <code>li</code> using the <code>list sort()</code> method.</p>
<p class="indenthandinga"><strong>d.</strong> Reset <code>li</code> to the unsorted contents of <code>vi0</code>. Time the combined operation of copying <code>li</code> to <code>vi</code>, sorting <code>vi</code>, and copying the result back to <code>li</code>.</p>
<p class="indenthanding1">To time these operations, you can use <code>clock()</code> from the <code>ctime</code> library. As in <a href="ch05.html#ch05ex14">Listing 5.14</a>, you can use this statement to start the first timing:</p>
<p class="programlistingB">clock_t start = clock();</p>
<p class="indenthanding1">Then use the following at the end of the operation to get the elapsed time:</p>
<p class="programlistingB">clock_t end = clock();<br/>cout &lt;&lt; (double)(end - start)/CLOCKS_PER_SEC;</p>
<p class="indenthanding1">This is by no means a definitive test because the results will depend on a variety of factors, including available memory, whether multiprocessing is going on, and the size of the array or list. (One would expect the relative efficiency advantage of the array over the list to increase with the number of elements being sorted.) Also if you have a choice between a default build and a release build, use the release build for the measurement. With today&#8217;s speedy computers, you probably will need to use as large an array as possible to get meaningful readings. You might try, for example, 100,000 elements, 1,000,000 elements, and 10,000,000 elements.</p>
<p class="question1"><a id="ch16qa2q10"/><strong>10.</strong> Modify <a href="ch16.html#ch16ex09">Listing 16.9</a> (<code>vect3.cpp</code>) as follows:</p>
<p class="indenthandinga"><strong>a.</strong> Add a <code>price</code> member to the <code>Review</code> structure.</p>
<p class="indenthandinga"><strong>b.</strong> Instead of using a <code>vector</code> of <code>Review</code> objects to hold the input, use a <code>vector</code> of <code>shared_ptr&lt;Review&gt;</code> objects. Remember that a <code>shared_ptr</code> has to be initialized with a pointer returned by <code>new</code>.</p>
<p class="indenthandinga"><strong>c.</strong> Follow the input stage with a loop that allows the user the following options for displaying books: in original order, in alphabetical order, in order of increasing ratings, in order of decreasing ratings, in order of increasing price, in order of decreasing price, and quitting.</p>
<p class="questionp"><a id="page_1060"/>Here&#8217;s one possible approach. After getting the initial input, create another vector of <code>shared_ptr</code>s initialized to the original array. Define an <code>operator&lt;()</code> function that compares pointed-to structures and use it to sort the second vector so that the <code>shared_ptr</code>s are in the order of the book names stored in the pointed-to objects. Repeat the process to get <code>vector</code>s of <code>shared_ptr</code>s sorted by <code>rating</code> and by <code>price</code>. Note that <code>rbegin()</code> and <code>rend()</code> save you the trouble of also creating <code>vector</code>s of reversed order.</p>
</body>
</html>
