<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>12. Classes and Dynamic Memory Allocation</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch12">12. Classes and Dynamic Memory Allocation</h2>
<p><a id="page_627"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Using dynamic memory allocation for class members</p>
<p class="indenthandingB">&#8226; Implicit and explicit copy constructors</p>
<p class="indenthandingB">&#8226; Implicit and explicit overloaded assignment operators</p>
<p class="indenthandingB">&#8226; What you must do if you use <code>new</code> in a constructor</p>
<p class="indenthandingB">&#8226; Using <code>static</code> class members</p>
<p class="indenthandingB">&#8226; Using placement <code>new</code> with objects</p>
<p class="indenthandingB">&#8226; Using pointers to objects</p>
<p class="indenthandingB">&#8226; Implementing a queue abstract data type (ADT)</p>
<p>This chapter looks at how to use <code>new</code> and <code>delete</code> with classes and how to deal with some of the subtle problems that using dynamic memory can cause. This may sound like a short list of topics, but these topics affect constructor design, destructor design, and operator overloading.</p>
<p>Let&#8217;s look at a specific example of how C++ can add to your memory load. Suppose you want to create a class with a member that represents someone&#8217;s last name. The simplest, most primitive way is to use a character array member to hold the name. But this has some drawbacks. You might use a 14-character array and then run into Bartholomew Smeadsbury-Crafthovingham. Or to be safer, you might use a 40-character array. But if you then create an array of 2,000 such objects, you&#8217;ll waste a lot of memory with character arrays that are only partly filled. (At that point, you&#8217;re adding to the computer&#8217;s memory load.) There is an alternative.</p>
<p>Often it is much better to decide many matters, such as how much storage to use, when a program runs rather than when it&#8217;s compiled. The usual C++ approach to storing a name in an object is to use the <code>new</code> operator in a class constructor to allocate the correct amount of memory while the program is running. The usual way to accomplish this is to <a id="page_628"/>use the <code>string</code> class, which takes care of the memory management details for you. But you won&#8217;t learn much about memory management that way, so let&#8217;s attack the problem directly. Introducing <code>new</code> to a class constructor raises several new problems unless you remember to take a series of additional steps, such as expanding the class destructor, bringing all constructors into harmony with the <code>new</code> destructor, and writing additional class methods to facilitate correct initialization and assignment. (This chapter, of course, explains all these steps.)</p>
<h3 id="ch12lev1sec1">Dynamic Memory and Classes</h3>
<p>What would you like for breakfast, lunch, and dinner for the next month? How many ounces of milk for dinner on the 3rd day? How many raisins in your cereal for breakfast on the 15th day? If you&#8217;re like most people, you&#8217;d rather postpone some of those decisions until the actual mealtimes. Part of the strategy in C++ is to take the same attitude toward memory allocation, letting the program decide about memory during runtime rather than during compile time. That way, memory use can depend on the needs of a program instead of on a rigid set of storage-class rules. Remember that to gain dynamic control of memory, C++ utilizes the <code>new</code> and <code>delete</code> operators. Unhappily, using these operators with classes can pose some new programming problems. As you&#8217;ll see, destructors can become necessary instead of merely ornamental. And sometimes you have to overload an assignment operator to get a program to behave properly. We&#8217;ll look into these matters now.</p>
<h4 id="ch12lev2sec1">A Review Example and Static Class Members</h4>
<p>We haven&#8217;t used <code>new</code> and <code>delete</code> for a while, so let&#8217;s review them with a short program. While we&#8217;re at it, let&#8217;s look at a new storage class: the static class member. The vehicle will be a <code>StringBad</code> class, later to be superseded by the slightly more able <code>String</code> class. (You&#8217;ve already seen the standard C++ <code>string</code> class, and you&#8217;ll learn more about it in <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library.&#8221; Meanwhile, the humble <code>StringBad</code> and <code>String</code> classes in this chapter provide some insight into what underlies such a class. A lot of programming techniques go into providing such a friendly interface.)</p>
<p><code>StringBad</code> and <code>String</code> class objects will hold a pointer to a string and a value representing the string length. We&#8217;ll use the <code>StringBad</code> and <code>String</code> classes primarily to give an inside look at how <code>new</code>, <code>delete</code>, and <code>static</code> class members operate. For that reason, the constructors and destructors will display messages when called so that you can follow the action. Also we&#8217;ll omit several useful member and friend functions, such as overloaded <code>++</code> and <code>&gt;&gt;</code> operators and a conversion function, in order to simplify the class interface. (But rejoice! The review questions for this chapter give you the opportunity to add those useful support functions.) <a href="#ch12ex01">Listing 12.1</a> shows the class declaration.</p>
<p class="caption1"><a id="page_629"/><a id="ch12ex01"/><strong>Listing 12.1. <code>strngbad.h</code></strong></p><hr/>
<p class="programlisting1">// strngbad.h -- flawed string class definition<br/>#include &lt;iostream&gt;<br/>#ifndef STRNGBAD_H_<br/>#define STRNGBAD_H_<br/>class StringBad<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to string<br/>&#160;&#160;&#160;&#160;int len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// length of string<br/>&#160;&#160;&#160;&#160;static int num_strings;&#160;&#160;&#160;&#160;// number of objects<br/>public:<br/>&#160;&#160;&#160;&#160;StringBad(const char * s); // constructor<br/>&#160;&#160;&#160;&#160;StringBad();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>&#160;&#160;&#160;&#160;~StringBad();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// destructor<br/>// friend function<br/>&#160;&#160;&#160;&#160;friend std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const StringBad &#38; st);<br/>};<br/>#endif</p><hr/>
<p>Why call the class <code>StringBad</code>? This is to remind you that <code>StringBad</code> is an example under development. It&#8217;s the first stage of developing a class by using dynamic memory allocation, and it does the obvious things correctly; for example, it uses <code>new</code> and <code>delete</code> correctly in the constructors and destructor. It doesn&#8217;t really do bad things, but the design omits doing some additional good things that are necessary but not at all obvious. Seeing the problems the class has should help you understand and remember the non-obvious changes you will make later, when you convert it to the more functional <code>String</code> class.</p>
<p>You should note two points about this declaration. First, it uses a pointer-to-<code>char</code> instead of a <code>char</code> array to represent a name. This means that the class declaration does not allocate storage space for the string itself. Instead, it uses <code>new</code> in the constructors to allocate space for the string. This arrangement avoids straitjacketing the class declaration with a predefined limit to the string size.</p>
<p>Second, the definition declares the <code>num_strings</code> member as belonging to the <code>static</code> storage class. A <em>static class member</em> has a special property: A program creates only one copy of a static class variable, regardless of the number of objects created. That is, a static member is shared among all objects of that class, much as a phone number might be shared among all members of a family. If, say, you create 10 <code>StringBad</code> objects, there would be 10 <code>str</code> members and 10 <code>len</code> members, but just 1 shared <code>num_strings</code> member (see <a href="#ch12fig01">Figure 12.1</a>). This is convenient for data that should be private to a class but that should have the same value for all class objects. The <code>num_strings</code> member, for example, is intended to keep track of the number of objects created.</p>
<p class="caption"><a id="page_630"/><a id="ch12fig01"/><strong>Figure 12.1. A static data member.</strong></p>
<p class="image"><img src="graphics/12fig01.jpg" alt="Image"/></p>
<p>By the way, <a href="#ch12ex01">Listing 12.1</a> uses the <code>num_strings</code> member as a convenient means of illustrating static data members and as a device to point out potential programming problems. In general, a string class doesn&#8217;t need such a member.</p>
<p>Take a look at the implementation of the class methods in <a href="#ch12ex02">Listing 12.2</a>. Notice how it handles using a pointer and a static member.</p>
<p class="caption1"><a id="ch12ex02"/><strong>Listing 12.2. <code>strngbad.cpp</code></strong></p><hr/>
<p class="programlisting1">// strngbad.cpp -- StringBad class methods<br/>#include &lt;cstring&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// string.h for some<br/>#include "strngbad.h"<br/>using std::cout;<br/><br/>// initializing static class member<br/>int StringBad::num_strings = 0;<br/><br/>// class methods<br/><br/>// construct StringBad from C string<br/>StringBad::StringBad(const char * s)<br/>{<br/>&#160;&#160;&#160;&#160;len = std::strlen(s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set size<br/>&#160;&#160;&#160;&#160;str = new char[len + 1];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// allot storage<br/>&#160;&#160;&#160;&#160;std::strcpy(str, s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initialize pointer<br/>&#160;&#160;&#160;&#160;num_strings++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set object count<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; num_strings &lt;&lt; ": \"" &lt;&lt; str<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "\" object created\n";&#160;&#160;&#160;&#160;// For Your Information<br/>}<br/><br/>StringBad::StringBad()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>{<br/>&#160;&#160;&#160;&#160;len = 4;<br/>&#160;&#160;&#160;&#160;str = new char[4];<br/>&#160;&#160;&#160;&#160;std::strcpy(str, "C++");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default string<br/>&#160;&#160;&#160;&#160;num_strings++;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; num_strings &lt;&lt; ": \"" &lt;&lt; str<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "\" default object created\n";&#160;&#160;// FYI<br/>}<br/><br/>StringBad::~StringBad()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// necessary destructor<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt; "\" object deleted, ";&#160;&#160;&#160;&#160;// FYI<br/>&#160;&#160;&#160;&#160;--num_strings;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// required<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; num_strings &lt;&lt; " left\n"; // FYI<br/>&#160;&#160;&#160;&#160;delete [] str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// required<br/>}<br/><br/>std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const StringBad &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; st.str;<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p><hr/>
<p><a id="page_631"/>First, notice the following statement from <a href="#ch12ex02">Listing 12.2</a>:</p>
<p class="programlisting">int StringBad::num_strings = 0;</p>
<p>This statement initializes the static <code>num_strings</code> member to <code>0</code>. Note that you cannot initialize a static member variable inside the class declaration. That&#8217;s because the declaration is a description of how memory is to be allocated but it doesn&#8217;t allocate memory. You allocate and initialize memory by creating an object using that format. In the case of a static class member, you initialize the static member independently, with a separate statement outside the class declaration. That&#8217;s because the static class member is stored separately rather than as part of an object. Note that the initialization statement gives the type and uses the scope operator, but it doesn&#8217;t use the static keyword.</p>
<p><a id="page_632"/>This initialization goes in the methods file, not in the class declaration file. That&#8217;s because the class declaration is in a header file, and a program may include a header file in several other files. That would result in multiple copies of the initialization statement, which is an error.</p>
<p>The exception to the noninitialization of a static data member inside the class declaration (see <a href="ch10.html#ch10">Chapter 10</a>, &#8220;<a href="ch10.html#ch10">Objects and Classes</a>&#8221;) is if the static data member is a <code>const</code> of integral or enumeration type.</p>
<div class="note"><hr/>
<p class="title"><a id="ch12note01"/>Note</p>
<p class="notepara">A static data member is declared in the class declaration and is initialized in the file containing the class methods. The scope operator is used in the initialization to indicate to which class the static member belongs. However, if the static member is a <code>const</code> integral type or an enumeration type, it can be initialized in the class declaration itself.</p>
<hr/></div>
<p>Next, notice that each constructor contains the expression <code>num_strings++</code>. This ensures that each time a program creates a new object, the shared variable <code>num_strings</code> increases by one, keeping track of the total number of <code>String</code> objects. Also the destructor contains the expression <code>--num_strings</code>. Thus, the <code>String</code> class also keeps track of deleted objects, keeping the value of the <code>num_strings</code> member current.</p>
<p>Now look at the first constructor in <a href="#ch12ex02">Listing 12.2</a>, which initializes a <code>String</code> object with a regular C string:</p>
<p class="programlisting">StringBad::StringBad(const char * s)<br/>{<br/>&#160;&#160;&#160;&#160;len = std::strlen(s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set size<br/>&#160;&#160;&#160;&#160;str = new char[len + 1];&#160;&#160;&#160;&#160;&#160;&#160;&#160;// allot storage<br/>&#160;&#160;&#160;&#160;std::strcpy(str, s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initialize pointer<br/>&#160;&#160;&#160;&#160;num_strings++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set object count<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; num_strings &lt;&lt; ": \"" &lt;&lt; str<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "\" object created\n"; // For Your Information<br/>}</p>
<p>Recall that the class <code>str</code> member is just a pointer, so the constructor has to provide the memory for holding a string. You can pass a string pointer to the constructor when you initialize an object:</p>
<p class="programlisting">String boston("Boston");</p>
<p>The constructor must then allocate enough memory to hold the string, and then it must copy the string to that location. Let&#8217;s go through the process step-by-step.</p>
<p>First, the function initializes the <code>len</code> member, using the <code>strlen()</code> function to compute the length of the string. Next, it uses <code>new</code> to allocate sufficient space to hold the string, and then it assigns the address of the new memory to the <code>str</code> member. (Recall that <code>strlen()</code> returns the length of a string, not counting the terminating null character, so the constructor adds one to <code>len</code> to allow space for the string, including the null character.)</p>
<p><a id="page_633"/>Next, the constructor uses <code>strcpy()</code> to copy the passed string into the new memory. Then it updates the object count. Finally, to help you monitor what&#8217;s going on, the constructor displays the current number of objects and the string stored in the object. This feature will come in handy later when we deliberately lead the <code>Stringbad</code> class into trouble.</p>
<p>To understand this approach, you should realize that the string is not stored in the object. The string is stored separately, in heap memory, and the object merely stores information that tells where to find the string.</p>
<p>Note that you do not use this:</p>
<p class="programlisting">str = s;&#160;&#160;// not the way to go</p>
<p>This merely stores the address without making a copy of the string.</p>
<p>The default constructor behaves similarly, except that it provides a default string of <code>"C++"</code>.</p>
<p>The destructor contains the example&#8217;s most important addition to the handling of classes:</p>
<p class="programlisting">StringBad::~StringBad()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// necessary destructor<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt; "\" object deleted, ";&#160;&#160;&#160;&#160;// FYI<br/>&#160;&#160;&#160;&#160;--num_strings;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// required<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; num_strings &lt;&lt; " left\n"; // FYI<br/>&#160;&#160;&#160;&#160;delete [] str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// required<br/>}</p>
<p>The destructor begins by announcing when the destructor gets called. This part is informative but not essential. However, the <code>delete</code> statement is vital. Recall that the <code>str</code> member points to memory allocated with <code>new</code>. When a <code>StringBad</code> object expires, the <code>str</code> pointer expires. But the memory <code>str</code> pointed to remains allocated unless you use <code>delete</code> to free it. Deleting an object frees the memory occupied by the object itself, but it does not automatically free memory pointed to by pointers that were object members. For that, you must use the destructor. By placing the <code>delete</code> statement in the destructor, you ensure that the memory that a constructor allocates with <code>new</code> is freed when the object expires.</p>
<div class="note"><hr/>
<p class="title"><a id="ch12note02"/>Warning</p>
<p class="notepara">Whenever you use <code>new</code> in a constructor to allocate memory, you should use <code>delete</code> in the corresponding destructor to free that memory. If you use <code>new []</code> (with brackets), then you should use <code>delete []</code> (with brackets).</p>
<hr/></div>
<p><a href="#ch12ex03">Listing 12.3</a>, which is taken from a program under development at <em>The Daily Vegetable</em>, illustrates when and how the <code>StringBad</code> constructors and destructors work. The program places the object declarations within an inner block because the destructor is called when execution exits the block in which an object is defined. Without the inner block, the destructors would be called after execution exits <code>main()</code>, which would prevent you in some environments from seeing the destructor messages before the execution window closes. Be sure to compile <a href="#ch12ex02">Listing 12.2</a> along with <a href="#ch12ex03">Listing 12.3</a>.</p>
<p class="caption1"><a id="page_634"/><a id="ch12ex03"/><strong>Listing 12.3. <code>vegnews.cpp</code></strong></p><hr/>
<p class="programlisting1">// vegnews.cpp -- using new and delete with classes<br/>// compile with strngbad.cpp<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>#include "strngbad.h"<br/><br/>void callme1(StringBad &#38;);&#160;&#160;// pass by reference<br/>void callme2(StringBad);&#160;&#160;&#160;&#160;// pass by value<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Starting an inner block.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;StringBad headline1("Celery Stalks at Midnight");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;StringBad headline2("Lettuce Prey");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;StringBad sports("Spinach Leaves Bowl for Dollars");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "headline1: " &lt;&lt; headline1 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "headline2: " &lt;&lt; headline2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "sports: " &lt;&lt; sports &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;callme1(headline1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "headline1: " &lt;&lt; headline1 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;callme2(headline2);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "headline2: " &lt;&lt; headline2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Initialize one object to another:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;StringBad sailor = sports;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "sailor: " &lt;&lt; sailor &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Assign one object to another:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;StringBad knot;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;knot = headline1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "knot: " &lt;&lt; knot &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Exiting the block.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "End of main()\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void callme1(StringBad &#38; rsb)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "String passed by reference:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;&#160;&#160;\"" &lt;&lt; rsb &lt;&lt; "\"\n";<br/>}<br/><br/>void callme2(StringBad sb)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "String passed by value:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;&#160;&#160;\"" &lt;&lt; sb &lt;&lt; "\"\n";<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch12note03"/><a id="page_635"/>Note</p>
<p class="notepara">This first draft of a design for <code>StringBad</code> has some deliberate flaws that make the exact output undefined. Some compilers I used, for example, produced versions that aborted before completing. However, although the output details may differ, the basic problems and solutions (soon to be revealed!) are the same.</p>
<hr/></div>
<p>Here is the output produced after compiling the program in <a href="#ch12ex03">Listing 12.3</a> with the Borland C++ 5.5 command-line compiler:</p>
<p class="programlisting">Starting an inner block.<br/>1: "Celery Stalks at Midnight" object created<br/>2: "Lettuce Prey" object created<br/>3: "Spinach Leaves Bowl for Dollars" object created<br/>headline1: Celery Stalks at Midnight<br/>headline2: Lettuce Prey<br/>sports: Spinach Leaves Bowl for Dollars<br/>String passed by reference:<br/>&#160;&#160;&#160;&#160;"Celery Stalks at Midnight"<br/>headline1: Celery Stalks at Midnight<br/>String passed by value:<br/>&#160;&#160;&#160;&#160;"Lettuce Prey"<br/>"Lettuce Prey" object deleted, 2 left<br/>headline2: D&#251;&#176;<br/>Initialize one object to another:<br/>sailor: Spinach Leaves Bowl for Dollars<br/>Assign one object to another:<br/>3: "C++" default object created<br/>knot: Celery Stalks at Midnight<br/>Exiting the block.<br/>"Celery Stalks at Midnight" object deleted, 2 left<br/>"Spinach Leaves Bowl for Dollars" object deleted, 1 left<br/>"Spinach Leaves Bowl for Doll8" object deleted, 0 left<br/>"@g" object deleted, -1 left<br/>"-|" object deleted, -2 left<br/>End of main()</p>
<p>The various nonstandard characters that appear in the output will vary from system to system; they are one of the signs that <code>StringBad</code> deserves to be called bad. Another sign is the negative object count. Newer compiler/operating system combinations typically abort the program just before displaying the line about having -1 objects left, and some of them report a General Protection Fault (GPF). A GPF indicates that a program tried to access a memory location forbidden to it; this is another bad sign.</p>
<h5 id="ch12lev3sec1">Program Notes</h5>
<p><a id="page_636"/>The program in <a href="#ch12ex03">Listing 12.3</a> starts out fine, but it staggers to a strange and ultimately disastrous conclusion. Let&#8217;s begin by looking at the good parts. The constructor announces that it has created three <code>StringBad</code> objects, it numbers them, and the program uses the overloaded <code>&lt;&lt;</code> operator to list them:</p>
<p class="programlistingB">1: "Celery Stalks at Midnight" object created<br/>2: "Lettuce Prey" object created<br/>3: "Spinach Leaves Bowl for Dollars" object created<br/>headline1: Celery Stalks at Midnight<br/>headline2: Lettuce Prey<br/>sports: Spinach Leaves Bowl for Dollars</p>
<p>Then the program passes <code>headline1</code> to the <code>callme1()</code> function and redisplays <code>headline1</code> after the call. Here&#8217;s the code:</p>
<p class="programlisting">callme1(headline1);<br/>cout &lt;&lt; "headline1: " &lt;&lt; headline1 &lt;&lt; endl;</p>
<p>And here&#8217;s the result:</p>
<p class="programlisting">String passed by reference:<br/>&#160;&#160;&#160;&#160;"Celery Stalks at Midnight"<br/>headline1: Celery Stalks at Midnight</p>
<p>This section of code seems to work fine, too.</p>
<p>But then the program executes the following code:</p>
<p class="programlisting">callme2(headline2);<br/>cout &lt;&lt; "headline2: " &lt;&lt; headline2 &lt;&lt; endl;</p>
<p>Here, <code>callme2()</code> passes <code>headline2</code> by value instead of by reference, and the result indicates a serious problem:</p>
<p class="programlisting">String passed by value:<br/>&#160;&#160;&#160;&#160;"Lettuce Prey"<br/>"Lettuce Prey" object deleted, 2 left<br/>headline2: D&#251;&#176;</p>
<p>First, passing <code>headline2</code> as a function argument somehow causes the destructor to be called. Second, although passing by value is supposed to protect the original argument from change, the function messes up the original string beyond recognition, and some nonstandard characters get displayed. (The exact text displayed will depend on what happens to sitting in memory.)</p>
<p>Even worse, look at the end of the output when the destructor gets called automatically for each of the objects created earlier:</p>
<p class="programlisting">Exiting the block.<br/>"Celery Stalks at Midnight" object deleted, 2 left<br/>"Spinach Leaves Bowl for Dollars" object deleted, 1 left<br/>"Spinach Leaves Bowl for Doll8" object deleted, 0 left<br/><a id="page_637"/>"@g" object deleted, -1 left<br/>"-|" object deleted, -2 left<br/>End of main()</p>
<p>Because automatic storage objects are deleted in an order opposite to that in which they are created, the first three objects deleted are <code>knots</code>, <code>sailor</code>, and <code>sport</code>. The <code>knots</code> and <code>sailor</code> deletions look okay, but for <code>sport</code>, <code>Dollars</code> has become <code>Doll8</code>. The only thing the program does with <code>sport</code> is use it to initialize <code>sailor</code>, but that act appears to have altered <code>sport</code>. And the last two objects deleted, <code>headline2</code> and <code>headline1</code>, are unrecognizable. Something messes up these strings before they are deleted. Also the counting is bizarre. How can there be -2 objects left?</p>
<p>Actually, the peculiar counting is a clue. Every object is constructed once and destroyed once, so the number of constructor calls should equal the number of destructor calls. Because the object count (<code>num_strings</code>) is decremented two times more than it is incremented, a constructor that doesn&#8217;t increment <code>num_strings</code> must be creating two objects. The class definition declares and defines two constructors (both of which increment <code>num_strings</code>), but it turns out that the program uses three constructors! For example, consider this line:</p>
<p class="programlisting">StringBad sailor = sports;</p>
<p>What constructor is used here? Not the default constructor, and not the constructor with a <code>const char *</code> parameter. Remember, initialization using this form is another syntax for the following:</p>
<p class="programlisting">StringBad sailor = StringBad(sports); //constructor using sports</p>
<p>Because <code>sports</code> is type <code>StringBad</code>, a matching constructor could have this prototype:</p>
<p class="programlistingB">StringBad(const StringBad &#38;);</p>
<p>And it turns out that the compiler automatically generates this constructor (called a <em>copy constructor</em> because it makes a copy of an object) if you initialize one object to another. The automatic version would not know about updating the <code>num_strings</code> static variable, so it would mess up the counting scheme. Indeed, all the problems exhibited by this example stem from member functions that the compiler generates automatically, so let&#8217;s look at that topic now.</p>
<h4 id="ch12lev2sec2">Special Member Functions</h4>
<p>The problems with the <code>StringBad</code> class stem from <em>special member functions</em>. These are member functions that are defined automatically. In the case of <code>StringBad</code>, the behavior of these member functions is inappropriate to this particular class design. In particular, C++ automatically provides the following member functions:</p>
<p class="indenthandingB">&#8226; A default constructor if you define no constructors</p>
<p class="indenthandingB">&#8226; A default destructor if you don&#8217;t define one</p>
<p class="indenthandingB">&#8226; A copy constructor if you don&#8217;t define one</p>
<p class="indenthandingB">&#8226; <a id="page_638"/>An assignment operator if you don&#8217;t define one</p>
<p class="indenthandingB">&#8226; An address operator if you don&#8217;t define one</p>
<p>More precisely, the compiler generates definitions for the last three items if a program uses objects in such a way as to require them. For example, if you assign one object to another, the program provides a definition for the assignment operator.</p>
<p>It turns out that the implicit copy constructor and the implicit assignment operator cause the <code>StringBad</code> class problems.</p>
<p>The implicit address operator returns the address of the invoking object (that is, the value of the <code>this</code> pointer). That&#8217;s fine for our purposes, and we won&#8217;t discuss this member function further. The default destructor does nothing, and we won&#8217;t discuss it, either, other than to point out that the class has already provided a substitute for it. But the others do warrant more discussion.</p>
<p>C++11 provides two more special member functions&#8212;the <em>move constructor</em> and the <em>move assignment operator</em>. <a href="ch18.html#ch18">Chapter 18</a>, &#8220;<a href="ch18.html#ch18">Visiting with the New C++ Standard</a>,&#8221; discusses these further.</p>
<h5 id="ch12lev3sec2">Default Constructors</h5>
<p>If you fail to provide any constructors at all, C++ provides you with a default constructor. For example, suppose you define a <code>Klunk</code> class and omit any constructors. In this case, the compiler supplies the following default:</p>
<p class="programlisting">Klunk::Klunk() { }&#160;&#160;// implicit default constructor</p>
<p>That is, it supplies a constructor (the <em>defaulted</em> default constructor) that takes no arguments and that does nothing. It&#8217;s needed because creating an object always invokes a constructor:</p>
<p class="programlisting">Klunk lunk;&#160;&#160;// invokes default constructor</p>
<p>The default constructor makes <code>lunk</code> like an ordinary automatic variable; that is, its value at initialization is unknown.</p>
<p>After you define any constructor, C++ doesn&#8217;t bother to define a default constructor. If you want to create objects that aren&#8217;t initialized explicitly, you then have to define a default constructor explicitly. It&#8217;s a constructor with no arguments, but you can use it to set particular values:</p>
<p class="programlisting">Klunk::Klunk()&#160;&#160;// explicit default constructor<br/>{<br/>&#160;&#160;&#160;&#160;klunk_ct = 0;<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>A constructor with arguments still can be a default constructor if all its arguments have default values. For example, the <code>Klunk</code> class could have the following inline constructor:</p>
<p class="programlisting">Klunk(int n = 0) { klunk_ct = n; }</p>
<p><a id="page_639"/>However, you can have only one default constructor. That is, you can&#8217;t do this:</p>
<p class="programlisting">Klunk() { klunk_ct = 0 }&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// constructor #1<br/>Klunk(int n = 0) { klunk_ct = n; }&#160;&#160;&#160;// ambiguous constructor #2</p>
<p>Why is this ambiguous? Consider the following two declarations:</p>
<p class="programlisting">Klunk kar(10);&#160;&#160;&#160;&#160;// clearly matches Klunt(int n)<br/>Klunk bus;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// could match either constructor</p>
<p>The second declaration matches constructor #1 (no argument), but it also matches constructor #2 (using the default argument <code>0</code>). This will cause the compiler to issue an error message.</p>
<h5 id="ch12lev3sec3">Copy Constructors</h5>
<p>A copy constructor is used to copy an object to a newly created object. That is, it&#8217;s used during initialization, including passing function arguments by value and not during ordinary assignment. A copy constructor for a class normally has this prototype:</p>
<p class="programlisting"><span class="EmpItalic">Class_name</span>(const <span class="EmpItalic">Class_name</span> &#38;);</p>
<p>Note that it takes a constant reference to a class object as its argument. For example, a copy constructor for the <code>String</code> class would have this prototype:</p>
<p class="programlisting">StringBad(const StringBad &#38;);</p>
<p>You must know two things about a copy constructor: when it&#8217;s used and what it does.</p>
<h6 id="ch12lev4sec1">When a Copy Constructor Is Used</h6>
<p>A copy constructor is invoked whenever a new object is created and initialized to an existing object of the same kind. This happens in several situations. The most obvious situation is when you explicitly initialize a new object to an existing object. For example, given that <code>motto</code> is a <code>StringBad</code> object, the following four defining declarations invoke a copy constructor:</p>
<p class="programlistingB">StringBad ditto(motto);&#160;&#160;// calls StringBad(const StringBad &#38;)<br/>StringBad metoo = motto; // calls StringBad(const StringBad &#38;)<br/>StringBad also = StringBad(motto);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls StringBad(const StringBad &#38;)<br/>StringBad * pStringBad = new StringBad(motto);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls StringBad(const StringBad &#38;)</p>
<p>Depending on the implementation, the middle two declarations may use a copy constructor directly to create <code>metoo</code> and <code>also</code>, or they may use a copy constructor to generate temporary objects whose contents are then assigned to <code>metoo</code> and <code>also</code>. The last example initializes an anonymous object to <code>motto</code> and assigns the address of the new object to the <code>pstring</code> pointer.</p>
<p>Less obviously, a compiler uses a copy constructor whenever a program generates copies of an object. In particular, it&#8217;s used when a function passes an object by value (as <code>callme2()</code> does in <a href="#ch12ex03">Listing 12.3</a>) or when a function returns an object. Remember, passing <a id="page_640"/>by value means creating a copy of the original variable. A compiler also uses a copy constructor whenever it generates temporary objects. For example, a compiler might generate a temporary <code>Vector</code> object to hold an intermediate result when adding three <code>Vector</code> objects. Compilers vary as to when they generate temporary objects, but all invoke a copy constructor when passing objects by value and when returning them. In particular, this function call in <a href="#ch12ex03">Listing 12.3</a> invokes a copy constructor:</p>
<p class="programlisting">callme2(headline2);</p>
<p>The program uses a copy constructor to initialize <code>sb</code>, the formal <code>StringBad</code>-type parameter for the <code>callme2()</code> function.</p>
<p>By the way, the fact that passing an object by value involves invoking a copy constructor is a good reason for passing by reference instead. That saves the time of invoking the constructor and the space for storing the new object.</p>
<h6 id="ch12lev4sec2">What a Default Copy Constructor Does</h6>
<p>The default copy constructor performs a member-by-member copy of the nonstatic members (<em>memberwise copying</em>, also sometimes called <em>shallow copying</em>). Each member is copied by value. In <a href="#ch12ex03">Listing 12.3</a>, the statement</p>
<p class="programlisting">StringBad sailor = sports;</p>
<p>amounts to the following (aside from the fact that it doesn&#8217;t compile because access to private members is not allowed):</p>
<p class="programlisting">StringBad sailor;<br/>sailor.str = sports.str;<br/>sailor.len = sports.len;</p>
<p>If a member is itself a class object, the copy constructor for that class is used to copy one member object to another. Static members, such as <code>num_strings</code>, are unaffected because they belong to the class as a whole instead of to individual objects. <a href="#ch12fig02">Figure 12.2</a> illustrates the action of an implicit copy constructor.</p>
<p class="caption"><a id="ch12fig02"/><strong>Figure 12.2. An inside look at memberwise copying.</strong></p>
<p class="image"><img src="graphics/12fig02.jpg" alt="Image"/></p>
<h4 id="ch12lev2sec3">Back to Stringbad: Where the Copy Constructor Goes Wrong</h4>
<p>You are now in a position to understand the twofold weirdness of <a href="#ch12ex03">Listing 12.3</a>. (Let&#8217;s assume that the output is the one shown after the listing.) The first weirdness is that the program output indicates two more objects destroyed than constructed. The explanation is that the program does create two additional objects, using the default copy constructor. The copy constructor is used to initialize the formal parameter of <code>callme2()</code> when that function is called, and it is used to initialize the object <code>sailor</code> to <code>sports</code>. The default copy constructor doesn&#8217;t vocalize its activities, so it doesn&#8217;t announce its creations, and it doesn&#8217;t increment the <code>num_strings</code> counter. However, the destructor does update the count, and it&#8217;s invoked upon the demise of all objects, regardless of how they were constructed. This weirdness is a problem because it means the program doesn&#8217;t keep an accurate object count. The solution is to provide an explicit copy constructor that does update the count:</p>
<p class="programlisting"><a id="page_641"/>StringBad::StringBad(const String &#38; s)<br/>{<br/>&#160;&#160;&#160;&#160;num_strings++;<br/>&#160;&#160;&#160;&#160;...// important stuff to go here<br/>}</p>
<div class="note"><hr/>
<p class="title"><a id="ch12note04"/>Tip</p>
<p class="notepara">If your class has a static data member whose value changes when new objects are created, you should provide an explicit copy constructor that handles the accounting.</p>
<hr/></div>
<p><a id="page_642"/>The second weirdness is the more subtle and dangerous. One symptom is the garbled string contents:</p>
<p class="programlisting">headline2: D&#251;&#176;</p>
<p>The cause is that the implicit copy constructor copies by value. Consider <a href="#ch12ex03">Listing 12.3</a>, for example. The effect, recall, is this:</p>
<p class="programlisting">sailor.str = sport.str;</p>
<p>This does not copy the string; it copies the pointer to a string. That is, after <code>sailor</code> is initialized to <code>sports</code>, you wind up with two pointers to the same string. That&#8217;s not a problem when the <code>operator&lt;&lt;()</code> function uses the pointer to display the string. It <em>is</em> a problem when the destructor is called. Recall that the <code>StringBad</code> destructor frees the memory pointed to by the <code>str</code> pointer. The effect of destroying <code>sailor</code> is this:</p>
<p class="programlistingB">delete [] sailor.str;&#160;&#160;&#160;&#160;// delete the string that ditto.str points to</p>
<p>The <code>sailor.str</code> pointer points to <code>"Spinach Leaves Bowl for Dollars"</code> because it is assigned the value of <code>sports.str</code>, which points to that string. So the <code>delete</code> statement frees the memory occupied by the string <code>"Spinach Leaves Bowl for Dollars"</code>.</p>
<p>Next, the effect of destroying <code>sports</code> is this:</p>
<p class="programlisting">delete [] sports.str;&#160;&#160;&#160;// effect is undefined</p>
<p>Here, <code>sports.str</code> points to the same memory location that has already been freed by the destructor for <code>sailor</code>, and this results in undefined, possibly harmful, behavior. In the case of <a href="#ch12ex03">Listing 12.3</a>, the program produces mangled strings, which is usually a sign of memory mismanagement.</p>
<p>Another disturbing symptom is that attempting to delete the same memory twice can cause the program to abort. Microsoft Visual C++ 2010 (debug mode), for example, displays an error message window saying &#8220;Debug Assertion Failed!&#8221;, and g++ 4.4.1 on Linux reports &#8220;double free or corruption&#8221; and aborts. Other systems might provide different messages or even no message, but the same evil lurks within the programs.</p>
<h5 id="ch12lev3sec4">Fixing the Problem by Defining an Explicit Copy Constructor</h5>
<p>The cure for the problems in the class design is to make a <em>deep copy</em>. That is, rather than just copy the address of the string, the copy constructor should duplicate the string and assign the address of the duplicate to the <code>str</code> member. That way, each object gets its own string rather than referring to another object&#8217;s string. And each call of the destructor frees a different string rather than making duplicate attempts at freeing the same string. Here&#8217;s how you can code the <code>String</code> copy constructor:</p>
<p class="programlisting">StringBad::StringBad(const StringBad &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;num_strings++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// handle static member update<br/>&#160;&#160;&#160;&#160;len = st.len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// same length<br/>&#160;&#160;&#160;&#160;str = new char [len + 1];&#160;&#160;// allot space<br/>&#160;&#160;&#160;&#160;std::strcpy(str, st.str);&#160;&#160;// copy string to new location<br/><a id="page_643"/>&#160;&#160;&#160;&#160;cout &lt;&lt; num_strings &lt;&lt; ": \"" &lt;&lt; str<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "\" object created\n"; // For Your Information<br/>}</p>
<p>What makes defining the copy constructor necessary is the fact that some class members are <code>new</code>-initialized pointers to data rather than the data themselves. <a href="#ch12fig03">Figure 12.3</a> illustrates deep copying.</p>
<p class="caption"><a id="ch12fig03"/><strong>Figure 12.3. An inside look at deep copying.</strong></p>
<p class="image"><img src="graphics/12fig03.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch12note05"/><a id="page_644"/>Caution</p>
<p class="notepara">If a class contains members that are pointers initialized by <code>new</code>, you should define a copy constructor that copies the pointed-to data instead of copying the pointers themselves. This is termed <em>deep copying</em>. The alternative form of copying (<em>memberwise</em>, or <em>shallow</em>, <em>copying</em>) just copies pointer values. A shallow copy is just that&#8212;the shallow &#8220;scraping off&#8221; of pointer information for copying, rather than the deeper &#8220;mining&#8221; required to copy the constructs referred to by the pointers.</p>
<hr/></div>
<h4 id="ch12lev2sec4">More <code>Stringbad</code> Problems: Assignment Operators</h4>
<p>Not all the problems in <a href="#ch12ex03">Listing 12.3</a> can be blamed on the default copy constructor; you have to look at the default assignment operator, too. Just as ANSI C allows structure assignment, C++ allows class object assignment. It does so by automatically overloading an assignment operator for a class. This operator has the following prototype:</p>
<p class="programlisting"><span class="EmpItalic">Class_name</span> &#38; <span class="EmpItalic">Class_name</span>::operator=(const <span class="EmpItalic">Class_name</span> &#38;);</p>
<p>That is, it takes and returns a reference to an object of the class. For example, here&#8217;s the prototype for the <code>StringBad</code> class:</p>
<p class="programlistingB">StringBad &#38; StringBad::operator=(const StringBad &#38;);</p>
<h5 id="ch12lev3sec5">When an Assignment Operator Is Used and What It Does</h5>
<p>An overloaded assignment operator is used when you assign one object to another existing object:</p>
<p class="programlisting">StringBad headline1("Celery Stalks at Midnight");<br/>...<br/>StringBad knot;<br/>knot = headline1;&#160;&#160;&#160;// assignment operator invoked</p>
<p>An assignment operator is not necessarily used when initializing an object:</p>
<p class="programlisting">StringBad metoo = knot; // use copy constructor, possibly assignment, too</p>
<p>Here <code>metoo</code> is a newly created object being initialized to <code>knot</code>&#8217;s values; hence, the copy constructor is used. However, as mentioned before, implementations have the option of handling this statement in two steps: using the copy constructor to create a temporary object and then using assignment to copy the values to the new object. That is, initialization always invokes a copy constructor, and forms using the <code>=</code> operator may also invoke an assignment operator.</p>
<p>Like a copy constructor, an implicit implementation of an assignment operator performs a member-to-member copy. If a member is itself an object of some class, the program uses the assignment operator defined for that class to do the copying for that particular member. Static data members are unaffected.</p>
<h5 id="ch12lev3sec6">Where <code>Stringbad</code> Assignment Goes Wrong</h5>
<p><a id="page_645"/><a href="#ch12ex03">Listing 12.3</a> assigns <code>headline1</code> to <code>knot</code>:</p>
<p class="programlisting">knot = headline1;</p>
<p>When the destructor is called for <code>knot</code>, it displays this message:</p>
<p class="programlisting">"Celery Stalks at Midnight" object deleted, 2 left</p>
<p>When the destructor is called for <code>headline1</code>, it displays this message:</p>
<p class="programlisting">"-|" object deleted, -2 left</p>
<p>(Many implementations abort before getting this far.)</p>
<p>Here you see the same problem that the implicit copy constructor caused: corrupted data. Once again, the problem is memberwise copying, which causes both <code>headline1.str</code> and <code>knot.str</code> to point to the same address. Thus, when the destructor is called for <code>knot</code>, it deletes the string <code>"Celery Stalks at Midnight"</code>, and when it&#8217;s called for <code>headline1</code>, it attempts to delete the previously deleted string. As mentioned earlier, the effect of attempting to delete previously deleted data is undefined, so it may change the memory contents, and it may cause a program to abort. As some like to point out, if the effect of a particular operation is undefined, your compiler can do anything it wants, including displaying the Declaration of Independence or freeing your hard disk of unsightly files. Of course, it would be a rare thing for a compiler writer to take the time to include such frivolous or destructive behavior.</p>
<h5 id="ch12lev3sec7">Fixing Assignment</h5>
<p>The solution for the problems created by an inappropriate default assignment operator is to provide your own assignment operator definition, one that makes a deep copy. The implementation is similar to that of the copy constructor, but there are some differences:</p>
<p class="indenthandingB">&#8226; Because the target object may already refer to previously allocated data, the function should use <code>delete []</code> to free former obligations.</p>
<p class="indenthandingB">&#8226; The function should protect against assigning an object to itself; otherwise, the freeing of memory described previously could erase the object&#8217;s contents before they are reassigned.</p>
<p class="indenthandingB">&#8226; The function returns a reference to the invoking object.</p>
<p>By returning an object, the function can emulate the way ordinary assignment for built-in types can be chained. That is, if <code>S0</code>, <code>S1</code>, and <code>S2</code> are <code>StringBad</code> objects, you can write the following:</p>
<p class="programlistingB">S0 = S1 = S2;</p>
<p>In function notation, this becomes the following:</p>
<p class="programlisting">S0.operator=(S1.operator=(S2));</p>
<p><a id="page_646"/>Thus, the return value of <code>S1.operator=(S2)</code> becomes the argument of the <code>S0.operator=()</code> function. Because the return value is a reference to a <code>String</code> object, it is the correct argument type.</p>
<p>Here&#8217;s how you could write an assignment operator for the <code>StringBad</code> class:</p>
<p class="programlistingB">StringBad &#38; StringBad::operator=(const StringBad &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;st)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// object assigned to itself<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// all done<br/>&#160;&#160;&#160;&#160;delete [] str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free old string<br/>&#160;&#160;&#160;&#160;len = st.len;<br/>&#160;&#160;&#160;&#160;str = new char [len + 1];&#160;&#160;// get space for new string<br/>&#160;&#160;&#160;&#160;std::strcpy(str, st.str);&#160;&#160;// copy the string<br/>&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// return reference to invoking object<br/>}</p>
<p>First, the code checks for self-assignment. It does so by seeing if the address of the right-hand side of the assignment (<code>&#38;s</code>) is the same as the address of the receiving object (<code>this</code>). If so, the program returns <code>*this</code> and terminates. You may recall from <a href="ch10.html#ch10">Chapter 10</a> that the assignment operator is one of the operators that can be overloaded only by a class member function.</p>
<p>Otherwise, the function proceeds to free the memory that <code>str</code> pointed to. The reason for this is that shortly thereafter <code>str</code> will be assigned the address of a new string. If you don&#8217;t first apply the <code>delete</code> operator, the previous string will remain in memory. Because the program no longer has a pointer to the old string, that memory will be wasted.</p>
<p>Next, the program proceeds like a copy constructor, allocating enough space for the new string and then copying the string from the right-hand object to the new location.</p>
<p>When it is finished, the program returns <code>*this</code> and terminates.</p>
<p>Assignment does not create a new object, so you don&#8217;t have to adjust the value of the static data member <code>num_strings</code>.</p>
<p>Adding the copy constructor and the assignment operator described previously to the <code>StringBad</code> class clears up all the problems. Here, for example, are the last few lines of output after these changes have been made:</p>
<p class="programlistingB">End of main()<br/>"Celery Stalks at Midnight" object deleted, 4 left<br/>"Spinach Leaves Bowl for Dollars" object deleted, 3 left<br/>"Spinach Leaves Bowl for Dollars" object deleted, 2 left<br/>"Lettuce Prey" object deleted, 1 left<br/>"Celery Stalks at Midnight" object deleted, 0 left</p>
<p>The object counting is correct now, and none of the strings have been mangled.</p>
<h3 id="ch12lev1sec2">The New, Improved <code>String</code> Class</h3>
<p><a id="page_647"/>Now that we are a bit wiser, we can revise the <code>StringBad</code> class, renaming it <code>String</code>. First, add the copy constructor and the assignment operator just discussed so that the class correctly manages the memory used by class objects. Next, now that you&#8217;ve seen when objects are constructed and destroyed, we can mute the class constructors and destructors so that they no longer announce each time they are used. Also now that you&#8217;re no longer watching the constructors at work, we can simplify the default constructor so that it constructs an empty string instead of <code>"C++"</code>.</p>
<p>Next, we can add a few capabilities to the class. A useful <code>String</code> class would incorporate all the functionality of the standard <code>cstring</code> library of string functions, but we&#8217;ll add only enough to see what happens. (Keep in mind that this <code>String</code> class is an illustrative example and that the C++ standard <code>string</code> class is much more extensive.) In particular, we&#8217;ll add the following methods:</p>
<p class="programlisting">int length () const { return len; }<br/>friend bool operator&lt;(const String &#38;st, const String &#38;st2);<br/>friend bool operator&gt;(const String &#38;st1, const String &#38;st2);<br/>friend bool operator==(const String &#38;st, const String &#38;st2);<br/>friend operator&gt;&gt;(istream &#38; is, String &#38; st);<br/>char &#38; operator[](int i);<br/>const char &#38; operator[](int i) const;<br/>static int HowMany();</p>
<p>The first new method returns the length of the stored string. The next three friend functions allow you to compare strings. The <code>operator&gt;&gt;()</code> function provides simple input capabilities. The two <code>operator[]()</code> functions provide array-notation access to individual characters in a string. The static class method <code>HowMany()</code> complements the static class data member <code>num_strings</code>. Let&#8217;s look at some details.</p>
<h4 id="ch12lev2sec5">The Revised Default Constructor</h4>
<p>The new default constructor merits notice. It look likes this:</p>
<p class="programlisting">String::String()<br/>{<br/>&#160;&#160;&#160;&#160;len = 0;<br/>&#160;&#160;&#160;&#160;str = new char[1];<br/>&#160;&#160;&#160;&#160;str[0] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default string<br/>}</p>
<p>You might wonder why the code uses</p>
<p class="programlisting">str = new char[1];</p>
<p>and not this:</p>
<p class="programlisting">str = new char;</p>
<p><a id="page_648"/>Both forms allocate the same amount of memory. The difference is that the first form is compatible with the class destructor and the second is not. Recall that the destructor contains this code:</p>
<p class="programlisting">delete [] str;</p>
<p>Using <code>delete []</code> is compatible with pointers initialized by using <code>new []</code> and with the null pointer. So another possibility would be to replace</p>
<p class="programlisting">str = new char[1];<br/>str[0] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default string</p>
<p>with this:</p>
<p class="programlisting">str = 0; // sets str to the null pointer</p>
<p>The effect of using <code>delete []</code> with any pointers initialized any other way is undefined:</p>
<p class="programlisting">char words[15] = "bad idea";<br/>char * p1= words;<br/>char * p2 = new char;<br/>char * p3;<br/>delete [] p1; // undefined, so don't do it<br/>delete [] p2; // undefined, so don't do it<br/>delete [] p3; // undefined, so don't do it</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch12sb01"/>C++11 Null Pointer</p>
<p class="sidebarpara">In C++98, the literal <code>0</code> has two meanings&#8212;it can be the numeric value <code>0</code>, and it can be the null pointer&#8212;thus making it difficult for the reader and compiler to distinguish between the two. Sometimes programmers use <code>(void *) 0</code> to identify the pointer version. (The null pointer itself may have a nonzero internal representation.) Other programmers use NULL, a C macro defined to represent the null pointer. However, this proved to be an incomplete solution. C++11 provides a better solution by introducing a new keyword, <code>nullptr</code>, to denote the null pointer. You still can use <code>0</code> as before&#8212;otherwise an enormous amount of existing code would be invalidated&#8212;but henceforth the recommendation is to use <code>nullptr</code> instead:</p>
<p class="programlistingB">str = nullptr;&#160;&#160;// C++11 null pointer notation</p>
<hr/></div>
<h4 id="ch12lev2sec6">Comparison Members</h4>
<p>Three of the methods in the <code>String</code> class perform comparisons. The <code>operator&lt;()</code> function returns <code>true</code> if the first string comes before the second string alphabetically (or, more precisely, in the machine collating sequence). The simplest way to implement the string comparison functions is to use the standard <code>strcmp()</code> function, which returns a negative value if its first argument precedes the second alphabetically, <code>0</code> if the strings are the same, and a positive value if the first follows the second alphabetically. So you can use <code>strcmp()</code> like this:</p>
<p class="programlisting">bool operator&lt;(const String &#38;st1, const String &#38;st2)<br/>{<br/>&#160;&#160;&#160;&#160;if (std::strcmp(st1.str, st2.str) &lt; 0)<br/><a id="page_649"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}</p>
<p>Because the built-in <code>&lt;</code> operator already returns a type <code>bool</code> value, you can simplify the code further to this:</p>
<p class="programlisting">bool operator&lt;(const String &#38;st1, const String &#38;st2)<br/>{<br/>&#160;&#160;&#160;&#160;return (std::strcmp(st1.str, st2.str) &lt; 0);<br/>}</p>
<p>Similarly, you can code the other two comparison functions like this:</p>
<p class="programlisting">bool operator&gt;(const String &#38;st1, const String &#38;st2)<br/>{<br/>&#160;&#160;&#160;&#160;return st2 &lt; st1;<br/>}<br/>bool operator==(const String &#38;st1, const String &#38;st2)<br/>{<br/>&#160;&#160;&#160;&#160;return (std::strcmp(st1.str, st2.str) == 0);<br/>}</p>
<p>The first definition expresses the <code>&gt;</code> operator in terms of the <code>&lt;</code> operator and would be a good choice for an inline function.</p>
<p>Making the comparison functions friends facilitates comparisons between <code>String</code> objects and regular C strings. For example, suppose <code>answer</code> is a <code>String</code> object and that you have the following code:</p>
<p class="programlisting">if ("love" == answer)</p>
<p>This gets translated to the following:</p>
<p class="programlisting">if (operator==("love", answer))</p>
<p>The compiler then uses one of the constructors to convert the code, in effect, to this:</p>
<p class="programlisting">if (operator==(String("love"), answer))</p>
<p>And this matches the prototype.</p>
<h4 id="ch12lev2sec7">Accessing Characters by Using Bracket Notation</h4>
<p>With a standard C-style string, you can use brackets to access individual characters:</p>
<p class="programlisting">char city[40] = "Amsterdam";<br/>cout &lt;&lt; city[0] &lt;&lt; endl; // display the letter A</p>
<p>In C++ the two bracket symbols constitute a single operator, the bracket operator, and you can overload this operator by using a method called <code>operator[]()</code>. Typically, a binary C++ operator (one with two operands) puts the operator between the two operands, as in <code>2 + 5</code>. But the bracket operator places one operand in front of the first bracket and the <a id="page_650"/>other operand between the two brackets. Thus, in the expression <code>city[0]</code>, <code>city</code> is the first operand, <code>[]</code> is the operator, and <code>0</code> is the second operand.</p>
<p>Suppose that <code>opera</code> is a <code>String</code> object:</p>
<p class="programlisting">String opera("The Magic Flute");</p>
<p>If you use the expression <code>opera[4]</code>, C++ looks for a method with this name and signature:</p>
<p class="programlisting">String::operator[](int i)</p>
<p>If it finds a matching prototype, the compiler replaces the expression <code>opera[4]</code> with this function call:</p>
<p class="programlisting">opera.operator[](4)</p>
<p>The <code>opera</code> object invokes the method, and the array subscript <code>4</code> becomes the function argument.</p>
<p>Here&#8217;s a simple implementation:</p>
<p class="programlisting">char &#38; String::operator[](int i)<br/>{<br/>&#160;&#160;&#160;&#160;return str[i];<br/>}</p>
<p>With this definition, the statement</p>
<p class="programlisting">cout &lt;&lt; opera[4];</p>
<p>becomes this:</p>
<p class="programlisting">cout &lt;&lt; opera.operator[4];</p>
<p>The return value is <code>opera.str[4]</code>, or the character <code>'M'</code>. So the public method gives access to private data.</p>
<p>Declaring the return type as type <code>char &#38;</code> allows you to assign values to a particular element. For example, you can use the following:</p>
<p class="programlisting">String means("might");<br/>means[0] = 'r';</p>
<p>The second statement is converted to an overloaded operator function call:</p>
<p class="programlisting">means.operator[][0] = 'r';</p>
<p>This assigns <code>'r'</code> to the method&#8217;s return value. But the function returns a reference to <code>means.str[0]</code>, making the code equivalent to</p>
<p class="programlisting">means.str[0] = 'r';</p>
<p>This last line of code violates private access, but because <code>operator[]()</code> is a class method, it is allowed to alter the array contents. The net effect of the code is that <code>"might"</code> becomes <code>"right"</code>.</p>
<p><a id="page_651"/>Suppose you have a constant object:</p>
<p class="programlisting">const String answer("futile");</p>
<p>Then, if the only available definition for <code>operator[]()</code>is the one you&#8217;ve just seen, the following code is labeled an error:</p>
<p class="programlisting">cout &lt;&lt; answer[1];&#160;&#160;// compile-time error</p>
<p>The reason is that <code>answer</code> is <code>const</code>, and the method doesn&#8217;t promise not to alter data. (In fact, sometimes the method&#8217;s job is to alter data, so it can&#8217;t promise not to.)</p>
<p>However, C++ distinguishes between <code>const</code> and non-<code>const</code> function signatures when overloading, so you can provide a second version of <code>operator[]()</code> that is used just by <code>const String</code> objects:</p>
<p class="programlisting">// for use with const String objects<br/>const char &#38; String::operator[](int i) const<br/>{<br/>&#160;&#160;&#160;&#160;return str[i];<br/>}</p>
<p>With the definitions, you have read/write access to regular <code>String</code> objects and read-only access to <code>const String</code> data:</p>
<p class="programlisting">String text("Once upon a time");<br/>const String answer("futile");<br/>cout &lt;&lt; text[1];&#160;&#160;&#160;&#160;// ok, uses non-const version of operator[]()<br/>cout &lt;&lt; answer[1];&#160;&#160;// ok, uses const version of operator[]()<br/>cin &gt;&gt; text[1];&#160;&#160;&#160;&#160;&#160;// ok, uses non-const version of operator[]()<br/>cin &gt;&gt; answer[1];&#160;&#160;&#160;// compile-time error</p>
<h4 id="ch12lev2sec8">Static Class Member Functions</h4>
<p>It&#8217;s possible to declare a member function as being static. (The keyword <code>static</code> should appear in the function declaration but not in the function definition if the latter is separate.) This has two important consequences.</p>
<p>First, a static member function doesn&#8217;t have to be invoked by an object; in fact, it doesn&#8217;t even get a <code>this</code> pointer to play with. If the static member function is declared in the public section, it can be invoked using the class name and the scope-resolution operator. For instance, you can give the <code>String</code> class a static member function called <code>HowMany()</code> with the following prototype/definition in the class declaration:</p>
<p class="programlisting">static int HowMany() { return num_strings; }</p>
<p>It could be invoked like this:</p>
<p class="programlisting">int count = String::HowMany();&#160;&#160;// invoking a static member function</p>
<p>The second consequence is that because a static member function is not associated with a particular object, the only data members it can use are the static data members. <a id="page_652"/>For example, the <code>HowMany()</code> static method can access the <code>num_strings</code> static member, but not <code>str</code> or <code>len</code>.</p>
<p>Similarly, a static member function can be used to set a classwide flag that controls how some aspect of the class interface behaves. For example, it can control the formatting used by a method that displays class contents.</p>
<h4 id="ch12lev2sec9">Further Assignment Operator Overloading</h4>
<p>Before looking at the new listings for the <code>String</code> class example, let&#8217;s consider another matter. Suppose you want to copy an ordinary string to a <code>String</code> object. For example, suppose you use <code>getline()</code> to read a string and you want to place it in a <code>String</code> object. The class methods already allow you to do the following:</p>
<p class="programlisting">String name;<br/>char temp[40];<br/>cin.getline(temp, 40);<br/>name = temp;&#160;&#160;// use constructor to convert type</p>
<p>However, this might not be a satisfactory solution if you have to do it often. To see why, let&#8217;s review how the final statement works:</p>
<p class="indenthandingN"><strong>1.</strong> The program uses the <code>String(const char *)</code> constructor to construct a temporary <code>String</code> object containing a copy of the string stored in <code>temp</code>. Remember from <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>,&#8221; that a constructor with a single argument serves as a conversion function.</p>
<p class="indenthandingN"><strong>2.</strong> In <a href="#ch12ex06">Listing 12.6</a>, later in this chapter, the program uses the <code>String &#38; String::operator=(const String &#38;)</code> function to copy information from the temporary object to the <code>name</code> object.</p>
<p class="indenthandingN"><strong>3.</strong> The program calls the <code>~String()</code> destructor to delete the temporary object.</p>
<p>The simplest way to make the process more efficient is to overload the assignment operator so that it works directly with ordinary strings. This removes the extra steps of creating and destroying a temporary object. Here&#8217;s one possible implementation:</p>
<p class="programlisting">String &#38; String::operator=(const char * s)<br/>{<br/>&#160;&#160;&#160;&#160;delete [] str;<br/>&#160;&#160;&#160;&#160;len = std::strlen(s);<br/>&#160;&#160;&#160;&#160;str = new char[len + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(str, s);<br/>&#160;&#160;&#160;&#160;return *this;<br/>}</p>
<p>As usual, you must deallocate memory formerly managed by <code>str</code> and allocate enough memory for the new string.</p>
<p><a href="#ch12ex04">Listing 12.4</a> shows the revised class declaration. In addition to the changes already mentioned, it defines the constant <code>CINLIM</code>, which is used in implementing <code>operator&gt;&gt;()</code>.</p>
<p class="caption1"><a id="page_653"/><a id="ch12ex04"/><strong>Listing 12.4. <code>string1.h</code></strong></p><hr/>
<p class="programlisting1">// string1.h -- fixed and augmented string class definition<br/><br/>#ifndef STRING1_H_<br/>#define STRING1_H_<br/>#include &lt;iostream&gt;<br/>using std::ostream;<br/>using std::istream;<br/><br/>class String<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to string<br/>&#160;&#160;&#160;&#160;int len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// length of string<br/>&#160;&#160;&#160;&#160;static int num_strings; // number of objects<br/>&#160;&#160;&#160;&#160;static const int CINLIM = 80;&#160;&#160;// cin input limit<br/>public:<br/>// constructors and other methods<br/>&#160;&#160;&#160;&#160;String(const char * s); // constructor<br/>&#160;&#160;&#160;&#160;String();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>&#160;&#160;&#160;&#160;String(const String &#38;); // copy constructor<br/>&#160;&#160;&#160;&#160;~String();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// destructor<br/>&#160;&#160;&#160;&#160;int length () const { return len; }<br/>// overloaded operator methods<br/>&#160;&#160;&#160;&#160;String &#38; operator=(const String &#38;);<br/>&#160;&#160;&#160;&#160;String &#38; operator=(const char *);<br/>&#160;&#160;&#160;&#160;char &#38; operator[](int i);<br/>&#160;&#160;&#160;&#160;const char &#38; operator[](int i) const;<br/>// overloaded operator friends<br/>&#160;&#160;&#160;&#160;friend bool operator&lt;(const String &#38;st, const String &#38;st2);<br/>&#160;&#160;&#160;&#160;friend bool operator&gt;(const String &#38;st1, const String &#38;st2);<br/>&#160;&#160;&#160;&#160;friend bool operator==(const String &#38;st, const String &#38;st2);<br/>&#160;&#160;&#160;&#160;friend ostream &#38; operator&lt;&lt;(ostream &#38; os, const String &#38; st);<br/>&#160;&#160;&#160;&#160;friend istream &#38; operator&gt;&gt;(istream &#38; is, String &#38; st);<br/>// static function<br/>&#160;&#160;&#160;&#160;static int HowMany();<br/>};<br/>#endif</p><hr/>
<p><a href="#ch12ex05">Listing 12.5</a> presents the revised method definitions.</p>
<p class="caption1"><a id="ch12ex05"/><strong>Listing 12.5. <code>string1.cpp</code></strong></p><hr/>
<p class="programlisting1">// string1.cpp -- String class methods<br/>#include &lt;cstring&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// string.h for some<br/>#include "string1.h"&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// includes &lt;iostream&gt;<br/><a id="page_654"/>using std::cin;<br/>using std::cout;<br/><br/>// initializing static class member<br/><br/>int String::num_strings = 0;<br/><br/>// static method<br/>int String::HowMany()<br/>{<br/>&#160;&#160;&#160;&#160;return num_strings;<br/>}<br/><br/>// class methods<br/>String::String(const char * s)&#160;&#160;&#160;&#160;&#160;// construct String from C string<br/>{<br/>&#160;&#160;&#160;&#160;len = std::strlen(s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set size<br/>&#160;&#160;&#160;&#160;str = new char[len + 1];&#160;&#160;&#160;&#160;&#160;&#160;&#160;// allot storage<br/>&#160;&#160;&#160;&#160;std::strcpy(str, s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initialize pointer<br/>&#160;&#160;&#160;&#160;num_strings++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set object count<br/>}<br/><br/>String::String()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>{<br/>&#160;&#160;&#160;&#160;len = 4;<br/>&#160;&#160;&#160;&#160;str = new char[1];<br/>&#160;&#160;&#160;&#160;str[0] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default string<br/>&#160;&#160;&#160;&#160;num_strings++;<br/>}<br/><br/>String::String(const String &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;num_strings++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// handle static member update<br/>&#160;&#160;&#160;&#160;len = st.len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// same length<br/>&#160;&#160;&#160;&#160;str = new char [len + 1];&#160;&#160;// allot space<br/>&#160;&#160;&#160;&#160;std::strcpy(str, st.str);&#160;&#160;// copy string to new location<br/>}<br/><br/>String::~String()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// necessary destructor<br/>{<br/>&#160;&#160;&#160;&#160;--num_strings;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// required<br/>&#160;&#160;&#160;&#160;delete [] str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// required<br/>}<br/><br/>// overloaded operator methods<br/><br/>&#160;&#160;&#160;&#160;// assign a String to a String<br/><a id="page_655"/>String &#38; String::operator=(const String &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;st)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;delete [] str;<br/>&#160;&#160;&#160;&#160;len = st.len;<br/>&#160;&#160;&#160;&#160;str = new char[len + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(str, st.str);<br/>&#160;&#160;&#160;&#160;return *this;<br/>}<br/><br/>&#160;&#160;&#160;&#160;// assign a C string to a String<br/>String &#38; String::operator=(const char * s)<br/>{<br/>&#160;&#160;&#160;&#160;delete [] str;<br/>&#160;&#160;&#160;&#160;len = std::strlen(s);<br/>&#160;&#160;&#160;&#160;str = new char[len + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(str, s);<br/>&#160;&#160;&#160;&#160;return *this;<br/>}<br/><br/>&#160;&#160;&#160;&#160;// read-write char access for non-const String<br/>char &#38; String::operator[](int i)<br/>{<br/>&#160;&#160;&#160;&#160;return str[i];<br/>}<br/><br/>&#160;&#160;&#160;&#160;// read-only char access for const String<br/>const char &#38; String::operator[](int i) const<br/>{<br/>&#160;&#160;&#160;&#160;return str[i];<br/>}<br/><br/>// overloaded operator friends<br/><br/>bool operator&lt;(const String &#38;st1, const String &#38;st2)<br/>{<br/>&#160;&#160;&#160;&#160;return (std::strcmp(st1.str, st2.str) &lt; 0);<br/>}<br/><br/>bool operator&gt;(const String &#38;st1, const String &#38;st2)<br/>{<br/>&#160;&#160;&#160;&#160;return st2 &lt; st1;<br/>}<br/><br/>bool operator==(const String &#38;st1, const String &#38;st2)<br/>{<br/>&#160;&#160;&#160;&#160;return (std::strcmp(st1.str, st2.str) == 0);<br/>}<br/><br/>&#160;&#160;&#160;&#160;// simple String output<br/>ostream &#38; operator&lt;&lt;(ostream &#38; os, const String &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; st.str;<br/>&#160;&#160;&#160;&#160;return os;<br/>}<br/><br/>&#160;&#160;&#160;&#160;// quick and dirty String input<br/>istream &#38; operator&gt;&gt;(istream &#38; is, String &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;char temp[String::CINLIM];<br/>&#160;&#160;&#160;&#160;is.get(temp, String::CINLIM);<br/>&#160;&#160;&#160;&#160;if (is)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st = temp;<br/>&#160;&#160;&#160;&#160;while (is &#38;&#38; is.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;return is;<br/>}</p><hr/>
<p><a id="page_656"/>The overloaded <code>&gt;&gt;</code> operator provides a simple way to read a line of keyboard input into a <code>String</code> object. It assumes an input line of <code>String::CINLIM</code> or fewer characters and discards any characters beyond that limit. Keep in mind that the value of an <code>istream</code> object in an <code>if</code> condition evaluates to <code>false</code> if input fails for some reason, such as encountering an end-of-file condition, or in the case of <code>get(char *, int)</code>, reading an empty line.</p>
<p><a href="#ch12ex06">Listing 12.6</a> exercises the <code>String</code> class with a short program that lets you enter a few strings. The program has the user enter sayings, puts the strings into <code>String</code> objects, displays them, and reports which string is the shortest and which comes first alphabetically.</p>
<p class="caption1"><a id="ch12ex06"/><strong>Listing 12.6. <code>sayings1.cpp</code></strong></p><hr/>
<p class="programlisting1">// sayings1.cpp -- using expanded String class<br/>// compile with string1.cpp<br/>#include &lt;iostream&gt;<br/>#include "string1.h"<br/>const int ArSize = 10;<br/>const int MaxLen =81;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;String name;<br/><a id="page_657"/>&#160;&#160;&#160;&#160;cout &lt;&lt;"Hi, what's your name?\n&gt;&gt; ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; name;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; name &lt;&lt; ", please enter up to " &lt;&lt; ArSize<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " short sayings &lt;empty line to quit&gt;:\n";<br/>&#160;&#160;&#160;&#160;String sayings[ArSize];&#160;&#160;&#160;&#160;&#160;// array of objects<br/>&#160;&#160;&#160;&#160;char temp[MaxLen];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// temporary string storage<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; ArSize; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i+1 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(temp, MaxLen);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin &#38;&#38; cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!cin || temp[0] == '\0')&#160;&#160;&#160;&#160;// empty line?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// i not incremented<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sayings[i] = temp;&#160;&#160;// overloaded assignment<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;int total = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// total # of lines read<br/><br/>&#160;&#160;&#160;&#160;if ( total &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are your sayings:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 0; i &lt; total; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; sayings[i][0] &lt;&lt; ": " &lt;&lt; sayings[i] &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int shortest = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int first = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 1; i &lt; total; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sayings[i].length() &lt; sayings[shortest].length())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shortest = i;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sayings[i] &lt; sayings[first])<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;first = i;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Shortest saying:\n" &lt;&lt; sayings[shortest] &lt;&lt; endl;;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "First alphabetically:\n" &lt;&lt; sayings[first] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "This program used "&lt;&lt; String::HowMany()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " String objects. Bye.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "No input! Bye.\n";<br/>&#160;&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch12note06"/><a id="page_658"/>Note</p>
<p class="notepara">Older versions of <code>get(char *, int)</code> don&#8217;t evaluate to <code>false</code> upon reading an empty line. For those versions, however, the first character in the string is a null character if an empty line is entered. This example uses the following code:</p>
<p class="programlistingB">if (!cin || temp[0] == '\0')&#160;&#160;&#160;&#160;// empty line?<br/>&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// i not incremented</p>
<p class="notepara">If the implementation follows the current C++ Standard, the first test in the <code>if</code> statement detects an empty line, whereas the second test detects the empty line for older implementations.</p>
<hr/></div>
<p>The program in <a href="#ch12ex06">Listing 12.6</a> asks the user to enter up to 10 sayings. Each saying is read into a temporary character array and then copied to a <code>String</code> object. If the user enters a blank line, a <code>break</code> statement terminates the input loop. After echoing the input, the program uses the <code>length()</code> and <code>operator&lt;()</code> member functions to locate the shortest string and the alphabetically earliest string. The program also uses the subscript operator (<code>[]</code>) to preface each saying with its initial character. Here&#8217;s a sample run:</p>
<p class="programlisting">Hi, what's your name?<br/>&gt;&gt; <span class="EmpStrong">Misty Gutz</span><br/>Misty Gutz, please enter up to 10 short sayings &lt;empty line to quit&gt;:<br/>1: <span class="EmpStrong">a fool and his money are soon parted</span><br/>2: <span class="EmpStrong">penny wise, pound foolish</span><br/>3: <span class="EmpStrong">the love of money is the root of much evil</span><br/>4: <span class="EmpStrong">out of sight, out of mind</span><br/>5: <span class="EmpStrong">absence makes the heart grow fonder</span><br/>6: <span class="EmpStrong">absinthe makes the hart grow fonder</span><br/>7:<br/>Here are your sayings:<br/>a: a fool and his money are soon parted<br/>p: penny wise, pound foolish<br/>t: the love of money is the root of much evil<br/>o: out of sight, out of mind<br/>a: absence makes the heart grow fonder<br/>a: absinthe makes the hart grow fonder<br/>Shortest saying:<br/>penny wise, pound foolish<br/>First alphabetically:<br/>a fool and his money are soon parted<br/>This program used 11 String objects. Bye.</p>
<h3 id="ch12lev1sec3">Things to Remember When Using <code>new</code> in Constructors</h3>
<p><a id="page_659"/>By now you&#8217;ve noticed that you must take special care when using <code>new</code> to initialize pointer members of an object. In particular, you should do the following:</p>
<p class="indenthandingB">&#8226; If you use <code>new</code> to initialize a pointer member in a constructor, you should use <code>delete</code> in the destructor.</p>
<p class="indenthandingB">&#8226; The uses of <code>new</code> and <code>delete</code> should be compatible. You should pair <code>new</code> with <code>delete</code> and <code>new []</code> with <code>delete []</code>.</p>
<p class="indenthandingB">&#8226; If there are multiple constructors, all should use <code>new</code> the same way&#8212;either all with brackets or all without brackets. There&#8217;s only one destructor, so all constructors have to be compatible with that destructor. However, it is permissible to initialize a pointer with <code>new</code> in one constructor and with the null pointer (<code>0</code>, or, with C++11, <code>nullptr</code>) in another constructor because it&#8217;s okay to apply the <code>delete</code> operation (with or without brackets) to the null pointer.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch12sb02"/><code>NULL</code> or <code>0</code> or <code>nullptr</code>?</p>
<p class="sidebarpara">Historically, the null pointer can be represented by <code>0</code> or by <code>NULL</code>, a symbolic constant defined as <code>0</code> in several header files. C programmers often use <code>NULL</code> instead of <code>0</code> as a visual reminder that the value is a pointer value, just as they use <code>'\0'</code> instead of <code>0</code> for the null character as a visual reminder that this value is a character. The C++ tradition, however, has favored a simple <code>0</code> instead of the equivalent <code>NULL</code>. And, as mentioned earlier, C++11 offers the <code>nullptr</code> keyword as a better alternative.</p>
<hr/></div>
<p class="indenthandingB">&#8226; You should define a copy constructor that initializes one object to another by doing deep copying. Typically, the constructor should emulate the following example:</p>
<p class="programlistingB">String::String(const String &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;num_strings++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// handle static member update if necessary<br/>&#160;&#160;&#160;&#160;&#160;len = st.len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// same length as copied string<br/>&#160;&#160;&#160;&#160;&#160;str = new char [len + 1]; // allot space<br/>&#160;&#160;&#160;&#160;&#160;std::strcpy(str, st.str); // copy string to new location<br/>}</p>
<p class="indenthandingBP">In particular, the copy constructor should allocate space to hold the copied data, and it should copy the data, not just the address of the data. Also it should update any static class members whose value would be affected by the process.</p>
<p class="indenthandingB">&#8226; You should define an assignment operator that copies one object to another by doing deep copying. Typically, the class method should emulate the following example:</p>
<p class="programlistingB"><a id="page_660"/>String &#38; String::operator=(const String &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;if (this == &#38;st)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// object assigned to itself<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// all done<br/>&#160;&#160;&#160;&#160;&#160;delete [] str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free old string<br/>&#160;&#160;&#160;&#160;&#160;len = st.len;<br/>&#160;&#160;&#160;&#160;&#160;str = new char [len + 1];&#160;&#160;&#160;// get space for new string<br/>&#160;&#160;&#160;&#160;&#160;std::strcpy(str, st.str);&#160;&#160;&#160;// copy the string<br/>&#160;&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// return reference to invoking object<br/>}</p>
<p>In particular, the method should check for self-assignment; it should free memory formerly pointed to by the member pointer; it should copy the data, not just the address of the data; and it should return a reference to the invoking object.</p>
<h4 id="ch12lev2sec10">Don&#8217;ts and Dos</h4>
<p>The following excerpt contains two examples of what not to do and one example of a good constructor:</p>
<p class="programlisting">String::String()<br/>{<br/>&#160;&#160;&#160;str = "default string";&#160;&#160;&#160;&#160;&#160;// oops, no new []<br/>&#160;&#160;&#160;len = std::strlen(str);<br/>}<br/><br/>String::String(const char * s)<br/>{<br/>&#160;&#160;&#160;len = std::strlen(s);<br/>&#160;&#160;&#160;str = new char;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// oops, no []<br/>&#160;&#160;&#160;std::strcpy(str, s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// oops, no room<br/>}<br/><br/>String::String(const String &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;len = st.len;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;str = new char[len + 1];&#160;&#160;&#160;&#160;&#160;&#160;// good, allocate space<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::strcpy(str, st.str);&#160;&#160;&#160;&#160;&#160;// good, copy value<br/>}</p>
<p>The first constructor fails to use <code>new</code> to initialize <code>str</code>. The destructor, when called for a default object, applies <code>delete</code> to <code>str</code>. The result of applying <code>delete</code> to a pointer not initialized by <code>new</code> is undefined, but it is probably bad. Any of the following would be okay:</p>
<p class="programlisting">String::String()<br/>{<br/>&#160;&#160;&#160;&#160;len = 0;<br/>&#160;&#160;&#160;&#160;str = new char[1];&#160;&#160;// uses new with []<br/>&#160;&#160;&#160;&#160;str[0] = '\0';<br/>}<br/><br/><a id="page_661"/>String::String()<br/>{<br/>&#160;&#160;&#160;&#160;len = 0;<br/>&#160;&#160;&#160;&#160;str = 0;&#160;&#160;// or, with C++11, str = nullptr;<br/>}<br/><br/>String::String()<br/>{<br/>&#160;&#160;&#160;&#160;static const char * s = "C++";&#160;&#160;&#160;&#160;&#160;// initialized just once<br/>&#160;&#160;&#160;&#160;len = std::strlen(s);<br/>&#160;&#160;&#160;&#160;str = new char[len + 1];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// uses new with []<br/>&#160;&#160;&#160;&#160;std::strcpy(str, s);<br/>}</p>
<p>Next, the second constructor in the original excerpt applies <code>new</code>, but it fails to request the correct amount of memory; hence, <code>new</code> returns a block containing space for just one character. Attempting to copy a longer string to that location is asking for memory problems. Also the use of <code>new</code> without brackets is inconsistent with the correct form of the other constructors.</p>
<p>The third constructor is fine.</p>
<p>Finally, here&#8217;s a destructor that <em>doesn&#8217;t</em> work correctly with the previous constructors:</p>
<p class="programlisting">String::~String()<br/>{<br/>&#160;&#160;&#160;&#160;delete str;&#160;&#160;&#160;&#160;&#160;&#160;// oops, should be delete [] str;<br/>}</p>
<p>The destructor uses <code>delete</code> incorrectly. Because the constructors request arrays of characters, the destructor should delete an array.</p>
<h4 id="ch12lev2sec11">Memberwise Copying for Classes with Class Members</h4>
<p>Suppose you use the <code>String</code> class, or, for that matter, the standard <code>string</code> class as a type for class members:</p>
<p class="programlisting">class Magazine<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;String title;<br/>&#160;&#160;&#160;&#160;string publisher;<br/>...<br/>};</p>
<p><code>String</code> and <code>string</code> both use dynamic memory allocation. Does that mean you need to write a copy constructor and assignment operator for the <code>Magazine</code> class? No&#8212;at least not in itself. The default memberwise copying and assignment behavior does have some smarts. If you copy or assign one <code>Magazine</code> object to another, memberwise copying uses the copy constructors and assignment operators defined for the member types. That is, the <a id="page_662"/><code>String</code> copy constructor will be used to copy the <code>title</code> member from one <code>Magazine</code> object to another, the <code>String</code> assignment operator will be used to assign the <code>title</code> member of one <code>Magazine</code> object to another, and so on. Things get more complicated, however, if the <code>Magazine</code> class needs a copy constructor and assignment operator for some other class member. In that case, those functions have to call the <code>String</code> and <code>string</code> copy constructors and assignment operators explicitly. But that&#8217;s a tale for <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a href="ch13.html#ch13">Class Inheritance</a>.&#8221;</p>
<h3 id="ch12lev1sec4">Observations About Returning Objects</h3>
<p>When a member function or standalone function returns an object, you have choices. The function could return a reference to an object, a constant reference to an object, an object, or a constant object. By now, you&#8217;ve seen examples of all but the last, so it&#8217;s a good time to review these options.</p>
<h4 id="ch12lev2sec12">Returning a Reference to a <code>const</code> Object</h4>
<p>The usual reason for using a <code>const</code> reference is efficiency, but there are restrictions on when this choice can be used. If a function returns an object that is passed to it, either by object invocation or as a method argument, you can increase the efficiency of the method by having it return a reference. For example, suppose you wanted to write a function <code>Max()</code> that returned the larger of two <code>Vector</code> objects, where <code>Vector</code> is the class developed in <a href="ch11.html#ch11">Chapter 11</a>. The function would be used in this manner:</p>
<p class="programlisting">Vector force1(50,60);<br/>Vector force2(10,70);<br/>Vector max;<br/>max = Max(force1, force2);</p>
<p>Either of the following two implementations would work:</p>
<p class="programlisting">// version 1<br/>Vector Max(const Vector &#38; v1, const Vector &#38; v2)<br/>{<br/>&#160;&#160;&#160;&#160;if (v1.magval() &gt; v2.magval())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return v1;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return v2;<br/>}<br/><br/>// version 2<br/>const Vector &#38; Max(const Vector &#38; v1, const Vector &#38; v2)<br/>{<br/>&#160;&#160;&#160;&#160;if (v1.magval() &gt; v2.magval())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return v1;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return v2;<br/>}</p>
<p><a id="page_663"/>There are three important points here. First, recall that returning an object invokes the copy constructor, whereas returning a reference doesn&#8217;t. Thus Version 2 does less work and is more efficient. Second, the reference should be to an object that exists when the calling function is executing. In this example, the reference is to either <code>force1</code> or <code>force2</code>, and both are objects defined in the calling function, so this requirement is met. Third, both <code>v1</code> and <code>v2</code> are declared as being <code>const</code> references, so the return type has to be <code>const</code> to match.</p>
<h4 id="ch12lev2sec13">Returning a Reference to a Non-<code>const</code> Object</h4>
<p>Two common examples of returning a non-<code>const</code> object are overloading the assignment operator and overloading the <code>&lt;&lt;</code> operator for use with <code>cout</code>. The first is done for reasons of efficiency, and the second for reasons of necessity.</p>
<p>The return value of <code>operator=()</code> is used for chained assignment:</p>
<p class="programlisting">String s1("Good stuff");<br/>String s2, s3;<br/>s3 = s2 = s1;</p>
<p>In this code, the return value of <code>s2.operator=(s1)</code> is assigned to <code>s3</code>. Returning either a <code>String</code> object or a reference to a <code>String</code> object would work, but, as with the <code>Vector</code> example, using a reference allows the function to avoid calling the <code>String</code> copy constructor to create a new <code>String</code> object. In this case, the return type is not <code>const</code> because the <code>operator=()</code> method returns a reference to <code>s2</code>, which it does modify.</p>
<p>The return value of <code>operator&lt;&lt;()</code> is used for chained output:</p>
<p class="programlisting">String s1("Good stuff");<br/>cout &lt;&lt; s1 &lt;&lt; "is coming!";</p>
<p>Here, the return value of <code>operator&lt;&lt;(cout, s1)</code> becomes the object used to display the string <code>"is coming!"</code>. Here, the return type has to be <code>ostream &#38;</code> and not just <code>ostream</code>. Using an <code>ostream</code> return type would require calling the <code>ostream</code> copy constructor, and, as it turns out, the <code>ostream</code> class does not have a public copy constructor. Fortunately, returning a reference to <code>cout</code> poses no problems because <code>cout</code> is already in scope in the calling function.</p>
<h4 id="ch12lev2sec14">Returning an Object</h4>
<p>If the object being returned is local to the called function, then it should not be returned by reference because the local object has its destructor called when the function terminates. Thus, when control returns to the calling function, there is no object left to which the reference can refer. In these circumstances, you should return an object, not a reference. Typically, overloaded arithmetic operators fall into this category. Consider this example, which uses the <code>Vector</code> class again:</p>
<p class="programlisting">Vector force1(50,60);<br/>Vector force2(10,70);<br/>Vector net;<br/>net = force1 + force2;</p>
<p><a id="page_664"/>The value being returned is not <code>force1</code>, which should be left unaltered by the process, nor <code>force2</code>, which should also be unaltered. Thus the return value can&#8217;t be a reference to an object that is already present in the calling function. Instead, the sum is a new, temporary object computed in <code>Vector::operator+()</code>, and the function shouldn&#8217;t return a reference to a temporary object either. Instead, it should return an actual vector object, not a reference:</p>
<p class="programlisting">Vector Vector::operator+(const Vector &#38; b) const<br/>{<br/>&#160;&#160;&#160;&#160;return Vector(x + b.x, y + b.y);<br/>}</p>
<p>There is the added expense of calling the copy constructor to create the returned object, but that is unavoidable.</p>
<p>One more observation: In the <code>Vector::operator+()</code> example, the constructor call <code>Vector(x + b.x, y + b.y)</code> creates an object that is accessible to the <code>operator+()</code> method; the implicit call to the copy constructor produced by the return statement, however, creates an object that is accessible to the calling program.</p>
<h4 id="ch12lev2sec15">Returning a <code>const</code> Object</h4>
<p>The preceding definition of <code>Vector::operator+()</code> has a bizarre property. The intended use is this:</p>
<p class="programlisting">net = force1 + force2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// 1: three Vector objects</p>
<p>However, the definition also allows you to use the following:</p>
<p class="programlisting">force1 + force2 = net;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// 2: dyslectic programming<br/>cout &lt;&lt; (force1 + force2 = net).magval() &lt;&lt; endl; // 3: demented programming</p>
<p>Three questions immediately arise. Why would anyone write such statements? Why are they possible? What do they do?</p>
<p>First, there is no sensible reason for writing such code, but not all code is written for sensible reasons. People, even programmers, make mistakes. For instance, if the comparison <code>operator==()</code> were defined for the <code>Vector</code> class, you might mistakenly type</p>
<p class="programlisting">if (force1 + force2 = net)</p>
<p>instead of this:</p>
<p class="programlisting">if (force1 + force2 == net)</p>
<p>Also programmers tend to be ingenious, and this can lead to ingeniously adventurous mistakes.</p>
<p>Second, this code is possible because the copy constructor constructs a temporary object to represent the return value. So in the preceding code, the expression <code>force1 + force2</code> stands for that temporary object. In Statement 1, the temporary object is assigned to <code>net</code>. In Statements 2 and 3, <code>net</code> is assigned to the temporary object.</p>
<p><a id="page_665"/>Third, the temporary object is used and then discarded. For instance, in Statement 2, the program computes the sum of <code>force1</code> and <code>force2</code>, copies the answer into the temporary return object, overwrites the contents with the contents of <code>net</code>, and then discards the temporary object. The original vectors are all left unchanged. In Statement 3, the magnitude of the temporary object is displayed before the object is deleted.</p>
<p>If you are concerned about the potential for misuse and abuse created by this behavior, you have a simple recourse: Declare the return type as a <code>const</code> object. For instance, if <code>Vector::operator+()</code> is declared to have return type <code>const Vector</code>, then Statement 1 is still allowed but Statements 2 and 3 become invalid.</p>
<p>In summary, if a method or function returns a local object, it should return an object, not a reference. In this example, the program uses the copy constructor to generate the returned object. If a method or function returns an object of a class for which there is no public copy constructor, such as the <code>ostream</code> class, it must return a reference to an object. Finally, some methods and functions, such as the overloaded assignment operator, can return either an object or a reference to an object. In this example, the reference is preferred for reasons of efficiency.</p>
<h3 id="ch12lev1sec5">Using Pointers to Objects</h3>
<p>C++ programs often use pointers to objects, so let&#8217;s get in a bit of practice. <a href="#ch12ex06">Listing 12.6</a> uses array index values to keep track of the shortest string and of the first string alphabetically. Another approach is to use pointers to point to the current leaders in these categories. <a href="#ch12ex07">Listing 12.7</a> implements this approach, using two pointers to <code>String</code>. Initially, the <code>shortest</code> pointer points to the first object in the array. Each time the program finds an object with a shorter string, it resets <code>shortest</code> to point to that object. Similarly, a <code>first</code> pointer tracks the alphabetically earliest string. Note that these two pointers do not create new objects; they merely point to existing objects. Hence they don&#8217;t require using <code>new</code> to allocate additional memory.</p>
<p>For variety, the program in <a href="#ch12ex07">Listing 12.7</a> uses a pointer that does keep track of a new object:</p>
<p class="programlistingB">String * favorite = new String(sayings[choice]);</p>
<p>Here the pointer <code>favorite</code> provides the only access to the nameless object created by <code>new</code>. This particular syntax means to initialize the new <code>String</code> object by using the object <code>sayings[choice]</code>. That invokes the copy constructor because the argument type for the copy constructor (<code>const String &#38;</code>) matches the initialization value (<code>sayings[choice]</code>). The program uses <code>srand()</code>, <code>rand()</code>, and <code>time()</code> to select a value for choice at random.</p>
<p class="caption1"><a id="ch12ex07"/><strong>Listing 12.7. <code>sayings2.cpp</code></strong></p><hr/>
<p class="programlisting1">// sayings2.cpp -- using pointers to objects<br/>// compile with string1.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt;&#160;&#160;&#160;&#160;&#160;&#160;// (or stdlib.h) for rand(), srand()<br/>#include &lt;ctime&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// (or time.h) for time()<br/><a id="page_666"/>#include "string1.h"<br/>const int ArSize = 10;<br/>const int MaxLen = 81;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;String name;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;"Hi, what's your name?\n&gt;&gt; ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; name;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; name &lt;&lt; ", please enter up to " &lt;&lt; ArSize<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " short sayings &lt;empty line to quit&gt;:\n";<br/>&#160;&#160;&#160;&#160;String sayings[ArSize];<br/>&#160;&#160;&#160;&#160;char temp[MaxLen];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// temporary string storage<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; ArSize; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i+1 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(temp, MaxLen);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin &#38;&#38; cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!cin || temp[0] == '\0') // empty line?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// i not incremented<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sayings[i] = temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded assignment<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;int total = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// total # of lines read<br/><br/>&#160;&#160;&#160;&#160;if (total &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are your sayings:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 0; i &lt; total; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; sayings[i] &lt;&lt; "\n";<br/><br/>&#160;&#160;&#160;&#160;// use pointers to keep track of shortest, first strings<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String * shortest = &#38;sayings[0]; // initialize to first object<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String * first = &#38;sayings[0];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 1; i &lt; total; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sayings[i].length() &lt; shortest-&gt;length())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shortest = &#38;sayings[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (sayings[i] &lt; *first)&#160;&#160;&#160;&#160;&#160;// compare values<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;first = &#38;sayings[i];&#160;&#160;&#160;&#160;&#160;// assign address<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Shortest saying:\n" &lt;&lt; * shortest &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "First alphabetically:\n" &lt;&lt; * first &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;srand(time(0));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int choice = rand() % total; // pick index at random<br/>&#160;&#160;&#160;&#160;// use new to create, initialize new String object<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String * favorite = new String(sayings[choice]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "My favorite saying:\n" &lt;&lt; *favorite &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete favorite;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Not much to say, eh?\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<div class="sidebar"><hr/>
<p class="title"><a id="ch12sb03"/><a id="page_667"/>Object Initialization with <code>new</code></p>
<p class="sidebarpara">In general, if <em><code>Class_name</code></em> is a class and if <em><code>value</code></em> is of type <em><code>Type_name</code></em>, the statement</p>
<p class="programlistingB"><span class="EmpItalic">Class_name</span> * pclass = new <span class="EmpItalic">Class_name</span>(<span class="EmpItalic">value</span>);</p>
<p class="sidebarpara">invokes this constructor:</p>
<p class="programlistingB"><span class="EmpItalic">Class_name</span>(<span class="EmpItalic">Type_name</span>);</p>
<p class="sidebarpara">There may be trivial conversions, such as to this:</p>
<p class="programlistingB"><span class="EmpItalic">Class_name</span>(const <span class="EmpItalic">Type_name</span> &#38;);</p>
<p class="sidebarpara">Also the usual conversions invoked by prototype matching, such as from <code>int</code> to <code>double</code>, takes place as long as there is no ambiguity. An initialization in the following form invokes the default constructor:</p>
<p class="programlistingB"><span class="EmpItalic">Class_name</span> * ptr = new <span class="EmpItalic">Class_name</span>;</p>
<hr/></div>
<p>Here&#8217;s a sample run of the program in <a href="#ch12ex07">Listing 12.7</a>:</p>
<p class="programlisting">Hi, what's your name?<br/>&gt;&gt; <span class="EmpStrong">Kirt Rood</span><br/>Kirt Rood, please enter up to 10 short sayings &lt;empty line to quit&gt;:<br/>1: <span class="EmpStrong">a friend in need is a friend indeed</span><br/>2: <span class="EmpStrong">neither a borrower nor a lender be</span><br/>3: <span class="EmpStrong">a stitch in time saves nine</span><br/>4: <span class="EmpStrong">a niche in time saves stine</span><br/>5: <span class="EmpStrong">it takes a crook to catch a crook</span><br/>6: <span class="EmpStrong">cold hands, warm heart</span><br/>7:<br/>Here are your sayings:<br/>a friend in need is a friend indeed<br/>neither a borrower nor a lender be<br/>a stitch in time saves nine<br/>a niche in time saves stine<br/>it takes a crook to catch a crook<br/>cold hands, warm heart<br/><a id="page_668"/>Shortest saying:<br/>cold hands, warm heart<br/>First alphabetically:<br/>a friend in need is a friend indeed<br/>My favorite saying:<br/>a stitch in time saves nine<br/>Bye</p>
<p>Because the program selects the favorite saying randomly, different runs of the program will show different choices, even for identical input.</p>
<h4 id="ch12lev2sec16">Looking Again at <code>new</code> and <code>delete</code></h4>
<p>Note that the program generated from <a href="#ch12ex04">Listings 12.4</a>, <a href="#ch12ex05">12.5</a>, and <a href="#ch12ex07">12.7</a> uses <code>new</code> and <code>delete</code> on two levels. First, it uses <code>new</code> to allocate storage space for the name strings for each object that is created. This happens in the constructor functions, so the destructor function uses <code>delete</code> to free that memory. Because each string is an array of characters, the destructor uses <code>delete</code> with brackets. Thus, memory used to store the string contents is freed automatically when an object is destroyed. Second, the code in <a href="#ch12ex07">Listing 12.7</a> uses <code>new</code> to allocate an entire object:</p>
<p class="programlisting">String * favorite = new String(sayings[choice]);</p>
<p>This allocates space not for the string to be stored but for the object&#8212;that is, for the <code>str</code> pointer that holds the address of the string and for the <code>len</code> member. (It does not allocate space for the <code>num_strings</code> member because it is a static member that is stored separately from the objects.) Creating the object, in turn, calls the constructor, which allocates space for storing the string and assigns the string&#8217;s address to <code>str</code>. The program then uses <code>delete</code> to delete this object when it is finished with it. The object is a single object, so the program uses <code>delete</code> without brackets. Again, this frees only the space used to hold the <code>str</code> pointer and the <code>len</code> member. It doesn&#8217;t free the memory used to hold the string <code>str</code> points to, but the destructor takes care of that final task (see <a href="#ch12fig04">Figure 12.4</a>).</p>
<p class="caption"><a id="ch12fig04"/><strong>Figure 12.4. Calling destructors.</strong></p>
<p class="image"><img src="graphics/12fig04.jpg" alt="Image"/></p>
<p>Again, destructors are called in the following situations (refer to <a href="#ch12fig04">Figure 12.4</a>):</p>
<p class="indenthandingB">&#8226; If an object is an automatic variable, the object&#8217;s destructor is called when the program exits the block in which the object is defined. Thus, in <a href="#ch12ex03">Listing 12.3</a> the destructor is called for <code>headlines[0]</code> and <code>headlines[1]</code> when the program exits <code>main()</code>, and the destructor for <code>grub</code> is called when the program exits <code>callme1()</code>.</p>
<p class="indenthandingB">&#8226; If an object is a static variable (external, static, static external, or from a namespace), its destructor is called when the program terminates. This is what happened for the <code>sports</code> object in <a href="#ch12ex03">Listing 12.3</a>.</p>
<p class="indenthandingB">&#8226; If an object is created by <code>new</code>, its destructor is called only when you explicitly use <code>delete</code> on the object.</p>
<h4 id="ch12lev2sec17">Pointers and Objects Summary</h4>
<p><a id="page_669"/>You should note several points about using pointers to objects (refer to <a href="#ch12fig05">Figure 12.5</a> for a summary):</p>
<p class="indenthandingB">&#8226; You declare a pointer to an object by using the usual notation:</p>
<p class="programlistingB">String * glamour;</p>
<p class="indenthandingB">&#8226; You can initialize a pointer to point to an existing object:</p>
<p class="programlistingB">String * first = &#38;sayings[0];</p>
<p class="indenthandingB">&#8226; You can initialize a pointer by using <code>new</code>. The following creates a new object:</p>
<p class="programlistingB">String * favorite = new String(sayings[choice]);</p>
<p class="indenthandingBP">Also see <a href="#ch12fig06">Figure 12.6</a> for a more detailed look at an example of initializing a pointer with <code>new</code>.</p>
<p class="indenthandingB">&#8226; Using <code>new</code> with a class invokes the appropriate class constructor to initialize the newly created object:</p>
<p class="programlistingB">// invokes default constructor<br/>String * gleep = new String;<br/><br/>// invokes the String(const char *) constructor<br/>String * glop = new String("my my my");<br/><br/><a id="page_670"/>// invokes the String(const String &#38;) constructor<br/>String * favorite = new String(sayings[choice]);</p>
<p class="indenthandingB">&#8226; You use the <code>-&gt;</code> operator to access a class method via a pointer:</p>
<p class="programlistingB">if (sayings[i].length() &lt; shortest-&gt;length())</p>
<p class="indenthandingB">&#8226; You apply the dereferencing operator (<code>*</code>) to a pointer to an object to obtain an object:</p>
<p class="programlistingB">if (sayings[i] &lt; *first)&#160;&#160;&#160;&#160;// compare object values<br/>&#160;&#160;&#160;&#160;&#160;first = &#38;sayings[i];&#160;&#160;&#160;// assign object address</p>
<p class="caption"><a id="ch12fig05"/><strong>Figure 12.5. Pointers and objects.</strong></p>
<p class="image"><img src="graphics/12fig05.jpg" alt="Image"/></p>
<p class="caption"><a id="page_671"/><a id="ch12fig06"/><strong>Figure 12.6. Creating an object with <code>new</code>.</strong></p>
<p class="image"><img src="graphics/12fig06.jpg" alt="Image"/></p>
<h4 id="ch12lev2sec18">Looking Again at Placement <code>new</code></h4>
<p>Recall that placement <code>new</code> allows you to specify the memory location used to allocate memory. <a href="ch09.html#ch09">Chapter 9</a>, &#8220;<a href="ch09.html#ch09">Memory Models and Namespaces</a>,&#8221; discusses placement <code>new</code> in the context of built-in types. Using placement <code>new</code> with objects adds some new twists. <a href="#ch12ex08">Listing 12.8</a> uses placement <code>new</code> along with regular <code>new</code> to allocate memory for objects. It defines a class with a chatty constructor and destructor so that you can follow the history of objects.</p>
<p class="caption1"><a id="ch12ex08"/><strong>Listing 12.8. <code>placenew1.cpp</code></strong></p><hr/>
<p class="programlisting1">// placenew1.cpp&#160;&#160;-- new, placement new, no delete<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;new&gt;<br/>using namespace std;<br/>const int BUF = 512;<br/><a id="page_672"/>class JustTesting<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;string words;<br/>&#160;&#160;&#160;&#160;int number;<br/>public:<br/>&#160;&#160;&#160;&#160;JustTesting(const string &#38; s = "Just Testing", int n = 0)<br/>&#160;&#160;&#160;&#160;{words = s; number = n; cout &lt;&lt; words &lt;&lt; " constructed\n"; }<br/>&#160;&#160;&#160;&#160;~JustTesting() { cout &lt;&lt; words &lt;&lt; " destroyed\n";}<br/>&#160;&#160;&#160;&#160;void Show() const { cout &lt;&lt; words &lt;&lt; ", " &lt;&lt; number &lt;&lt; endl;}<br/>};<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;char * buffer = new char[BUF];&#160;&#160;&#160;&#160;&#160;&#160;&#160;// get a block of memory<br/><br/>&#160;&#160;&#160;&#160;JustTesting *pc1, *pc2;<br/><br/>&#160;&#160;&#160;&#160;pc1 = new (buffer) JustTesting;&#160;&#160;&#160;&#160;&#160;&#160;// place object in buffer<br/>&#160;&#160;&#160;&#160;pc2 = new JustTesting("Heap1", 20);&#160;&#160;// place object on heap<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory block addresses:\n" &lt;&lt; "buffer: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; (void *) buffer &lt;&lt; "&#160;&#160;&#160;&#160;heap: " &lt;&lt; pc2 &lt;&lt;endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory contents:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pc1 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;pc1-&gt;Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pc2 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;pc2-&gt;Show();<br/><br/>&#160;&#160;&#160;&#160;JustTesting *pc3, *pc4;<br/>&#160;&#160;&#160;&#160;pc3 = new (buffer) JustTesting("Bad Idea", 6);<br/>&#160;&#160;&#160;&#160;pc4 = new JustTesting("Heap2", 10);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory contents:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pc3 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;pc3-&gt;Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pc4 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;pc4-&gt;Show();<br/><br/>&#160;&#160;&#160;&#160;delete pc2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free Heap1<br/>&#160;&#160;&#160;&#160;delete pc4;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free Heap2<br/>&#160;&#160;&#160;&#160;delete [] buffer;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free buffer<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_673"/>The program in <a href="#ch12ex08">Listing 12.8</a> uses <code>new</code> to create a memory buffer of 512 bytes. It then uses <code>new</code> to create two objects of type <code>JustTesting</code> on the heap and attempts to use placement <code>new</code> to create two objects of type <code>JustTesting</code> in the memory buffer. Finally, it uses <code>delete</code> to free the memory allocated by <code>new</code>. Here is the output:</p>
<p class="programlisting">Just Testing constructed<br/>Heap1 constructed<br/>Memory block addresses:<br/>buffer: 00320AB0&#160;&#160;&#160;&#160;heap: 00320CE0<br/>Memory contents:<br/>00320AB0: Just Testing, 0<br/>00320CE0: Heap1, 20<br/>Bad Idea constructed<br/>Heap2 constructed<br/>Memory contents:<br/>00320AB0: Bad Idea, 6<br/>00320EC8: Heap2, 10<br/>Heap1 destroyed<br/>Heap2 destroyed<br/>Done</p>
<p>As usual, the formatting and exact values for the memory addresses will vary from system to system.</p>
<p>There are a couple problems with placement <code>new</code> as used in <a href="#ch12ex08">Listing 12.8</a>. First, when creating a second object, placement <code>new</code> simply overwrites the same location used for the first object with a new object. Not only is this rude, it means that the destructor was never called for the first object. This, of course, would create real problems if, say, the class used dynamic memory allocation for its members.</p>
<p>Second, using <code>delete</code> with <code>pc2</code> and <code>pc4</code> automatically invokes the destructors for the two objects that <code>pc2</code> and <code>pc4</code> point to. But using <code>delete []</code> with <code>buffer</code> does not invoke the destructors for the objects created with placement <code>new</code>.</p>
<p>One lesson to be learned here is the same lesson you learned in <a href="ch09.html#ch09">Chapter 9</a>: It&#8217;s up to you to manage the memory locations in a buffer that placement <code>new</code> populates. To use two different locations, you provide two different addresses within the buffer, making sure that the locations don&#8217;t overlap. You can, for example, use this:</p>
<p class="programlisting">pc1 = new (buffer) JustTesting;<br/>pc3 = new (buffer + sizeof (JustTesting)) JustTesting("Better Idea", 6);</p>
<p>Here the pointer <code>pc3</code> is offset from <code>pc1</code> by the size of a <code>JustTesting</code> object.</p>
<p>The second lesson to be learned here is that if you use placement <code>new</code> to store objects, you need to arrange for their destructors to be called. But how? For objects created on the heap, you can use this:</p>
<p class="programlisting">delete pc2;&#160;&#160;&#160;// delete object pointed to by pc2</p>
<p><a id="page_674"/>But you can&#8217;t use this:</p>
<p class="programlisting">delete pc1;&#160;&#160;&#160;// delete object pointed to by pc1? NO!<br/>delete pc3;&#160;&#160;&#160;// delete object pointed to by pc3? NO!</p>
<p>The reason is that <code>delete</code> works in conjunction with <code>new</code> but not with placement <code>new</code>. The pointer <code>pc3</code>, for example, does not receive an address returned by <code>new</code>, so <code>delete pc3</code> throws a runtime error. The pointer <code>pc1</code>, on the other hand, has the same numeric value as <code>buffer</code>, but <code>buffer</code> is initialized using <code>new []</code>, so it&#8217;s freed using d<code>elete []</code>, not <code>delete</code>. Even if <code>buffer</code> were initialized by <code>new</code> instead of <code>new []</code>, <code>delete pc1</code> would free <code>buffer</code>, not <code>pc1</code>. That&#8217;s because the <code>new</code>/<code>delete</code> system knows about the 256-byte block that is allocated, but it doesn&#8217;t know anything about what placement <code>new</code> does with the block.</p>
<p>Note that the program does free the buffer:</p>
<p class="programlisting">delete [] buffer;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free buffer</p>
<p>As this comment suggests, <code>delete [] buffer;</code> deletes the entire block of memory allocated by <code>new</code>. But it doesn&#8217;t call the destructors for any objects that placement <code>new</code> constructs in the block. You can tell this is so because this program uses chatty destructors, which report the demise of <code>"Heap1"</code> and <code>"Heap2"</code> but which remain silent about <code>"Just Testing"</code> and <code>"Bad Idea"</code>.</p>
<p>The solution to this quandary is that you must call the destructor explicitly for any object created by placement <code>new</code>. Normally, destructors are called automatically; this is one of the rare cases that require an explicit call. An explicit call to a destructor requires identifying the object to be destroyed. Because there are pointers to the objects, you can use these pointers:</p>
<p class="programlisting">pc3-&gt;~JustTesting();&#160;&#160;// destroy object pointed to by pc3<br/>pc1-&gt;~JustTesting();&#160;&#160;// destroy object pointed to by pc1</p>
<p><a href="#ch12ex09">Listing 12.9</a> fixes <a href="#ch12ex08">Listing 12.8</a> by managing memory locations used by placement <code>new</code> and by adding appropriate uses of <code>delete</code> and of explicit destructor calls. One important fact is the proper order of deletion. The objects constructed by placement <code>new</code> should be destroyed in order opposite that in which they were constructed. The reason is that, in principle, a later object might have dependencies on an earlier object. And the buffer used to hold the objects should be freed only after all the contained objects are destroyed.</p>
<p class="caption1"><a id="ch12ex09"/><strong>Listing 12.9. <code>placenew2.cpp</code></strong></p><hr/>
<p class="programlisting1">// placenew2.cpp&#160;&#160;-- new, placement new, no delete<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;new&gt;<br/>using namespace std;<br/>const int BUF = 512;<br/><br/>class JustTesting<br/>{<br/><a id="page_675"/>private:<br/>&#160;&#160;&#160;&#160;string words;<br/>&#160;&#160;&#160;&#160;int number;<br/>public:<br/>&#160;&#160;&#160;&#160;JustTesting(const string &#38; s = "Just Testing", int n = 0)<br/>&#160;&#160;&#160;&#160;{words = s; number = n; cout &lt;&lt; words &lt;&lt; " constructed\n"; }<br/>&#160;&#160;&#160;&#160;~JustTesting() { cout &lt;&lt; words &lt;&lt; " destroyed\n";}<br/>&#160;&#160;&#160;&#160;void Show() const { cout &lt;&lt; words &lt;&lt; ", " &lt;&lt; number &lt;&lt; endl;}<br/>};<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;char * buffer = new char[BUF];&#160;&#160;&#160;&#160;&#160;&#160;&#160;// get a block of memory<br/><br/>&#160;&#160;&#160;&#160;JustTesting *pc1, *pc2;<br/><br/>&#160;&#160;&#160;&#160;pc1 = new (buffer) JustTesting;&#160;&#160;&#160;&#160;&#160;&#160;// place object in buffer<br/>&#160;&#160;&#160;&#160;pc2 = new JustTesting("Heap1", 20);&#160;&#160;// place object on heap<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory block addresses:\n" &lt;&lt; "buffer: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; (void *) buffer &lt;&lt; "&#160;&#160;&#160;&#160;heap: " &lt;&lt; pc2 &lt;&lt;endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory contents:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pc1 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;pc1-&gt;Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pc2 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;pc2-&gt;Show();<br/><br/>&#160;&#160;&#160;&#160;JustTesting *pc3, *pc4;<br/>// fix placement new location<br/>&#160;&#160;&#160;&#160;pc3 = new (buffer + sizeof (JustTesting))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;JustTesting("Better Idea", 6);<br/>&#160;&#160;&#160;&#160;pc4 = new JustTesting("Heap2", 10);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory contents:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pc3 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;pc3-&gt;Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pc4 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;pc4-&gt;Show();<br/><br/>&#160;&#160;&#160;&#160;delete pc2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free Heap1<br/>&#160;&#160;&#160;&#160;delete pc4;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free Heap2<br/>// explicitly destroy placement new objects<br/>&#160;&#160;&#160;&#160;pc3-&gt;~JustTesting();&#160;&#160;// destroy object pointed to by pc3<br/>&#160;&#160;&#160;&#160;pc1-&gt;~JustTesting();&#160;&#160;// destroy object pointed to by pc1<br/>&#160;&#160;&#160;&#160;delete [] buffer;&#160;&#160;&#160;&#160;&#160;// free buffer<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_676"/>Here is the output of the program in <a href="#ch12ex09">Listing 12.9</a>:</p>
<p class="programlisting">Just Testing constructed<br/>Heap1 constructed<br/>Memory block addresses:<br/>buffer: 00320AB0&#160;&#160;&#160;&#160;heap: 00320CE0<br/>Memory contents:<br/>00320AB0: Just Testing, 0<br/>00320CE0: Heap1, 20<br/>Better Idea constructed<br/>Heap2 constructed<br/>Memory contents:<br/>00320AD0: Better Idea, 6<br/>00320EC8: Heap2, 10<br/>Heap1 destroyed<br/>Heap2 destroyed<br/>Better Idea destroyed<br/>Just Testing destroyed<br/>Done</p>
<p>The program in <a href="#ch12ex09">Listing 12.9</a> places the two placement <code>new</code> objects in adjacent location and calls the proper destructors.</p>
<h3 id="ch12lev1sec6">Reviewing Techniques</h3>
<p>By now, you&#8217;ve encountered several programming techniques for dealing with various class-related problems, and you may be having trouble keeping track of all of them. So the following sections summarize several techniques and when they are used.</p>
<h4 id="ch12lev2sec19">Overloading the <code>&lt;&lt;</code> Operator</h4>
<p>To redefine the <code>&lt;&lt;</code> operator so that you use it with <code>cout</code> to display an object&#8217;s contents, you define a friend operator function that has the following form:</p>
<p class="programlisting">ostream &#38; operator&lt;&lt;(ostream &#38; os, const <span class="EmpItalic">c_name</span> &#38; obj)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; ... ;&#160;&#160;// display object contents<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p>Here <em><code>c_name</code></em> represents the name of the class. If the class provides public methods that return the required contents, you can use those methods in the operator function and dispense with the friend status.</p>
<h4 id="ch12lev2sec20">Conversion Functions</h4>
<p><a id="page_677"/>To convert a single value to a class type, you create a class constructor that has the following prototype:</p>
<p class="programlisting"><span class="EmpItalic">c_name</span>(<span class="EmpItalic">type_name</span> value);</p>
<p>Here <em><code>c_name</code></em> represents the class name, and <em><code>type_name</code></em> represents the name of the type you want to convert.</p>
<p>To convert a class type to some other type, you create a class member function that has the following prototype:</p>
<p class="programlisting">operator <span class="EmpItalic">type_name()</span>;</p>
<p>Although this function has no declared return type, it should return a value of the desired type.</p>
<p>Remember to use conversion functions with care. You can use the keyword <code>explicit</code> when declaring a constructor to prevent it from being used for implicit conversions.</p>
<h4 id="ch12lev2sec21">Classes Whose Constructors Use <code>new</code></h4>
<p>You need to take several precautions when designing classes that use the <code>new</code> operator to allocate memory pointed to by a class member (yes, we summarized these precautions recently, but the rules are very important to remember, particularly because the compiler does not know them and thus won&#8217;t catch your mistakes):</p>
<p class="indenthandingB">&#8226; Any class member that points to memory allocated by <code>new</code> should have the <code>delete</code> operator applied to it in the class destructor. This frees the allocated memory.</p>
<p class="indenthandingB">&#8226; If a destructor frees memory by applying <code>delete</code> to a pointer that is a class member, every constructor for that class should initialize that pointer, either by using <code>new</code> or by setting the pointer to the null pointer.</p>
<p class="indenthandingB">&#8226; Constructors should settle on using either <code>new []</code> or <code>new</code>, but not a mixture of both. The destructor should use <code>delete []</code> if the constructors use <code>new []</code>, and it should use <code>delete</code> if the constructors use <code>new</code>.</p>
<p class="indenthandingB">&#8226; You should define a copy constructor that allocates new memory rather than copying a pointer to existing memory. This enables a program to initialize one class object to another. The constructor should normally have the following prototype:</p>
<p class="programlistingB"><span class="EmpItalic">className</span>(const <span class="EmpItalic">className</span> &#38;)</p>
<p class="indenthandingB">&#8226; You should define a class member function that overloads the assignment operator and that has a function definition with the following prototype (where <code>c_pointer</code> is a member of the <em><code>c_name</code></em> class and has the type pointer-to-<em><code>type_name</code></em>). The following example assumes that the constructors initialize the variable <code>c_pointer</code> by using <code>new []</code>:</p>
<p class="programlistingB"><a id="page_678"/><span class="EmpItalic">c_name</span> &#38; <span class="EmpItalic">c_name</span>::operator=(const <span class="EmpItalic">c_name</span> &#38; cn)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38; cn)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;// done if self-assignment<br/>&#160;&#160;&#160;&#160;delete [] c_pointer;<br/>&#160;&#160;&#160;&#160;// set size number of type_name units to be copied<br/>&#160;&#160;&#160;&#160;c_pointer = new type_name[size];<br/>&#160;&#160;&#160;&#160;// then copy data pointed to by cn.c_pointer to<br/>&#160;&#160;&#160;&#160;// location pointed to by c_pointer<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;return *this;<br/>}</p>
<h3 id="ch12lev1sec7">A Queue Simulation</h3>
<p>Let&#8217;s apply your improved understanding of classes to a programming problem. The Bank of Heather wants to open an automatic teller machine (ATM) in the Food Heap supermarket. The Food Heap management is concerned about lines at the ATM interfering with traffic flow in the market and may want to impose a limit on the number of people allowed to line up at the ATM. The Bank of Heather people want estimates of how long customers will have to wait in line. Your task is to prepare a program that simulates the situation so that management can see what the effect of the ATM might be.</p>
<p>A rather natural way of representing the problem is to use a queue of customers. A queue is an abstract data type (ADT) that holds an ordered sequence of items. New items are added to the rear of the queue, and items can be removed from the front. A queue is a bit like a stack, except that a stack has additions and removals at the same end. This makes a stack a LIFO (last in, first out) structure, whereas the queue is a FIFO (first in, first out) structure. Conceptually, a queue is like a line at a checkout stand or an ATM, so it&#8217;s ideally suited to the task. So one part of the project is to define a <code>Queue</code> class. (In <a href="ch16.html#ch16">Chapter 16</a>, you&#8217;ll read about the Standard Template Library <code>queue</code> class, but you&#8217;ll learn more by developing your own than by just reading about such a class.)</p>
<p>The items in the queue will be customers. A Bank of Heather representative tells you that, on average, a third of the customers will take one minute to be processed, a third will take two minutes, and a third will take three minutes. Furthermore, customers arrive at random intervals, but the average number of customers per hour is fairly constant. Two more parts of your project will be to design a class representing customers and to put together a program that simulates the interactions between customers and the queue (see <a href="#ch12fig07">Figure 12.7</a>).</p>
<p class="caption"><a id="page_679"/><a id="ch12fig07"/><strong>Figure 12.7. A queue.</strong></p>
<p class="image"><img src="graphics/12fig07.jpg" alt="Image"/></p>
<h4 id="ch12lev2sec22">A Queue Class</h4>
<p>The first order of business is to design a <code>Queue</code> class. First, you need to list the attributes of the kind of queue you&#8217;ll need:</p>
<p class="indenthandingB">&#8226; A queue holds an ordered sequence of items.</p>
<p class="indenthandingB">&#8226; A queue has a limit on the number of items it can hold.</p>
<p class="indenthandingB">&#8226; You should be able to create an empty queue.</p>
<p class="indenthandingB">&#8226; You should be able to check whether a queue is empty.</p>
<p class="indenthandingB">&#8226; You should be able to check whether a queue is full.</p>
<p class="indenthandingB">&#8226; You should be able to add an item to the end of a queue.</p>
<p class="indenthandingB">&#8226; You should be able to remove an item from the front of a queue.</p>
<p class="indenthandingB">&#8226; You should be able to determine the number of items in the queue.</p>
<p>As usual when designing a class, you need to develop a public interface and a private implementation.</p>
<h5 id="ch12lev3sec8">The Queue Class Interface</h5>
<p>The queue attributes listed in the preceding section suggest the following public interface for a queue class:</p>
<p class="programlisting"><a id="page_680"/>class Queue<br/>{<br/>&#160;&#160;&#160;&#160;enum {Q_SIZE = 10};<br/>private:<br/>// private representation to be developed later<br/>public:<br/>&#160;&#160;&#160;&#160;Queue(int qs = Q_SIZE); // create queue with a qs limit<br/>&#160;&#160;&#160;&#160;~Queue();<br/>&#160;&#160;&#160;&#160;bool isempty() const;<br/>&#160;&#160;&#160;&#160;bool isfull() const;<br/>&#160;&#160;&#160;&#160;int queuecount() const;<br/>&#160;&#160;&#160;&#160;bool enqueue(const Item &#38;item); // add item to end<br/>&#160;&#160;&#160;&#160;bool dequeue(Item &#38;item);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// remove item from front<br/>};</p>
<p>The constructor creates an empty queue. By default, the queue can hold up to 10 items, but that can be overridden with an explicit initialization argument:</p>
<p class="programlisting">Queue line1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// queue with 10-item limit<br/>Queue line2(20);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// queue with 20-item limit</p>
<p>When using the queue, you can use a <code>typedef</code> to define <code>Item</code>. (In <a href="ch14.html#ch14">Chapter 14</a>, &#8220;<a href="ch14.html#ch14">Reusing Code in C++</a>,&#8221; you&#8217;ll learn how to use class templates instead.)</p>
<h5 id="ch12lev3sec9">The Queue Class Implementation</h5>
<p>After you determine the interface, you can implement it. First, you have to decide how to represent the queue data. One approach is to use <code>new</code> to dynamically allocate an array with the required number of elements. However, arrays aren&#8217;t a good match to queue operations. For example, removing an item from the front of the array should be followed up by shifting every remaining element one unit closer to the front. Otherwise, you need to do something more elaborate, such as treat the array as circular. Using a linked list, however, is a reasonable fit to the requirements of a queue. A <em>linked list</em> consists of a sequence of nodes. Each <em>node</em> contains the information to be held in the list, plus a pointer to the next node in the list. For the queue in this example, each data part is a type <code>Item</code> value, and you can use a structure to represent a node:</p>
<p class="programlisting">struct Node<br/>{<br/>&#160;&#160;&#160;&#160;&#160;Item item;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// data stored in the node<br/>&#160;&#160;&#160;&#160;&#160;struct Node * next;&#160;&#160;&#160;&#160;// pointer to next node<br/>};</p>
<p><a href="#ch12fig08">Figure 12.8</a> illustrates a linked list.</p>
<p class="caption"><a id="ch12fig08"/><strong>Figure 12.8. A linked list.</strong></p>
<p class="image"><img src="graphics/12fig08.jpg" alt="Image"/></p>
<p>The example shown in <a href="#ch12fig08">Figure 12.8</a> is called a <em>singly linked list</em> because each node has a single link, or pointer, to another node. If you have the address of the first node, you can follow the pointers to each subsequent node in the list. Commonly, the pointer in the last node in the list is set to <code>NULL</code> (or, equivalently, to <code>0</code>) to indicate that there are no further nodes. With C++11, you should use the new <code>nullptr</code> keyword. To keep track of a linked <a id="page_681"/>list, you must know the address of the first node. You can use a data member of the <code>Queue</code> class to point to the beginning of the list. In principle, that&#8217;s all the information you need because you can trace down the chain of nodes to find any other node. However, because a queue always adds a new item to the end of the queue, it is convenient to have a data member point to the last node, too (see <a href="#ch12fig09">Figure 12.9</a>). In addition, you can use data members to keep track of the maximum number of items allowed in the queue and of the current number of items. Thus, the private part of the class declaration can look like this:</p>
<p class="programlisting">class Queue<br/>{<br/>private:<br/>// class scope definitions<br/>&#160;&#160;&#160;&#160;// Node is a nested structure definition local to this class<br/>&#160;&#160;&#160;&#160;struct Node { Item item; struct Node * next;};<br/>&#160;&#160;&#160;&#160;enum {Q_SIZE = 10};<br/>// private class members<br/>&#160;&#160;&#160;&#160;Node * front;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to front of Queue<br/>&#160;&#160;&#160;&#160;Node * rear;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to rear of Queue<br/>&#160;&#160;&#160;&#160;int items;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// current number of items in Queue<br/>&#160;&#160;&#160;&#160;const int qsize;&#160;&#160;&#160;&#160;// maximum number of items in Queue<br/>&#160;&#160;&#160;&#160;...<br/>public:<br/>//...<br/>};</p>
<p class="caption"><a id="ch12fig09"/><strong>Figure 12.9. A <code>Queue</code> object.</strong></p>
<p class="image"><img src="graphics/12fig09.jpg" alt="Image"/></p>
<p>The declaration uses the C++ ability to nest a structure or class declaration inside a class. By placing the <code>Node</code> declaration inside the <code>Queue</code> class, you give it class scope. That is, <code>Node</code> is a type that you can use to declare class members and as a type name in class methods, but the <a id="page_682"/>type is restricted to the class. That way, you don&#8217;t have to worry about this declaration of <code>Node</code> conflicting with some global declaration or with a <code>Node</code> declared inside some other class. Some obsolescent compilers do not support nested structures and classes. If yours doesn&#8217;t, then you have to define a <code>Node</code> structure globally, giving it file scope.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch12sb04"/>Nested Structures and Classes</p>
<p class="sidebarpara">A structure, a class, or an enumeration declared within a class declaration is said to be <em>nested</em> in the class. It has class scope. Such a declaration doesn&#8217;t create a data object. Rather, it specifies a type that can be used internally within the class. If the declaration is made in the private section of the class, then the declared type can be used only within the class. If the declaration is made in the public section, then the declared type can also be used out of the class, through use of the scope-resolution operator. For example, if <code>Node</code> were declared in the public section of the <code>Queue</code> class, you could declare variables of type <code>Queue::Node</code> outside the <code>Queue</code> class.</p>
<hr/></div>
<p>After you settle on a data representation, the next step is to code the class methods.</p>
<h5 id="ch12lev3sec10">The Class Methods</h5>
<p>A class constructor should provide values for the class members. Because the queue in this example begins in an empty state, you should set the front and rear pointers to <code>NULL</code> (or <code>0</code> <a id="page_683"/>or <code>nullptr</code>) and <code>items</code> to <code>0</code>. Also you should set the maximum queue size <code>qsize</code> to the constructor argument <code>qs</code>. Here&#8217;s an implementation that does not work:</p>
<p class="programlisting">Queue::Queue(int qs)<br/>{<br/>&#160;&#160;&#160;&#160;front = rear = NULL;<br/>&#160;&#160;&#160;&#160;items = 0;<br/>&#160;&#160;&#160;&#160;qsize = qs;&#160;&#160;&#160;&#160;// not acceptable!<br/>}</p>
<p>The problem is that <code>qsize</code> is a <code>const</code>, so it can be <em>initialized to</em> a value, but it can&#8217;t be <em>assigned</em> a value. Conceptually, calling a constructor creates an object before the code within the brackets is executed. Thus, calling the <code>Queue(int qs)</code> constructor causes the program to first allocate space for the four member variables. Then program flow enters the brackets and uses ordinary assignment to place values into the allocated space. Therefore, if you want to initialize a <code>const</code> data member, you have to do so when the object is created before execution reaches the body of the constructor. C++ provides a special syntax for doing just that. It&#8217;s called a <em>member initializer list</em>. The member initializer list consists of a comma-separated list of initializers preceded by a colon. It&#8217;s placed after the closing parenthesis of the argument list and before the opening bracket of the function body. If a data member is named <code>mdata</code> and if it&#8217;s to be initialized to the value <code>val</code>, the initializer has the form <code>mdata(val)</code>. Using this notation, you can write the <code>Queue</code> constructor like this:</p>
<p class="programlisting">Queue::Queue(int qs) : qsize(qs)&#160;&#160;&#160;// initialize qsize to qs<br/>{<br/>&#160;&#160;&#160;&#160;front = rear = NULL;<br/>&#160;&#160;&#160;&#160;items = 0;<br/>}</p>
<p>In general, the initial value can involve constants and arguments from the constructor&#8217;s argument list. The technique is not limited to initializing constants; you can also write the <code>Queue</code> constructor like this:</p>
<p class="programlisting">Queue::Queue(int qs) : qsize(qs), front(NULL), rear(NULL), items(0)<br/>{<br/>}</p>
<p>Only constructors can use this initializer-list syntax. As you&#8217;ve seen, you have to use this syntax for <code>const</code> class members. You also have to use it for class members that are declared as references:</p>
<p class="programlisting">class Agency {...};<br/>class Agent<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;Agency &#38; belong;&#160;&#160;&#160;&#160;// must use initializer list to initialize<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>Agent::Agent(Agency &#38; a) : belong(a) {...}</p>
<p><a id="page_684"/>That&#8217;s because references, like <code>const</code> data, can be initialized only when created. For simple data members, such as <code>front</code> and <code>items</code>, it doesn&#8217;t make much difference whether you use a member initializer list or use assignment in the function body. As you&#8217;ll see in <a href="ch14.html#ch14">Chapter 14</a>, however, it&#8217;s more efficient to use the member initializer list for members that are themselves class objects.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch12sb05"/>The Member Initializer List Syntax</p>
<p class="sidebarpara">If <code>Classy</code> is a class and if <code>mem1</code>, <code>mem2</code>, and <code>mem3</code> are class data members, a class constructor can use the following syntax to initialize the data members:</p>
<p class="programlistingB">Classy::Classy(int n, int m) :mem1(n), mem2(0), mem3(n*m + 2)<br/>{<br/>//...<br/>}</p>
<p class="sidebarpara">This initializes <code>mem1</code> to <code>n</code>, <code>mem2</code> to <code>0</code>, and <code>mem3</code> to <code>n*m + 2</code>. Conceptually, these initializations take place when the object is created and before any code within the brackets is executed. Note the following:</p>
<p class="indenthandingB">&#8226; This form can be used only with constructors.</p>
<p class="indenthandingB">&#8226; You must (at least, in pre-C++11) use this form to initialize a nonstatic <code>const</code> data member.</p>
<p class="indenthandingB">&#8226; You must use this form to initialize a reference data member.</p>
<p class="sidebarpara">Data members are initialized in the order in which they appear in the class declaration, not in the order in which initializers are listed.</p>
<hr/></div>
<div class="note"><hr/>
<p class="title"><a id="ch12note07"/>Caution</p>
<p class="notepara">You can&#8217;t use the member initializer list syntax with class methods other than constructors.</p>
<hr/></div>
<p>The parenthesized form used in the member initializer list can be used in ordinary initializations, too. That is, if you like, you can replace code such as</p>
<p class="programlisting">int games = 162;<br/>double talk = 2.71828;</p>
<p>with</p>
<p class="programlisting">int games(162);<br/>double talk(2.71828);</p>
<p>This allows initializing built-in types to look like initializing class objects.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch12sb06"/>C++11 Member In-Class Initialization</p>
<p class="sidebarpara">C++11 allows you to do what would seem to be the intuitively obvious thing to do:</p>
<p class="programlistingB">class Classy<br/>{<br/>&#160;&#160;&#160;&#160;int mem1 = 10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// in-class initialization<br/>&#160;&#160;&#160;&#160;const int mem2 = 20; // in-class initialization<br/>//...<br/>};</p>
<p class="sidebarpara">This is equivalent to using a member initialization list in the constructors:</p>
<p class="programlistingB">Classy::Classy() : mem1(10), mem2(20) {...}</p>
<p class="sidebarpara">The members <code>mem1</code> and <code>mem2</code> get initialized to <code>10</code> and <code>20</code>, respectively, unless a constructor using a member initialization list is called. Then the actual list overrides these default initializations:</p>
<p class="programlistingB">Classy::Classy(int n) : mem1(n) {...}</p>
<p class="sidebarpara">In this case, the constructor would use the value of <code>n</code> to initialize <code>mem1</code>, and <code>mem2</code> still would be set to <code>20</code>.</p>
<hr/></div>
<p><a id="page_685"/>The code for <code>isempty()</code>, <code>isfull()</code>, and <code>queuecount()</code> is simple. If <code>items</code> is <code>0</code>, the queue is empty. If <code>items</code> is <code>qsize</code>, the queue is full. Returning the value of <code>items</code> answers the question of how many items are in the queue. You&#8217;ll see the code later this chapter in <a href="#ch12ex11">Listing 12.11</a>.</p>
<p>Adding an item to the rear of the queue (enqueuing) is more involved. Here is one approach:</p>
<p class="programlisting">bool Queue::enqueue(const Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;Node * add = new Node;&#160;&#160;// create node<br/>// on failure, new throws std::bad_alloc exception<br/>&#160;&#160;&#160;&#160;add-&gt;item = item;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set node pointers<br/>&#160;&#160;&#160;&#160;add-&gt;next = NULL;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// or nullptr;<br/>&#160;&#160;&#160;&#160;items++;<br/>&#160;&#160;&#160;&#160;if (front == NULL)&#160;&#160;&#160;&#160;&#160;&#160;// if queue is empty,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;front = add;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// place item at front<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rear-&gt;next = add;&#160;&#160;&#160;// else place at rear<br/>&#160;&#160;&#160;&#160;rear = add;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// have rear point to new node<br/>&#160;&#160;&#160;&#160;return true;<br/>}</p>
<p>In brief, the method goes through the following phases (see <a href="#ch12fig10">Figure 12.10</a>):</p>
<p class="indenthandingN"><strong>1.</strong> Terminate if the queue is already full. (For this implementation, the maximum size is selected by the user via the constructor.)</p>
<p class="indenthandingN"><strong>2.</strong> Create a new node. If <code>new</code> can&#8217;t do so, it throws an exception, which is a topic taken up in <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>.&#8221; The practical upshot is that unless one provides additional programming to handle the exception, the program terminates.</p>
<p class="indenthandingN"><strong>3.</strong> <a id="page_686"/>Place proper values into the node. In this case, the code copies an <code>Item</code> value into the data part of the node and sets the node&#8217;s next pointer to <code>NULL</code> (or <code>0</code> or, in C++11, <code>nullptr</code>). This prepares the node to be the last item in the queue.</p>
<p class="indenthandingN"><strong>4.</strong> Increase the item count (<code>items</code>) by one.</p>
<p class="indenthandingN"><strong>5.</strong> Attach the node to the rear of the queue. There are two parts to this process. The first is linking the node to the other nodes in the list. This is done by having the <code>next</code> pointer of the currently rear node point to the new rear node. The second part is to set the <code>Queue</code> member pointer <code>rear</code> to point to the new node so that the queue can access the last node directly. If the queue is empty, you must also set the <code>front</code> pointer to point to the new node. (If there&#8217;s just one node, it&#8217;s both the front and the rear node.)</p>
<p class="caption"><a id="ch12fig10"/><strong>Figure 12.10. Enqueuing an item.</strong></p>
<p class="image"><img src="graphics/12fig10.jpg" alt="Image"/></p>
<p><a id="page_687"/>Removing an item from the front of the queue (dequeuing) also has several steps. Here is one approach:</p>
<p class="programlisting">bool Queue::dequeue(Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (front == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;item = front-&gt;item;&#160;&#160;&#160;&#160;&#160;// set item to first item in queue<br/>&#160;&#160;&#160;&#160;items--;<br/>&#160;&#160;&#160;&#160;Node * temp = front;&#160;&#160;&#160;&#160;// save location of first item<br/>&#160;&#160;&#160;&#160;front = front-&gt;next;&#160;&#160;&#160;&#160;// reset front to next item<br/>&#160;&#160;&#160;&#160;delete temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// delete former first item<br/>&#160;&#160;&#160;&#160;if (items == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rear = NULL;<br/>&#160;&#160;&#160;&#160;return true;<br/>}</p>
<p>In brief, the method goes through the following phases (see <a href="#ch12fig11">Figure 12.11</a>):</p>
<p class="indenthandingN"><strong>1.</strong> Terminate if the queue is already empty.</p>
<p class="indenthandingN"><strong>2.</strong> Provide the first item in the queue to the calling function. This is accomplished by copying the data portion of the current <code>front</code> node into the reference variable passed to the method.</p>
<p class="indenthandingN"><strong>3.</strong> Decrease the item count (<code>items</code>) by one.</p>
<p class="indenthandingN"><strong>4.</strong> Save the location of the front node for later deletion.</p>
<p class="indenthandingN"><strong>5.</strong> Take the node off the queue. This is accomplished by setting the <code>Queue</code> member pointer <code>front</code> to point to the next node, whose address is provided by <code>front-&gt;next</code>.</p>
<p class="indenthandingN"><strong>6.</strong> To conserve memory, delete the former first node.</p>
<p class="indenthandingN"><strong>7.</strong> If the list is now empty, set <code>rear</code> to <code>NULL</code>. (The front pointer would already be <code>NULL</code> in this case, after setting <code>front-&gt;next</code>.) Again, you can use <code>0</code> instead of <code>NULL</code>, or, with C++11, you can use <code>nullptr</code>.</p>
<p class="caption"><a id="ch12fig11"/><strong>Figure 12.11. Dequeuing an item.</strong></p>
<p class="image"><img src="graphics/12fig11.jpg" alt="Image"/></p>
<p>Step 4 is necessary because step 5 erases the queue&#8217;s memory of where the former first node is.<a id="page_688"/></p>
<h5 id="ch12lev3sec11">Other Class Methods?</h5>
<p><a id="page_689"/>Do you need any more methods? The class constructor doesn&#8217;t use <code>new</code>, so at first glance, it may appear that you don&#8217;t have to worry about the special requirements of classes that do use <code>new</code> in the constructors. Of course, that first glance is misleading because adding objects to a queue does invoke <code>new</code> to create new nodes. It&#8217;s true that the <code>dequeue()</code> method cleans up by deleting nodes, but there&#8217;s no guarantee that a queue will be empty when it expires. Therefore, the class does require an explicit destructor&#8212;one that deletes all remaining nodes. Here&#8217;s an implementation that starts at the front of the list and deletes each node in turn:</p>
<p class="programlisting">Queue::~Queue()<br/>{<br/>&#160;&#160;&#160;&#160;Node * temp;<br/>&#160;&#160;&#160;&#160;while (front != NULL)&#160;&#160;&#160;// while queue is not yet empty<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp = front;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// save address of front item<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;front = front-&gt;next;// reset pointer to next item<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// delete former front<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<p>Hmmm. You&#8217;ve seen that classes that use <code>new</code> usually require explicit copy constructors and assignment operators that do deep copying. Is that the case here? The first question to answer is, &#8220;Does the default memberwise copying do the right thing?&#8221; The answer is no. Memberwise copying of a <code>Queue</code> object would produce a new object that points to the front and rear of the same linked list as the original. Thus, adding an item to the copy <code>Queue</code> object changes the shared linked list. That&#8217;s bad enough. What&#8217;s worse is that only the copy&#8217;s rear pointer gets updated, essentially corrupting the list from the standpoint of the original object. Clearly, then, cloning or copying queues requires providing a copy constructor and an assignment constructor that do deep copying.</p>
<p>Of course, that raises the question of why you would want to copy a queue. Well, perhaps you would want to save snapshots of a queue during different stages of a simulation. Or you would like to provide identical input to two different strategies. Actually, it might be useful to have operations that split a queue, the way supermarkets sometimes do when opening an additional checkout stand. Similarly, you might want to combine two queues into one or truncate a queue.</p>
<p>But suppose you don&#8217;t want to do any of these things in this simulation. Can&#8217;t you simply ignore those concerns and use the methods you already have? Of course you can. However, at some time in the future, you might need to use a queue again, but with copying. And you might forget that you failed to provide proper code for copying. In that case, your programs will compile and run, but they will generate puzzling results and crashes. So it would seem that it&#8217;s best to provide a copy constructor and an assignment operator, even though you don&#8217;t need them now.</p>
<p><a id="page_690"/>Fortunately, there is a sneaky way to avoid doing this extra work while still protecting against future program crashes. The idea is to define the required methods as dummy private methods:</p>
<p class="programlisting">class Queue<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;Queue(const Queue &#38; q) : qsize(0) { }&#160;&#160;&#160;// preemptive definition<br/>&#160;&#160;&#160;&#160;Queue &#38; operator=(const Queue &#38; q) { return *this;}<br/>//...<br/>};</p>
<p>This has two effects. First, it overrides the default method definitions that otherwise would be generated automatically. Second, because these methods are private, they can&#8217;t be used by the world at large. That is, if <code>nip</code> and <code>tuck</code> are <code>Queue</code> objects, the compiler won&#8217;t allow the following:</p>
<p class="programlisting">Queue snick(nip);&#160;&#160;&#160;&#160;&#160;// not allowed<br/>tuck = nip;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed</p>
<p>Therefore, instead of being faced with mysterious runtime malfunctions in the future, you&#8217;ll get an easier-to-trace compiler error, stating that these methods aren&#8217;t accessible. Also this trick is useful when you define a class whose objects really should not be copied.</p>
<p>C++11 provides an alternative way to disable a method by using the keyword <code>delete</code>; <a href="ch18.html#ch18">Chapter 18</a> returns to this topic.</p>
<p>Are there any other effects to note? Yes. Recall that a copy constructor is invoked when objects are passed (or returned) by value. However, this is no problem if you follow the preferred practice of passing objects as references. Also a copy constructor is used to create other temporary objects. But the <code>Queue</code> definition lacks operations that lead to temporary objects, such as overloading the addition operator.</p>
<h4 id="ch12lev2sec23">The <code>Customer</code> Class</h4>
<p>At this point, we need to design a customer class. In general, an ATM customer has many properties, such as a name, account numbers, and account balances. However, the only properties you need for the simulation are when a customer joins the queue and the time required for the customer&#8217;s transaction. When the simulation produces a new customer, the program should create a new customer object, storing in it the customer&#8217;s time of arrival and a randomly generated value for the transaction time. When the customer reaches the front of the queue, the program should note the time and subtract the queue-joining time to get the customer&#8217;s waiting time. Here&#8217;s how you can define and implement the <code>Customer</code> class:</p>
<p class="programlisting">class Customer<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;long arrive;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// arrival time for customer<br/>&#160;&#160;&#160;&#160;int processtime;&#160;&#160;&#160;&#160;// processing time for customer<br/><a id="page_691"/>public:<br/>&#160;&#160;&#160;&#160;Customer() { arrive = processtime = 0; }<br/>&#160;&#160;&#160;&#160;void set(long when);<br/>&#160;&#160;&#160;&#160;long when() const { return arrive; }<br/>&#160;&#160;&#160;&#160;int ptime() const { return processtime; }<br/>};<br/>void Customer::set(long when)<br/>{<br/>&#160;&#160;&#160;&#160;processtime = std::rand() % 3 + 1;<br/>&#160;&#160;&#160;&#160;arrive = when;<br/>}</p>
<p>The default constructor creates a null customer. The <code>set()</code> member function sets the arrival time to its argument and randomly picks a value from 1 through 3 for the processing time.</p>
<p><a href="#ch12ex10">Listing 12.10</a> gathers together the <code>Queue</code> and <code>Customer</code> class declarations, and <a href="#ch12ex11">Listing 12.11</a> provides the methods.</p>
<p class="caption1"><a id="ch12ex10"/><strong>Listing 12.10. <code>queue.h</code></strong></p><hr/>
<p class="programlisting1">// queue.h -- interface for a queue<br/>#ifndef QUEUE_H_<br/>#define QUEUE_H_<br/>// This queue will contain Customer items<br/>class Customer<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;long arrive;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// arrival time for customer<br/>&#160;&#160;&#160;&#160;int processtime;&#160;&#160;&#160;&#160;// processing time for customer<br/>public:<br/>&#160;&#160;&#160;&#160;Customer() { arrive = processtime = 0; }<br/>&#160;&#160;&#160;&#160;void set(long when);<br/>&#160;&#160;&#160;&#160;long when() const { return arrive; }<br/>&#160;&#160;&#160;&#160;int ptime() const { return processtime; }<br/>};<br/><br/>typedef Customer Item;<br/><br/>class Queue<br/>{<br/>private:<br/>// class scope definitions<br/>&#160;&#160;&#160;&#160;// Node is a nested structure definition local to this class<br/>&#160;&#160;&#160;&#160;struct Node { Item item; struct Node * next;};<br/>&#160;&#160;&#160;&#160;enum {Q_SIZE = 10};<br/>// private class members<br/>&#160;&#160;&#160;&#160;Node * front;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to front of Queue<br/>&#160;&#160;&#160;&#160;Node * rear;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to rear of Queue<br/>&#160;&#160;&#160;&#160;int items;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// current number of items in Queue<br/>&#160;&#160;&#160;&#160;const int qsize;&#160;&#160;&#160;&#160;// maximum number of items in Queue<br/>&#160;&#160;&#160;&#160;// preemptive definitions to prevent public copying<br/>&#160;&#160;&#160;&#160;Queue(const Queue &#38; q) : qsize(0) { }<br/>&#160;&#160;&#160;&#160;Queue &#38; operator=(const Queue &#38; q) { return *this;}<br/>public:<br/>&#160;&#160;&#160;&#160;Queue(int qs = Q_SIZE); // create queue with a qs limit<br/>&#160;&#160;&#160;&#160;~Queue();<br/>&#160;&#160;&#160;&#160;bool isempty() const;<br/>&#160;&#160;&#160;&#160;bool isfull() const;<br/>&#160;&#160;&#160;&#160;int queuecount() const;<br/>&#160;&#160;&#160;&#160;bool enqueue(const Item &#38;item); // add item to end<br/>&#160;&#160;&#160;&#160;bool dequeue(Item &#38;item);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// remove item from front<br/>};<br/>#endif</p><hr/>
<p class="caption1"><a id="page_692"/><a id="ch12ex11"/><strong>Listing 12.11. <code>queue.cpp</code></strong></p><hr/>
<p class="programlisting1">// queue.cpp -- Queue and Customer methods<br/>#include "queue.h"<br/>#include &lt;cstdlib&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// (or stdlib.h) for rand()<br/><br/>// Queue methods<br/>Queue::Queue(int qs) : qsize(qs)<br/>{<br/>&#160;&#160;&#160;&#160;front = rear = NULL;&#160;&#160;&#160;&#160;// or nullptr<br/>&#160;&#160;&#160;&#160;items = 0;<br/>}<br/><br/>Queue::~Queue()<br/>{<br/>&#160;&#160;&#160;&#160;Node * temp;<br/>&#160;&#160;&#160;&#160;while (front != NULL)&#160;&#160;&#160;// while queue is not yet empty<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp = front;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// save address of front item<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;front = front-&gt;next;// reset pointer to next item<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// delete former front<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>bool Queue::isempty() const<br/>{<br/>&#160;&#160;&#160;&#160;return items == 0;<br/>}<br/><br/><a id="page_693"/>bool Queue::isfull() const<br/>{<br/>&#160;&#160;&#160;&#160;return items == qsize;<br/>}<br/><br/>int Queue::queuecount() const<br/>{<br/>&#160;&#160;&#160;&#160;return items;<br/>}<br/><br/>// Add item to queue<br/>bool Queue::enqueue(const Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;Node * add = new Node;&#160;&#160;// create node<br/>// on failure, new throws std::bad_alloc exception<br/>&#160;&#160;&#160;&#160;add-&gt;item = item;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set node pointers<br/>&#160;&#160;&#160;&#160;add-&gt;next = NULL;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// or nullptr;<br/>&#160;&#160;&#160;&#160;items++;<br/>&#160;&#160;&#160;&#160;if (front == NULL)&#160;&#160;&#160;&#160;&#160;&#160;// if queue is empty,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;front = add;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// place item at front<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rear-&gt;next = add;&#160;&#160;&#160;// else place at rear<br/>&#160;&#160;&#160;&#160;rear = add;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// have rear point to new node<br/>&#160;&#160;&#160;&#160;return true;<br/>}<br/><br/>// Place front item into item variable and remove from queue<br/>bool Queue::dequeue(Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (front == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;item = front-&gt;item;&#160;&#160;&#160;&#160;&#160;// set item to first item in queue<br/>&#160;&#160;&#160;&#160;items--;<br/>&#160;&#160;&#160;&#160;Node * temp = front;&#160;&#160;&#160;&#160;// save location of first item<br/>&#160;&#160;&#160;&#160;front = front-&gt;next;&#160;&#160;&#160;&#160;// reset front to next item<br/>&#160;&#160;&#160;&#160;delete temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// delete former first item<br/>&#160;&#160;&#160;&#160;if (items == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rear = NULL;<br/>&#160;&#160;&#160;&#160;return true;<br/>}<br/><br/>// customer method<br/><br/>// when is the time at which the customer arrives<br/>// the arrival time is set to when and the processing<br/>// time set to a random value in the range 1 - 3<br/>void Customer::set(long when)<br/>{<br/>&#160;&#160;&#160;&#160;processtime = std::rand() % 3 + 1;<br/>&#160;&#160;&#160;&#160;arrive = when;<br/>}</p><hr/>
<h4 id="ch12lev2sec24">The ATM Simulation</h4>
<p><a id="page_694"/>You now have the tools needed for the ATM simulation. The program should allow the user to enter three quantities: the maximum queue size, the number of hours the program will simulate, and the average number of customers per hour. The program should use a loop in which each cycle represents one minute. During each minute cycle, the program should do the following:</p>
<p class="indenthandingN"><strong>1.</strong> Determine whether a new customer has arrived. If so, add the customer to the queue if there is room; otherwise, turn the customer away.</p>
<p class="indenthandingN"><strong>2.</strong> If no one is being processed, take the first person from the queue. Determine how long the person has been waiting and set a <code>wait_time</code> counter to the processing time that the new customer will need.</p>
<p class="indenthandingN"><strong>3.</strong> If a customer is being processed, decrement the <code>wait_time</code> counter by one minute.</p>
<p class="indenthandingN"><strong>4.</strong> Track various quantities, such as the number of customers served, the number of customers turned away, cumulative time spent waiting in line, and cumulative queue length.</p>
<p>When the simulation cycle is finished, the program should report various statistical findings.</p>
<p>An interesting matter is how the program determines whether a new customer has arrived. Suppose that on average, 10 customers arrive per hour. That amounts to a customer every 6 minutes. The program computes and stores that value in the variable <code>min_per_cust</code>. However, having a customer show up exactly every 6 minutes is unrealistic. What you really want (at least most of the time) is a more random process that averages to a customer every 6 minutes. The program uses this function to determine whether a customer shows up during a cycle:</p>
<p class="programlisting">bool newcustomer(double x)<br/>{<br/>&#160;&#160;&#160;&#160;return (std::rand() * x / RAND_MAX &lt; 1);<br/>}</p>
<p>Here&#8217;s how it works. The value <code>RAND_MAX</code> is defined in the <code>cstdlib</code> file (formerly <code>stdlib.h</code>) and represents the largest value the <code>rand()</code> function can return (<code>0</code> is the lowest value). Suppose that <code>x</code>, the average time between customers, is <code>6</code>. Then the value of <code>rand() * x / RAND_MAX</code> will be somewhere between <code>0</code> and <code>6</code>. In particular, it will be less than <a id="page_695"/>1 one-sixth of the time, on average. However, it&#8217;s possible that this function might yield two customers spaced 1 minute apart one time and two customers 20 minutes apart another time. This behavior leads to the clumpiness that often distinguishes real processes from the clocklike regularity of exactly one customer every 6 minutes. This particular method breaks down if the average time between arrivals drops below 1 minute, but the simulation is not intended to handle that scenario. If you did need to deal with such a case, you&#8217;d use a finer time resolution, perhaps letting each cycle represent 10 seconds.</p>
<p><a href="#ch12ex12">Listing 12.12</a> presents the details of the simulation. Running the simulation for a long time period provides insight into long-term averages, and running it for short times provides insight into short-term variations.</p>
<p class="caption1"><a id="ch12ex12"/><strong>Listing 12.12. <code>bank.cpp</code></strong></p><hr/>
<p class="programlisting1">// bank.cpp -- using the Queue interface<br/>// compile with queue.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt; // for rand() and srand()<br/>#include &lt;ctime&gt;&#160;&#160;&#160;// for time()<br/>#include "queue.h"<br/>const int MIN_PER_HR = 60;<br/><br/>bool newcustomer(double x); // is there a new customer?<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;using std::ios_base;<br/>// setting things up<br/>&#160;&#160;&#160;&#160;std::srand(std::time(0));&#160;&#160;&#160;&#160;//&#160;&#160;random initializing of rand()<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Case Study: Bank of Heather Automatic Teller\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter maximum size of queue: ";<br/>&#160;&#160;&#160;&#160;int qs;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; qs;<br/>&#160;&#160;&#160;&#160;Queue line(qs);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// line queue holds up to qs people<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the number of simulation hours: ";<br/>&#160;&#160;&#160;&#160;int hours;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;hours of simulation<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; hours;<br/>&#160;&#160;&#160;&#160;// simulation will run 1 cycle per minute<br/>&#160;&#160;&#160;&#160;long cyclelimit = MIN_PER_HR * hours; // # of cycles<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the average number of customers per hour: ";<br/>&#160;&#160;&#160;&#160;double perhour;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;average # of arrival per hour<br/><a id="page_696"/>&#160;&#160;&#160;&#160;cin &gt;&gt; perhour;<br/>&#160;&#160;&#160;&#160;double min_per_cust;&#160;&#160;&#160;&#160;//&#160;&#160;average time between arrivals<br/>&#160;&#160;&#160;&#160;min_per_cust = MIN_PER_HR / perhour;<br/><br/>&#160;&#160;&#160;&#160;Item temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;new customer data<br/>&#160;&#160;&#160;&#160;long turnaways = 0;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;turned away by full queue<br/>&#160;&#160;&#160;&#160;long customers = 0;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;joined the queue<br/>&#160;&#160;&#160;&#160;long served = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;served during the simulation<br/>&#160;&#160;&#160;&#160;long sum_line = 0;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;cumulative line length<br/>&#160;&#160;&#160;&#160;int wait_time = 0;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;time until autoteller is free<br/>&#160;&#160;&#160;&#160;long line_wait = 0;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;cumulative time in line<br/><br/><br/>// running the simulation<br/>&#160;&#160;&#160;&#160;for (int cycle = 0; cycle &lt; cyclelimit; cycle++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (newcustomer(min_per_cust))&#160;&#160;// have newcomer<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (line.isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;turnaways++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;customers++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp.set(cycle);&#160;&#160;&#160;&#160;// cycle = time of arrival<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line.enqueue(temp); // add newcomer to line<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (wait_time &lt;= 0 &#38;&#38; !line.isempty())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line.dequeue (temp);&#160;&#160;&#160;&#160;&#160;&#160;// attend next customer<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wait_time = temp.ptime(); // for wait_time minutes<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line_wait += cycle - temp.when();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;served++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (wait_time &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wait_time--;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum_line += line.queuecount();<br/>&#160;&#160;&#160;&#160;}<br/><br/>// reporting results<br/>&#160;&#160;&#160;&#160;if (customers &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "customers accepted: " &lt;&lt; customers &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;customers served: " &lt;&lt; served &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;turnaways: " &lt;&lt; turnaways &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "average queue size: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.precision(2);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; (double) sum_line / cyclelimit &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; " average wait time: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; (double) line_wait / served &lt;&lt; " minutes\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "No customers!\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done!\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>//&#160;&#160;x = average time, in minutes, between customers<br/>//&#160;&#160;return value is true if customer shows up this minute<br/>bool newcustomer(double x)<br/>{<br/>&#160;&#160;&#160;&#160;return (std::rand() * x / RAND_MAX &lt; 1);<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch12note08"/><a id="page_697"/>Note</p>
<p class="notepara">You might have a compiler that has not implemented <code>bool</code>. In that case, you can use <code>int</code> instead of <code>bool</code>, <code>0</code> instead of <code>false</code>, and <code>1</code> instead of <code>true</code>. You might also have to use <code>stdlib.h</code> and <code>time.h</code> instead of the newer <code>cstdlib</code> and <code>ctime</code>. You might have to define <code>RAND_MAX</code> yourself.</p>
<hr/></div>
<p>Here are a few sample runs of the program built from <a href="#ch12ex10">Listings 12.10</a>, <a href="#ch12ex11">12.11</a>, and <a href="#ch12ex12">12.12</a>:</p>
<p class="programlisting">Case Study: Bank of Heather Automatic Teller<br/>Enter maximum size of queue: <span class="EmpStrong">10</span><br/>Enter the number of simulation hours: <span class="EmpStrong">100</span><br/>Enter the average number of customers per hour: <span class="EmpStrong">15</span><br/>customers accepted: 1485<br/>&#160;&#160;customers served: 1485<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;turnaways: 0<br/>average queue size: 0.15<br/>&#160;average wait time: 0.63 minutes<br/>Done!<br/><br/>Case Study: Bank of Heather Automatic Teller<br/>Enter maximum size of queue: <span class="EmpStrong">10</span><br/>Enter the number of simulation hours: <span class="EmpStrong">100</span><br/>Enter the average number of customers per hour: <span class="EmpStrong">30</span><br/>customers accepted: 2896<br/>&#160;&#160;customers served: 2888<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;turnaways: 101<br/>average queue size: 4.64<br/>&#160;average wait time: 9.63 minutes<br/>Done!<br/><br/><a id="page_698"/>Case Study: Bank of Heather Automatic Teller<br/>Enter maximum size of queue: <span class="EmpStrong">20</span><br/>Enter the number of simulation hours: <span class="EmpStrong">100</span><br/>Enter the average number of customers per hour: <span class="EmpStrong">30</span><br/>customers accepted: 2943<br/>&#160;&#160;customers served: 2943<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;turnaways: 93<br/>average queue size: 13.06<br/>&#160;average wait time: 26.63 minutes<br/>Done!</p>
<p>Note that going from 15 customers per hour to 30 customers per hour doesn&#8217;t double the average wait time; it increases it by about a factor of 15. Allowing a longer queue just makes matters worse. However, the simulation doesn&#8217;t allow for the fact that many customers, frustrated with a long wait, would simply leave the queue.</p>
<p>Here are a few more sample runs of the program in <a href="#ch12ex12">Listing 12.12</a>; they illustrate the short-term variations you might see, even though the average number of customers per hour is kept constant:</p>
<p class="programlisting">Case Study: Bank of Heather Automatic Teller<br/>Enter maximum size of queue: <span class="EmpStrong">10</span><br/>Enter the number of simulation hours: <span class="EmpStrong">4</span><br/>Enter the average number of customers per hour: <span class="EmpStrong">30</span><br/>customers accepted: 114<br/>&#160;&#160;customers served: 110<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;turnaways: 0<br/>average queue size: 2.15<br/>&#160;average wait time: 4.52 minutes<br/>Done!<br/><br/>Case Study: Bank of Heather Automatic Teller<br/>Enter maximum size of queue: <span class="EmpStrong">10</span><br/>Enter the number of simulation hours: <span class="EmpStrong">4</span><br/>Enter the average number of customers per hour: <span class="EmpStrong">30</span><br/>customers accepted: 121<br/>&#160;&#160;customers served: 116<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;turnaways: 5<br/>average queue size: 5.28<br/>&#160;average wait time: 10.72 minutes<br/>Done!<br/><br/>Case Study: Bank of Heather Automatic Teller<br/>Enter maximum size of queue: <span class="EmpStrong">10</span><br/>Enter the number of simulation hours: <span class="EmpStrong">4</span><br/>Enter the average number of customers per hour: <span class="EmpStrong">30</span><br/>customers accepted: 112<br/>&#160;&#160;customers served: 109<br/><a id="page_699"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;turnaways: 0<br/>average queue size: 2.41<br/>&#160;average wait time: 5.16 minutes<br/>Done!</p>
<h3 id="ch12lev1sec8">Summary</h3>
<p>This chapter covers many important aspects of defining and using classes. Several of these aspects are subtle&#8212;even difficult&#8212;concepts. If some of them seem obscure or unusually complex to you, don&#8217;t feel bad; they affect most newcomers to C++ that way. Often the way you come to really appreciate concepts such as copy constructors is through getting into trouble by ignoring them. So some of the material in this chapter may seem vague to you until your own experiences enrich your understanding.</p>
<p>You can use <code>new</code> in a class constructor to allocate memory for data and then assign the address of the memory to a class member. This enables a class, for example, to handle strings of various sizes without committing the class design in advance to a fixed array size. Using <code>new</code> in class constructors also raises potential problems when an object expires. If an object has member pointers pointing to memory allocated by <code>new</code>, freeing the memory used to hold the object does not automatically free the memory pointed to by the object member pointers. Therefore, if you use <code>new</code> in a class constructor to allocate memory, you should use <code>delete</code> in the class destructor to free that memory. That way, the demise of an object automatically triggers the deletion of pointed-to memory.</p>
<p>Objects that have members pointing to memory allocated by <code>new</code> also have problems with initializing one object to another or assigning one object to another. By default, C++ uses memberwise initialization and assignment, which means that the initialized or the assigned-to object winds up with exact copies of the original object&#8217;s members. If an original member points to a block of data, the copy member points to the same block. When the program eventually deletes the two objects, the class destructor attempts to delete the same block of memory twice, which is an error. The solution is to define a special copy constructor that redefines initialization and to overload the assignment operator. In each case, the new definition should create duplicates of any pointed-to data and have the new object point to the copies. That way, both the old and the new objects refer to separate but identical data, with no overlap. The same reasoning applies to defining an assignment operator. In each case, the goal is to make a deep copy&#8212;that is, to copy the real data and not just pointers to the data.</p>
<p>When an object has automatic storage or external storage, the destructor for that object is called automatically when the object ceases to exist. If you allocate storage for an object by using <code>new</code> and assign its address to a pointer, the destructor for that object is called automatically when you apply <code>delete</code> to the pointer. However, if you allocate storage for class objects by using placement <code>new</code> instead of regular <code>new</code>, you also take on the responsibility of calling the destructor for that object explicitly by invoking the destructor method with a pointer to the object. C++ allows you to place structure, class, and enumeration definitions inside a class. Such nested types have class scope, meaning that they <a id="page_700"/>are local to the class and don&#8217;t conflict with structures, classes, and enumerations of the same name that are defined elsewhere.</p>
<p>C++ provides a special syntax for class constructors that can be used to initialize data members. This syntax consists of a colon followed by a comma-separated list of initializers. This is placed after the closing parenthesis of the constructor arguments and before the opening brace of the function body. Each initializer consists of the name of the member being initialized followed by parentheses containing the initialization value. Conceptually, these initializations take place when the object is created and before any statements in the function body are executed. The syntax looks like this:</p>
<p class="programlisting">queue(int qs) : qsize(qs), items(0), front(NULL), rear(NULL) { }</p>
<p>This form is obligatory if the data member is a nonstatic <code>const</code> member or a reference, except that C++11 in-class initialization can be used for nonstatic <code>const</code> members.</p>
<p>C++11 allows in-class initialization (that is, initialization in the class definition):</p>
<p class="programlisting">class Queue<br/>{<br/>private:<br/>...<br/>&#160;&#160;&#160;&#160;Node * front = NULL;<br/>&#160;&#160;&#160;&#160;enum {Q_SIZE = 10};<br/>&#160;&#160;&#160;&#160;Node * rear = NULL;<br/>&#160;&#160;&#160;&#160;int items = 0;<br/>&#160;&#160;&#160;&#160;const int qsize = Q_SIZE;<br/>...<br/>};</p>
<p>This is equivalent to using a member initialization list. However, any constructor using a membership initialization list will override the corresponding in-class initializations.</p>
<p>As you might have noticed, classes require much more care and attention to detail than do simple C-style structures. In return, they do much more for you.</p>
<h3 id="ch12lev1sec9">Chapter Review</h3>
<p class="question"><a id="ch12qa1q1" href="app10.html#ch12qa1a1"><strong>1.</strong></a> Suppose a <code>String</code> class has the following private members:</p>
<p class="programlistingB">class String<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * str;&#160;&#160;&#160;&#160;// points to string allocated by new<br/>&#160;&#160;&#160;&#160;int len;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// holds length of string<br/>//...<br/>};</p>
<p class="indenthandinga"><strong>a.</strong> <a id="page_701"/>What&#8217;s wrong with this default constructor?</p>
<p class="programlistingB">String::String() {}</p>
<p class="indenthandinga"><strong>b.</strong> What&#8217;s wrong with this constructor?</p>
<p class="programlistingB">String::String(const char * s)<br/>{<br/>&#160;&#160;&#160;&#160;str = s;<br/>&#160;&#160;&#160;&#160;len = strlen(s);<br/>}</p>
<p class="indenthandinga"><strong>c.</strong> What&#8217;s wrong with this constructor?</p>
<p class="programlistingB">String::String(const char * s)<br/>{<br/>&#160;&#160;&#160;&#160;strcpy(str, s);<br/>&#160;&#160;&#160;&#160;len = strlen(s);<br/>}</p>
<p class="question"><a id="ch12qa1q2" href="app10.html#ch12qa1a2"><strong>2.</strong></a> Name three problems that may arise if you define a class in which a pointer member is initialized by using <code>new</code>. Indicate how they can be remedied.</p>
<p class="question"><a id="ch12qa1q3" href="app10.html#ch12qa1a3"><strong>3.</strong></a> What class methods does the compiler generate automatically if you don&#8217;t provide them explicitly? Describe how these implicitly generated functions behave.</p>
<p class="question"><a id="ch12qa1q4" href="app10.html#ch12qa1a4"><strong>4.</strong></a> Identify and correct the errors in the following class declaration:</p>
<p class="programlistingB">class nifty<br/>{<br/>// data<br/>&#160;&#160;&#160;&#160;char personality[];<br/>&#160;&#160;&#160;&#160;int talents;<br/>// methods<br/>&#160;&#160;&#160;&#160;nifty();<br/>&#160;&#160;&#160;&#160;nifty(char * s);<br/>&#160;&#160;&#160;&#160;ostream &#38; operator&lt;&lt;(ostream &#38; os, nifty &#38; n);<br/>}<br/><br/>nifty:nifty()<br/>{<br/>&#160;&#160;&#160;&#160;personality = NULL;<br/>&#160;&#160;&#160;&#160;talents = 0;<br/>}<br/><br/>nifty:nifty(char * s)<br/>{<br/>&#160;&#160;&#160;&#160;personality = new char [strlen(s)];<br/>&#160;&#160;&#160;&#160;personality = s;<br/>&#160;&#160;&#160;&#160;talents = 0;<br/>}<br/><br/><a id="page_702"/>ostream &#38; nifty:operator&lt;&lt;(ostream &#38; os, nifty &#38; n)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; n;<br/>}</p>
<p class="question"><a id="ch12qa1q5" href="app10.html#ch12qa1a5"><strong>5.</strong></a> Consider the following class declaration:</p>
<p class="programlistingB">class Golfer<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * fullname;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// points to string containing golfer's name<br/>&#160;&#160;&#160;&#160;int games;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// holds number of golf games played<br/>&#160;&#160;&#160;&#160;int * scores;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// points to first element of array of golf scores<br/>public:<br/>&#160;&#160;&#160;&#160;Golfer();<br/>&#160;&#160;&#160;&#160;Golfer(const char * name, int g= 0);<br/>&#160;&#160;&#160;&#160;&#160;// creates empty dynamic array of g elements if g &gt; 0<br/>&#160;&#160;&#160;&#160;Golfer(const Golfer &#38; g);<br/>&#160;&#160;&#160;&#160;~Golfer();<br/>};</p>
<p class="indenthandinga"><strong>a.</strong> What class methods would be invoked by each of the following statements?</p>
<p class="programlistingB">Golfer nancy;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #1<br/>Golfer lulu("Little Lulu");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #2<br/>Golfer roy("Roy Hobbs", 12);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #3<br/>Golfer * par = new Golfer;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #4<br/>Golfer next = lulu;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #5<br/>Golfer hazzard = "Weed Thwacker";&#160;&#160;&#160;&#160;// #6<br/>*par = nancy;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #7<br/>nancy = "Nancy Putter";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #8</p>
<p class="indenthandinga"><strong>b.</strong> Clearly, the class requires several more methods to make it useful. What additional method does it require to protect against data corruption?</p>
<h3 id="ch12lev1sec10">Programming Exercises</h3>
<p class="question"><a id="ch12qa2q1"/><strong>1.</strong> Consider the following class declaration:</p>
<p class="programlistingB">class Cow {<br/>&#160;&#160;&#160;&#160;char name[20];<br/>&#160;&#160;&#160;&#160;char * hobby;<br/>&#160;&#160;&#160;&#160;double weight;<br/>public:<br/>&#160;&#160;&#160;&#160;Cow();<br/>&#160;&#160;&#160;&#160;Cow(const char * nm, const char * ho, double wt);<br/>&#160;&#160;&#160;&#160;Cow(const Cow c&#38;);<br/><a id="page_703"/>&#160;&#160;&#160;&#160;~Cow();<br/>&#160;&#160;&#160;&#160;Cow &#38; operator=(const Cow &#38; c);<br/>&#160;&#160;&#160;&#160;void ShowCow() const;&#160;&#160;// display all cow data<br/>};</p>
<p class="questionp">Provide the implementation for this class and write a short program that uses all the member functions.</p>
<p class="question"><a id="ch12qa2q2"/><strong>2.</strong> Enhance the <code>String</code> class declaration (that is, upgrade <code>string1.h</code> to <code>string2.h</code>) by doing the following:</p>
<p class="indenthandinga"><strong>a.</strong> Overload the <code>+</code> operator to allow you to join two strings into one.</p>
<p class="indenthandinga"><strong>b.</strong> Provide a <code>stringlow()</code> member function that converts all alphabetic characters in a string to lowercase. (Don&#8217;t forget the <code>cctype</code> family of character functions.)</p>
<p class="indenthandinga"><strong>c.</strong> Provide a <code>stringup()</code> member function that converts all alphabetic characters in a string to uppercase.</p>
<p class="indenthandinga"><strong>d.</strong> Provide a member function that takes a <code>char</code> argument and returns the number of times the character appears in the string.</p>
<p class="questionp">Test your work in the following program:</p>
<p class="programlistingB">// pe12_2.cpp<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>#include "string2.h"<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;String s1(" and I am a C++ student.");<br/>&#160;&#160;&#160;&#160;String s2 = "Please enter your name: ";<br/>&#160;&#160;&#160;&#160;String s3;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; s2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded &lt;&lt; operator<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; s3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded &gt;&gt; operator<br/>&#160;&#160;&#160;&#160;s2 = "My name is " + s3;&#160;&#160;&#160;&#160;// overloaded =, + operators<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; s2 &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;s2 = s2 + s1;<br/>&#160;&#160;&#160;&#160;s2.stringup();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// converts string to uppercase<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The string\n" &lt;&lt; s2 &lt;&lt; "\ncontains " &lt;&lt; s2.has('A')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " 'A' characters in it.\n";<br/>&#160;&#160;&#160;&#160;s1 = "red";&#160;&#160;&#160;&#160;&#160;// String(const char *),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// then String &#38; operator=(const String&#38;)<br/>&#160;&#160;&#160;&#160;String rgb[3] = { String(s1), String("green"), String("blue")};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the name of a primary color for mixing light: ";<br/>&#160;&#160;&#160;&#160;String ans;<br/>&#160;&#160;&#160;&#160;bool success = false;<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; ans)<br/><a id="page_704"/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ans.stringlow();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// converts string to lowercase<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 3; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ans == rgb[i])&#160;&#160;// overloaded == operator<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "That's right!\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;success = true;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (success)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Try again!\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="questionp">Your output should look like this sample run:</p>
<p class="programlistingB">Please enter your name: <span class="EmpStrong">Fretta Farbo</span><br/>My name is Fretta Farbo.<br/>The string<br/>MY NAME IS FRETTA FARBO AND I AM A C++ STUDENT.<br/>contains 6 'A' characters in it.<br/>Enter the name of a primary color for mixing light: yellow<br/>Try again!<br/><span class="EmpStrong">BLUE</span><br/>That's right!<br/>Bye</p>
<p class="question"><a id="ch12qa2q3"/><strong>3.</strong> Rewrite the <code>Stock</code> class, as described in <a href="ch10.html#ch10ex07">Listings 10.7</a> and <a href="ch10.html#ch10ex08">10.8</a> in <a href="ch10.html#ch10">Chapter 10</a> so that it uses dynamically allocated memory directly instead of using <code>string</code> class objects to hold the stock names. Also replace the <code>show()</code> member function with an overloaded <code>operator&lt;&lt;()</code> definition. Test the new definition program in <a href="ch10.html#ch10ex09">Listing 10.9</a>.</p>
<p class="question"><a id="ch12qa2q4"/><strong>4.</strong> Consider the following variation of the <code>Stack</code> class defined in <a href="ch10.html#ch10ex10">Listing 10.10</a>:</p>
<p class="programlistingB">// stack.h -- class declaration for the stack ADT<br/>typedef unsigned long Item;<br/><br/>class Stack<br/>{<br/><a id="page_705"/>private:<br/>&#160;&#160;&#160;&#160;enum {MAX = 10};&#160;&#160;&#160;&#160;&#160;&#160;// constant specific to class<br/>&#160;&#160;&#160;&#160;Item&#160;&#160;* pitems;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// holds stack items<br/>&#160;&#160;&#160;&#160;int size;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// number of elements in stack<br/>&#160;&#160;&#160;&#160;int top;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// index for top stack item<br/>public:<br/>&#160;&#160;&#160;&#160;Stack(int n = MAX);&#160;&#160;&#160;&#160;// creates stack with n elements<br/>&#160;&#160;&#160;&#160;Stack(const Stack &#38; st);<br/>&#160;&#160;&#160;&#160;~Stack();<br/>&#160;&#160;&#160;&#160;bool isempty() const;<br/>&#160;&#160;&#160;&#160;bool isfull() const;<br/>&#160;&#160;&#160;&#160;// push() returns false if stack already is full, true otherwise<br/>&#160;&#160;&#160;&#160;bool push(const Item &#38; item); // add item to stack<br/>&#160;&#160;&#160;&#160;// pop() returns false if stack already is empty, true otherwise<br/>&#160;&#160;&#160;&#160;bool pop(Item &#38; item);&#160;&#160;// pop top into item<br/>&#160;&#160;&#160;&#160;Stack &#38; operator=(const Stack &#38; st);<br/>};</p>
<p class="questionp">As the private members suggest, this class uses a dynamically allocated array to hold the stack items. Rewrite the methods to fit this new representation and write a program that demonstrates all the methods, including the copy constructor and assignment operator.</p>
<p class="question"><a id="ch12qa2q5"/><strong>5.</strong> The Bank of Heather has performed a study showing that ATM customers won&#8217;t wait more than one minute in line. Using the simulation from <a href="#ch12ex10">Listing 12.10</a>, find a value for number of customers per hour that leads to an average wait time of one minute. (Use at least a 100-hour trial period.)</p>
<p class="question"><a id="ch12qa2q6"/><strong>6.</strong> The Bank of Heather would like to know what would happen if it added a second ATM. Modify the simulation in this chapter so that it has two queues. Assume that a customer will join the first queue if it has fewer people in it than the second queue and that the customer will join the second queue otherwise. Again, find a value for number of customers per hour that leads to an average wait time of one minute. (Note: This is a nonlinear problem in that doubling the number of ATMs doesn&#8217;t double the number of customers who can be handled per hour with a one-minute wait maximum.)</p>
</body>
</html>
