<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>13. Class Inheritance</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch13">13. Class Inheritance</h2>
<p><a id="page_707"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Inheritance as an <em>is-a</em> relationship</p>
<p class="indenthandingB">&#8226; How to publicly derive one class from another</p>
<p class="indenthandingB">&#8226; Protected access</p>
<p class="indenthandingB">&#8226; Constructor member initializer lists</p>
<p class="indenthandingB">&#8226; Upcasting and downcasting</p>
<p class="indenthandingB">&#8226; Virtual member functions</p>
<p class="indenthandingB">&#8226; Early (static) binding and late (dynamic) binding</p>
<p class="indenthandingB">&#8226; Abstract base classes</p>
<p class="indenthandingB">&#8226; Pure virtual functions</p>
<p class="indenthandingB">&#8226; When and how to use public inheritance</p>
<p>One of the main goals of object-oriented programming is to provide reusable code. When you develop a new project, particularly if the project is large, it&#8217;s nice to be able to reuse proven code rather than to reinvent it. Employing old code saves time and because it has already been used and tested, can help suppress the introduction of bugs into a program. Also the less you have to concern yourself with details, the better you can concentrate on overall program strategy.</p>
<p>Traditional C function libraries provide reusability through predefined, precompiled functions, such as <code>strlen()</code> and <code>rand()</code>, that you can use in your programs. Many vendors furnish specialized C libraries that provide functions beyond those of the standard C library. For example, you can purchase libraries of database management functions and of screen control functions. However, function libraries have a limitation: Unless the vendor supplies the source code for its library functions (and often it doesn&#8217;t), you can&#8217;t extend or modify the functions to meet your particular needs. Instead, you have to shape your program to meet the workings of the library. Even if the vendor does supply the source code, you run the risk of unintentionally modifying how part of a function works or of altering the relationships among library functions as you add your changes.</p>
<p><a id="page_708"/>C++ classes bring a higher level of reusability. Many vendors now offer class libraries, which consist of class declarations and implementations. Because a class combines data representation with class methods, it provides a more integrated package than does a function library. A single class, for example, may provide all the resources for managing a dialog box. Often class libraries are available in source code, which means you can modify them to meet your needs. But C++ has a better method than code modification for extending and modifying classes. This method, called <em>class inheritance</em>, lets you derive new classes from old ones, with the derived class inheriting the properties, including the methods, of the old class, called a <em>base class</em>. Just as inheriting a fortune is usually easier than earning one from scratch, deriving a class through inheritance is usually easier than designing a new one. Here are some things you can do with inheritance:</p>
<p class="indenthandingB">&#8226; You can add functionality to an existing class. For example, given a basic array class, you could add arithmetic operations.</p>
<p class="indenthandingB">&#8226; You can add to the data that a class represents. For example, given a basic string class, you could derive a class that adds a data member representing a color to be used when displaying the string.</p>
<p class="indenthandingB">&#8226; You can modify how a class method behaves. For example, given a <code>Passenger</code> class that represents the services provided to an airline passenger, you can derive a <code>FirstClassPassenger</code> class that provides a higher level of services.</p>
<p>Of course, you could accomplish the same aims by duplicating the original class code and modifying it, but the inheritance mechanism allows you to proceed by just providing the new features. You don&#8217;t even need access to the source code to derive a class. Thus, if you purchase a class library that provides only the header files and the compiled code for class methods, you can still derive new classes based on the library classes. Conversely, you can distribute your own classes to others, keeping parts of your implementation secret, yet still giving your clients the option of adding features to your classes.</p>
<p>Inheritance is a splendid concept, and its basic implementation is quite simple. But managing inheritance so that it works properly in all situations requires some adjustments. This chapter looks at both the simple and the subtle aspects of inheritance.</p>
<h3 id="ch13lev1sec1">Beginning with a Simple Base Class</h3>
<p>When one class inherits from another, the original class is called a <em>base class</em>, and the inheriting class is called a <em>derived class</em>. So to illustrate inheritance, let&#8217;s begin with a base class. The Webtown Social Club has decided to keep track of its members who play table tennis. As head programmer for the club, you have designed the simple <code>TableTennisPlayer</code> class defined in <a href="#ch13ex01">Listings 13.1</a> and <a href="#ch13ex02">13.2</a>.</p>
<p class="caption1"><a id="ch13ex01"/><strong>Listing 13.1. <code>tabtenn0.h</code></strong></p><hr/>
<p class="programlisting1">// tabtenn0.h -- a table-tennis base class<br/>#ifndef TABTENN0_H_<br/>#define TABTENN0_H_<br/>#include &lt;string&gt;<br/>using std::string;<br/>// simple base class<br/>class TableTennisPlayer<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;string firstname;<br/>&#160;&#160;&#160;&#160;string lastname;<br/>&#160;&#160;&#160;&#160;bool hasTable;<br/>public:<br/>&#160;&#160;&#160;&#160;TableTennisPlayer (const string &#38; fn = "none",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const string &#38; ln = "none", bool ht = false);<br/>&#160;&#160;&#160;&#160;void Name() const;<br/>&#160;&#160;&#160;&#160;bool HasTable() const { return hasTable; };<br/>&#160;&#160;&#160;&#160;void ResetTable(bool v) { hasTable = v; };<br/>};<br/>#endif</p><hr/>
<p class="caption1"><a id="page_709"/><a id="ch13ex02"/><strong>Listing 13.2. <code>tabtenn0.cpp</code></strong></p><hr/>
<p class="programlisting1">//tabtenn0.cpp -- simple base-class methods<br/>#include "tabtenn0.h"<br/>#include &lt;iostream&gt;<br/><br/>TableTennisPlayer::TableTennisPlayer (const string &#38; fn,<br/>&#160;&#160;&#160;&#160;const string &#38; ln, bool ht) : firstname(fn),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lastname(ln), hasTable(ht) {}<br/><br/>void TableTennisPlayer::Name() const<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; lastname &lt;&lt; ", " &lt;&lt; firstname;<br/>}</p><hr/>
<p>All the <code>TableTennisPlayer</code> class does is keep track of the players&#8217; names and whether they have tables. There are a couple of points to notice. First, the class uses the standard <code>string</code> class to hold the names. This is more convenient, flexible, and safer than using a character array. And it is rather more professional than the <code>String</code> class of <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>.&#8221; Second, the constructor uses the member initializer list syntax introduced in <a href="ch12.html#ch12">Chapter 12</a>. You could also do this:</p>
<p class="programlisting">TableTennisPlayer::TableTennisPlayer (const string &#38; fn,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const string &#38; ln, bool ht)<br/>{<br/>&#160;&#160;&#160;&#160;firstname = fn;<br/>&#160;&#160;&#160;&#160;lastname = ln;<br/>&#160;&#160;&#160;&#160;hasTable = ht;<br/>}</p>
<p><a id="page_710"/>However, this approach has the effect of first calling the default <code>string</code> constructor for <code>firstname</code> and then invoking the <code>string</code> assignment operator to reset <code>firstname</code> to <code>fn</code>. But the member initializer list syntax saves a step by just using the <code>string</code> copy constructor to initialize <code>firstname</code> to <code>fn</code>.</p>
<p><a href="#ch13ex03">Listing 13.3</a> shows this modest class in action.</p>
<p class="caption1"><a id="ch13ex03"/><strong>Listing 13.3. <code>usett0.cpp</code></strong></p><hr/>
<p class="programlisting1">// usett0.cpp -- using a base class<br/>#include &lt;iostream&gt;<br/>#include "tabtenn0.h"<br/><br/>int main ( void )<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;TableTennisPlayer player1("Chuck", "Blizzard", true);<br/>&#160;&#160;&#160;&#160;TableTennisPlayer player2("Tara", "Boomdea", false);<br/>&#160;&#160;&#160;&#160;player1.Name();<br/>&#160;&#160;&#160;&#160;if (player1.HasTable())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": has a table.\n";<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": hasn't a table.\n";<br/>&#160;&#160;&#160;&#160;player2.Name();<br/>&#160;&#160;&#160;&#160;if (player2.HasTable())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": has a table";<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": hasn't a table.\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>And here&#8217;s the output of the program in <a href="#ch13ex01">Listings 13.1</a>, <a href="#ch13ex02">13.2</a>, and <a href="#ch13ex03">13.3</a>:</p>
<p class="programlisting">Blizzard, Chuck: has a table.<br/>Boomdea, Tara: hasn't a table.</p>
<p>Note that the program uses constructors with C-style string arguments:</p>
<p class="programlisting">TableTennisPlayer player1("Chuck", "Blizzard", true);<br/>TableTennisPlayer player2("Tara", "Boomdea", false);</p>
<p>But the formal parameters for the constructor were declared as type <code>const string &#38;</code>. This is a type mismatch, but the <code>string</code> class, much like the <code>String</code> class of <a href="ch12.html#ch12">Chapter 12</a>, has a constructor with a <code>const char *</code> parameter, and that constructor is used automatically to create a <code>string</code> object initialized by the C-style string. In short, you can use either a <code>string</code> object or a C-style string as an argument to the <code>TableTennisPlayer</code> constructor. The first invokes a <code>string</code> constructor with a <code>const string &#38;</code> parameter, and the second invokes a <code>string</code> constructor with a <code>const char *</code> parameter.</p>
<h4 id="ch13lev2sec1">Deriving a Class</h4>
<p><a id="page_711"/>Some members of the Webtown Social Club have played in local table tennis tournaments, and they demand a class that includes the point ratings they&#8217;ve earned through their play. Rather than start from scratch, you can derive a class from the <code>TableTennisPlayer</code> class. The first step is to have the <code>RatedPlayer</code> class declaration show that it derives from the <code>TableTennisPlayer</code> class:</p>
<p class="programlisting">// RatedPlayer derives from the TableTennisPlayer base class<br/>class RatedPlayer : public TableTennisPlayer<br/>{<br/>...<br/>};</p>
<p>The colon indicates that the <code>RatedPlayer</code> class is based on the <code>TableTennisPlayer</code> class. This particular heading indicates that <code>TableTennisPlayer</code> is a public base class; this is termed <em>public derivation</em>. An object of a derived class incorporates a base class object. With public derivation, the public members of the base class become public members of the derived class. The private portions of a base class become part of the derived class, but they can be accessed only through public and protected methods of the base class. (We&#8217;ll get to protected members in a bit.)</p>
<p>What does this accomplish? If you declare a <code>RatedPlayer</code> object, it has the following special properties:</p>
<p class="indenthandingB">&#8226; An object of the derived type has stored within it the data members of the base type. (The derived class inherits the base-class implementation.)</p>
<p class="indenthandingB">&#8226; An object of the derived type can use the methods of the base type. (The derived class inherits the base-class interface.)</p>
<p>Thus, a <code>RatedPlayer</code> object can store the first name and last name of each player and whether the player has a table. Also a <code>RatedPlayer</code> object can use the <code>Name()</code>, <code>HasTable()</code>, and <code>ResetTable()</code> methods from the <code>TableTennisPlayer</code> class (see <a href="#ch13fig01">Figure 13.1</a> for another example).</p>
<p class="caption"><a id="ch13fig01"/><strong>Figure 13.1. Base-class and derived-class objects.</strong></p>
<p class="image"><img src="graphics/13fig01.jpg" alt="Image"/></p>
<p>What needs to be added to these inherited features?</p>
<p class="indenthandingB">&#8226; A derived class needs its own constructors.</p>
<p class="indenthandingB">&#8226; A derived class can add additional data members and member functions as needed.</p>
<p>In this particular case, the class needs one more data member to hold the <code>ratings</code> value. It should also have a method for retrieving the rating and a method for resetting the rating. So the class declaration could look like this:</p>
<p class="programlisting">// simple derived class<br/>class RatedPlayer : public TableTennisPlayer<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;unsigned int rating;&#160;&#160;&#160;&#160;&#160;// add a data member<br/><a id="page_712"/>public:<br/>&#160;&#160;&#160;&#160;RatedPlayer (unsigned int r = 0, const string &#38; fn = "none",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const string &#38; ln = "none", bool ht = false);<br/>&#160;&#160;&#160;&#160;RatedPlayer(unsigned int r, const TableTennisPlayer &#38; tp);<br/>&#160;&#160;&#160;&#160;unsigned int Rating() const { return rating; }&#160;&#160;// add a method<br/>&#160;&#160;&#160;&#160;void ResetRating (unsigned int r) {rating = r;} // add a method<br/>};</p>
<p>The constructors have to provide data for the new members, if any, and for the inherited members. The first <code>RatedPlayer</code> constructor uses a separate formal parameter for each member, and the second <code>RatedPlayer</code> constructor uses a <code>TableTennisPlayer</code> parameter, which bundles three items (<code>firstname</code>, <code>lastname</code>, and <code>hasTable</code>) into a single unit.</p>
<h4 id="ch13lev2sec2">Constructors: Access Considerations</h4>
<p><a id="page_713"/>A derived class does not have direct access to the private members of the base class; it has to work through the base-class methods. For example, the <code>RatedPlayer</code> constructors cannot directly set the inherited members (<code>firstname</code>, <code>lastname</code>, and <code>hasTable</code>). Instead, they have to use public base-class methods to access private base-class members. In particular, the derived-class constructors have to use the base-class constructors.</p>
<p>When a program constructs a derived-class object, it first constructs the base-class object. Conceptually, that means the base-class object should be constructed before the program enters the body of the derived-class constructor. C++ uses the member initializer list syntax to accomplish this. Here, for instance, is the code for the first <code>RatedPlayer</code> constructor:</p>
<p class="programlisting">RatedPlayer::RatedPlayer(unsigned int r, const string &#38; fn,<br/>&#160;&#160;&#160;&#160;&#160;const string &#38; ln, bool ht) : TableTennisPlayer(fn, ln, ht)<br/>{<br/>&#160;&#160;&#160;&#160;rating = r;<br/>}</p>
<p>The following part is the member initializer list:</p>
<p class="programlisting">: TableTennisPlayer(fn, ln, ht)</p>
<p>It&#8217;s executable code, and it calls the <code>TableTennisPlayer</code> constructor. Suppose, for example, a program has the following declaration:</p>
<p class="programlisting">RatedPlayer rplayer1(1140, "Mallory", "Duck", true);</p>
<p>The <code>RatedPlayer</code> constructor assigns the actual arguments <code>"Mallory"</code>, <code>"Duck"</code>, and <code>true</code> to the formal parameters <code>fn</code>, <code>ln</code>, and <code>ht</code>. It then passes these parameters on as actual arguments to the <code>TableTennisPlayer</code> constructor. This constructor, in turn, creates the embedded <code>TableTennisPlayer</code> object and stores the data <code>"Mallory"</code>, <code>"Duck"</code>, and <code>true</code> in it. Then the program enters the body of the <code>RatedPlayer</code> constructor, completes the construction of the <code>RatedPlayer</code> object, and assigns the value of the parameter <code>r</code> (that is, <code>1140</code>) to the <code>rating</code> member (see <a href="#ch13fig02">Figure 13.2</a> for another example).</p>
<p class="caption"><a id="ch13fig02"/><strong>Figure 13.2. Passing arguments through to a base-class constructor.</strong></p>
<p class="image"><img src="graphics/13fig02.jpg" alt="Image"/></p>
<p><a id="page_714"/>What if you omit the member initializer list?</p>
<p class="programlisting">RatedPlayer::RatedPlayer(unsigned int r, const string &#38; fn,<br/>&#160;&#160;&#160;&#160;&#160;const string &#38; ln, bool ht) // what if no initializer list?<br/>{<br/>&#160;&#160;&#160;&#160;rating = r;<br/>}</p>
<p>The base-class object must be created first, so if you omit calling a base-class constructor, the program uses the default base-class constructor. Therefore, the previous code is the same as the following:</p>
<p class="programlisting">RatedPlayer::RatedPlayer(unsigned int r, const string &#38; fn,<br/>&#160;&#160;&#160;&#160;&#160;const string &#38; ln, bool ht) // : TableTennisPlayer()<br/>{<br/>&#160;&#160;&#160;&#160;rating = r;<br/>}</p>
<p>Unless you want the default constructor to be used, you should explicitly provide the correct base-class constructor call.</p>
<p>Now let&#8217;s look at code for the second constructor:</p>
<p class="programlisting">RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &#38; tp)<br/>&#160;&#160;&#160;&#160;: TableTennisPlayer(tp)<br/>{<br/>&#160;&#160;&#160;&#160;rating = r;<br/>}</p>
<p>Again, the <code>TableTennisPlayer</code> information is passed on to a <code>TableTennisPlayer</code> constructor:</p>
<p class="programlisting">TableTennisPlayer(tp)</p>
<p>Because <code>tp</code> is type <code>const TableTennisPlayer &#38;</code>, this call invokes the base-class copy constructor. The base class didn&#8217;t define a copy constructor, but recall from <a href="ch12.html#ch12">Chapter 12</a> that the compiler automatically generates a copy constructor if one is needed and you haven&#8217;t defined one already. In this case, the implicit copy constructor, which does memberwise copying, is fine because the class doesn&#8217;t directly use dynamic memory allocation. (The <code>string</code> members do use dynamic memory allocation, but, recall, memberwise copying will use the <code>string</code> class copy constructors to copy the <code>string</code> members.)</p>
<p>You may, if you like, also use member initializer list syntax for members of the derived class. In this case, you use the member name instead of the class name in the list. Thus, the second constructor can also be written in this manner:</p>
<p class="programlisting">// alternative version<br/>RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &#38; tp)<br/>&#160;&#160;&#160;&#160;: TableTennisPlayer(tp), rating(r)<br/>{<br/>}</p>
<p><a id="page_715"/>These are the key points about constructors for derived classes:</p>
<p class="indenthandingB">&#8226; The base-class object is constructed first.</p>
<p class="indenthandingB">&#8226; The derived-class constructor should pass base-class information to a base-class constructor via a member initializer list.</p>
<p class="indenthandingB">&#8226; The derived-class constructor should initialize the data members that were added to the derived class.</p>
<p>This example doesn&#8217;t provide explicit destructors, so the implicit destructors are used. Destroying an object occurs in the opposite order used to construct an object. That is, the body of the derived-class destructor is executed first, and then the base-class destructor is called automatically.</p>
<div class="note"><hr/>
<p class="title"><a id="ch13note01"/>Note</p>
<p class="notepara">When creating an object of a derived class, a program first calls the base-class constructor and then calls the derived-class constructor. The base-class constructor is responsible for initializing the inherited data members. The derived-class constructor is responsible for initializing any added data members. A derived-class constructor always calls a base-class constructor. You can use the initializer list syntax to indicate <em>which</em> base-class constructor to use. Otherwise, the default base-class constructor is used.</p>
<p class="notepara">When an object of a derived class expires, the program first calls the derived-class destructor and then calls the base-class destructor.</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch13sb01"/>Member Initializer Lists</p>
<p class="sidebarpara">A constructor for a derived class can use the initializer list mechanism to pass values along to a base-class constructor. Consider this example:</p>
<p class="programlistingB">derived::derived(<span class="EmpItalic">type1</span> x, <span class="EmpItalic">type2</span> y) : base(x,y) // initializer list<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p class="sidebarpara">Here, <code>derived</code> is the derived class, <code>base</code> is the base class, and <code>x</code> and <code>y</code> are variables used by the base-class constructor. If, say, the derived-class constructor receives the arguments <code>10</code> and <code>12</code>, this mechanism then passes <code>10</code> and <code>12</code> on to the base-class constructor defined as taking arguments of these types. Except for the case of virtual base classes (see <a href="ch14.html#ch14">Chapter 14</a>, &#8220;<a href="ch14.html#ch14">Reusing Code in C++</a>&#8221;), a class can pass values back only to its immediate base class. However, that class can use the same mechanism to pass back information to its immediate base class, and so on. If you don&#8217;t supply a base-class constructor in a member initializer list, the program uses the default base-class constructor. The member initializer list can be used <em>only</em> in constructors.</p>
<hr/></div>
<h4 id="ch13lev2sec3">Using a Derived Class</h4>
<p><a id="page_716"/>To use a derived class, a program needs access to the base-class declarations. <a href="#ch13ex04">Listing 13.4</a> places both class declarations in the same header file. You could give each class its own header file, but because the two classes are related, it makes more organizational sense to keep the class declarations together.</p>
<p class="caption1"><a id="ch13ex04"/><strong>Listing 13.4. <code>tabtenn1.h</code></strong></p><hr/>
<p class="programlisting1">// tabtenn1.h -- a table-tennis base class<br/>#ifndef TABTENN1_H_<br/>#define TABTENN1_H_<br/>#include &lt;string&gt;<br/>using std::string;<br/>// simple base class<br/>class TableTennisPlayer<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;string firstname;<br/>&#160;&#160;&#160;&#160;string lastname;<br/>&#160;&#160;&#160;&#160;bool hasTable;<br/>public:<br/>&#160;&#160;&#160;&#160;TableTennisPlayer (const string &#38; fn = "none",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const string &#38; ln = "none", bool ht = false);<br/>&#160;&#160;&#160;&#160;void Name() const;<br/>&#160;&#160;&#160;&#160;bool HasTable() const { return hasTable; };<br/>&#160;&#160;&#160;&#160;void ResetTable(bool v) { hasTable = v; };<br/>};<br/><br/>// simple derived class<br/>class RatedPlayer : public TableTennisPlayer<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;unsigned int rating;<br/>public:<br/>&#160;&#160;&#160;&#160;RatedPlayer (unsigned int r = 0, const string &#38; fn = "none",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const string &#38; ln = "none", bool ht = false);<br/>&#160;&#160;&#160;&#160;RatedPlayer(unsigned int r, const TableTennisPlayer &#38; tp);<br/>&#160;&#160;&#160;&#160;unsigned int Rating() const { return rating; }<br/>&#160;&#160;&#160;&#160;void ResetRating (unsigned int r) {rating = r;}<br/>};<br/><br/>#endif</p><hr/>
<p><a href="#ch13ex05">Listing 13.5</a> provides the method definitions for both classes. Again, you could use separate files, but it&#8217;s simpler to keep the definitions together.</p>
<p class="caption1"><a id="page_717"/><a id="ch13ex05"/><strong>Listing 13.5. <code>tabtenn1.cpp</code></strong></p><hr/>
<p class="programlisting1">//tabtenn1.cpp -- simple base-class methods<br/>#include "tabtenn1.h"<br/>#include &lt;iostream&gt;<br/><br/>TableTennisPlayer::TableTennisPlayer (const string &#38; fn,<br/>&#160;&#160;&#160;&#160;const string &#38; ln, bool ht) : firstname(fn),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lastname(ln), hasTable(ht) {}<br/><br/>void TableTennisPlayer::Name() const<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; lastname &lt;&lt; ", " &lt;&lt; firstname;<br/>}<br/><br/>// RatedPlayer methods<br/>RatedPlayer::RatedPlayer(unsigned int r, const string &#38; fn,<br/>&#160;&#160;&#160;&#160;&#160;const string &#38; ln, bool ht) : TableTennisPlayer(fn, ln, ht)<br/>{<br/>&#160;&#160;&#160;&#160;rating = r;<br/>}<br/><br/>RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &#38; tp)<br/>&#160;&#160;&#160;&#160;: TableTennisPlayer(tp), rating(r)<br/>{<br/>}</p><hr/>
<p><a href="#ch13ex06">Listing 13.6</a> creates objects of both the <code>TableTennisPlayer</code> class and the <code>RatedPlayer</code> class. Notice that objects of both classes can use the <code>TableTennisPlayer</code> class <code>Name()</code> and <code>HasTable()</code> methods.</p>
<p class="caption1"><a id="ch13ex06"/><strong>Listing 13.6. <code>usett1.cpp</code></strong></p><hr/>
<p class="programlisting1">// usett1.cpp -- using base class and derived class<br/>#include &lt;iostream&gt;<br/>#include "tabtenn1.h"<br/><br/>int main ( void )<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;TableTennisPlayer player1("Tara", "Boomdea", false);<br/>&#160;&#160;&#160;&#160;RatedPlayer rplayer1(1140, "Mallory", "Duck", true);<br/>&#160;&#160;&#160;&#160;rplayer1.Name();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// derived object uses base method<br/>&#160;&#160;&#160;&#160;if (rplayer1.HasTable())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": has a table.\n";<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": hasn't a table.\n";<br/>&#160;&#160;&#160;&#160;player1.Name();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// base object uses base method<br/>&#160;&#160;&#160;&#160;if (player1.HasTable())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": has a table";<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": hasn't a table.\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: ";<br/>&#160;&#160;&#160;&#160;rplayer1.Name();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "; Rating: " &lt;&lt; rplayer1.Rating() &lt;&lt; endl;<br/>// initialize RatedPlayer using TableTennisPlayer object<br/>&#160;&#160;&#160;&#160;RatedPlayer rplayer2(1212, player1);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: ";<br/>&#160;&#160;&#160;&#160;rplayer2.Name();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "; Rating: " &lt;&lt; rplayer2.Rating() &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_718"/>Here is the output of the program in <a href="#ch13ex04">Listings 13.4</a>, <a href="#ch13ex05">13.5</a>, and <a href="#ch13ex06">13.6</a>:</p>
<p class="programlisting">Duck, Mallory: has a table.<br/>Boomdea, Tara: hasn't a table.<br/>Name: Duck, Mallory; Rating: 1140<br/>Name: Boomdea, Tara; Rating: 1212</p>
<h4 id="ch13lev2sec4">Special Relationships Between Derived and Base Classes</h4>
<p>A derived class has some special relationships with the base class. One, which you&#8217;ve just seen, is that a derived-class object can use base-class methods, provided that the methods are not private:</p>
<p class="programlisting">RatedPlayer rplayer1(1140, "Mallory", "Duck", true);<br/>rplayer1.Name();&#160;&#160;// derived object uses base method</p>
<p>Two other important relationships are that a base-class pointer can point to a derived-class object without an explicit type cast and that a base-class reference can refer to a derived-class object without an explicit type cast:</p>
<p class="programlisting">RatedPlayer rplayer1(1140, "Mallory", "Duck", true);<br/>TableTennisPlayer &#38; rt = rplayer;<br/>TableTennisPlayer * pt = &#38;rplayer;<br/>rt.Name();&#160;&#160;&#160;// invoke Name() with reference<br/>pt-&gt;Name();&#160;&#160;// invoke Name() with pointer</p>
<p>However, a base-class pointer or reference can invoke just base-class methods, so you couldn&#8217;t use <code>rt</code> or <code>pt</code> to invoke, say, the derived-class <code>ResetRanking()</code> method.</p>
<p><a id="page_719"/>Ordinarily, C++ requires that references and pointer types match the assigned types, but this rule is relaxed for inheritance. However, the rule relaxation is just in one direction. You can&#8217;t assign base-class objects and addresses to derived-class references and pointers:</p>
<p class="programlisting">TableTennisPlayer player("Betsy", "Bloop", true);<br/>RatedPlayer &#38; rr = player;&#160;&#160;&#160;&#160;&#160;&#160;// NOT ALLOWED<br/>RatedPlayer * pr = player;&#160;&#160;&#160;&#160;&#160;&#160;// NOT ALLOWED</p>
<p>Both these sets of rules make sense. For example, consider the implications of having a base-class reference refer to a derived object. In this case, you can use the base-class reference to invoke base-class methods for the derived-class object. Because the derived class inherits the base-class methods and data members, this causes no problems. Now consider what would happen if you could assign a base-class object to a derived-class reference. The derived-class reference would be able to invoke derived-class methods for the base object, and that could cause problems. For example, applying the <code>RatedPlayer::Rating()</code> method to a <code>TableTennisPlayer</code> object makes no sense because the <code>TableTennisPlayer</code> object doesn&#8217;t have a <code>rating</code> member.</p>
<p>The fact that base-class references and pointers can refer to derived-class objects has some interesting consequences. One is that functions defined with base-class reference or pointer arguments can be used with either base-class or derived-class objects. For instance, consider this function:</p>
<p class="programlisting">void Show(const TableTennisPlayer &#38; rt)<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: ";<br/>&#160;&#160;&#160;&#160;rt.Name();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nTable: ";<br/>&#160;&#160;&#160;&#160;if (rt.HasTable())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "yes\n";<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "no\n";<br/>}</p>
<p>The formal parameter <code>rt</code> is a reference to a base class, so it can refer to a base-class object or to a derived-class object. Thus, you can use <code>Show()</code> with either a <code>TableTennis</code> argument or a <code>RatedPlayer</code> argument:</p>
<p class="programlisting">TableTennisPlayer player1("Tara", "Boomdea", false);<br/>RatedPlayer rplayer1(1140, "Mallory", "Duck", true);<br/>Show(player1);&#160;&#160;&#160;// works with TableTennisPlayer argument<br/>Show(rplayer1);&#160;&#160;// works with RatedPlayer argument</p>
<p>A similar relationship would hold for a function with a pointer-to-base-class formal parameter; it could be used with either the address of a base-class object or the address of a derived-class object as an actual argument:</p>
<p class="programlisting"><a id="page_720"/>void Wohs(const TableTennisPlayer * pt);&#160;&#160;// function with pointer parameter<br/>...<br/>TableTennisPlayer player1("Tara", "Boomdea", false);<br/>RatedPlayer rplayer1(1140, "Mallory", "Duck", true);<br/>Wohs(&#38;player1);&#160;&#160;&#160;// works with TableTennisPlayer * argument<br/>Wohs(&#38;rplayer1);&#160;&#160;// works with RatedPlayer * argument</p>
<p>The reference compatibility property also allows you to initialize a base-class object to a derived-class object, although somewhat indirectly. Suppose you have this code:</p>
<p class="programlisting">RatedPlayer olaf1(1840, "Olaf", "Loaf", true);<br/>TableTennisPlayer olaf2(olaf1);</p>
<p>The exact match for initializing <code>olaf2</code> would be a constructor with this prototype:</p>
<p class="programlisting">TableTennisPlayer(const RatedPlayer &#38;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// doesn't exist</p>
<p>The class definitions don&#8217;t include this constructor, but there is the implicit copy constructor:</p>
<p class="programlisting">// implicit copy constructor<br/>TableTennisPlayer(const TableTennisPlayer &#38;);</p>
<p>The formal parameter is a reference to the base type, so it can refer to a derived type. Thus, the attempt to initialize <code>olaf2</code> to <code>olaf1</code> uses this constructor, which copies the <code>firstname</code>, <code>lastname</code>, and <code>hasTable</code> members. In other words, it initializes <code>olaf2</code> to the <code>TableTennisPlayer</code> object embedded in the <code>RatedPlayer</code> object <code>olaf1</code>.</p>
<p>Similarly, you can assign a derived-class object to a base-class object:</p>
<p class="programlisting">RatedPlayer olaf1(1840, "Olaf", "Loaf", true);<br/>TableTennisPlayer winner;<br/>winner = olaf1; // assign derived to base object</p>
<p>In this case, the program uses the implicit overloaded assignment operator:</p>
<p class="programlisting">TableTennisPlayer &#38; operator=(const TableTennisPlayer &#38;) const;</p>
<p>Again, a base-class reference refers to a derived-class object, and just the base-class portion of <code>olaf1</code> is copied to <code>winner</code>.</p>
<h3 id="ch13lev1sec2">Inheritance: An <em>Is-a</em> Relationship</h3>
<p>The special relationship between a derived class and a base class is based on an underlying model for C++ inheritance. Actually, C++ has three varieties of inheritance: public, protected, and private. Public inheritance is the most common form, and it models an <em>is-a</em> relationship. This is shorthand for saying that an object of a derived class should also be an object of the base class. Anything you do with a base-class object, you should be able to do with a derived-class object. Suppose, for example, that you have a <code>Fruit</code> class. It could store, say, the weight and caloric content of a fruit. Because a banana is a particular kind of fruit, you could derive a <code>Banana</code> class from the <code>Fruit</code> class. The new class would inherit all the data members of the original class, so a <code>Banana</code> object would have members representing the weight and caloric content of a banana. The new <code>Banana</code> class also might add <a id="page_721"/>members that apply particularly to bananas and not to fruit in general, such as the Banana Institute Peel Index. Because the derived class can add features, it&#8217;s probably more accurate to describe the relationship as an <em>is-a-kind-of</em> relationship, but <em>is-a</em> is the usual term.</p>
<p>To clarify <em>is-a</em> relationships, let&#8217;s look at some examples that don&#8217;t match that model. Public inheritance doesn&#8217;t model a <em>has-a</em> relationship. A lunch, for example, might contain a fruit. But a lunch, in general, is not a fruit. Therefore, you should not derive a <code>Lunch</code> class from the <code>Fruit</code> class in an attempt to place fruit in a lunch. The correct way to handle putting fruit into a lunch is to consider the matter as a <em>has-a</em> relationship: A lunch has a fruit. As you&#8217;ll see in <a href="ch14.html#ch14">Chapter 14</a>, that&#8217;s most easily modeled by including a <code>Fruit</code> object as a data member of a <code>Lunch</code> class (see <a href="#ch13fig03">Figure 13.3</a>).</p>
<p class="caption"><a id="ch13fig03"/><strong>Figure 13.3. Is-a and has-a relationships.</strong></p>
<p class="image"><img src="graphics/13fig03.jpg" alt="Image"/></p>
<p>Public inheritance doesn&#8217;t model an <em>is-like-a</em> relationship&#8212;that is, it doesn&#8217;t do similes. It&#8217;s often pointed out that lawyers are like sharks. But it is not literally true that a lawyer is a shark. For example, sharks can live underwater. Therefore, you shouldn&#8217;t derive a <code>Lawyer</code> class from a <code>Shark</code> class. Inheritance can add properties to a base class; it doesn&#8217;t remove properties from a base class. In some cases, shared characteristics can be handled by designing a class encompassing those characteristics and then using that class, either in an <em>is-a</em> or <em>has-a</em> relationship, to define the related classes.</p>
<p><a id="page_722"/>Public inheritance doesn&#8217;t model an <em>is-implemented-as-a</em> relationship. For example, you could implement a stack by using an array. However, it wouldn&#8217;t be proper to derive a <code>Stack</code> class from an <code>Array</code> class. A stack is not an array. For example, array indexing is not a stack property. Also a stack could be implemented in some other way, such as by using a linked list. A proper approach would be to hide the array implementation by giving the stack a private <code>Array</code> object member.</p>
<p>Public inheritance doesn&#8217;t model a <em>uses-a</em> relationship. For example, a computer can use a laser printer, but it doesn&#8217;t make sense to derive a <code>Printer</code> class from a <code>Computer</code> class, or vice versa. You might, however, devise friend functions or classes to handle communication between <code>Printer</code> objects and <code>Computer</code> objects.</p>
<p>Nothing in the C++ language prevents you from using public inheritance to model <em>has-a</em>, <em>is-implemented-as-a</em>, or <em>uses-a</em> relationships. However, doing so usually leads to programming problems. So let&#8217;s stick to the <em>is-a</em> relationships.</p>
<h3 id="ch13lev1sec3">Polymorphic Public Inheritance</h3>
<p>The <code>RatedPlayer</code> example of inheritance is a simple one. Objects of the derived class use the base-class methods without change. But you can encounter situations in which you want a method to behave differently for the derived class than it does for the base class. That is, the way a particular method behaves may depend on the object that invokes it. This more sophisticated behavior is termed <em>polymorphic</em> (&#8220;having many forms&#8221;) because you can have multiple behaviors for a method, depending on the context. There are two key mechanisms for implementing polymorphic public inheritance:</p>
<p class="indenthandingB">&#8226; Redefining base-class methods in a derived class</p>
<p class="indenthandingB">&#8226; Using virtual methods</p>
<p>It&#8217;s time for another example. You have leveraged your experience with the Webtown Social Club to become head programmer for the Pontoon National Bank. The first thing the bank asks you to do is develop two classes. One class will represent its basic checking plan, the Brass Account, and the second class will represent the Brass Plus checking account, which adds an overdraft protection feature. That is, if a user writes a check larger (but not too much larger) than his or her balance, the bank will cover the check, charging the user for the excess payment and adding a surcharge. You can characterize the two accounts in terms of data to be stored and operations to be allowed.</p>
<p>First, here is the information for a Brass Account checking plan:</p>
<p class="indenthandingB">&#8226; Client name</p>
<p class="indenthandingB">&#8226; Account number</p>
<p class="indenthandingB">&#8226; Current balance</p>
<p>And here are the operations to be represented:</p>
<p class="indenthandingB">&#8226; Creating an account</p>
<p class="indenthandingB">&#8226; Depositing money into the account</p>
<p class="indenthandingB">&#8226; <a id="page_723"/>Withdrawing money from the account</p>
<p class="indenthandingB">&#8226; Displaying the account information</p>
<p>For the Brass Plus Account checking plan, the Pontoon National Bank wants all the features of the Brass Account as well as the following additional items of information:</p>
<p class="indenthandingB">&#8226; An upper limit to the overdraft protection</p>
<p class="indenthandingB">&#8226; An interest rate charged for overdraft loans</p>
<p class="indenthandingB">&#8226; The overdraft amount currently owed to the bank</p>
<p>No additional operations are needed, but two operations need to be implemented differently:</p>
<p class="indenthandingB">&#8226; The withdrawing money operation has to incorporate overdraft protection for the Brass Plus Account</p>
<p class="indenthandingB">&#8226; The display operation has to show the additional information required by the Brass Plus Account</p>
<p>Suppose you call one class <code>Brass</code> and the second class <code>BrassPlus</code>. Should you derive <code>BrassPlus</code> publicly from <code>Brass</code>? To answer this question, first answer another: Does the <code>BrassPlus</code> class meet the <em>is-a</em> test? Sure. Everything that is true of a <code>Brass</code> object will be true for a <code>BrassPlus</code> object. Both store a client name, an account number, and a balance. With both, you can make deposits and withdrawals and display account information. Note that the <em>is-a</em> relationship is not, in general, symmetric. A fruit, in general, is not a banana; similarly, a <code>Brass</code> object won&#8217;t have all the capabilities of a <code>BrassPlus</code> object.</p>
<h4 id="ch13lev2sec5">Developing the <code>Brass</code> and <code>BrassPlus</code> Classes</h4>
<p>The Brass Account class information is pretty straightforward, but the bank hasn&#8217;t told you enough details about how the overdraft system works. In response to your request for further information, the friendly Pontoon National Bank representative tells you the following:</p>
<p class="indenthandingB">&#8226; A Brass Plus Account limits how much money the bank will lend you to cover overdrafts. The default value is $500, but some customers may start with a different limit.</p>
<p class="indenthandingB">&#8226; The bank may change a customer&#8217;s overdraft limit.</p>
<p class="indenthandingB">&#8226; A Brass Plus Account charges interest on the loan. The default value is 11.125%, but some customers may start with a different rate.</p>
<p class="indenthandingB">&#8226; The bank may change a customer&#8217;s interest rate.</p>
<p class="indenthandingB">&#8226; The account keeps track of how much the customer owes the bank (overdraft loans plus interest). The user cannot pay off this amount through a regular deposit or <a id="page_724"/>through a transfer from another account. Instead, he or she must pay in cash to a special bank officer, who will, if necessary, seek out the customer. When the debt is paid, the account can reset the amount owed to 0.</p>
<p>The last feature is an unusual way for a bank to do business, but it has the fortunate side effect of keeping the programming problem simpler.</p>
<p>This list suggests that the new class needs constructors that provide account information and that include a debt limit with a default value of $500 and an interest rate with a default value of 10%. Also there should be methods for resetting the debt limit, interest rate, and current debt. These are all things to be added to the <code>Brass</code> class, and they will be declared in the <code>BrassPlus</code> class declaration.</p>
<p>The information about the two classes suggests class declarations like those in <a href="#ch13ex07">Listing 13.7</a>.</p>
<p class="caption1"><a id="ch13ex07"/><strong>Listing 13.7. <code>brass.h</code></strong></p><hr/>
<p class="programlisting1">// brass.h&#160;&#160;-- bank account classes<br/>#ifndef BRASS_H_<br/>#define BRASS_H_<br/>#include &lt;string&gt;<br/>// Brass Account Class<br/>class Brass<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string fullName;<br/>&#160;&#160;&#160;&#160;long acctNum;<br/>&#160;&#160;&#160;&#160;double balance;<br/>public:<br/>&#160;&#160;&#160;&#160;Brass(const std::string &#38; s = "Nullbody", long an = -1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double bal = 0.0);<br/>&#160;&#160;&#160;&#160;void Deposit(double amt);<br/>&#160;&#160;&#160;&#160;virtual void Withdraw(double amt);<br/>&#160;&#160;&#160;&#160;double Balance() const;<br/>&#160;&#160;&#160;&#160;virtual void ViewAcct() const;<br/>&#160;&#160;&#160;&#160;virtual ~Brass() {}<br/>};<br/><br/>//Brass Plus Account Class<br/>class BrassPlus : public Brass<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double maxLoan;<br/>&#160;&#160;&#160;&#160;double rate;<br/>&#160;&#160;&#160;&#160;double owesBank;<br/>public:<br/>&#160;&#160;&#160;&#160;BrassPlus(const std::string &#38; s = "Nullbody", long an = -1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double bal = 0.0, double ml = 500,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double r = 0.11125);<br/>&#160;&#160;&#160;&#160;BrassPlus(const Brass &#38; ba, double ml = 500,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double r = 0.11125);<br/>&#160;&#160;&#160;&#160;virtual void ViewAcct()const;<br/>&#160;&#160;&#160;&#160;virtual void Withdraw(double amt);<br/>&#160;&#160;&#160;&#160;void ResetMax(double m) { maxLoan = m; }<br/>&#160;&#160;&#160;&#160;void ResetRate(double r) { rate = r; };<br/>&#160;&#160;&#160;&#160;void ResetOwes() { owesBank = 0; }<br/>};<br/><br/>#endif</p><hr/>
<p><a id="page_725"/>There are several points to notice in <a href="#ch13ex07">Listing 13.7</a>:</p>
<p class="indenthandingB">&#8226; The <code>BrassPlus</code> class adds three new private data members and three new public member functions to the <code>Brass</code> class.</p>
<p class="indenthandingB">&#8226; Both the <code>Brass</code> class and the <code>BrassPlus</code> class declare the <code>ViewAcct()</code> and <code>Withdraw()</code> methods; these are the methods that will behave differently for a <code>BrassPlus</code> object than they do with a <code>Brass</code> object.</p>
<p class="indenthandingB">&#8226; The <code>Brass</code> class uses the new keyword <code>virtual</code> in declaring <code>ViewAcct()</code> and <code>Withdraw()</code>. These methods are now termed <em>virtual methods</em>.</p>
<p class="indenthandingB">&#8226; The <code>Brass</code> class also declares a virtual destructor, even though the destructor does nothing.</p>
<p>The first point in the list is nothing new. The <code>RatedPlayer</code> class did something similar when it added a new data member and two new methods to the <code>TableTennisPlayer</code> class.</p>
<p>The second point in the list is how the declarations specify that methods are to behave differently for the derived class. The two <code>ViewAcct()</code> prototypes indicate that there will be two separate method definitions. The qualified name for the base-class version is <code>Brass::ViewAcct()</code>, and the qualified name for the derived-class version is <code>BrassPlus::ViewAcct()</code>. A program will use the object type to determine which version to use:</p>
<p class="programlisting">Brass dom("Dominic Banker", 11224, 4183.45);<br/>BrassPlus dot("Dorothy Banker", 12118, 2592.00);<br/>dom.ViewAcct();&#160;&#160;&#160;&#160;&#160;&#160;// use Brass::ViewAcct()<br/>dot.ViewAcct();&#160;&#160;&#160;&#160;&#160;&#160;// use BrassPlus::ViewAcct()</p>
<p>Similarly, there will be two versions of <code>Withdraw()</code>: one that&#8217;s used by <code>Brass</code> objects and one that&#8217;s used by <code>BrassPlus</code> objects. Methods that behave the same for both classes, such as <code>Deposit()</code> and <code>Balance()</code>, are declared only in the base class.</p>
<p>The third point (the use of <code>virtual</code>) is more involved than the first two points. It determines which method is used if the method is invoked by a reference or a pointer instead of by an object. If you don&#8217;t use the keyword <code>virtual</code>, the program chooses a method based on the reference type or pointer type. If you do use the keyword <code>virtual</code>, <a id="page_726"/>the program chooses a method based on the type of object the reference or pointer refers to. Here is how a program behaves if <code>ViewAcct()</code> is not virtual:</p>
<p class="programlisting">// behavior with non-virtual ViewAcct()<br/>// method chosen according to reference type<br/>Brass dom("Dominic Banker", 11224, 4183.45);<br/>BrassPlus dot("Dorothy Banker", 12118, 2592.00);<br/>Brass &#38; b1_ref = dom;<br/>Brass &#38; b2_ref = dot;<br/>b1_ref.ViewAcct();&#160;&#160;&#160;&#160;&#160;&#160;// use Brass::ViewAcct()<br/>b2_ref.ViewAcct();&#160;&#160;&#160;&#160;&#160;&#160;// use Brass::ViewAcct()</p>
<p>The reference variables are type <code>Brass</code>, so <code>Brass::ViewAccount()</code> is chosen. Using pointers to <code>Brass</code> instead of references results in similar behavior.</p>
<p>In contrast, here is the behavior if <code>ViewAcct()</code> is virtual:</p>
<p class="programlisting">// behavior with virtual ViewAcct()<br/>// method chosen according to object type<br/>Brass dom("Dominic Banker", 11224, 4183.45);<br/>BrassPlus dot("Dorothy Banker", 12118, 2592.00);<br/>Brass &#38; b1_ref = dom;<br/>Brass &#38; b2_ref = dot;<br/>b1_ref.ViewAcct();&#160;&#160;&#160;&#160;&#160;&#160;// use Brass::ViewAcct()<br/>b2_ref.ViewAcct();&#160;&#160;&#160;&#160;&#160;&#160;// use BrassPlus::ViewAcct()</p>
<p>In this case, both references are type <code>Brass</code>, but <code>b2_ref</code> refers to a <code>BrassPlus</code> object, so <code>BrassPlus::ViewAcct()</code> is used for it. Using pointers to <code>Brass</code> instead of references results in similar behavior.</p>
<p>It turns out, as you&#8217;ll see in a bit, that this behavior of virtual functions is very handy. Therefore, it is the common practice to declare as virtual in the base class those methods that might be redefined in a derived class. When a method is declared virtual in a base class, it is automatically virtual in the derived class, but it is a good idea to document which functions are virtual by using the keyword <code>virtual</code> in the derived class declarations, too.</p>
<p>The fourth point is that the base class declares a virtual destructor. This is to make sure that the correct sequence of destructors is called when a derived object is destroyed. We&#8217;ll discuss this point in more detail later in this chapter.</p>
<div class="note"><hr/>
<p class="title"><a id="ch13note02"/>Note</p>
<p class="notepara">If you redefine a base-class method in a derived class, the usual practice is to declare the base-class method as virtual. This makes the program choose the method version based on object type instead of the type of a reference or pointer. It&#8217;s also the usual practice to declare a virtual destructor for the base class.</p>
<hr/></div>
<h5 id="ch13lev3sec1">Class Implementations</h5>
<p><a id="page_727"/>The next step is to prepare the class implementation. Part of this has been done already by the inline function definitions in the header file. <a href="#ch13ex08">Listing 13.8</a> provides the remaining method definitions. Note that the keyword <code>virtual</code> is used just in the method prototypes in the class declaration, not in the method definitions in <a href="#ch13ex08">Listing 13.8</a>.</p>
<p class="caption1"><a id="ch13ex08"/><strong>Listing 13.8. <code>brass.cpp</code></strong></p><hr/>
<p class="programlisting1">// brass.cpp -- bank account class methods<br/>#include &lt;iostream&gt;<br/>#include "brass.h"<br/>using std::cout;<br/>using std::endl;<br/>using std::string;<br/><br/>// formatting stuff<br/>typedef std::ios_base::fmtflags format;<br/>typedef std::streamsize precis;<br/>format setFormat();<br/>void restore(format f, precis p);<br/><br/>// Brass methods<br/><br/>Brass::Brass(const string &#38; s, long an, double bal)<br/>{<br/>&#160;&#160;&#160;&#160;fullName = s;<br/>&#160;&#160;&#160;&#160;acctNum = an;<br/>&#160;&#160;&#160;&#160;balance = bal;<br/>}<br/><br/>void Brass::Deposit(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;if (amt &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Negative deposit not allowed; "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "deposit is cancelled.\n";<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;balance += amt;<br/>}<br/><br/>void Brass::Withdraw(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;// set up ###.## format<br/>&#160;&#160;&#160;&#160;format initialState = setFormat();<br/>&#160;&#160;&#160;&#160;precis prec = cout.precision(2);<br/><br/>&#160;&#160;&#160;&#160;if (amt &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Withdrawal amount must be positive; "<br/><a id="page_728"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "withdrawal canceled.\n";<br/>&#160;&#160;&#160;&#160;else if (amt &lt;= balance)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;balance -= amt;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Withdrawal amount of $" &lt;&lt; amt<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " exceeds your balance.\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Withdrawal canceled.\n";<br/>&#160;&#160;&#160;&#160;restore(initialState, prec);<br/>}<br/>double Brass::Balance() const<br/>{<br/>&#160;&#160;&#160;&#160;return balance;<br/>}<br/><br/>void Brass::ViewAcct() const<br/>{<br/>&#160;&#160;&#160;&#160;&#160;// set up ###.## format<br/>&#160;&#160;&#160;&#160;format initialState = setFormat();<br/>&#160;&#160;&#160;&#160;precis prec = cout.precision(2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Client: " &lt;&lt; fullName &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Account Number: " &lt;&lt; acctNum &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Balance: $" &lt;&lt; balance &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;restore(initialState, prec); // restore original format<br/>}<br/><br/>// BrassPlus Methods<br/>BrassPlus::BrassPlus(const string &#38; s, long an, double bal,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double ml, double r) : Brass(s, an, bal)<br/>{<br/>&#160;&#160;&#160;&#160;maxLoan = ml;<br/>&#160;&#160;&#160;&#160;owesBank = 0.0;<br/>&#160;&#160;&#160;&#160;rate = r;<br/>}<br/><br/>BrassPlus::BrassPlus(const Brass &#38; ba, double ml, double r)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Brass(ba)&#160;&#160;&#160;// uses implicit copy constructor<br/>{<br/>&#160;&#160;&#160;&#160;maxLoan = ml;<br/>&#160;&#160;&#160;&#160;owesBank = 0.0;<br/>&#160;&#160;&#160;&#160;rate = r;<br/>}<br/><br/>// redefine how ViewAcct() works<br/>void BrassPlus::ViewAcct() const<br/>{<br/>&#160;&#160;&#160;&#160;// set up ###.## format<br/>&#160;&#160;&#160;&#160;format initialState = setFormat();<br/><a id="page_729"/>&#160;&#160;&#160;&#160;precis prec = cout.precision(2);<br/><br/>&#160;&#160;&#160;&#160;Brass::ViewAcct();&#160;&#160;&#160;// display base portion<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Maximum loan: $" &lt;&lt; maxLoan &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Owed to bank: $" &lt;&lt; owesBank &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout.precision(3);&#160;&#160;// ###.### format<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Loan Rate: " &lt;&lt; 100 * rate &lt;&lt; "%\n";<br/>&#160;&#160;&#160;&#160;restore(initialState, prec);<br/>}<br/><br/>// redefine how Withdraw() works<br/>void BrassPlus::Withdraw(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;// set up ###.## format<br/>&#160;&#160;&#160;&#160;format initialState = setFormat();<br/>&#160;&#160;&#160;&#160;precis prec = cout.precision(2);<br/><br/>&#160;&#160;&#160;&#160;double bal = Balance();<br/>&#160;&#160;&#160;&#160;if (amt &lt;= bal)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Brass::Withdraw(amt);<br/>&#160;&#160;&#160;&#160;else if ( amt &lt;= bal + maxLoan - owesBank)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double advance = amt - bal;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;owesBank += advance * (1.0 + rate);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bank advance: $" &lt;&lt; advance &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Finance charge: $" &lt;&lt; advance * rate &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Deposit(advance);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Brass::Withdraw(amt);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Credit limit exceeded. Transaction cancelled.\n";<br/>&#160;&#160;&#160;&#160;restore(initialState, prec);<br/>}<br/><br/>format setFormat()<br/>{<br/>&#160;&#160;&#160;&#160;// set up ###.## format<br/>&#160;&#160;&#160;&#160;return cout.setf(std::ios_base::fixed,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::ios_base::floatfield);<br/>}<br/><br/>void restore(format f, precis p)<br/>{<br/>&#160;&#160;&#160;&#160;cout.setf(f, std::ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout.precision(p);<br/>}</p><hr/>
<p><a id="page_730"/>Before looking at details of <a href="#ch13ex08">Listing 13.8</a>, such as handling of formatting in some of the methods, let&#8217;s examine the aspects that relate directly to inheritance. Keep in mind that the derived class does not have direct access to private base-class data; the derived class has to use base-class public methods to access that data. The means of access depends on the method. Constructors use one technique, and other member functions use a different technique.</p>
<p>The technique that derived-class constructors use to initialize base-class private data is the member initializer list syntax. The <code>RatedPlayer</code> class constructors use that technique, and so do the <code>BrassPlus</code> constructors:</p>
<p class="programlisting">BrassPlus::BrassPlus(const string &#38; s, long an, double bal,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double ml, double r) : Brass(s, an, bal)<br/>{<br/>&#160;&#160;&#160;&#160;maxLoan = ml;<br/>&#160;&#160;&#160;&#160;owesBank = 0.0;<br/>&#160;&#160;&#160;&#160;rate = r;<br/>}<br/><br/>BrassPlus::BrassPlus(const Brass &#38; ba, double ml, double r)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Brass(ba)&#160;&#160;&#160;// uses implicit copy constructor<br/>{<br/>&#160;&#160;&#160;&#160;maxLoan = ml;<br/>&#160;&#160;&#160;&#160;owesBank = 0.0;<br/>&#160;&#160;&#160;&#160;rate = r;<br/>}</p>
<p>Each of these constructors uses the member initializer list syntax to pass base-class information to a base-class constructor and then uses the constructor body to initialize the new data items added by the <code>BrassPlus</code> class.</p>
<p>Non-constructors can&#8217;t use the member initializer list syntax. But a derived-class method can call a public base-class method. For instance, ignoring the formatting aspect, the core of the <code>BrassPlus</code> version of <code>ViewAcct()</code> is this:</p>
<p class="programlisting">// redefine how ViewAcct() works<br/>void BrassPlus::ViewAcct() const<br/>{<br/>...<br/>&#160;&#160;&#160;&#160;Brass::ViewAcct();&#160;&#160;&#160;// display base portion<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Maximum loan: $" &lt;&lt; maxLoan &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Owed to bank: $" &lt;&lt; owesBank &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Loan Rate: " &lt;&lt; 100 * rate &lt;&lt; "%\n";<br/>...<br/>}</p>
<p>In other words, <code>BrassPlus::ViewAcct()</code> displays the added <code>BrassPlus</code> data members and calls on the base-class method <code>Brass::ViewAcct()</code> to display the base-class data members. Using the scope-resolution operator in a derived-class method to invoke a base-class method is a standard technique.</p>
<p><a id="page_731"/>It&#8217;s vital that the code use the scope-resolution operator. Suppose that, instead, you wrote the code this way:</p>
<p class="programlisting">// redefine erroneously how ViewAcct() works<br/>void BrassPlus::ViewAcct() const<br/>{<br/>...<br/>&#160;&#160;&#160;&#160;ViewAcct();&#160;&#160;&#160;// oops! recursive call<br/>...<br/>}</p>
<p>If the code doesn&#8217;t use the scope-resolution operator, the compiler assumes that <code>ViewAcct()</code> is <code>BrassPlus::ViewAcct()</code>, and this creates a recursive function that has no termination&#8212;not a good thing.</p>
<p>Next, consider the <code>BrassPlus::Withdraw()</code> method. If the client withdraws an amount larger than the balance, the method should arrange for a loan. It can use <code>Brass::Withdraw()</code> to access the balance member, but <code>Brass::Withdraw()</code> issues an error message if the withdrawal amount exceeds the balance. This implementation avoids the message by using the <code>Deposit()</code> method to make the loan and then calling <code>Brass::Withdraw()</code> when sufficient funds are available:</p>
<p class="programlisting">// redefine how Withdraw() works<br/>void BrassPlus::Withdraw(double amt)<br/>{<br/>...<br/>&#160;&#160;&#160;&#160;double bal = Balance();<br/>&#160;&#160;&#160;&#160;if (amt &lt;= bal)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Brass::Withdraw(amt);<br/>&#160;&#160;&#160;&#160;else if ( amt &lt;= bal + maxLoan - owesBank)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double advance = amt - bal;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;owesBank += advance * (1.0 + rate);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bank advance: $" &lt;&lt; advance &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Finance charge: $" &lt;&lt; advance * rate &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Deposit(advance);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Brass::Withdraw(amt);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Credit limit exceeded. Transaction cancelled.\n";<br/>...<br/>}</p>
<p>Note that the method uses the base-class <code>Balance()</code> function to determine the original balance. The code doesn&#8217;t have to use the scope-resolution operator for <code>Balance()</code> because this method has not been redefined in the derived class.</p>
<p>The <code>ViewAcct()</code> and the <code>Withdraw()</code> methods use the <code>setf()</code> and <code>precision()</code> formatting methods to set the output mode for floating-point values to fixed-point, two <a id="page_732"/>places to the right of the decimal. When these modes are set, output stays in that mode, so the polite thing for these methods to do is to reset the formatting mode to its state prior to calling the methods. <a href="ch08.html#ch08ex08">Listings 8.8</a> and <a href="ch10.html#ch10ex05">10.5</a> use similar approaches. To avoid some code duplication, the program moves some of the formatting actions to helper functions:</p>
<p class="programlisting">// formatting stuff<br/>typedef std::ios_base::fmtflags format;<br/>typedef std::streamsize precis;<br/>format setFormat();<br/>void restore(format f, precis p);</p>
<p>The <code>setFormat()</code> function sets fixed-point notation and returns the previous flag setting:</p>
<p class="programlisting">format setFormat()<br/>{<br/>&#160;&#160;&#160;&#160;// set up ###.## format<br/>&#160;&#160;&#160;&#160;return cout.setf(std::ios_base::fixed,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::ios_base::floatfield);<br/>}</p>
<p>And the <code>restore()</code> function resets the format and the precision:</p>
<p class="programlisting">void restore(format f, precis p)<br/>{<br/>&#160;&#160;&#160;&#160;cout.setf(f, std::ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout.precision(p);<br/>}</p>
<p>You can find more details about formatting in <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>.&#8221;</p>
<h5 id="ch13lev3sec2">Using the <code>Brass</code> and <code>BrassPlus</code> Classes</h5>
<p><a href="#ch13ex09">Listing 13.9</a> shows the class definitions with a <code>Brass</code> object and a <code>BrassPlus</code> object.</p>
<p class="caption1"><a id="ch13ex09"/><strong>Listing 13.9. <code>usebrass1.cpp</code></strong></p><hr/>
<p class="programlisting1">// usebrass1.cpp -- testing bank account classes<br/>// compile with brass.cpp<br/>#include &lt;iostream&gt;<br/>#include "brass.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;Brass Piggy("Porcelot Pigg", 381299, 4000.00);<br/>&#160;&#160;&#160;&#160;BrassPlus Hoggy("Horatio Hogg", 382288, 3000.00);<br/>&#160;&#160;&#160;&#160;Piggy.ViewAcct();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;Hoggy.ViewAcct();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Depositing $1000 into the Hogg Account:\n";<br/>&#160;&#160;&#160;&#160;Hoggy.Deposit(1000.00);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "New balance: $" &lt;&lt; Hoggy.Balance() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Withdrawing $4200 from the Pigg Account:\n";<br/>&#160;&#160;&#160;&#160;Piggy.Withdraw(4200.00);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Pigg account balance: $" &lt;&lt; Piggy.Balance() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Withdrawing $4200 from the Hogg Account:\n";<br/>&#160;&#160;&#160;&#160;Hoggy.Withdraw(4200.00);<br/>&#160;&#160;&#160;&#160;Hoggy.ViewAcct();<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_733"/>In the following output of the program in <a href="#ch13ex09">Listing 13.9</a>, note that Hogg gets overdraft protection and Pigg does not:</p>
<p class="programlisting">Client: Porcelot Pigg<br/>Account Number: 381299<br/>Balance: $4000.00<br/><br/>Client: Horatio Hogg<br/>Account Number: 382288<br/>Balance: $3000.00<br/>Maximum loan: $500.00<br/>Owed to bank: $0.00<br/>Loan Rate: 11.125%<br/><br/>Depositing $1000 into the Hogg Account:<br/>New balance: $4000<br/>Withdrawing $4200 from the Pigg Account:<br/>Withdrawal amount of $4200.00 exceeds your balance.<br/>Withdrawal canceled.<br/>Pigg account balance: $4000<br/>Withdrawing $4200 from the Hogg Account:<br/>Bank advance: $200.00<br/>Finance charge: $22.25<br/>Client: Horatio Hogg<br/>Account Number: 382288<br/>Balance: $0.00<br/>Maximum loan: $500.00<br/>Owed to bank: $222.25<br/>Loan Rate: 11.125%</p>
<h5 id="ch13lev3sec3">Showing Virtual Method Behavior</h5>
<p><a id="page_734"/>In <a href="#ch13ex09">Listing 13.9</a> the methods are invoked by objects, not pointers or references, so this program doesn&#8217;t use the virtual method feature. Let&#8217;s look at an example for which the virtual methods do come into play. Suppose you would like to manage a mixture of <code>Brass</code> and <code>BrassPlus</code> accounts. It would be nice if you could have a single array that holds a mixture of <code>Brass</code> and <code>BrassPlus</code> objects, but that&#8217;s not possible. Every item in an array has to be of the same type, and <code>Brass</code> and <code>BrassPlus</code> are two separate types. However, you can create an array of pointers-to-<code>Brass</code>. In that case, every element is of the same type, but because of the public inheritance model, a pointer-to-<code>Brass</code> can point to either a <code>Brass</code> or a <code>BrassPlus</code> object. Thus, in effect, you have a way of representing a collection of more than one type of object with a single array. This is polymorphism, and <a href="#ch13ex10">Listing 13.10</a> shows a simple example.</p>
<p class="caption1"><a id="ch13ex10"/><strong>Listing 13.10. <code>usebrass2.cpp</code></strong></p><hr/>
<p class="programlisting1">// usebrass2.cpp -- polymorphic example<br/>// compile with brass.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include "brass.h"<br/>const int CLIENTS = 4;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;Brass * p_clients[CLIENTS];<br/>&#160;&#160;&#160;std::string temp;<br/>&#160;&#160;&#160;long tempnum;<br/>&#160;&#160;&#160;double tempbal;<br/>&#160;&#160;&#160;char kind;<br/><br/>&#160;&#160;&#160;for (int i = 0; i &lt; CLIENTS; i++)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter client's name: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;getline(cin,temp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter client's account number: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; tempnum;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter opening balance: $";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; tempbal;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter 1 for Brass Account or "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "2 for BrassPlus Account: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin &gt;&gt; kind &#38;&#38; (kind != '1' &#38;&#38; kind != '2'))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt;"Enter either 1 or 2: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (kind == '1')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p_clients[i] = new Brass(temp, tempnum, tempbal);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double tmax, trate;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the overdraft limit: $";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; tmax;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the interest rate "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "as a decimal fraction: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; trate;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p_clients[i] = new BrassPlus(temp, tempnum, tempbal,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tmax, trate);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;for (int i = 0; i &lt; CLIENTS; i++)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;p_clients[i]-&gt;ViewAcct();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;for (int i = 0; i &lt; CLIENTS; i++)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete p_clients[i];&#160;&#160;// free memory<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_735"/>The program in <a href="#ch13ex10">Listing 13.10</a> lets user input determine the type of account to be added and then uses <code>new</code> to create and initialize an object of the proper type. You may recall that <code>getline(cin,temp)</code> reads a line of input from <code>cin</code> and stores it in the <code>string</code> object <code>temp</code>.</p>
<p>Here is a sample run of the program in <a href="#ch13ex10">Listing 13.10</a>:</p>
<p class="programlisting">Enter client's name: <span class="EmpStrong">Harry Fishsong</span><br/>Enter client's account number: <span class="EmpStrong">112233</span><br/>Enter opening balance: $<span class="EmpStrong">1500</span><br/>Enter 1 for Brass Account or 2 for BrassPlus Account: <span class="EmpStrong">1</span><br/>Enter client's name: <span class="EmpStrong">Dinah Otternoe</span><br/>Enter client's account number: <span class="EmpStrong">121213</span><br/>Enter opening balance: $<span class="EmpStrong">1800</span><br/>Enter 1 for Brass Account or 2 for BrassPlus Account: <span class="EmpStrong">2</span><br/>Enter the overdraft limit: <span class="EmpStrong">$350</span><br/>Enter the interest rate as a decimal fraction: <span class="EmpStrong">0.12</span><br/><a id="page_736"/>Enter client's name: <span class="EmpStrong">Brenda Birdherd</span><br/>Enter client's account number: <span class="EmpStrong">212118</span><br/>Enter opening balance: $<span class="EmpStrong">5200</span><br/>Enter 1 for Brass Account or 2 for BrassPlus Account: <span class="EmpStrong">2</span><br/>Enter the overdraft limit: $<span class="EmpStrong">800</span><br/>Enter the interest rate as a decimal fraction: <span class="EmpStrong">0.10</span><br/>Enter client's name: <span class="EmpStrong">Tim Turtletop</span><br/>Enter client's account number: <span class="EmpStrong">233255</span><br/>Enter opening balance: $<span class="EmpStrong">688</span><br/>Enter 1 for Brass Account or 2 for BrassPlus Account: <span class="EmpStrong">1</span><br/><br/>Client: Harry Fishsong<br/>Account Number: 112233<br/>Balance: $1500.00<br/><br/>Client: Dinah Otternoe<br/>Account Number: 121213<br/>Balance: $1800.00<br/>Maximum loan: $350.00<br/>Owed to bank: $0.00<br/>Loan Rate: 12.00%<br/><br/>Client: Brenda Birdherd<br/>Account Number: 212118<br/>Balance: $5200.00<br/>Maximum loan: $800.00<br/>Owed to bank: $0.00<br/>Loan Rate: 10.00%<br/><br/>Client: Tim Turtletop<br/>Account Number: 233255<br/>Balance: $688.00<br/><br/>Done.</p>
<p>The polymorphic aspect is provided by the following code:</p>
<p class="programlisting">for (i = 0; i &lt; CLIENTS; i++)<br/>{<br/>&#160;&#160;&#160;&#160;p_clients[i]-&gt;ViewAcct();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}</p>
<p>If the array member points to a <code>Brass</code> object, <code>Brass::ViewAcct()</code> is invoked; if the array member points to a <code>BrassPlus</code> object, <code>BrassPlus::ViewAcct()</code> is invoked. If <code>Brass::ViewAcct()</code> were been declared as virtual, <code>Brass:ViewAcct()</code> would be invoked in all cases.</p>
<h5 id="ch13lev3sec4">The Need for Virtual Destructors</h5>
<p><a id="page_737"/>The code in <a href="#ch13ex10">Listing 13.10</a> that uses <code>delete</code> to free the objects allocated by <code>new</code> illustrates why the base class should have a virtual destructor, even if no destructor appears to be needed. If the destructors are not virtual, then just the destructor corresponding to the pointer type is called. In <a href="#ch13ex10">Listing 13.10</a>, this means that only the <code>Brass</code> destructor would be called, even if the pointer pointed to a <code>BrassPlus</code> object. If the destructors are virtual, the destructor corresponding to the object type is called. So if a pointer points to a <code>BrassPlus</code> object, the <code>BrassPlus</code> destructor is called. And when a <code>BrassPlus</code> destructor finishes, it automatically calls the base-class constructor. Thus, using virtual destructors ensures that the correct sequence of destructors is called. In <a href="#ch13ex10">Listing 13.10</a>, this correct behavior isn&#8217;t essential because the destructors do nothing. But if, say, <code>BrassPlus</code> had a do-something destructor, it would be vital for <code>Brass</code> to have a virtual destructor, even if it did nothing.</p>
<h3 id="ch13lev1sec4">Static and Dynamic Binding</h3>
<p>Which block of executable code gets used when a program calls a function? The compiler has the responsibility of answering this question. Interpreting a function call in the source code as executing a particular block of function code is termed <em>binding</em> the function name. With C, the task is simple because each function name corresponds to a distinct function. With C++, the task is more complex because of function overloading. The compiler has to look at the function arguments as well as the function name to figure out which function to use. Nonetheless, this kind of binding is a task a C or C++ compiler could perform during the compiling process; binding that takes place during compilation is called <em>static binding</em> (or <em>early binding</em>). However, virtual functions make the job more difficult yet. As shown in <a href="#ch13ex10">Listing 13.10</a>, the decision of which function to use can&#8217;t be made at compile time because the compiler doesn&#8217;t know which kind of object the user is going to choose to make. Therefore, the compiler has to generate code that allows the correct virtual method to be selected as the program runs; this is called <em>dynamic binding</em> (or <em>late binding</em>).</p>
<p>Now that you&#8217;ve seen virtual methods at work, let&#8217;s look at this process in greater depth, beginning with how C++ handles pointer and reference type compatibility.</p>
<h4 id="ch13lev2sec6">Pointer and Reference Type Compatibility</h4>
<p>Dynamic binding in C++ is associated with methods invoked by pointers and references, and this is governed, in part, by the inheritance process. One way public inheritance models the <em>is-a</em> relationship is in how it handles pointers and references to objects. Normally, C++ does not allow you to assign an address of one type to a pointer of another type. Nor does it let a reference to one type refer to another type:</p>
<p class="programlisting">double x = 2.5;<br/>int * pi = &#38;x;&#160;&#160;&#160;// invalid assignment, mismatched pointer types<br/>long &#38; rl = x;&#160;&#160;&#160;// invalid assignment, mismatched reference type</p>
<p><a id="page_738"/>However, as you&#8217;ve seen, a reference or a pointer to a base class can refer to a derived-class object without using an explicit type cast. For example, the following initializations are allowed:</p>
<p class="programlisting">BrassPlus dilly ("Annie Dill", 493222, 2000);<br/>Brass * pb = &#38;dilly;&#160;&#160;&#160;// ok<br/>Brass &#38; rb = dilly;&#160;&#160;&#160;&#160;// ok</p>
<p>Converting a derived-class reference or pointer to a base-class reference or pointer is called <em>upcasting</em>, and it is always allowed for public inheritance without the need for an explicit type cast. This rule is part of expressing the <em>is-a</em> relationship. A <code>BrassPlus</code> object is a <code>Brass</code> object in that it inherits all the data members and member functions of a <code>Brass</code> object. Therefore, anything that you can do to a <code>Brass</code> object, you can do to a <code>BrassPlus</code> object. So a function designed to handle a <code>Brass</code> reference can, without fear of creating problems, perform the same acts on a <code>BrassPlus</code> object. The same idea applies if you pass a pointer to an object as a function argument. Upcasting is transitive. That is, if you derive a <code>BrassPlusPlus</code> class from <code>BrassPlus</code>, then a <code>Brass</code> pointer or reference can refer to a <code>Brass</code> object, a <code>BrassPlus</code> object, or a <code>BrassPlusPlus</code> object.</p>
<p>The opposite process, converting a base-class pointer or reference to a derived-class pointer or reference, is called <em>downcasting</em>, and it is not allowed without an explicit type cast. The reason for this restriction is that the <em>is-a</em> relationship is not, in general, symmetric. A derived class could add new data members, and the class member functions that used these data members wouldn&#8217;t apply to the base class. For example, suppose you derive a <code>Singer</code> class from an <code>Employee</code> class, adding a data member representing a singer&#8217;s vocal range and a member function, called <code>range()</code>, that reports the value for the vocal range. It wouldn&#8217;t make sense to apply the <code>range()</code> method to an <code>Employee</code> object. But if implicit downcasting were allowed, you could accidentally set a pointer-to-<code>Singer</code> to the address of an <code>Employee</code> object and use the pointer to invoke the <code>range()</code> method (see <a href="#ch13fig04">Figure 13.4</a>).</p>
<p>Upcasting also takes place for function calls with base-class references or pointers as parameters. Consider the following code fragment, and suppose each function calls upon the virtual method <code>ViewAcct()</code>:</p>
<p class="programlisting">void fr(Brass &#38; rb); // uses rb.ViewAcct()<br/>void fp(Brass * pb); // uses pb-&gt;ViewAcct()<br/>void fv(Brass b);&#160;&#160;&#160;&#160;// uses b.ViewAcct()<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Brass b("Billy Bee", 123432, 10000.0);<br/>&#160;&#160;&#160;&#160;BrassPlus bp("Betty Beep", 232313, 12345.0);<br/>&#160;&#160;&#160;&#160;fr(b);&#160;&#160;// uses Brass::ViewAcct()<br/>&#160;&#160;&#160;&#160;fr(bp); // uses BrassPlus::ViewAcct()<br/>&#160;&#160;&#160;&#160;fp(b);&#160;&#160;// uses Brass::ViewAcct()<br/>&#160;&#160;&#160;&#160;fp(bp); // uses BrassPlus::ViewAcct()<br/><a id="page_739"/>&#160;&#160;&#160;&#160;fv(b);&#160;&#160;// uses Brass::ViewAcct()<br/>&#160;&#160;&#160;&#160;fv(bp); // uses Brass::ViewAcct()<br/>...<br/>}</p>
<p>Passing by value causes only the <code>Brass</code> component of a <code>BrassPlus</code> object to be passed to the <code>fv()</code> function. But the implicit upcasting that occurs with references and pointers causes the <code>fr()</code> and <code>fp()</code> functions to use <code>Brass::ViewAcct()</code> for <code>Brass</code> objects and <code>BrassPlus::ViewAcct()</code> for <code>BrassPlus</code> objects.</p>
<p>Implicit upcasting makes it possible for a base-class pointer or reference to refer to either a base-class object or a derived-class object, and that produces the need for dynamic binding. Virtual member functions are the C++ answer to that need.</p>
<h4 id="ch13lev2sec7">Virtual Member Functions and Dynamic Binding</h4>
<p>Let&#8217;s revisit the process of invoking a method with a reference or pointer. Consider the following code:</p>
<p class="programlisting">BrassPlus ophelia;&#160;&#160;&#160;&#160;// derived-class object<br/>Brass * bp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// base-class pointer<br/>bp = &#38;ophelia;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Brass pointer to BrassPlus object<br/>bp-&gt;ViewAcct();&#160;&#160;&#160;&#160;&#160;&#160;&#160;// which version?</p>
<p>As discussed before, if <code>ViewAcct()</code> is not declared as virtual in the base class, <code>bp-&gt;ViewAcct()</code> goes by the pointer type (<code>Brass *</code>) and invokes <code>Brass::ViewAcct()</code>. The pointer type is known at compile time, so the compiler can bind <code>ViewAcct()</code> to <code>Brass::ViewAcct()</code> at compile time. In short, the compiler uses static binding for nonvirtual methods.</p>
<p>But if <code>ViewAcct()</code> is declared as virtual in the base class, <code>bp-&gt;ViewAcct()</code> goes by the object type (<code>BrassPlus</code>) and invokes <code>BrassPlus::ViewAcct()</code>. In this example, you can see that the object type is <code>BrassPlus</code>, but, in general, (as in <a href="#ch13ex10">Listing 13.10</a>) the object type might only be determined when the program is running. Therefore, the compiler generates code that binds <code>ViewAcct()</code> to <code>Brass::ViewAcct()</code> or <code>BrassPlus::ViewAcct()</code>, depending on the object type, while the program executes. In short, the compiler uses dynamic binding for virtual methods.</p>
<p>In most cases, dynamic binding is a good thing because it allows a program to choose the method designed for a particular type. Given this fact, you might be wondering about the following:</p>
<p class="indenthandingB">&#8226; Why have two kinds of binding?</p>
<p class="indenthandingB">&#8226; If dynamic binding is so good, why isn&#8217;t it the default?</p>
<p class="indenthandingB">&#8226; How does it work?</p>
<p>We&#8217;ll look at answers to these questions next.</p>
<h5 id="ch13lev3sec5">Why Two Kinds of Binding and Why Static Is the Default</h5>
<p><a id="page_740"/>If dynamic binding allows you to redefine class methods but static binding makes a partial botch of it, why have static binding at all? There are two reasons: efficiency and a conceptual model.</p>
<p>First, let&#8217;s consider efficiency. For a program to be able to make a runtime decision, it has to have some way to keep track of what sort of object a base-class pointer or reference refers to, and that entails some extra processing overhead. (You&#8217;ll see one method of dynamic binding later.) If, for example, you design a class that won&#8217;t be used as a base class for inheritance, you don&#8217;t need dynamic binding. Similarly, if you have a derived class, such as the <code>RatedPlayer</code> example, that does not redefine any methods, you don&#8217;t need dynamic binding. In these cases, it makes sense to use static binding and gain a little efficiency. The fact that static binding is more efficient is the reason it is the default choice for C++. Stroustrup says that one of the guiding principles of C++ is that you shouldn&#8217;t have to pay (in memory usage or processing time) for features you don&#8217;t use. You should therefore go to virtual functions only if the program design needs them.</p>
<p>Next, let&#8217;s consider the conceptual model. When you design a class, you may have member functions that you don&#8217;t want redefined in derived classes. For example, the <code>Brass::Balance()</code> function, which returns the account balance, seems like a function that shouldn&#8217;t be redefined. By making this function nonvirtual, you accomplish two things. First, you make it more efficient. Second, you announce that it is your intention that this function not be redefined. That suggests reserving the virtual label just for methods you expect to be redefined.</p>
<div class="note"><hr/>
<p class="title"><a id="ch13note03"/>Tip</p>
<p class="notepara">If a method in a base class will be redefined in a derived class, you should make it virtual. If the method should not be redefined, you should make it nonvirtual.</p>
<hr/></div>
<p>Of course, when you design a class, it&#8217;s not always obvious into which category a method falls. Like many aspects of real life, class design is not a linear process.</p>
<h5 id="ch13lev3sec6">How Virtual Functions Work</h5>
<p>C++ specifies how virtual functions should behave, but it leaves the implementation up to the compiler writer. You don&#8217;t need to know the implementation method to use virtual functions, but seeing how it is done may help you understand the concepts better, so let&#8217;s take a look.</p>
<p>The usual way compilers handle virtual functions is to add a hidden member to each object. The hidden member holds a pointer to an array of function addresses. Such an array is usually termed a <em>virtual function table</em> (<em>vtbl</em>). The vtbl holds the addresses of the virtual functions declared for objects of that class. For example, an object of a base class contains a pointer to a table of addresses of all the virtual functions for that class. An object of a derived class contains a pointer to a separate table of addresses. If the derived class provides a new definition of a virtual function, the vtbl holds the address of the new function. <a id="page_741"/>If the derived class doesn&#8217;t redefine the virtual function, the vtbl holds the address of the original version of the function. If the derived class defines a new function and makes it virtual, its address is added to the vtbl (see <a href="#ch13fig05">Figure 13.5</a>). Note that whether you define 1 or 10 virtual functions for a class, you add just one address member to an object; it&#8217;s the table size that varies.</p>
<p class="caption"><a id="ch13fig05"/><strong>Figure 13.5. A virtual function mechanism.</strong></p>
<p class="image"><img src="graphics/13fig05.jpg" alt="Image"/></p>
<p><a id="page_742"/>When you call a virtual function, the program looks at the vtbl address stored in an object and goes to the corresponding table of function addresses. If you use the first virtual function defined in the class declaration, the program uses the first function address in the array and executes the function that has that address. If you use the third virtual function in the class declaration, the program uses the function whose address is in the third element of the array.</p>
<p>In short, using virtual functions has the following modest costs in memory and execution speed:</p>
<p class="indenthandingB">&#8226; Each object has its size increased by the amount needed to hold an address.</p>
<p class="indenthandingB">&#8226; For each class, the compiler creates a table (an array) of addresses of virtual functions.</p>
<p class="indenthandingB">&#8226; For each function call, there&#8217;s an extra step of going to a table to look up an address.</p>
<p>Keep in mind that although nonvirtual functions are slightly more efficient than virtual functions, they don&#8217;t provide dynamic binding.</p>
<h4 id="ch13lev2sec8">Things to Know About Virtual Methods</h4>
<p>We&#8217;ve already discussed the main points about virtual methods:</p>
<p class="indenthandingB">&#8226; Beginning a class method declaration with the keyword <code>virtual</code> in a base class makes the function virtual for the base class and all classes derived from the base class, including classes derived from the derived classes, and so on.</p>
<p class="indenthandingB">&#8226; If a virtual method is invoked by using a reference to an object or by using a pointer to an object, the program uses the method defined for the object type rather than the method defined for the reference or pointer type. This is called <em>dynamic</em>, or <em>late</em>, <em>binding</em>. This behavior is important because it&#8217;s always valid for a base-class pointer or reference to refer to an object of a derived type.</p>
<p class="indenthandingB">&#8226; If you&#8217;re defining a class that will be used as a base class for inheritance, you should declare as virtual functions the class methods that may have to be redefined in derived classes.</p>
<p>There are several other things you may need to know about virtual methods, some of which have been mentioned in passing already. Let&#8217;s look at them next.</p>
<h5 id="ch13lev3sec7">Constructors</h5>
<p>Constructors can&#8217;t be virtual. Creating a derived object invokes a derived-class constructor, not a base-class constructor. The derived-class constructor then uses a base-class constructor, but this sequence is distinct from the inheritance mechanism. Thus, a derived class doesn&#8217;t inherit the base-class constructors, so usually there&#8217;s not much point to making them virtual, anyway.</p>
<h5 id="ch13lev3sec8">Destructors</h5>
<p>Destructors should be virtual unless a class isn&#8217;t to be used as a base class. For example, suppose <code>Employee</code> is a base class and <code>Singer</code> is a derived class that adds a <code>char *</code> member <a id="page_743"/>that points to memory allocated by <code>new</code>. Then, when a <code>Singer</code> object expires, it&#8217;s vital that the <code>~Singer()</code> destructor be called to free that memory.</p>
<p>Now consider the following code:</p>
<p class="programlisting">Employee * pe = new Singer; // legal because Employee is base for Singer<br/>...<br/>delete pe;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ~Employee() or ~Singer()?</p>
<p>If the default static binding applies, the <code>delete</code> statement invokes the <code>~Employee()</code> destructor. This frees memory pointed to by the <code>Employee</code> components of the <code>Singer</code> object but not memory pointed to by the new class members. However, if the destructors are virtual, the same code invokes the <code>~Singer()</code> destructor, which frees memory pointed to by the <code>Singer</code> component, and then calls the <code>~Employee()</code> destructor to free memory pointed to by the <code>Employee</code> component.</p>
<p>Note that this implies that even if a base class doesn&#8217;t require the services of an explicit destructor, you shouldn&#8217;t rely on the default constructor. Instead, you should provide a virtual destructor, even if it has nothing to do:</p>
<p class="programlisting">virtual ~BaseClass() { }</p>
<p>By the way, it&#8217;s not an error for a class to have a virtual destructor even if it is not intended to be a base class; it&#8217;s just a matter of efficiency.</p>
<div class="note"><hr/>
<p class="title"><a id="ch13note04"/>Tip</p>
<p class="notepara">Normally, you should provide a base class with a virtual destructor even if the class doesn&#8217;t need a destructor.</p>
<hr/></div>
<h5 id="ch13lev3sec9">Friends</h5>
<p>Friends can&#8217;t be virtual functions because friends are not class members, and only members can be virtual functions. If this poses a problem for a design, you might be able to sidestep it by having the friend function use virtual member functions internally.</p>
<h5 id="ch13lev3sec10">No Redefinition</h5>
<p>If a derived class fails to redefine a function (virtual or not), the class will use the base class version of the function. If a derived class is part of a long chain of derivations, it will use the most recently defined version of the function. The exception is if the base versions are hidden, as described next.</p>
<h5 id="ch13lev3sec11">Redefinition Hides Methods</h5>
<p>Suppose you create something like the following:</p>
<p class="programlisting">class Dwelling<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void showperks(int a) const;<br/>...<br/>};<br/>class Hovel : public Dwelling<br/><a id="page_744"/>{<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void showperks() const;<br/>...<br/>};</p>
<p>This causes a problem. You might get a compiler warning similar to the following:</p>
<p class="programlisting">Warning: Hovel::showperks(void) hides Dwelling::showperks(int)</p>
<p>Or perhaps you won&#8217;t get a warning. Either way, the code has the following implications:</p>
<p class="programlisting">Hovel trump;<br/>trump.showperks();&#160;&#160;&#160;&#160;&#160;&#160;// valid<br/>trump.showperks(5);&#160;&#160;&#160;&#160;&#160;// invalid</p>
<p>The new definition defines a <code>showperks()</code> function that takes no arguments. Rather than resulting in two overloaded versions of the function, this redefinition <em>hides</em> the base class version that takes an <code>int</code> argument. In short, redefining inherited methods is not a variation of overloading. If you redefine a function in a derived class, it doesn&#8217;t just override the base class declaration with the same function signature. Instead, it hides <em>all</em> base-class methods of the same name, regardless of the argument signatures.</p>
<p>This fact of life leads to a couple rules of thumb. First, if you redefine an inherited method, you need to make sure you match the original prototype exactly. One relatively new exception to this rule is that a return type that is a reference or pointer to a base class can be replaced by a reference or pointer to the derived class. This feature is termed <em>covariance of return type</em> because the return type is allowed to vary in parallel with the class type:</p>
<p class="programlisting">class Dwelling<br/>{<br/>public:<br/>// a base method<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual Dwelling &#38; build(int n);<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};<br/>class Hovel : public Dwelling<br/>{<br/>public:<br/>// a derived method with a covariant return type<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual Hovel &#38; build(int n);&#160;&#160;// same function signature<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};</p>
<p>Note that this exception applies only to return values, not to arguments.</p>
<p>Second, if the base class declaration is overloaded, you need to redefine all the base-class versions in the derived class:</p>
<p class="programlisting"><a id="page_745"/>class Dwelling<br/>{<br/>public:<br/>// three overloaded showperks()<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void showperks(int a) const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void showperks(double x) const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void showperks() const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};<br/>class Hovel : public Dwelling<br/>{<br/>public:<br/>// three redefined showperks()<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void showperks(int a) const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void showperks(double x) const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void showperks() const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};</p>
<p>If you redefine just one version, the other two become hidden and cannot be used by objects of the derived class. Note that if no change is needed, the redefinition can simply call the base-class version:</p>
<p class="programlisting">void Hovel::showperks() const {Dwelling::showperks();}</p>
<h3 id="ch13lev1sec5">Access Control: <code>protected</code></h3>
<p>So far the class examples in this book have used the keywords <code>public</code> and <code>private</code> to control access to class members. There is one more access category, denoted with the keyword <code>protected</code>. The <code>protected</code> keyword is like <code>private</code> in that the outside world can access class members in a <code>protected</code> section only by using public class members. The difference between <code>private</code> and <code>protected</code> comes into play only within classes derived from the base class. Members of a derived class can access protected members of a base class directly, but they cannot directly access private members of the base class. So members in the protected category behave like private members as far as the outside world is concerned but behave like public members as far as derived classes are concerned.</p>
<p>For example, suppose the <code>Brass</code> class declared the <code>balance</code> member as protected:</p>
<p class="programlisting">class Brass<br/>{<br/>protected:<br/>&#160;&#160;&#160;&#160;double balance;<br/>...<br/>};</p>
<p>In this case, the <code>BrassPlus</code> class could access <code>balance</code> directly without using <code>Brass</code> methods. For example, the core of <code>BrassPlus::Withdraw()</code> could be written this way:</p>
<p class="programlisting"><a id="page_746"/>void BrassPlus::Withdraw(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;if (amt &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Withdrawal amount must be positive; "<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "withdrawal canceled.\n";<br/>&#160;&#160;&#160;&#160;else if (amt &lt;= balance)&#160;&#160;&#160;&#160;&#160;&#160;&#160;// access balance directly<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;balance -= amt;<br/>&#160;&#160;&#160;&#160;else if ( amt &lt;= balance + maxLoan - owesBank)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double advance = amt - balance;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;owesBank += advance * (1.0 + rate);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bank advance: $" &lt;&lt; advance &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Finance charge: $" &lt;&lt; advance * rate &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Deposit(advance);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;balance -= amt;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Credit limit exceeded. Transaction cancelled.\n";<br/>}</p>
<p>Using protected data members may simplify writing the code, but it has a design defect. For example, continuing with the <code>BrassPlus</code> example, if <code>balance</code> were protected, you could write code like this:</p>
<p class="programlisting">void BrassPlus::Reset(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;balance = amt;<br/>}</p>
<p>The <code>Brass</code> class was designed so that the <code>Deposit()</code> and <code>Withdraw()</code> interface provides the only means for altering <code>balance</code>. But the <code>Reset()</code> method essentially makes <code>balance</code> a public variable as far as <code>BrassPlus</code> objects are concerned, ignoring, for example, the safeguards found in <code>Withdraw()</code>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch13note05"/>Caution</p>
<p class="notepara">You should prefer private to protected access control for class data members, and you should use base-class methods to provide derived classes access to base-class data.</p>
<hr/></div>
<p>However, protected access control can be quite useful for member functions, giving derived classes access to internal functions that are not available publicly.</p>
<h3 id="ch13lev1sec6">Abstract Base Classes</h3>
<p>So far you&#8217;ve seen simple inheritance and the more intricate polymorphic inheritance. The next step in increasing sophistication is the abstract base class (ABC). Let&#8217;s look at some programming situations that provide the background for ABCs.</p>
<p><a id="page_747"/>Sometimes applying the <em>is-a</em> rule is not as simple as it might appear. Suppose, for example, you are developing a graphics program that is supposed to represent, among other things, circles and ellipses. A circle is a special case of an ellipse: It&#8217;s an ellipse whose long axis is the same as its short axis. Therefore, all circles are ellipses, and it is tempting to derive a <code>Circle</code> class from an <code>Ellipse</code> class. But when you get to the details, you may find problems.</p>
<p>To see this, first consider what you might include as part of an <code>Ellipse</code> class. Data members could include the coordinates of the center of the ellipse, the semimajor axis (half the long diameter), the semiminor axis (half the short diameter), and an orientation angle that gives the angle from the horizontal coordinate axis to the semimajor axis. Also the class could include methods to move the ellipse, to return the area of the ellipse, to rotate the ellipse, and to scale the semimajor and semiminor axes:</p>
<p class="programlisting">class Ellipse<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double x;&#160;&#160;&#160;&#160;&#160;// x-coordinate of the ellipse's center<br/>&#160;&#160;&#160;&#160;double y;&#160;&#160;&#160;&#160;&#160;// y-coordinate of the ellipse's center<br/>&#160;&#160;&#160;&#160;double a;&#160;&#160;&#160;&#160;&#160;// semimajor axis<br/>&#160;&#160;&#160;&#160;double b;&#160;&#160;&#160;&#160;&#160;// semiminor axis<br/>&#160;&#160;&#160;&#160;double angle; // orientation angle in degrees<br/>&#160;&#160;&#160;&#160;...<br/>public:<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;void Move(int nx, ny) { x = nx; y = ny; }<br/>&#160;&#160;&#160;&#160;virtual double Area() const { return 3.14159 * a * b; }<br/>&#160;&#160;&#160;&#160;virtual void Rotate(double nang) { angle += nang; }<br/>&#160;&#160;&#160;&#160;virtual void Scale(double sa, double sb)&#160;&#160;{ a *= sa; b *= sb; }<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>Now suppose you derive a <code>Circle</code> class from the <code>Ellipse</code> class:</p>
<p class="programlisting">class Circle : public Ellipse<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>Although a circle is an ellipse, this derivation is awkward. For example, a circle needs only a single value, its radius, to describe its size and shape instead of having a semimajor axis (<code>a</code>) and semiminor axis (<code>b</code>). The <code>Circle</code> constructors can take care of that by assigning the same value to both the <code>a</code> and <code>b</code> members, but then you have redundant representation of the same information. The <code>angle</code> parameter and the <code>Rotate()</code> method don&#8217;t really make sense for a circle, and the <code>Scale()</code> method, as it stands, can change a circle to a non-circle by scaling the two axes differently. You can try fixing things with tricks, such as putting a redefined <code>Rotate()</code> method in the private section of the <code>Circle</code> class so that <a id="page_748"/><code>Rotate()</code> can&#8217;t be used publicly with a circle, but, on the whole, it seems simpler to define a <code>Circle</code> class without using inheritance:</p>
<p class="programlisting">class Circle&#160;&#160;&#160;&#160;&#160;&#160;// no inheritance<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double x;&#160;&#160;&#160;&#160;&#160;// x-coordinate of the circle's center<br/>&#160;&#160;&#160;&#160;double y;&#160;&#160;&#160;&#160;&#160;// y-coordinate of the circle's center<br/>&#160;&#160;&#160;&#160;double r;&#160;&#160;&#160;&#160;&#160;// radius<br/>&#160;&#160;&#160;&#160;...<br/>public:<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;void Move(int nx, ny) { x = nx; y = ny; }<br/>&#160;&#160;&#160;&#160;double Area() const { return 3.14159 * r * r; }<br/>&#160;&#160;&#160;&#160;void Scale(double sr)&#160;&#160;{ r *= sr; }<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>Now the class has only the members it needs. Yet this solution also seems weak. The <code>Circle</code> and <code>Ellipse</code> classes have a lot in common, but defining them separately ignores that fact.</p>
<p>There is another solution: You can abstract from the <code>Ellipse</code> and <code>Circle</code> classes what they have in common and place those features in an ABC. Next, you derive both the <code>Circle</code> and <code>Ellipse</code> classes from the ABC. Then, for example, you can use an array of base-class pointers to manage a mixture of <code>Ellipse</code> and <code>Circle</code> objects&#8212;that is, you can use a polymorphic approach. In this case, what the two classes have in common are the coordinates of the center of the shape; a <code>Move()</code> method, which is the same for both; and an <code>Area()</code> method, which works differently for the two classes. Indeed, the <code>Area()</code> method can&#8217;t even be implemented for the ABC because it doesn&#8217;t have the necessary data members. C++ has a way to provide an unimplemented function by using a <em>pure virtual function</em>. A pure virtual function has <code>= 0</code> at the end of its declaration, as shown for the <code>Area()</code> method:</p>
<p class="programlisting">class BaseEllipse&#160;&#160;// abstract base class<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double x;&#160;&#160;&#160;// x-coordinate of center<br/>&#160;&#160;&#160;&#160;double y;&#160;&#160;&#160;// y-coordinate of center<br/>&#160;&#160;&#160;&#160;...<br/>public:<br/>&#160;&#160;&#160;&#160;BaseEllipse(double x0 = 0, double y0 = 0) : x(x0),y(y0) {}<br/>&#160;&#160;&#160;&#160;virtual ~BaseEllipse() {}<br/>&#160;&#160;&#160;&#160;void Move(int nx, ny) { x = nx; y = ny; }<br/>&#160;&#160;&#160;&#160;virtual double Area() const = 0; // a pure virtual function<br/>&#160;&#160;&#160;...<br/>}</p>
<p><a id="page_749"/>When a class declaration contains a pure virtual function, you can&#8217;t create an object of that class. The idea is that classes with pure virtual functions exist solely to serve as base classes. For a class to be a genuine ABC, it has to have at least one pure virtual function. It is the <code>= 0</code> in the prototype that makes a virtual function a pure virtual function. In the case of the <code>Area()</code> method, the function has no definition, but C++ allows even a pure virtual function to have a definition. For example, perhaps all the base methods are like <code>Move()</code> in that they can be defined for the base class, but you still need to make the class abstract. You could then make the prototype virtual:</p>
<p class="programlisting">void Move(int nx, ny) = 0;</p>
<p>This makes the base class abstract. But then you could still provide a definition in the implementation file:</p>
<p class="programlisting">void BaseEllipse::Move(int nx, ny) { x = nx; y = ny; }</p>
<p>In short, the <code>= 0</code> in the prototype indicates that the class is an abstract base class and that the class doesn&#8217;t necessarily have to define the function.</p>
<p>Now you can derive the <code>Ellipse</code> class and <code>Circle</code> class from the <code>BaseEllipse</code> class, adding the members needed to complete each class. One point to note is that the <code>Circle</code> class always represents circles, whereas the <code>Ellipse</code> class represents ellipses that can also be circles. However, an <code>Ellipse</code> class circle can be rescaled to a non-circle, whereas a <code>Circle</code> class circle must remain a circle.</p>
<p>A program using these classes would be able to create <code>Ellipse</code> objects and <code>Circle</code> objects but no <code>BaseEllipse</code> objects. Because <code>Circle</code> and <code>Ellipse</code> objects have the same base class, a collection of such objects can be managed with an array of <code>BaseEllipse</code> pointers. Classes such as <code>Circle</code> and <code>Ellipse</code> are sometimes termed <em>concrete</em> classes to indicate that you can create objects of those types.</p>
<p>In short, an ABC describes an interface that uses a least one pure virtual function, and classes derived from an ABC use regular virtual functions to implement the interface in terms of the properties of the particular derived class.</p>
<h4 id="ch13lev2sec9">Applying the ABC Concept</h4>
<p>You&#8217;d probably like to see a complete example of an ABC, so let&#8217;s apply the concept to representing the <code>Brass</code> and <code>BrassPlus</code> accounts, starting with an ABC called <code>AcctABC</code>. This class should contain all methods and data members that are common to both the <code>Brass</code> and the <code>BrassPlus</code> classes. The methods that are to work differently for the <code>BrassPlus</code> class than they do for the <code>Brass</code> class should be declared as virtual functions. At least one virtual function should be a pure virtual function in order to make the <code>AcctABC</code> class abstract.</p>
<p><a href="#ch13ex11">Listing 13.11</a> is a header file that declares the <code>AcctABC</code> class (an ABC) and the <code>Brass</code> and <code>BrassPlus</code> classes (both concrete classes). To facilitate derived class access to base class data, <code>AcctABC</code> provides some protected methods. Recall that protected methods are methods that derived-class methods can call but that are not part of the public interface for derived-class objects. <code>AcctABC</code> also provides a protected member function to handle the <a id="page_750"/>formatting previously handled by nonmember functions. Also the <code>AcctABC</code> class has two pure virtual functions, so it is, indeed, an abstract class.</p>
<p class="caption1"><a id="ch13ex11"/><strong>Listing 13.11. <code>acctabc.h</code></strong></p><hr/>
<p class="programlisting1">// acctabc.h&#160;&#160;-- bank account classes<br/>#ifndef ACCTABC_H_<br/>#define ACCTABC_H_<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/><br/>// Abstract Base Class<br/>class AcctABC<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string fullName;<br/>&#160;&#160;&#160;&#160;long acctNum;<br/>&#160;&#160;&#160;&#160;double balance;<br/>protected:<br/>&#160;&#160;&#160;&#160;struct Formatting<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::ios_base::fmtflags flag;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::streamsize pr;<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;const std::string &#38; FullName() const {return fullName;}<br/>&#160;&#160;&#160;&#160;long AcctNum() const {return acctNum;}<br/>&#160;&#160;&#160;&#160;Formatting SetFormat() const;<br/>&#160;&#160;&#160;&#160;void Restore(Formatting &#38; f) const;<br/>public:<br/>&#160;&#160;&#160;&#160;AcctABC(const std::string &#38; s = "Nullbody", long an = -1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double bal = 0.0);<br/>&#160;&#160;&#160;&#160;void Deposit(double amt) ;<br/>&#160;&#160;&#160;&#160;virtual void Withdraw(double amt) = 0; // pure virtual function<br/>&#160;&#160;&#160;&#160;double Balance() const {return balance;};<br/>&#160;&#160;&#160;&#160;virtual void ViewAcct() const = 0;&#160;&#160;&#160;&#160;&#160;// pure virtual function<br/>&#160;&#160;&#160;&#160;virtual ~AcctABC() {}<br/>};<br/><br/>// Brass Account Class<br/>class Brass :public AcctABC<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;Brass(const std::string &#38; s = "Nullbody", long an = -1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double bal = 0.0) : AcctABC(s, an, bal) { }<br/>&#160;&#160;&#160;&#160;virtual void Withdraw(double amt);<br/>&#160;&#160;&#160;&#160;virtual void ViewAcct() const;<br/>&#160;&#160;&#160;&#160;virtual ~Brass() {}<br/>};<br/><br/>//Brass Plus Account Class<br/>class BrassPlus : public AcctABC<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double maxLoan;<br/>&#160;&#160;&#160;&#160;double rate;<br/>&#160;&#160;&#160;&#160;double owesBank;<br/>public:<br/>&#160;&#160;&#160;&#160;BrassPlus(const std::string &#38; s = "Nullbody", long an = -1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double bal = 0.0, double ml = 500,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double r = 0.10);<br/>&#160;&#160;&#160;&#160;BrassPlus(const Brass &#38; ba, double ml = 500, double r = 0.1);<br/>&#160;&#160;&#160;&#160;virtual void ViewAcct()const;<br/>&#160;&#160;&#160;&#160;virtual void Withdraw(double amt);<br/>&#160;&#160;&#160;&#160;void ResetMax(double m) { maxLoan = m; }<br/>&#160;&#160;&#160;&#160;void ResetRate(double r) { rate = r; };<br/>&#160;&#160;&#160;&#160;void ResetOwes() { owesBank = 0; }<br/>};<br/>#endif</p><hr/>
<p><a id="page_751"/>The next step is to implement the methods that don&#8217;t already have inline definitions. <a href="#ch13ex12">Listing 13.12</a> does that.</p>
<p class="caption1"><a id="ch13ex12"/><strong>Listing 13.12. <code>acctabc.cpp</code></strong></p><hr/>
<p class="programlisting1">// acctabc.cpp -- bank account class methods<br/>#include &lt;iostream&gt;<br/>#include "acctabc.h"<br/>using std::cout;<br/>using std::ios_base;<br/>using std::endl;<br/>using std::string;<br/><br/>// Abstract Base Class<br/>AcctABC::AcctABC(const string &#38; s, long an, double bal)<br/>{<br/>&#160;&#160;&#160;&#160;fullName = s;<br/>&#160;&#160;&#160;&#160;acctNum = an;<br/>&#160;&#160;&#160;&#160;balance = bal;<br/>}<br/><br/>void AcctABC::Deposit(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;if (amt &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Negative deposit not allowed; "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "deposit is cancelled.\n";<br/><a id="page_752"/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;balance += amt;<br/>}<br/><br/>void AcctABC::Withdraw(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;balance -= amt;<br/>}<br/><br/>// protected methods for formatting<br/>AcctABC::Formatting AcctABC::SetFormat() const<br/>{<br/>&#160;// set up ###.## format<br/>&#160;&#160;&#160;&#160;Formatting f;<br/>&#160;&#160;&#160;&#160;f.flag =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;f.pr = cout.precision(2);<br/>&#160;&#160;&#160;&#160;return f;<br/>}<br/><br/>void AcctABC::Restore(Formatting &#38; f) const<br/>{<br/>&#160;&#160;&#160;&#160;cout.setf(f.flag, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout.precision(f.pr);<br/>}<br/><br/>// Brass methods<br/>void Brass::Withdraw(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;if (amt &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Withdrawal amount must be positive; "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "withdrawal canceled.\n";<br/>&#160;&#160;&#160;&#160;else if (amt &lt;= Balance())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AcctABC::Withdraw(amt);<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Withdrawal amount of $" &lt;&lt; amt<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " exceeds your balance.\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Withdrawal canceled.\n";<br/>}<br/><br/>void Brass::ViewAcct() const<br/>{<br/><br/>&#160;&#160;&#160;&#160;Formatting f = SetFormat();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Brass Client: " &lt;&lt; FullName() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Account Number: " &lt;&lt; AcctNum() &lt;&lt; endl;<br/><a id="page_753"/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Balance: $" &lt;&lt; Balance() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;Restore(f);<br/>}<br/><br/>// BrassPlus Methods<br/>BrassPlus::BrassPlus(const string &#38; s, long an, double bal,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double ml, double r) : AcctABC(s, an, bal)<br/>{<br/>&#160;&#160;&#160;&#160;maxLoan = ml;<br/>&#160;&#160;&#160;&#160;owesBank = 0.0;<br/>&#160;&#160;&#160;&#160;rate = r;<br/>}<br/><br/>BrassPlus::BrassPlus(const Brass &#38; ba, double ml, double r)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: AcctABC(ba)&#160;&#160;&#160;// uses implicit copy constructor<br/>{<br/>&#160;&#160;&#160;&#160;maxLoan = ml;<br/>&#160;&#160;&#160;&#160;owesBank = 0.0;<br/>&#160;&#160;&#160;&#160;rate = r;<br/>}<br/><br/>void BrassPlus::ViewAcct() const<br/>{<br/>&#160;&#160;&#160;&#160;Formatting f = SetFormat();<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "BrassPlus Client: " &lt;&lt; FullName() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Account Number: " &lt;&lt; AcctNum() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Balance: $" &lt;&lt; Balance() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Maximum loan: $" &lt;&lt; maxLoan &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Owed to bank: $" &lt;&lt; owesBank &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout.precision(3);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Loan Rate: " &lt;&lt; 100 * rate &lt;&lt; "%\n";<br/>&#160;&#160;&#160;&#160;Restore(f);<br/>}<br/><br/>void BrassPlus::Withdraw(double amt)<br/>{<br/>&#160;&#160;&#160;&#160;Formatting f = SetFormat();<br/><br/>&#160;&#160;&#160;&#160;double bal = Balance();<br/>&#160;&#160;&#160;&#160;if (amt &lt;= bal)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AcctABC::Withdraw(amt);<br/>&#160;&#160;&#160;&#160;else if ( amt &lt;= bal + maxLoan - owesBank)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double advance = amt - bal;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;owesBank += advance * (1.0 + rate);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bank advance: $" &lt;&lt; advance &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Finance charge: $" &lt;&lt; advance * rate &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Deposit(advance);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AcctABC::Withdraw(amt);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Credit limit exceeded. Transaction cancelled.\n";<br/>&#160;&#160;&#160;&#160;Restore(f);<br/>}</p><hr/>
<p><a id="page_754"/>The <code>FullName()</code> and <code>AcctNum()</code> protected methods provide read-only access to the <code>fullName</code> and <code>acctNum</code> data members and make it possible to customize <code>ViewAcct()</code> a little more individually for each derived class.</p>
<p>This version makes a couple of improvements in the implementation of the formatting. The previous version used two function calls to set the formatting and one to restore it:</p>
<p class="programlisting">format initialState = setFormat();<br/>precis prec = cout.precision(2);<br/>...<br/>restore(initialState, prec); // restore original format</p>
<p>The new version defines a structure to hold the two formatting values and uses that structure to set and restore formats with just two calls:</p>
<p class="programlisting">struct Formatting<br/>{<br/>&#160;&#160;&#160;&#160;&#160;std::ios_base::fmtfglas flag;<br/>&#160;&#160;&#160;&#160;&#160;std::streamsize pr;<br/>};<br/>...<br/>Formatting f = SetFormat();<br/>...<br/>Restore(f);</p>
<p>It&#8217;s a neater look.</p>
<p>A problem with the older version was that the original <code>setFormat()</code> and <code>restore()</code> were standalone functions, so those function names would conflict with client-defined functions of the same name. There are several ways to solve that problem. One is to declare both functions <code>static</code>, making them private to the <code>brass.cpp</code> file or to its successor, <code>acctabc.cpp</code>. A second is to place both functions and the <code>struct Formatting</code> definition into a namespace. But one of the topics for this example is protected access, so this example places the structure definition and the functions in the protected part of the class definition. This makes them available to the base class and the derived class while hiding them from the outside world.</p>
<p><a id="page_755"/>This new implementation of the <code>Brass</code> and <code>BrassPlus</code> accounts can be used in the same manner as the old one because the class methods have the same names and interfaces as before. For example, to convert <a href="#ch13ex10">Listing 13.10</a> to use the new implementation, you just need to take these steps to convert <code>usebrass2.cpp</code> to a <code>usebrass3.cpp</code> file:</p>
<p class="indenthandingB">&#8226; Link <code>usebrass2.cpp</code> with <code>acctabc.cpp</code> instead of with <code>brass.cpp</code>.</p>
<p class="indenthandingB">&#8226; Include <code>acctabc.h</code> instead of <code>brass.h</code>.</p>
<p class="indenthandingB">&#8226; Replace</p>
<p class="programlistingB">Brass * p_clients[CLIENTS];</p>
<p>with</p>
<p class="programlisting">AcctABC * p_clients[CLIENTS];</p>
<p><a href="#ch13ex13">Listing 13.13</a> shows the resulting file, renamed <code>usebrass3.cpp</code>.</p>
<p class="caption1"><a id="ch13ex13"/><strong>Listing 13.13. <code>usebrass3.cpp</code></strong></p><hr/>
<p class="programlisting1">// usebrass3.cpp -- polymorphic example using an abstract base class<br/>// compile with acctacb.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include "acctabc.h"<br/>const int CLIENTS = 4;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;AcctABC * p_clients[CLIENTS];<br/>&#160;&#160;&#160;std::string temp;<br/>&#160;&#160;&#160;long tempnum;<br/>&#160;&#160;&#160;double tempbal;<br/>&#160;&#160;&#160;char kind;<br/><br/>&#160;&#160;&#160;for (int i = 0; i &lt; CLIENTS; i++)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter client's name: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;getline(cin,temp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter client's account number: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; tempnum;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter opening balance: $";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; tempbal;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter 1 for Brass Account or "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "2 for BrassPlus Account: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin &gt;&gt; kind &#38;&#38; (kind != '1' &#38;&#38; kind != '2'))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt;"Enter either 1 or 2: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (kind == '1')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p_clients[i] = new Brass(temp, tempnum, tempbal);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double tmax, trate;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the overdraft limit: $";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; tmax;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the interest rate "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "as a decimal fraction: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; trate;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p_clients[i] = new BrassPlus(temp, tempnum, tempbal,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tmax, trate);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;for (int i = 0; i &lt; CLIENTS; i++)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;p_clients[i]-&gt;ViewAcct();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;for (int i = 0; i &lt; CLIENTS; i++)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete p_clients[i];&#160;&#160;// free memory<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/><br/>&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_756"/>The program itself behaves the same as the non-abstract base class version, so given the same input as for <a href="#ch13ex10">Listing 13.10</a>, the output would be the same.</p>
<h4 id="ch13lev2sec10">ABC Philosophy</h4>
<p>The ABC methodology is a much more systematic, disciplined way to approach inheritance than the more ad hoc, spur-of-the-moment approach used by the <code>RatedPlayer</code> example. Before designing an ABC, you first have to develop a model of what classes are needed to represent a programming problem and how they relate to one another. One school of thought holds that if you design an inheritance hierarchy of classes, the only concrete classes should be those that never serve as a base class. This approach tends to produce cleaner designs with fewer complications.</p>
<p><a id="page_757"/>One way of thinking about ABCs is to consider them an enforcement of interface. An ABC demands that its pure virtual functions be overridden in any concrete derived classes&#8212;forcing the derived class to obey the rules of interface the ABC has set. This model is common in component-based programming paradigms, in which the use of ABCs allows the component designer to create an &#8220;interface contract&#8221; where all components derived from the ABC are guaranteed to uphold <em>at least</em> the common functionality specified by the ABC.</p>
<h3 id="ch13lev1sec7">Inheritance and Dynamic Memory Allocation</h3>
<p>How does inheritance interact with dynamic memory allocation (the use of <code>new</code> and <code>delete</code>)? For example, if a base class uses dynamic memory allocation and redefines assignment and a copy constructor, how does that affect the implementation of the derived class? The answer depends on the nature of the derived class. If the derived class does not itself use dynamic memory allocation, you needn&#8217;t take any special steps. If the derived class does also use dynamic memory allocation, then there are a couple new tricks to learn. Let&#8217;s look at these two cases.</p>
<h4 id="ch13lev2sec11">Case 1: Derived Class Doesn&#8217;t Use <code>new</code></h4>
<p>Suppose you begin with the following base class that uses dynamic memory allocation:</p>
<p class="programlisting">//&#160;&#160;Base Class Using DMA<br/>class baseDMA<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * label;<br/>&#160;&#160;&#160;&#160;int rating;<br/><br/>public:<br/>&#160;&#160;&#160;&#160;baseDMA(const char * l = "null", int r = 0);<br/>&#160;&#160;&#160;&#160;baseDMA(const baseDMA &#38; rs);<br/>&#160;&#160;&#160;&#160;virtual ~baseDMA();<br/>&#160;&#160;&#160;&#160;baseDMA &#38; operator=(const baseDMA &#38; rs);<br/>...<br/>};</p>
<p>The declaration contains the special methods that are required when constructors use <code>new</code>: a destructor, a copy constructor, and an overloaded assignment operator.</p>
<p>Now suppose you derive a <code>lackDMA</code> class from <code>baseDMA</code> and that <code>lackDMA</code> does not use <code>new</code> or have other unusual design features that require special treatment:</p>
<p class="programlisting">// derived class without DMA<br/>class lacksDMA :public baseDMA<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char color[40];<br/><a id="page_758"/>public:<br/>...<br/>};</p>
<p>Do you now have to define an explicit destructor, copy constructor, and assignment operator for the <code>lackDMA</code> class? The answer is no.</p>
<p>First, consider the need for a destructor. If you don&#8217;t define one, the compiler defines a default destructor that does nothing. Actually, the default destructor for a derived class always does something; it calls the base-class destructor after executing its own code. Because the <code>lackDMA</code> members, we assume, don&#8217;t require any special action, the default destructor is fine.</p>
<p>Next, consider the copy constructor. As you saw in <a href="ch12.html#ch12">Chapter 12</a>, the default copy constructor does memberwise copying, which is inappropriate for dynamic memory allocation. However, memberwise copying is fine for the new <code>lacksDMA</code> member. That leaves the matter of the inherited <code>baseDMA</code> object. What you need to know is that memberwise copying uses the form of copying that is defined for the data type in question. So copying a <code>long</code> to a <code>long</code> is done using ordinary assignment. But copying a class member or an inherited class component is done using the copy constructor for that class. Thus, the default copy constructor for the <code>lacksDMA</code> class uses the explicit <code>baseDMA</code> copy constructor to copy the <code>baseDMA</code> portion of a <code>lacksDMA</code> object. So the default copy constructor is fine for the new <code>lacksDMA</code> member, and it&#8217;s also fine for the inherited <code>baseDMA</code> object.</p>
<p>Essentially the same situation holds for assignment. The default assignment operator for a class automatically uses the base-class assignment operator for the base-class component. So it, too, is fine.</p>
<p>These properties of inherited objects also hold true for class members that are themselves objects. For example, <a href="ch10.html#ch10">Chapter 10</a>, &#8220;<a href="ch10.html#ch10">Objects and Classes</a>,&#8221; implements the <code>Stock</code> class by using a <code>string</code> object to represent the company name. The standard <code>string</code> class, like our <code>String</code> example, uses dynamic memory allocation. Now you see why this wouldn&#8217;t create problems. The default <code>Stock</code> copy constructor would use the <code>string</code> copy constructor to copy the <code>company</code> member of an object, the default <code>Stock</code> assignment operator would use the <code>string</code> assignment operator to assign the <code>company</code> member of an object, and the <code>Stock</code> destructor (default or otherwise) would automatically call the <code>string</code> destructor.</p>
<h4 id="ch13lev2sec12">Case 2: Derived Class Does Use <code>new</code></h4>
<p>Suppose that the derived class uses <code>new</code>:</p>
<p class="programlisting">// derived class with DMA<br/>class hasDMA :public baseDMA<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * style;&#160;&#160;// use new in constructors<br/>public:<br/>...<br/>};</p>
<p><a id="page_759"/>In this case, of course, you do have to define an explicit destructor, copy constructor, and assignment operator for the derived class. Let&#8217;s consider these methods in turn.</p>
<p>A derived class destructor automatically calls the base-class destructor, so its own responsibility is to clean up after what the derived-class constructors do. Thus, the <code>hasDMA</code> destructor has to free the memory managed by the <code>style</code> pointer and can rely on the <code>baseDMA</code> destructor to free the memory managed by the <code>label</code> pointer:</p>
<p class="programlisting">baseDMA::~baseDMA()&#160;&#160;// takes care of baseDMA stuff<br/>{<br/>&#160;&#160;&#160;delete [] label;<br/>}<br/><br/>hasDMA::~hasDMA()&#160;&#160;&#160;&#160;&#160;&#160;// takes care of hasDMA stuff<br/>{<br/>&#160;&#160;&#160;&#160;delete [] style;<br/>}</p>
<p>Next, consider copy constructors. The <code>baseDMA</code> copy constructor follows the usual pattern for arrays of <code>char</code>. That is, they use <code>strlen()</code> to find the length needed to hold the C-style string, allocate sufficient memory (the number of characters plus one byte for the null character), and use the <code>strcpy()</code> function to copy the original string to the target:</p>
<p class="programlisting">baseDMA::baseDMA(const baseDMA &#38; rs)<br/>{<br/>&#160;&#160;&#160;&#160;label = new char[std::strlen(rs.label) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(label, rs.label);<br/>&#160;&#160;&#160;&#160;rating = rs.rating;<br/>}</p>
<p>The <code>hasDMA</code> copy constructor only has access to <code>hasDMA</code> data, so it must invoke the <code>baseDMA</code> copy constructor to handle the <code>baseDMA</code> share of the data:</p>
<p class="programlisting">hasDMA::hasDMA(const hasDMA &#38; hs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: baseDMA(hs)<br/>{<br/>&#160;&#160;&#160;&#160;style = new char[std::strlen(hs.style) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(style, hs.style);<br/>}</p>
<p>The point to note is that the member initializer list passes a <code>hasDMA</code> reference to a <code>baseDMA</code> constructor. There is no <code>baseDMA</code> constructor with a type <code>hasDMA</code> reference parameter, but none is needed. That&#8217;s because the <code>baseDMA</code> copy constructor has a <code>baseDMA</code> reference parameter, and a base class reference can refer to a derived type. Thus, the <code>baseDMA</code> copy constructor uses the <code>baseDMA</code> portion of the <code>hasDMA</code> argument to construct the <code>baseDMA</code> portion of the new object.</p>
<p>Next, consider assignment operators. The <code>baseDMA</code> assignment operator follows the usual pattern:</p>
<p class="programlisting"><a id="page_760"/>baseDMA &#38; baseDMA::operator=(const baseDMA &#38; rs)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;rs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;delete [] label;<br/>&#160;&#160;&#160;&#160;label = new char[std::strlen(rs.label) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(label, rs.label);<br/>&#160;&#160;&#160;&#160;rating = rs.rating;<br/>&#160;&#160;&#160;&#160;return *this;<br/>}</p>
<p>Because <code>hasDMA</code> also uses dynamic memory allocation, it, too, needs an explicit assignment operator. Being a <code>hasDMA</code> method, it only has direct access to <code>hasDMA</code> data. Nonetheless, an explicit assignment operator for a derived class also has to take care of assignment for the inherited base class <code>baseDMA</code> object. You can accomplish this by explicitly calling the base class assignment operator, as shown here:</p>
<p class="programlisting">hasDMA &#38; hasDMA::operator=(const hasDMA &#38; hs)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;hs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;baseDMA::operator=(hs);&#160;&#160;// copy base portion<br/>&#160;&#160;&#160;&#160;delete [] style;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prepare for new style<br/>&#160;&#160;&#160;&#160;style = new char[std::strlen(hs.style) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(style, hs.style);<br/>&#160;&#160;&#160;&#160;return *this;<br/>}</p>
<p>The following statement might look a little odd:</p>
<p class="programlisting">baseDMA::operator=(hs);&#160;&#160;// copy base portion</p>
<p>But using function notation instead of operator notation lets you use the scope-resolution operator. In effect, the statement means the following:</p>
<p class="programlisting">*this = hs;&#160;&#160;// use baseDMA::operator=()</p>
<p>But, of course, the compiler ignores comments, so if you used the latter code, the compiler would use <code>hasDMA::operator=()</code> instead and create a recursive call. Using function notation gets the correct assignment operator called.</p>
<p>In summary, when both the base class and the derived class use dynamic memory allocation, the derived-class destructor, copy constructor, and assignment operator all must use their base-class counterparts to handle the base-class component. This common requirement is accomplished three different ways. For a destructor, it is done automatically. For a constructor, it is accomplished by invoking the base-class copy constructor in the member initialization list, or else the default constructor is invoked automatically. For the assignment operator, it is accomplished by using the scope-resolution operator in an explicit call of the base-class assignment operator.</p>
<h4 id="ch13lev2sec13">An Inheritance Example with Dynamic Memory Allocation and Friends</h4>
<p><a id="page_761"/>To illustrate these ideas of inheritance and dynamic memory allocation, let&#8217;s integrate the <code>baseDMA</code>, <code>lacksDMA</code>, and <code>hasDMA</code> classes just discussed into a single example. <a href="#ch13ex14">Listing 13.14</a> is a header file for these classes. To what we&#8217;ve already discussed, it adds a friend function that illustrates how derived classes can access friends to a base class.</p>
<p class="caption1"><a id="ch13ex14"/><strong>Listing 13.14. <code>dma.h</code></strong></p><hr/>
<p class="programlisting1">// dma.h&#160;&#160;-- inheritance and dynamic memory allocation<br/>#ifndef DMA_H_<br/>#define DMA_H_<br/>#include &lt;iostream&gt;<br/><br/>//&#160;&#160;Base Class Using DMA<br/>class baseDMA<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * label;<br/>&#160;&#160;&#160;&#160;int rating;<br/><br/>public:<br/>&#160;&#160;&#160;&#160;baseDMA(const char * l = "null", int r = 0);<br/>&#160;&#160;&#160;&#160;baseDMA(const baseDMA &#38; rs);<br/>&#160;&#160;&#160;&#160;virtual ~baseDMA();<br/>&#160;&#160;&#160;&#160;baseDMA &#38; operator=(const baseDMA &#38; rs);<br/>&#160;&#160;&#160;&#160;friend std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const baseDMA &#38; rs);<br/>};<br/><br/>// derived class without DMA<br/>// no destructor needed<br/>// uses implicit copy constructor<br/>// uses implicit assignment operator<br/>class lacksDMA :public baseDMA<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum { COL_LEN = 40};<br/>&#160;&#160;&#160;&#160;char color[COL_LEN];<br/>public:<br/>&#160;&#160;&#160;&#160;lacksDMA(const char * c = "blank", const char * l = "null",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int r = 0);<br/>&#160;&#160;&#160;&#160;lacksDMA(const char * c, const baseDMA &#38; rs);<br/>&#160;&#160;&#160;&#160;friend std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const lacksDMA &#38; rs);<br/>};<br/><br/>// derived class with DMA<br/>class hasDMA :public baseDMA<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * style;<br/>public:<br/>&#160;&#160;&#160;&#160;hasDMA(const char * s = "none", const char * l = "null",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int r = 0);<br/>&#160;&#160;&#160;&#160;hasDMA(const char * s, const baseDMA &#38; rs);<br/>&#160;&#160;&#160;&#160;hasDMA(const hasDMA &#38; hs);<br/>&#160;&#160;&#160;&#160;~hasDMA();<br/>&#160;&#160;&#160;&#160;hasDMA &#38; operator=(const hasDMA &#38; rs);<br/>&#160;&#160;&#160;&#160;friend std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const hasDMA &#38; rs);<br/>};<br/><br/>#endif</p><hr/>
<p><a id="page_762"/><a href="#ch13ex15">Listing 13.15</a> provides the method definitions for the <code>baseDMA</code>, <code>lacksDMA</code>, and <code>hasDMA</code> classes.</p>
<p class="caption1"><a id="ch13ex15"/><strong>Listing 13.15. <code>dma.cpp</code></strong></p><hr/>
<p class="programlisting1">// dma.cpp --dma class methods<br/><br/>#include "dma.h"<br/>#include &lt;cstring&gt;<br/><br/>// baseDMA methods<br/>baseDMA::baseDMA(const char * l, int r)<br/>{<br/>&#160;&#160;&#160;&#160;label = new char[std::strlen(l) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(label, l);<br/>&#160;&#160;&#160;&#160;rating = r;<br/>}<br/><br/>baseDMA::baseDMA(const baseDMA &#38; rs)<br/>{<br/>&#160;&#160;&#160;&#160;label = new char[std::strlen(rs.label) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(label, rs.label);<br/>&#160;&#160;&#160;&#160;rating = rs.rating;<br/>}<br/><br/>baseDMA::~baseDMA()<br/>{<br/>&#160;&#160;&#160;&#160;delete [] label;<br/>}<br/><br/><a id="page_763"/>baseDMA &#38; baseDMA::operator=(const baseDMA &#38; rs)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;rs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;delete [] label;<br/>&#160;&#160;&#160;&#160;label = new char[std::strlen(rs.label) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(label, rs.label);<br/>&#160;&#160;&#160;&#160;rating = rs.rating;<br/>&#160;&#160;&#160;&#160;return *this;<br/>}<br/><br/>std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const baseDMA &#38; rs)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Label: " &lt;&lt; rs.label &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Rating: " &lt;&lt; rs.rating &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;return os;<br/>}<br/><br/>// lacksDMA methods<br/>lacksDMA::lacksDMA(const char * c, const char * l, int r)<br/>&#160;&#160;&#160;&#160;: baseDMA(l, r)<br/>{<br/>&#160;&#160;&#160;&#160;std::strncpy(color, c, 39);<br/>&#160;&#160;&#160;&#160;color[39] = '\0';<br/>}<br/><br/>lacksDMA::lacksDMA(const char * c, const baseDMA &#38; rs)<br/>&#160;&#160;&#160;&#160;: baseDMA(rs)<br/>{<br/>&#160;&#160;&#160;&#160;std::strncpy(color, c, COL_LEN - 1);<br/>&#160;&#160;&#160;&#160;color[COL_LEN - 1] = '\0';<br/>}<br/><br/>std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const lacksDMA &#38; ls)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; (const baseDMA &#38;) ls;<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Color: " &lt;&lt; ls.color &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;return os;<br/>}<br/><br/>// hasDMA methods<br/>hasDMA::hasDMA(const char * s, const char * l, int r)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: baseDMA(l, r)<br/>{<br/>&#160;&#160;&#160;&#160;style = new char[std::strlen(s) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(style, s);<br/>}<br/><br/>hasDMA::hasDMA(const char * s, const baseDMA &#38; rs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: baseDMA(rs)<br/>{<br/>&#160;&#160;&#160;&#160;style = new char[std::strlen(s) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(style, s);<br/>}<br/><br/>hasDMA::hasDMA(const hasDMA &#38; hs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: baseDMA(hs)&#160;&#160;// invoke base class copy constructor<br/>{<br/>&#160;&#160;&#160;&#160;style = new char[std::strlen(hs.style) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(style, hs.style);<br/>}<br/><br/>hasDMA::~hasDMA()<br/>{<br/>&#160;&#160;&#160;&#160;delete [] style;<br/>}<br/><br/>hasDMA &#38; hasDMA::operator=(const hasDMA &#38; hs)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;hs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;baseDMA::operator=(hs);&#160;&#160;// copy base portion<br/>&#160;&#160;&#160;&#160;delete [] style;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prepare for new style<br/>&#160;&#160;&#160;&#160;style = new char[std::strlen(hs.style) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(style, hs.style);<br/>&#160;&#160;&#160;&#160;return *this;<br/>}<br/><br/>std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const hasDMA &#38; hs)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; (const baseDMA &#38;) hs;<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Style: " &lt;&lt; hs.style &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p><hr/>
<p><a id="page_764"/>The new feature to note in <a href="#ch13ex14">Listings 13.14</a> and <a href="#ch13ex15">13.15</a> is how derived classes can make use of a friend to a base class. Consider, for example, the following friend to the <code>hasDMA</code> class:</p>
<p class="programlisting">friend std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const hasDMA &#38; rs);</p>
<p>Being a friend to the <code>hasDMA</code> class gives this function access to the <code>style</code> member. But there&#8217;s a problem: This function is not a friend to the <code>baseDMA</code> class, so how can it access the <code>label</code> and <code>rating</code> members? The solution is to use the <code>operator&lt;&lt;()</code> function that <a id="page_765"/>is a friend to the <code>baseDMA</code> class. The next problem is that because friends are not member functions, you can&#8217;t use the scope-resolution operator to indicate which function to use. The solution to this problem is to use a type cast so that prototype matching will select the correct function. Thus, the code type casts the type <code>const hasDMA &#38;</code> parameter to a type <code>const baseDMA &#38;</code> argument:</p>
<p class="programlisting">std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const hasDMA &#38; hs)<br/>{<br/>//&#160;&#160;type cast to match operator&lt;&lt;(ostream &#38; , const baseDMA &#38;)<br/>&#160;&#160;&#160;&#160;os &lt;&lt; (const baseDMA &#38;) hs;<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Style: " &lt;&lt; hs.style &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p><a href="#ch13ex16">Listing 13.16</a> tests the <code>baseDMA</code>, <code>lacksDMA</code>, and <code>hasDMA</code> classes in a short program.</p>
<p class="caption1"><a id="ch13ex16"/><strong>Listing 13.16. <code>usedma.cpp</code></strong></p><hr/>
<p class="programlisting1">// usedma.cpp -- inheritance, friends, and DMA<br/>// compile with dma.cpp<br/>#include &lt;iostream&gt;<br/>#include "dma.h"<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;baseDMA shirt("Portabelly", 8);<br/>&#160;&#160;&#160;&#160;lacksDMA balloon("red", "Blimpo", 4);<br/>&#160;&#160;&#160;&#160;hasDMA map("Mercator", "Buffalo Keys", 5);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Displaying baseDMA object:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; shirt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Displaying lacksDMA object:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; balloon &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Displaying hasDMA object:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; map &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;lacksDMA balloon2(balloon);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Result of lacksDMA copy:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; balloon2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;hasDMA map2;<br/>&#160;&#160;&#160;&#160;map2 = map;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Result of hasDMA assignment:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; map2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_766"/>Here&#8217;s the output of the program in <a href="#ch13ex14">Listings 13.14</a>, <a href="#ch13ex15">13.15</a>, and <a href="#ch13ex16">13.16</a>:</p>
<p class="programlisting">Displaying baseDMA object:<br/>Label: Portabelly<br/>Rating: 8<br/><br/>Displaying lacksDMA object:<br/>Label: Blimpo<br/>Rating: 4<br/>Color: red<br/><br/>Displaying hasDMA object:<br/>Label: Buffalo Keys<br/>Rating: 5<br/>Style: Mercator<br/><br/>Result of lacksDMA copy:<br/>Label: Blimpo<br/>Rating: 4<br/>Color: red<br/><br/>Result of hasDMA assignment:<br/>Label: Buffalo Keys<br/>Rating: 5<br/>Style: Mercator</p>
<h3 id="ch13lev1sec8">Class Design Review</h3>
<p>C++ can be applied to a wide variety of programming problems, and you can&#8217;t reduce class design to some paint-by-numbers routine. However, there are some guidelines that often apply, and this is as good a time as any to go over them by reviewing and amplifying earlier discussions.</p>
<h4 id="ch13lev2sec14">Member Functions That the Compiler Generates for You</h4>
<p>As first discussed in <a href="ch12.html#ch12">Chapter 12</a>, the compiler automatically generates certain public member functions, termed <em>special member functions</em>. The fact that it does so suggests that these special member functions are particularly important. Let&#8217;s look again at some of them now.</p>
<h5 id="ch13lev3sec12">Default Constructors</h5>
<p>A default constructor is one that has no arguments, or else one for which all the arguments have default arguments. If you don&#8217;t define any constructors, the compiler defines a default constructor for you. Its existence allows you to create objects. For example, suppose <code>Star</code> is a class. You need a default constructor to use the following:</p>
<p class="programlisting"><a id="page_767"/>Star rigel;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create an object without explicit initialization<br/>Star pleiades[6];&#160;&#160;// create an array of objects</p>
<p>One more thing an automatic default constructor does is call the default constructors for any base classes and for any members that are objects of another class.</p>
<p>Also if you write a derived-class constructor without explicitly invoking a base-class constructor in the member initializer list, the compiler uses the base class default constructor to construct the base class portion of the new object. If there is no base-class default constructor, you get a compile-time error in this situation.</p>
<p>If you define a constructor of any kind, the compiler does not define a default constructor for you. In that case, it&#8217;s up to you to provide a default constructor if one is needed.</p>
<p>Note that one of the motivations for having constructors is to ensure that objects are always properly initialized. Also if a class has any pointer members, they certainly should be initialized. Thus, it&#8217;s a good idea to supply an explicit default constructor that initializes all class data members to reasonable values.</p>
<h5 id="ch13lev3sec13">Copy Constructors</h5>
<p>A copy constructor for a class is a constructor that takes an object of the class type as its argument. Typically, the declared parameter is a constant reference to the class type. For example, the copy constructor for a <code>Star</code> class would have this prototype:</p>
<p class="programlisting">Star(const Star &#38;);</p>
<p>A class copy constructor is used in the following situations:</p>
<p class="indenthandingB">&#8226; When a new object is initialized to an object of the same class</p>
<p class="indenthandingB">&#8226; When an object is passed to a function by value</p>
<p class="indenthandingB">&#8226; When a function returns an object by value</p>
<p class="indenthandingB">&#8226; When the compiler generates a temporary object</p>
<p>If a program doesn&#8217;t use a copy constructor (explicitly or implicitly), the compiler provides a prototype but not a function definition. Otherwise, the program defines a copy constructor that performs memberwise initialization. That is, each member of the new object is initialized to the value of the corresponding member of the original object. If a member is itself a class object, then memberwise initialization uses the copy constructor defined for that particular class.</p>
<p>In some cases, memberwise initialization is undesirable. For example, member pointers initialized with <code>new</code> generally require that you institute deep copying, as with the <code>baseDMA</code> class example. Or a class may have a static variable that needs to be modified. In such cases, you need to define your own copy constructor.</p>
<h5 id="ch13lev3sec14">Assignment Operators</h5>
<p>A default assignment operator handles assigning one object to another object of the same class. Don&#8217;t confuse assignment with initialization. If a statement creates a new object, it&#8217;s using initialization, and if a statement alters the value of an existing object, it&#8217;s assignment:</p>
<p class="programlisting"><a id="page_768"/>Star sirius;<br/>Star alpha = sirius;&#160;&#160;&#160;&#160;&#160;// initialization (one notation)<br/>Star dogstar;<br/>dogstar = sirius;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assignment</p>
<p>Default assignment uses memberwise assignment. If a member is itself a class object, then default memberwise assignment uses the assignment operator defined for that particular class. If you need to define a copy constructor explicitly, you also need, for the same reasons, to define the assignment operator explicitly. The prototype for a <code>Star</code> class assignment operator is this:</p>
<p class="programlisting">Star &#38; Star::operator=(const Star &#38;);</p>
<p>Note that the assignment operator function returns a reference to a <code>Star</code> object. The <code>baseDMA</code> class shows a typical example of an explicit assignment operator function.</p>
<p>The compiler doesn&#8217;t generate assignment operators for assigning one type to another. Suppose you want to be able to assign a string to a <code>Star</code> object. One approach is to define such an operator explicitly:</p>
<p class="programlisting">Star &#38; Star::operator=(const char *) {...}</p>
<p>A second approach is to rely on a conversion function (see &#8220;<a href="#ch13lev3sec17">Conversion Considerations</a>&#8221; in the next section) to convert a string to a <code>Star</code> object and use the <code>Star</code>-to-<code>Star</code> assignment function. The first approach runs more quickly but requires more code. The conversion function approach can lead to compiler-befuddling situations.</p>
<p><a href="ch18.html#ch18">Chapter 18</a>, &#8220;<a href="ch18.html#ch18">Visiting with the New C++ Standard</a>,&#8221; discusses two more special methods added by C++11: the move constructor and the move assignment operator.</p>
<h4 id="ch13lev2sec15">Other Class Method Considerations</h4>
<p>There are several other points to keep in mind as you define a class. The following sections list some of them.</p>
<h5 id="ch13lev3sec15">Constructor Considerations</h5>
<p>Constructors are different from other class methods in that they create new objects, whereas other methods are invoked by existing objects. This is one reason constructors aren&#8217;t inherited. Inheritance means a derived object can use a base-class method, but, in the case of constructors, the object doesn&#8217;t exist until after the constructor has done its work.</p>
<h5 id="ch13lev3sec16">Destructor Considerations</h5>
<p>You need to remember to define an explicit destructor that deletes any memory allocated by <code>new</code> in the class constructors and takes care of any other special bookkeeping that destroying a class object requires. If the class is to be used as a base class, you should provide a virtual destructor even if the class doesn&#8217;t require a destructor.</p>
<h5 id="ch13lev3sec17">Conversion Considerations</h5>
<p><a id="page_769"/>Any constructor that can be invoked with exactly one argument defines conversion from the argument type to the class type. For example, consider the following constructor prototypes for a <code>Star</code> class:</p>
<p class="programlisting">Star(const char *);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// converts char * to Star<br/>Star(const Spectral &#38;, int members = 1); // converts Spectral to Star</p>
<p>Conversion constructors are used, for example, when a convertible type is passed to a function that is defined as taking a class argument. For instance, suppose you have the following:</p>
<p class="programlisting">Star north;<br/>north = "polaris";</p>
<p>The second statement would invoke the <code>Star::operator=(const Star &#38;)</code> function, using <code>Star::Star(const char *)</code> to generate a <code>Star</code> object to be used as an argument for the assignment operator function. This assumes that you haven&#8217;t defined a <code>(char *)</code>-to-<code>Star</code> assignment operator.</p>
<p>Using <code>explicit</code> in the prototype for a one-argument constructor disables implicit conversions but still allows explicit conversions:</p>
<p class="programlisting">class Star<br/>{<br/>...<br/>public:<br/>&#160;&#160;&#160;&#160;explicit Star(const char *);<br/>...<br/>};<br/>...<br/>Star north;<br/>north = "polaris";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed<br/>north = Star("polaris");&#160;&#160;// allowed</p>
<p>To convert from a class object to some other type, you define a conversion function (see <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>&#8221;). A conversion function is a class member function with no arguments or declared return type that has the name of the type to be converted to. Despite having no declared return type, the function should return the desired conversion value. Here are some examples:</p>
<p class="programlisting">Star::Star double() {...}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// converts star to double<br/>Star::Star const char * () {...}&#160;&#160;&#160;// converts to const char</p>
<p>You should be judicious with such functions, only using them if they make good sense. Also with some class designs, having conversion functions increases the likelihood of writing ambiguous code. For example, suppose you define a <code>double</code> conversion for the <code>Vector</code> type of <a href="ch11.html#ch11">Chapter 11</a>, and suppose you have the following code:</p>
<p class="programlisting">Vector ius(6.0, 0.0);<br/>Vector lux = ius + 20.2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ambiguous</p>
<p><a id="page_770"/>The compiler could convert <code>ius</code> to <code>double</code> and use <code>double</code> addition, or else it could convert <code>20.2</code> to <code>vector</code> (using one of the constructors) and use <code>vector</code> addition. Instead, it would do neither and inform you of an ambiguous construction.</p>
<p>C++11 provides the option of using the keyword <code>explicit</code> with conversion functions. As with constructors, <code>explicit</code> allows explicit conversions using type casts, but disallows implicit conversions.</p>
<h5 id="ch13lev3sec18">Passing an Object by Value Versus Passing a Reference</h5>
<p>In general, if you write a function using an object argument, you should pass the object by reference rather than by value. One reason for this is efficiency. Passing an object by value involves generating a temporary copy, which means calling the copy constructor and then later calling the destructor. Calling these functions takes time, and copying a large object can be quite a bit slower than passing a reference. If the function doesn&#8217;t modify the object, you should declare the argument as a <code>const</code> reference.</p>
<p>Another reason for passing objects by reference is that, in the case of inheritance using virtual functions, a function defined as accepting a base-class reference argument can also be used successfully with derived classes, as you saw earlier in this chapter. (Also see the section &#8220;<a href="#ch13lev3sec25">Virtual Methods</a>,&#8221; later in this chapter.)</p>
<h5 id="ch13lev3sec19">Returning an Object Versus Returning a Reference</h5>
<p>Some class methods return objects. You&#8217;ve probably noticed that some members return objects directly whereas others return references. Sometimes a method must return an object, but if it isn&#8217;t necessary, you should use a reference instead. Let&#8217;s look at this more closely.</p>
<p>First, the only coding difference between returning an object directly and returning a reference is in the function prototype and header:</p>
<p class="programlisting">Star nova1(const Star &#38;);&#160;&#160;&#160;&#160;&#160;// returns a Star object<br/>Star &#38; nova2(const Star &#38;);&#160;&#160;&#160;// returns a reference to a Star</p>
<p>Next, the reason you should return a reference rather than an object is that returning an object involves generating a temporary copy of the returned object. It&#8217;s the copy that is made available to the calling program. Thus, returning an object involves the time cost of calling a copy constructor to generate the copy and the time cost of calling the destructor to get rid of the copy. Returning a reference saves time and memory use. Returning an object directly is analogous to passing an object by value: Both processes generate temporary copies. Similarly, returning a reference is analogous to passing an object by reference: Both the calling and the called function operate on the same object.</p>
<p>However, it&#8217;s not always possible to return a reference. A function shouldn&#8217;t return a reference to a temporary object created in the function because the reference becomes invalid when the function terminates and the object disappears. In this case, the code should return an object in order to generate a copy that will be available to the calling program.</p>
<p><a id="page_771"/>As a rule of thumb, if a function returns a temporary object created in the function, you shouldn&#8217;t use a reference. For example, the following method uses a constructor to create a new object, and it then returns a copy of that object:</p>
<p class="programlisting">Vector Vector::operator+(const Vector &#38; b) const<br/>{<br/>&#160;&#160;&#160;&#160;return Vector(x + b.x, y + b.y);<br/>}</p>
<p>If a function returns an object that was passed to it via a reference or pointer, you should return the object by reference. For example, the following code returns, by reference, either the object that invokes the function or else the object passed as an argument:</p>
<p class="programlisting">const Stock &#38; Stock::topval(const Stock &#38; s) const<br/>{<br/>&#160;&#160;&#160;&#160;if (s.total_val &gt; total_val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return s;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// argument object<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invoking object<br/>}</p>
<h5 id="ch13lev3sec20">Using <code>const</code></h5>
<p>You need to be alert to opportunities to use <code>const</code>. You can use it to guarantee that a method doesn&#8217;t modify an argument:</p>
<p class="programlisting">Star::Star(const char * s) {...} // won't change the string to which s points</p>
<p>You can use <code>const</code> to guarantee that a method won&#8217;t modify the object that invokes it:</p>
<p class="programlisting">void Star::show() const {...} // won't change invoking object</p>
<p>Here <code>const</code> means <code>const Star * this</code>, where <code>this</code> points to the invoking object.</p>
<p>Normally, a function that returns a reference can be on the left side of an assignment statement, which really means you can assign a value to the object referred to. But you can use <code>const</code> to ensure that a reference or pointer return value can&#8217;t be used to modify data in an object:</p>
<p class="programlisting">const Stock &#38; Stock::topval(const Stock &#38; s) const<br/>{<br/>&#160;&#160;&#160;&#160;if (s.total_val &gt; total_val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return s;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// argument object<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invoking object<br/>}</p>
<p>Here the method returns a reference either to <code>this</code> or to <code>s</code>. Because <code>this</code> and <code>s</code> are both declared <code>const</code>, the function is not allowed to change them, which means the returned reference also must be declared <code>const</code>.</p>
<p><a id="page_772"/>Note that if a function declares an argument as a reference or pointer to a <code>const</code>, it cannot pass along that argument to another function unless that function also guarantees not to change the argument.</p>
<h4 id="ch13lev2sec16">Public Inheritance Considerations</h4>
<p>Naturally, adding inheritance to a program brings up a number of considerations. Let&#8217;s look at a few.</p>
<h5 id="ch13lev3sec21"><em>Is-a</em> Relationship Considerations</h5>
<p>You should be guided by the <em>is-a</em> relationship. If your proposed derived class is not a particular kind of the base class, you shouldn&#8217;t use public derivation. For example, you shouldn&#8217;t derive a <code>Programmer</code> class from a <code>Brain</code> class. If you want to represent the belief that a programmer has a brain, you should use a <code>Brain</code> class object as a member of the <code>Programmer</code> class.</p>
<p>In some cases the best approach may be to create an abstract data class with pure virtual functions and to derive other classes from it.</p>
<p>Remember that one expression of the <em>is-a</em> relationship is that a base class pointer can point to a derived-class object and that a base-class reference can refer to a derived-class object without an explicit type cast. Also remember that the reverse is not true; thus, you cannot have a derived-class pointer or reference refer to a base-class object without an explicit type cast. Depending on the class declarations, such an explicit type cast (a downcast) may or may not make sense. (You might want to review <a href="#ch13fig04">Figure 13.4</a>.)</p>
<p class="caption"><a id="ch13fig04"/><strong>Figure 13.4. Upcasting and downcasting.</strong></p>
<p class="image"><img src="graphics/13fig04.jpg" alt="Image"/></p>
<h5 id="ch13lev3sec22">What&#8217;s Not Inherited</h5>
<p>Constructors are not inherited. That is, creating a derived object requires calling a derived-class constructor. However, derived-class constructors typically use the member-initializer list syntax to call on base-class constructors to construct the base class portion of a derived object. If the derived-class constructor doesn&#8217;t explicitly call a base-class constructor by using the member-initializer list syntax, it uses the base class&#8217;s default constructor. In an inheritance chain, each class can use a member initializer list to pass back information to its immediate base class. C++11 adds a mechanism that enables the inheriting of constructors. However, the default behavior is still that constructors are not inherited.</p>
<p>Destructors are not inherited either. However, when an object is destroyed, the program first calls the derived destructor and then the base destructor. If there is a default base class destructor, the compiler generates a default derived class destructor. Generally speaking, if a class serves as a base class, its destructor should be virtual.</p>
<p>Assignment operators are not inherited. The reason is simple. An inherited method has the same function signature in a derived class as it does in the base class. However, an assignment operator has a function signature that changes from class to class because it has a formal parameter that is the class type. Assignment operators do have some interesting properties, which we&#8217;ll look at next.</p>
<h5 id="ch13lev3sec23">Assignment Operator Considerations</h5>
<p><a id="page_773"/>If the compiler detects that a program assigns one object to another of the same class, it automatically supplies that class with an assignment operator. The default, or implicit, version of this operator uses memberwise assignment, with each member of the target object being assigned the value of the corresponding member of the source object. However, if the object belongs to a derived class, the compiler uses the base-class assignment operator to handle assignment for the base-class portion of the derived-class object. If you&#8217;ve explicitly provided an assignment operator for the base class, that operator is used. Similarly, if a class contains a member that is an object of another class, the assignment operator for that class is used for that member.</p>
<p>As you&#8217;ve seen several times, you need to provide an explicit assignment operator if class constructors use <code>new</code> to initialize pointers. Because C++ uses the base-class assignment operator for the base part of derived objects, you don&#8217;t need to redefine the assignment operator for a derived class <em>unless</em> it adds data members that require special care. For example, the <code>baseDMA</code> class defines assignment explicitly, but the derived <code>lacksDMA</code> class uses the implicit assignment operator generated for that class.</p>
<p><a id="page_774"/>Suppose, however, that a derived class does use <code>new</code>, and you have to provide an explicit assignment operator. The operator must provide for every member of the class, not just the new members. The <code>hasDMA</code> class illustrates how this can be done:</p>
<p class="programlisting">hasDMA &#38; hasDMA::operator=(const hasDMA &#38; hs)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;hs)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;baseDMA::operator=(hs);&#160;&#160;// copy base portion<br/>&#160;&#160;&#160;&#160;delete [] style;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prepare for new style<br/>&#160;&#160;&#160;&#160;style = new char[std::strlen(hs.style) + 1];<br/>&#160;&#160;&#160;&#160;std::strcpy(style, hs.style);<br/>&#160;&#160;&#160;&#160;return *this;<br/>}</p>
<p>What about assigning a derived-class object to a base-class object? (Note that this is not the same as initializing a base-class reference to a derived-class object.) Take a look at this example:</p>
<p class="programlisting">Brass blips;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// base class<br/>BrassPlus snips("Rafe Plosh", 91191,3993.19, 600.0, 0.12); // derived class<br/>blips = snips;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assign derived object to base object</p>
<p>Which assignment operator is used? Remember that the assignment statement is translated into a method that is invoked by the left-hand object:</p>
<p class="programlisting">blips.operator=(snips);</p>
<p>Here the left-hand object is a <code>Brass</code> object, so it invokes the <code>Brass::operator=(const Brass &#38;)</code> function. The <em>is-a</em> relationship allows the <code>Brass</code> reference to refer to a derived-class object, such as <code>snips</code>. The assignment operator only deals with base-class members, so the <code>maxLoan</code> member and other <code>BrassPlus</code> members of <code>snips</code> are ignored in the assignment. In short, you can assign a derived object to a base object, and only the base-class members are involved.</p>
<p>What about the reverse? Can you assign a base-class object to a derived object? Take a look at this example:</p>
<p class="programlisting">Brass gp("Griff Hexbait", 21234, 1200);&#160;&#160;&#160;// base class<br/>BrassPlus temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// derived class<br/>temp = gp;&#160;&#160;&#160;// possible?</p>
<p>Here the assignment statement would be translated as follows:</p>
<p class="programlisting">temp.operator=(gp);</p>
<p>The left-hand object is a <code>BrassPlus</code> object, so it invokes the <code>BrassPlus::operator=(const BrassPlus &#38;)</code> function. However, a derived-class reference cannot automatically refer to a base-class object, so this code <em>won&#8217;t</em> run unless there is <em>also</em> a conversion constructor:</p>
<p class="programlisting">BrassPlus(const Brass &#38;);</p>
<p><a id="page_775"/>It could be, as is the case for the <code>BrassPlus</code> class, that the conversion constructor is a constructor with a base-class argument plus additional arguments, provided that the additional arguments have default values:</p>
<p class="programlisting">BrassPlus(const Brass &#38; ba, double ml = 500, double r = 0.1);</p>
<p>If there is a conversion constructor, the program uses this constructor to create a temporary <code>BrassPlus</code> object from <code>gp</code>, which is then used as an argument to the assignment operator.</p>
<p>Alternatively, you could define an assignment operator for assigning a base class to a derived class:</p>
<p class="programlisting">BrassPlus &#38; BrassPlus ::operator=(const Brass &#38;) {...}</p>
<p>Here the types match the assignment statement exactly, and no type conversions are needed.</p>
<p>In short, the answer to the question &#8220;Can you assign a base-class object to a derived object?&#8221; is &#8220;Maybe.&#8221; You can if the derived class has a constructor that defines the conversion of a base-class object to a derived-class object. And you can if the derived class defines an assignment operator for assigning a base-class object to a derived object. If neither of these two conditions holds, then you can&#8217;t make the assignment unless you use an explicit type cast.</p>
<h5 id="ch13lev3sec24">Private Versus Protected Members</h5>
<p>Remember that protected members act like public members as far as a derived class is concerned, but they act like private members for the world at large. A derived class can access protected members of a base class directly, but it can access private members only via base-class member functions. Thus, making base-class members private offers more security, whereas making them protected simplifies coding and speeds up access. Stroustrup, in his book <em>The Design and Evolution of C++</em>, indicates that it&#8217;s better to use private data members than protected data members but that protected methods are useful.</p>
<h5 id="ch13lev3sec25">Virtual Method Considerations</h5>
<p>When you design a base class, you have to decide whether to make class methods virtual. If you want a derived class to be able to redefine a method, you define the method as virtual in the base class. This enables late, or dynamic, binding. If you don&#8217;t want the method to be redefined, you don&#8217;t make it virtual. This doesn&#8217;t prevent someone from redefining the method, but it should be interpreted as meaning that you don&#8217;t want it redefined.</p>
<p>Note that inappropriate code can circumvent dynamic binding. Consider, for example, the following two functions:</p>
<p class="programlisting">void show(const Brass &#38; rba)<br/>{<br/>&#160;&#160;&#160;&#160;rba.ViewAcct();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}<br/><br/><a id="page_776"/>void inadequate(Brass ba)<br/>{<br/>&#160;&#160;&#160;&#160;ba.ViewAcct();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}</p>
<p>The first function passes an object by reference, and the second passes an object by value.</p>
<p>Now suppose you use each with a derived class argument:</p>
<p class="programlisting">BrassPlus buzz("Buzz Parsec", 00001111, 4300);<br/>show(buzz);<br/>inadequate(buzz);</p>
<p>The <code>show()</code> function call results in the <code>rba</code> argument being a reference to the <code>BrassPlus</code> object <code>buzz</code>, so <code>rba.ViewAcct()</code> is interpreted as the <code>BrassPlus</code> version, as it should be. But in the <code>inadequate()</code> function, which passes an object by value, <code>ba</code> is a <code>Brass</code> object constructed by the <code>Brass(const Brass &#38;)</code> constructor. (Automatic upcasting allows the constructor argument to refer to a <code>BrassPlus</code> object.) Thus, in <code>inadequate()</code>, <code>ba.ViewAcct()</code> is the <code>Brass</code> version, so only the <code>Brass</code> component of <code>buzz</code> is displayed.</p>
<h5 id="ch13lev3sec26">Destructor Considerations</h5>
<p>As mentioned earlier, a base class destructor should be virtual. That way, when you delete a derived object via a base-class pointer or reference to the object, the program uses the derived-class destructor followed by the base-class destructor rather than using only the base-class destructor.</p>
<h5 id="ch13lev3sec27">Friend Considerations</h5>
<p>Because a friend function is not actually a class member, it&#8217;s not inherited. However, you might still want a friend to a derived class to use a friend to the base class. The way to accomplish this is to type cast a derived-class reference or pointer to the base-class equivalent and to then use the type cast reference or pointer to invoke the base-class friend:</p>
<p class="programlisting">ostream &#38; operator&lt;&lt;(ostream &#38; os, const hasDMA &#38; hs)<br/>{<br/>//&#160;&#160;type cast to match operator&lt;&lt;(ostream &#38; , const baseDMA &#38;)<br/>&#160;&#160;&#160;&#160;os &lt;&lt; (const baseDMA &#38;) hs;<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Style: " &lt;&lt; hs.style &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p>You can also use the <code>dynamic_cast&lt;&gt;</code> operator, discussed in <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>,&#8221; for the type cast:</p>
<p class="programlisting">os &lt;&lt; dynamic_cast&lt;const baseDMA &#38;&gt; (hs);</p>
<p>For reasons discussed in <a href="ch15.html#ch15">Chapter 15</a>, this would be the preferred form of type cast.</p>
<h5 id="ch13lev3sec28">Observations on Using Base-Class Methods</h5>
<p><a id="page_777"/>Publicly derived objects can use base-class methods in many ways:</p>
<p class="indenthandingB">&#8226; A derived object automatically uses inherited base-class methods if the derived class hasn&#8217;t redefined the method.</p>
<p class="indenthandingB">&#8226; A derived-class destructor automatically invokes the base-class constructor.</p>
<p class="indenthandingB">&#8226; A derived-class constructor automatically invokes the base-class default constructor if you don&#8217;t specify another constructor in a member-initialization list.</p>
<p class="indenthandingB">&#8226; A derived-class constructor explicitly invokes the base-class constructor specified in a member-initialization list.</p>
<p class="indenthandingB">&#8226; Derived-class methods can use the scope-resolution operator to invoke public and protected base-class methods.</p>
<p class="indenthandingB">&#8226; Friends to a derived class can type cast a derived-class reference or pointer to a base-class reference or pointer and then use that reference or pointer to invoke a friend to the base class.</p>
<h4 id="ch13lev2sec17">Class Function Summary</h4>
<p>C++ class functions come in many variations. Some can be inherited, and some can&#8217;t. Some operator functions can be either member functions or friends, and others can only be member functions. <a href="#ch13table01">Table 13.1</a>, based on a similar table from <em>The Annotated C++ Reference Manual</em>, summarizes these properties. In it, the notation <em><code>op</code></em><code>=</code> stands for assignment operators of the form <code>+=</code>, <code>*=</code>, and so on. Note that the properties for the <em><code>op</code></em><code>=</code> operators are no different from those of the &#8220;other operators&#8221; category. The reason for listing <em><code>op</code></em><code>=</code> separately is to point out that these operators don&#8217;t behave like the <code>=</code> operator.</p>
<p class="caption"><a id="ch13table01"/><strong>Table 13.1. Member Function Properties</strong></p>
<p class="image"><img src="graphics/13tab01.jpg" alt="Image"/></p>
<h3 id="ch13lev1sec9">Summary</h3>
<p><a id="page_778"/>Inheritance enables you to adapt programming code to your particular needs by defining a new class (a derived class) from an existing class (the base class). Public inheritance models an <em>is-a</em> relationship, meaning that a derived-class object should also be a kind of base-class object. As part of the <em>is-a</em> model, a derived class inherits the data members and most methods of the base class. However, a derived class doesn&#8217;t inherit the base-class constructors, destructors, and assignment operators. A derived class can access the public and protected members of the base class directly and the private base-class members via the public and protected base-class methods. You can then add new data members and methods to the class, and you can use the derived class as a base class for further development. Each derived class requires its own constructors. When a program creates a derived-class object, it first calls a base-class constructor and then the derived-class constructor. When a program deletes an object, it first calls the derived-class destructor and then the base-class destructor.</p>
<p>If a class is meant to be a base class, you may choose to use protected members instead of private members so that derived classes can access those members directly. However, using private members, in general, reduces the scope for programming bugs. If you intend that a derived class can redefine a base-class method, you should make it a virtual function by declaring it with the keyword <code>virtual</code>. This enables objects accessed by pointers or references to be handled on the basis of the object type rather than on the basis of the reference type or pointer type. In particular, the destructor for a base class should normally be virtual.</p>
<p>You might want to define an ABC that defines an interface without getting into implementation matters. For example, you could define an abstract <code>Shape</code> class from which particular shape classes, such as <code>Circle</code> and <code>Square</code>, will be derived. An ABC must include at least one pure virtual method. You declare a pure virtual method by placing <code>= 0</code> before the closing semicolon of the declaration:</p>
<p class="programlisting">virtual double area() const = 0;</p>
<p><a id="page_779"/>You don&#8217;t have to define pure virtual methods, and you can&#8217;t create an object of a class that contains pure virtual members. Instead, pure virtual methods serve to define a common interface to be used by derived classes.</p>
<h3 id="ch13lev1sec10">Chapter Review</h3>
<p class="question"><a id="ch13qa1q1" href="app10.html#ch13qa1a1"><strong>1.</strong></a> What does a derived class inherit from a base class?</p>
<p class="question"><a id="ch13qa1q2" href="app10.html#ch13qa1a2"><strong>2.</strong></a> What doesn&#8217;t a derived class inherit from a base class?</p>
<p class="question"><a id="ch13qa1q3" href="app10.html#ch13qa1a3"><strong>3.</strong></a> Suppose the return type for the <code>baseDMA::operator=()</code> function were defined as <code>void</code> instead of <code>baseDMA &#38;</code>. What effect, if any, would that have? What if the return type were <code>baseDMA</code> instead of <code>baseDMA &#38;</code>?</p>
<p class="question"><a id="ch13qa1q4" href="app10.html#ch13qa1a4"><strong>4.</strong></a> In what order are class constructors and class destructors called when a derived-class object is created and deleted?</p>
<p class="question"><a id="ch13qa1q5" href="app10.html#ch13qa1a5"><strong>5.</strong></a> If a derived class doesn&#8217;t add any data members to the base class, does the derived class require constructors?</p>
<p class="question"><a id="ch13qa1q6" href="app10.html#ch13qa1a6"><strong>6.</strong></a> Suppose a base class and a derived class both define a method with the same name and a derived-class object invokes the method. What method is called?</p>
<p class="question"><a id="ch13qa1q7" href="app10.html#ch13qa1a7"><strong>7.</strong></a> When should a derived class define an assignment operator?</p>
<p class="question"><a id="ch13qa1q8" href="app10.html#ch13qa1a8"><strong>8.</strong></a> Can you assign the address of an object of a derived class to a pointer to the base class? Can you assign the address of an object of a base class to a pointer to the derived class?</p>
<p class="question"><a id="ch13qa1q9" href="app10.html#ch13qa1a9"><strong>9.</strong></a> Can you assign an object of a derived class to an object of the base class? Can you assign an object of a base class to an object of the derived class?</p>
<p class="question1"><a id="ch13qa1q10" href="app10.html#ch13qa1a10"><strong>10.</strong></a> Suppose you define a function that takes a reference to a base-class object as an argument. Why can this function also use a derived-class object as an argument?</p>
<p class="question1"><a id="ch13qa1q11" href="app10.html#ch13qa1a11"><strong>11.</strong></a> Suppose you define a function that takes a base-class object as an argument (that is, the function passes a base-class object by value). Why can this function also use a derived-class object as an argument?</p>
<p class="question1"><a id="ch13qa1q12" href="app10.html#ch13qa1a12"><strong>12.</strong></a> Why is it usually better to pass objects by reference than by value?</p>
<p class="question1"><a id="ch13qa1q13" href="app10.html#ch13qa1a13"><strong>13.</strong></a> Suppose <code>Corporation</code> is a base class and <code>PublicCorporation</code> is a derived class. Also suppose that each class defines a <code>head()</code> member function, that <code>ph</code> is a pointer to the <code>Corporation</code> type, and that <code>ph</code> is assigned the address of a <code>PublicCorporation</code> object. How is <code>ph-&gt;head()</code> interpreted if the base class defines <code>head()</code> as a</p>
<p class="indenthandinga"><strong>a.</strong> Regular nonvirtual method</p>
<p class="indenthandinga"><strong>b.</strong> Virtual method</p>
<p class="question1"><a id="page_780"/><a id="ch13qa1q14" href="app10.html#ch13qa1a14"><strong>14.</strong></a> What&#8217;s wrong, if anything, with the following code?</p>
<p class="programlistingB">class Kitchen<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double kit_sq_ft;<br/>public:<br/>&#160;&#160;&#160;&#160;Kitchen() {kit_sq_ft = 0.0; }<br/>&#160;&#160;&#160;&#160;virtual double area() const { return kit_sq_ft * kit_sq_ft; }<br/>};<br/>class House : public Kitchen<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double all_sq_ft;<br/>public:<br/>&#160;&#160;&#160;&#160;House() {all_sq_ft += kit_sq_ft;}<br/>&#160;&#160;&#160;&#160;double area(const char *s) const { cout &lt;&lt; s; return all_sq_ft; }<br/>};</p>
<h3 id="ch13lev1sec11">Programming Exercises</h3>
<p class="question"><a id="ch13qa2q1"/><strong>1.</strong> Start with the following class declaration:</p>
<p class="programlistingB">// base class<br/>class Cd {&#160;&#160;// represents a CD disk<br/>private:<br/>&#160;&#160;&#160;&#160;char performers[50];<br/>&#160;&#160;&#160;&#160;char label[20];<br/>&#160;&#160;&#160;&#160;int selections;&#160;&#160;&#160;// number of selections<br/>&#160;&#160;&#160;&#160;double playtime;&#160;&#160;// playing time in minutes<br/>public:<br/>&#160;&#160;&#160;&#160;Cd(char * s1, char * s2, int n, double x);<br/>&#160;&#160;&#160;&#160;Cd(const Cd &#38; d);<br/>&#160;&#160;&#160;&#160;Cd();<br/>&#160;&#160;&#160;&#160;~Cd();<br/>&#160;&#160;&#160;&#160;void Report() const;&#160;&#160;// reports all CD data<br/>&#160;&#160;&#160;&#160;Cd &#38; operator=(const Cd &#38; d);<br/>};</p>
<p class="questionp">Derive a <code>Classic</code> class that adds an array of <code>char</code> members that will hold a string identifying the primary work on the CD. If the base class requires that any functions be virtual, modify the base-class declaration to make it so. If a declared method is not needed, remove it from the definition. Test your product with the following program:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/>#include "classic.h"&#160;&#160;&#160;&#160;&#160;// which will contain #include cd.h<br/><a id="page_781"/>void Bravo(const Cd &#38; disk);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Cd c1("Beatles", "Capitol", 14, 35.5);<br/>&#160;&#160;&#160;&#160;Classic c2 = Classic("Piano Sonata in B flat, Fantasia in C",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Alfred Brendel", "Philips", 2, 57.17);<br/>&#160;&#160;&#160;&#160;Cd *pcd = &#38;c1;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using object directly:\n";<br/>&#160;&#160;&#160;&#160;c1.Report();&#160;&#160;&#160;&#160;// use Cd method<br/>&#160;&#160;&#160;&#160;c2.Report();&#160;&#160;&#160;&#160;// use Classic method<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using type cd * pointer to objects:\n";<br/>&#160;&#160;&#160;&#160;pcd-&gt;Report();&#160;&#160;// use Cd method for cd object<br/>&#160;&#160;&#160;&#160;pcd = &#38;c2;<br/>&#160;&#160;&#160;&#160;pcd-&gt;Report();&#160;&#160;// use Classic method for classic object<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Calling a function with a Cd reference argument:\n";<br/>&#160;&#160;&#160;&#160;Bravo(c1);<br/>&#160;&#160;&#160;&#160;Bravo(c2);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Testing assignment: ";<br/>&#160;&#160;&#160;&#160;Classic copy;<br/>&#160;&#160;&#160;&#160;copy = c2;<br/>&#160;&#160;&#160;&#160;copy.Report()<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void Bravo(const Cd &#38; disk)<br/>{<br/>&#160;&#160;&#160;&#160;disk.Report();<br/>}</p>
<p class="question"><a id="ch13qa2q2"/><strong>2.</strong> Do Programming Exercise 1 but use dynamic memory allocation instead of fixed-size arrays for the various strings tracked by the two classes.</p>
<p class="question"><a id="ch13qa2q3"/><strong>3.</strong> Revise the <code>baseDMA</code>-<code>lacksDMA</code>-<code>hasDMA</code> class hierarchy so that all three classes are derived from an ABC. Test the result with a program similar to the one in <a href="#ch13ex10">Listing 13.10</a>. That is, it should feature an array of pointers to the ABC and allow the user to make runtime decisions as to what types of objects are created. Add virtual <code>View()</code> methods to the class definitions to handle displaying the data.</p>
<p class="question"><a id="ch13qa2q4"/><strong>4.</strong> The Benevolent Order of Programmers maintains a collection of bottled port. To describe it, the BOP Portmaster has devised a <code>Port</code> class, as declared here:</p>
<p class="programlistingB"><a id="page_782"/>#include &lt;iostream&gt;<br/>using namespace std;<br/>class Port<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * brand;<br/>&#160;&#160;&#160;&#160;char style[20]; // i.e., tawny, ruby, vintage<br/>&#160;&#160;&#160;&#160;int bottles;<br/>public:<br/>&#160;&#160;&#160;&#160;Port(const char * br = "none", const char * st = "none", int b = 0);<br/>&#160;&#160;&#160;&#160;Port(const Port &#38; p);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// copy constructor<br/>&#160;&#160;&#160;&#160;virtual ~Port() { delete [] brand; }<br/>&#160;&#160;&#160;&#160;Port &#38; operator=(const Port &#38; p);<br/>&#160;&#160;&#160;&#160;Port &#38; operator+=(int b);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// adds b to bottles<br/>&#160;&#160;&#160;&#160;Port &#38; operator-=(int b);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// subtracts b from bottles, if available<br/>&#160;&#160;&#160;&#160;int BottleCount() const { return bottles; }<br/>&#160;&#160;&#160;&#160;virtual void Show() const;<br/>&#160;&#160;&#160;&#160;friend ostream &#38; operator&lt;&lt;(ostream &#38; os, const Port &#38; p);<br/>};</p>
<p class="questionp">The <code>Show()</code> method presents information in the following format:</p>
<p class="programlistingB">Brand: Gallo<br/>Kind: tawny<br/>Bottles: 20</p>
<p class="questionp">The <code>operator&lt;&lt;()</code> function presents information in the following format (with no newline character at the end):</p>
<p class="programlistingB">Gallo, tawny, 20</p>
<p class="questionp">The Portmaster completed the method definitions for the <code>Port</code> class and then derived the <code>VintagePort</code> class as follows before being relieved of his position for accidentally routing a bottle of &#8216;45 Cockburn to someone preparing an experimental barbecue sauce:</p>
<p class="programlistingB">class VintagePort : public Port // style necessarily = "vintage"<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char * nickname;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// i.e., "The Noble" or "Old Velvet", etc.<br/>&#160;&#160;&#160;&#160;int year;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// vintage year<br/>public:<br/>&#160;&#160;&#160;&#160;VintagePort();<br/>&#160;&#160;&#160;&#160;VintagePort(const char * br, int b, const char * nn, int y);<br/>&#160;&#160;&#160;&#160;VintagePort(const VintagePort &#38; vp);<br/>&#160;&#160;&#160;&#160;~VintagePort() { delete [] nickname; }<br/>&#160;&#160;&#160;&#160;VintagePort &#38; operator=(const VintagePort &#38; vp);<br/><a id="page_783"/>&#160;&#160;&#160;&#160;void Show() const;<br/>&#160;&#160;&#160;&#160;friend ostream &#38; operator&lt;&lt;(ostream &#38; os, const VintagePort &#38; vp);<br/>};</p>
<p class="questionp">You get the job of completing the <code>VintagePort</code> work.</p>
<p class="indenthandinga"><strong>a.</strong> Your first task is to re-create the <code>Port</code> method definitions because the former Portmaster immolated his upon being relieved.</p>
<p class="indenthandinga"><strong>b.</strong> Your second task is to explain why certain methods are redefined and others are not.</p>
<p class="indenthandinga"><strong>c.</strong> Your third task is to explain why <code>operator=()</code> and <code>operator&lt;&lt;()</code> are not virtual.</p>
<p class="indenthandinga"><strong>d.</strong> Your fourth task is to provide definitions for the <code>VintagePort</code> methods.</p>
</body>
</html>
