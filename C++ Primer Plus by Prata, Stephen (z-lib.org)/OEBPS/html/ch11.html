<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>11. Working with Classes</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch11">11. Working with Classes</h2>
<p><a id="page_563"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Operator overloading</p>
<p class="indenthandingB">&#8226; Friend functions</p>
<p class="indenthandingB">&#8226; Overloading the <code>&lt;&lt;</code> operator for output</p>
<p class="indenthandingB">&#8226; State members</p>
<p class="indenthandingB">&#8226; Using <code>rand()</code> to generate random values</p>
<p class="indenthandingB">&#8226; Automatic conversions and type casts for classes</p>
<p class="indenthandingB">&#8226; Class conversion functions</p>
<p>C++ classes are feature-rich, complex, and powerful. In <a href="ch10.html#ch10">Chapter 10</a>, &#8220;<a href="ch10.html#ch10">Objects and Classes</a>,&#8221; you began a journey toward object-oriented programming by learning to define and use a simple class. You saw how a class defines a data type by defining the type of data to be used to represent an object and by also defining, through member functions, the operations that can be performed with that data. And you learned about two special member functions, the constructor and the destructor, that manage creating and discarding objects made to a class specification. This chapter takes you a few steps further in the exploration of class properties, concentrating on class design techniques rather than on general principles. You&#8217;ll probably find some of the features covered here straightforward and some a bit more subtle. To best understand these new features, you should try the examples and experiment with them: What happens if you use a regular argument instead of a reference argument for this function? What happens if you leave something out of a destructor? Don&#8217;t be afraid to make mistakes; usually you can learn more from unraveling an error than by doing something correctly but by rote. (However, don&#8217;t assume that a maelstrom of mistakes inevitably leads to incredible insight.) In the end, you&#8217;ll be rewarded with a fuller understanding of how C++ works and of what C++ can do for you.</p>
<p>This chapter starts with operator overloading, which lets you use standard C++ operators such as <code>=</code> and <code>+</code> with class objects. Then it examines friends, the C++ mechanism for letting nonmember functions access private data. Finally, it looks at how you can instruct <a id="page_564"/>C++ to perform automatic type conversions with classes. As you go through this chapter and <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; you&#8217;ll gain a greater appreciation of the roles class constructors and class destructors play. Also you&#8217;ll see some of the stages you may go through as you develop and improve a class design.</p>
<p>One difficulty with learning C++, at least by the time you&#8217;ve gotten this far into the subject, is that there is an awful lot to remember. And it&#8217;s unreasonable to expect to remember it all until you&#8217;ve logged enough experience on which to hang your memories. Learning C++, in this respect, is like learning a feature-laden word processor or spreadsheet program. No one feature is that daunting, but, in practice, most people really know well only those features they use regularly, such as searching for text or italicizing. You may recall having read somewhere how to generate alternative characters or create a table of contents, but those skills probably won&#8217;t be part of your daily repertoire until you face a situation in which you need them frequently. Probably the best approach to absorbing the wealth of material in this chapter is to begin incorporating just some of these new features into your own C++ programming. As your experiences enhance your understanding and appreciation of these features, you can begin adding other C++ features. As Bjarne Stroustrup, the creator of C++, suggested at a C++ conference for professional programmers: &#8220;Ease yourself into the language. Don&#8217;t feel you have to use all of the features, and don&#8217;t try to use them all on the first day.&#8221;</p>
<h3 id="ch11lev1sec1">Operator Overloading</h3>
<p>Let&#8217;s look at a technique for giving object operations a prettier look. <em>Operator overloading</em> is an example of C++ polymorphism. In <a href="ch08.html#ch08">Chapter 8</a>, &#8220;<a href="ch08.html#ch08">Adventures in Functions</a>,&#8221; you saw how C++ enables you to define several functions that have the same name, provided that they have different signatures (argument lists). That is called <em>function overloading</em>, or <em>functional polymorphism</em>. Its purpose is to let you use the same function name for the same basic operation, even though you apply the operation to different data types. (Imagine how awkward English would be if you had to use a different verb form for each different type of object&#8212;for example, lift_lft your left foot, but lift_sp your spoon.) Operator overloading extends the overloading concept to operators, letting you assign multiple meanings to C++ operators. Actually, many C++ (and C) operators already are overloaded. For example, the <code>*</code> operator, when applied to an address, yields the value stored at that address. But applying <code>*</code> to two numbers yields the product of the values. C++ uses the number and type of operands to decide which action to take.</p>
<p>C++ lets you extend operator overloading to user-defined types, permitting you, say, to use the <code>+</code> symbol to add two objects. Again, the compiler uses the number and type of operands to determine which definition of addition to use. Overloaded operators can often make code look more natural. For example, a common computing task is adding two arrays. Usually, this winds up looking like the following <code>for</code> loop:</p>
<p class="programlisting">for (int i = 0; i &lt; 20; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;evening[i] = sam[i] + janet[i];&#160;&#160;// add element by element</p>
<p><a id="page_565"/>But in C++, you can define a class that represents arrays and that overloads the <code>+</code> operator so that you can do this:</p>
<p class="programlisting">evening = sam + janet;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// add two array objects</p>
<p>This simple addition notation conceals the mechanics and emphasizes what is essential, and that is another goal of OOP.</p>
<p>To overload an operator, you use a special function form called an <em>operator function</em>. An operator function has the following form, where <em><code>op</code></em> is the symbol for the operator being overloaded:</p>
<p class="programlisting">operator<span class="EmpItalic">op</span>(<span class="EmpItalic">argument-list</span>)</p>
<p>For example, <code>operator+()</code> overloads the <code>+</code> operator and <code>operator*()</code> overloads the <code>*</code> operator. The <em><code>op</code></em> has to be a valid C++ operator; you can&#8217;t just make up a new symbol. For example, you can&#8217;t have an <code>operator@()</code> function because C++ has no <code>@</code> operator. But the <code>operator[]()</code> function would overload the <code>[]</code> operator because <code>[]</code> is the array-indexing operator. Suppose, for example, that you have a <code>Salesperson</code> class for which you define an <code>operator+()</code> member function to overload the <code>+</code> operator so that it adds sales figures of one salesperson object to another. Then, if <code>district2</code>, <code>sid</code>, and <code>sara</code> are all objects of the <code>Salesperson</code> class, you can write this equation:</p>
<p class="programlisting">district2 = sid + sara;</p>
<p>The compiler, recognizing the operands as belonging to the <code>Salesperson</code> class, replaces the operator with the corresponding operator function:</p>
<p class="programlisting">district2 = sid.operator+(sara);</p>
<p>The function then uses the <code>sid</code> object implicitly (because it invoked the method) and the <code>sara</code> object explicitly (because it&#8217;s passed as an argument) to calculate the sum, which it then returns. Of course, the nice part is that you can use the nifty <code>+</code> operator notation instead of the clunky function notation.</p>
<p>C++ imposes some restrictions on operator overloading, but they&#8217;re easiest to understand after you&#8217;ve seen how overloading works. So let&#8217;s develop a few examples to clarify the process and then discuss the limitations.</p>
<h3 id="ch11lev1sec2">Time on Our Hands: Developing an Operator Overloading Example</h3>
<p>If you worked on the Priggs account for 2 hours 35 minutes in the morning and 2 hours 40 minutes in the afternoon, how long did you work altogether on the account? Here&#8217;s an example where the concept of addition makes sense, but the units that you are adding (a mixture of hours and minutes) don&#8217;t match a built-in type. <a href="ch07.html#ch07">Chapter 7</a>, &#8220;<a href="ch07.html#ch07">Functions: C++&#8217;s Programming Modules</a>,&#8221; handles a similar case by defining a <code>travel_time</code> structure and a <code>sum()</code> function for adding such structures. Now let&#8217;s generalize that to a <code>Time</code> class, using a method to handle addition. Let&#8217;s begin with an ordinary method, called <a id="page_566"/><code>Sum()</code>, and then see how to convert it to an overloaded operator. <a href="#ch11ex01">Listing 11.1</a> shows the class declaration.</p>
<p class="caption1"><a id="ch11ex01"/><strong>Listing 11.1. <code>mytime0.h</code></strong></p><hr/>
<p class="programlisting1">// mytime0.h -- Time class before operator overloading<br/>#ifndef MYTIME0_H_<br/>#define MYTIME0_H_<br/><br/>class Time<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int hours;<br/>&#160;&#160;&#160;&#160;int minutes;<br/>public:<br/>&#160;&#160;&#160;&#160;Time();<br/>&#160;&#160;&#160;&#160;Time(int h, int m = 0);<br/>&#160;&#160;&#160;&#160;void AddMin(int m);<br/>&#160;&#160;&#160;&#160;void AddHr(int h);<br/>&#160;&#160;&#160;&#160;void Reset(int h = 0, int m = 0);<br/>&#160;&#160;&#160;&#160;Time Sum(const Time &#38; t) const;<br/>&#160;&#160;&#160;&#160;void Show() const;<br/>};<br/>#endif</p><hr/>
<p>The <code>Time</code> class provides methods for adjusting and resetting times, for displaying time values, and for adding two times. <a href="#ch11ex02">Listing 11.2</a> shows the methods definitions; note how the <code>AddMin()</code> and <code>Sum()</code> methods use integer division and the modulus operator to adjust the <code>minutes</code> and <code>hours</code> values when the total number of minutes exceeds 59. Also because the only <code>iostream</code> feature used is <code>cout</code> and because it is used only once, it seems economical to use <code>std::cout</code> rather than use the whole <code>std</code> namespace.</p>
<p class="caption1"><a id="ch11ex02"/><strong>Listing 11.2. <code>mytime0.cpp</code></strong></p><hr/>
<p class="programlisting1">// mytime0.cpp&#160;&#160;-- implementing Time methods<br/>#include &lt;iostream&gt;<br/>#include "mytime0.h"<br/><br/>Time::Time()<br/>{<br/>&#160;&#160;&#160;&#160;hours = minutes = 0;<br/>}<br/><br/>Time::Time(int h, int m )<br/>{<br/>&#160;&#160;&#160;&#160;hours = h;<br/>&#160;&#160;&#160;&#160;minutes = m;<br/>}<br/><br/>void Time::AddMin(int m)<br/>{<br/>&#160;&#160;&#160;&#160;minutes += m;<br/>&#160;&#160;&#160;&#160;hours += minutes / 60;<br/>&#160;&#160;&#160;&#160;minutes %= 60;<br/>}<br/><br/>void Time::AddHr(int h)<br/>{<br/>&#160;&#160;&#160;&#160;hours += h;<br/>}<br/><br/>void Time::Reset(int h, int m)<br/>{<br/>&#160;&#160;&#160;&#160;hours = h;<br/>&#160;&#160;&#160;&#160;minutes = m;<br/>}<br/><br/>Time Time::Sum(const Time &#38; t) const<br/>{<br/>&#160;&#160;&#160;&#160;Time sum;<br/>&#160;&#160;&#160;&#160;sum.minutes = minutes + t.minutes;<br/>&#160;&#160;&#160;&#160;sum.hours = hours + t.hours + sum.minutes / 60;<br/>&#160;&#160;&#160;&#160;sum.minutes %= 60;<br/>&#160;&#160;&#160;&#160;return sum;<br/>}<br/><br/>void Time::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; hours &lt;&lt; " hours, " &lt;&lt; minutes &lt;&lt; " minutes";<br/>}</p><hr/>
<p><a id="page_567"/>Consider the code for the <code>Sum()</code> function. Note that the argument is a reference but that the return type is not a reference. The reason for making the argument a reference is efficiency. The code would produce the same results if the <code>Time</code> object were passed by value, but it&#8217;s usually faster and more memory-efficient to just pass a reference.</p>
<p>However, the return value cannot be a reference. The reason is that the function creates a new <code>Time</code> object (<code>sum</code>) that represents the sum of the other two <code>Time</code> objects. Returning the object, as this code does, creates a copy of the object that the calling function can use. If the return type were <code>Time &#38;</code>, however, the reference would be to the <code>sum</code> object. But the <code>sum</code> object is a local variable and is destroyed when the function terminates, so the reference would be a reference to a non-existent object. Using a <code>Time</code> return <a id="page_568"/>type, however, means the program constructs a <em>copy</em> of <code>sum</code> before destroying it, and the calling function gets the copy.</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note01"/>Caution</p>
<p class="notepara">Don&#8217;t return a reference to a local variable or another temporary object. When the function terminates and the local variable or temporary object disappears, the reference becomes a reference to non-existent data.</p>
<hr/></div>
<p>Finally, <a href="#ch11ex03">Listing 11.3</a> tests the time summation part of the <code>Time</code> class.</p>
<p class="caption1"><a id="ch11ex03"/><strong>Listing 11.3. <code>usetime0.cpp</code></strong></p><hr/>
<p class="programlisting1">// usetime0.cpp -- using the first draft of the Time class<br/>// compile usetime0.cpp and mytime0.cpp together<br/>#include &lt;iostream&gt;<br/>#include "mytime0.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;Time planning;<br/>&#160;&#160;&#160;&#160;Time coding(2, 40);<br/>&#160;&#160;&#160;&#160;Time fixing(5, 55);<br/>&#160;&#160;&#160;&#160;Time total;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "planning time = ";<br/>&#160;&#160;&#160;&#160;planning.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "coding time = ";<br/>&#160;&#160;&#160;&#160;coding.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "fixing time = ";<br/>&#160;&#160;&#160;&#160;fixing.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;total = coding.Sum(fixing);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "coding.Sum(fixing) = ";<br/>&#160;&#160;&#160;&#160;total.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_569"/>Here is the output of the program in <a href="#ch11ex01">Listings 11.1</a>, <a href="#ch11ex02">11.2</a>, and <a href="#ch11ex03">11.3</a>:</p>
<p class="programlisting">planning time = 0 hours, 0 minutes<br/>coding time = 2 hours, 40 minutes<br/>fixing time = 5 hours, 55 minutes<br/>coding.Sum(fixing) = 8 hours, 35 minutes</p>
<h4 id="ch11lev2sec1">Adding an Addition Operator</h4>
<p>It&#8217;s a simple matter to convert the <code>Time</code> class to using an overloaded addition operator. You just change the name of <code>Sum()</code> to the odder-looking name <code>operator+()</code>. That&#8217;s right: You just append the operator symbol (<code>+</code>, in this case) to the end of <code>operator</code> and use the result as a method name. This is one place where you can use a character other than a letter, a digit, or an underscore in an identifier name. <a href="#ch11ex04">Listings 11.4</a> and <a href="#ch11ex05">11.5</a> reflect this small change.</p>
<p class="caption1"><a id="ch11ex04"/><strong>Listing 11.4. <code>mytime1.h</code></strong></p><hr/>
<p class="programlisting1">// mytime1.h -- Time class before operator overloading<br/>#ifndef MYTIME1_H_<br/>#define MYTIME1_H_<br/><br/>class Time<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int hours;<br/>&#160;&#160;&#160;&#160;int minutes;<br/>public:<br/>&#160;&#160;&#160;&#160;Time();<br/>&#160;&#160;&#160;&#160;Time(int h, int m = 0);<br/>&#160;&#160;&#160;&#160;void AddMin(int m);<br/>&#160;&#160;&#160;&#160;void AddHr(int h);<br/>&#160;&#160;&#160;&#160;void Reset(int h = 0, int m = 0);<br/>&#160;&#160;&#160;&#160;Time operator+(const Time &#38; t) const;<br/>&#160;&#160;&#160;&#160;void Show() const;<br/>};<br/>#endif</p><hr/>
<p class="caption1"><a id="ch11ex05"/><strong>Listing 11.5. <code>mytime1.cpp</code></strong></p><hr/>
<p class="programlisting1">// mytime1.cpp&#160;&#160;-- implementing Time methods<br/>#include &lt;iostream&gt;<br/>#include "mytime1.h"<br/><br/>Time::Time()<br/>{<br/>&#160;&#160;&#160;&#160;hours = minutes = 0;<br/>}<br/><br/>Time::Time(int h, int m )<br/>{<br/>&#160;&#160;&#160;&#160;hours = h;<br/>&#160;&#160;&#160;&#160;minutes = m;<br/>}<br/><br/>void Time::AddMin(int m)<br/>{<br/>&#160;&#160;&#160;&#160;minutes += m;<br/>&#160;&#160;&#160;&#160;hours += minutes / 60;<br/>&#160;&#160;&#160;&#160;minutes %= 60;<br/>}<br/><br/>void Time::AddHr(int h)<br/>{<br/>&#160;&#160;&#160;&#160;hours += h;<br/>}<br/><br/>void Time::Reset(int h, int m)<br/>{<br/>&#160;&#160;&#160;&#160;hours = h;<br/>&#160;&#160;&#160;&#160;minutes = m;<br/>}<br/><br/>Time Time::operator+(const Time &#38; t) const<br/>{<br/>&#160;&#160;&#160;&#160;Time sum;<br/>&#160;&#160;&#160;&#160;sum.minutes = minutes + t.minutes;<br/>&#160;&#160;&#160;&#160;sum.hours = hours + t.hours + sum.minutes / 60;<br/>&#160;&#160;&#160;&#160;sum.minutes %= 60;<br/>&#160;&#160;&#160;&#160;return sum;<br/>}<br/><br/>void Time::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; hours &lt;&lt; " hours, " &lt;&lt; minutes &lt;&lt; " minutes";<br/>}</p><hr/>
<p><a id="page_570"/>Like <code>Sum()</code>, <code>operator+()</code> is invoked by a <code>Time</code> object, takes a second <code>Time</code> object as an argument, and returns a <code>Time</code> object. Thus, you can invoke the <code>operator+()</code> method by using the same syntax that <code>Sum()</code> uses:</p>
<p class="programlisting">total = coding.operator+(fixing);&#160;&#160;&#160;&#160;// function notation</p>
<p><a id="page_571"/>But naming the method <code>operator+()</code> also lets you use operator notation:</p>
<p class="programlisting">total = coding + fixing;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// operator notation</p>
<p>Either notation invokes the <code>operator+()</code> method. Note that with the operator notation, the object to the left of the operator (<code>coding</code>, in this case) is the invoking object, and the object to the right (<code>fixing</code>, in this case) is the one passed as an argument. <a href="#ch11ex06">Listing 11.6</a> illustrates this point.</p>
<p class="caption1"><a id="ch11ex06"/><strong>Listing 11.6. <code>usetime1.cpp</code></strong></p><hr/>
<p class="programlisting1">// usetime1.cpp -- using the second draft of the Time class<br/>// compile usetime1.cpp and mytime1.cpp together<br/>#include &lt;iostream&gt;<br/>#include "mytime1.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;Time planning;<br/>&#160;&#160;&#160;&#160;Time coding(2, 40);<br/>&#160;&#160;&#160;&#160;Time fixing(5, 55);<br/>&#160;&#160;&#160;&#160;Time total;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "planning time = ";<br/>&#160;&#160;&#160;&#160;planning.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "coding time = ";<br/>&#160;&#160;&#160;&#160;coding.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "fixing time = ";<br/>&#160;&#160;&#160;&#160;fixing.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;total = coding + fixing;<br/>&#160;&#160;&#160;&#160;// operator notation<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "coding + fixing = ";<br/>&#160;&#160;&#160;&#160;total.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;Time morefixing(3, 28);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "more fixing time = ";<br/>&#160;&#160;&#160;&#160;morefixing.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;total = morefixing.operator+(total);<br/>&#160;&#160;&#160;&#160;// function notation<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "morefixing.operator+(total) = ";<br/>&#160;&#160;&#160;&#160;total.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_572"/>Here is the output of the program in <a href="#ch11ex04">Listings 11.4</a>, <a href="#ch11ex05">11.5</a>, and <a href="#ch11ex06">11.6</a>:</p>
<p class="programlisting">planning time = 0 hours, 0 minutes<br/>coding time = 2 hours, 40 minutes<br/>fixing time = 5 hours, 55 minutes<br/>coding + fixing = 8 hours, 35 minutes<br/>more fixing time = 3 hours, 28 minutes<br/>morefixing.operator+(total) = 12 hours, 3 minutes</p>
<p>In short, the name of the <code>operator+()</code> function allows it to be invoked by using either function notation or operator notation. The compiler uses the operand types to figure out what to do:</p>
<p class="programlisting">int a, b, c;<br/>Time A, B, C;<br/>c = a + b;&#160;&#160;&#160;&#160;&#160;&#160;// use int addition<br/>C = A + B;&#160;&#160;&#160;&#160;&#160;&#160;// use addition as defined for Time objects</p>
<p>Can you add more than two objects? For example, if <code>t1</code>, <code>t2</code>, <code>t3</code>, and <code>t4</code> are all <code>Time</code> objects, can you do the following?</p>
<p class="programlisting">t4 = t1 + t2 + t3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid?</p>
<p>The way to answer this is to consider how the statement gets translated into function calls. Because addition is a left-to-right operator, the statement is first translated to this:</p>
<p class="programlisting">t4 = t1.operator+(t2 + t3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid?</p>
<p>Then the function argument is itself translated to a function call, giving the following:</p>
<p class="programlisting">t4 = t1.operator+(t2.operator+(t3));&#160;&#160;&#160;// valid? YES</p>
<p>Is this valid? Yes, it is. The function call <code>t2.operator+(t3)</code> returns a <code>Time</code> object that represents the sum of <code>t2</code> and <code>t3</code>. This object then becomes the object of the <code>t1.operator+()</code> function call, and that call returns the sum of <code>t1</code> and the <code>Time</code> object that represents the sum of <code>t2</code> and <code>t3</code>. In short, the final return value is the sum of <code>t1</code>, <code>t2</code>, and <code>t3</code>, just as desired.</p>
<h4 id="ch11lev2sec2">Overloading Restrictions</h4>
<p><a id="page_573"/>Most C++ operators (see <a href="#ch11table01">Table 11.1</a>) can be overloaded in the manner described in the preceding section. Overloaded operators (with some exceptions) don&#8217;t necessarily have to be member functions. However, at least one of the operands has to be a user-defined type. Let&#8217;s take a closer look at the limits C++ imposes on user-defined operator overloading:</p>
<p class="indenthandingB">&#8226; The overloaded operator must have at least one operand that is a user-defined type. This prevents you from overloading operators for the standard types. Thus, you can&#8217;t redefine the minus operator (<code>-</code>) so that it yields the sum of two <code>double</code> values instead of their difference. This restriction preserves program sanity, although it may hinder creative accounting.</p>
<p class="indenthandingB">&#8226; You can&#8217;t use an operator in a manner that violates the syntax rules for the original operator. For example, you can&#8217;t overload the modulus operator (<code>%</code>) so that it can be used with a single operand:</p>
<p class="programlistingB">int x;<br/>Time shiva;<br/>% x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invalid for modulus operator<br/>% shiva;&#160;&#160;&#160;// invalid for overloaded operator</p>
<p class="indenthandingBP">Similarly, you can&#8217;t alter operator precedence. So if you overload the addition operator to let you add two classes, the new operator has the same precedence as ordinary addition.</p>
<p class="indenthandingB">&#8226; You can&#8217;t create new operator symbols. For example, you can&#8217;t define an <code>operator**()</code> function to denote exponentiation.</p>
<p class="indenthandingB">&#8226; You cannot overload the following operators:</p>
<p class="image"><img src="graphics/573tab01.jpg" alt="Image"/></p>
<p class="indenthandingBP">This still leaves all the operators in <a href="#ch11table01">Table 11.1</a> available for overloading.</p>
<p class="indenthandingB">&#8226; <a id="page_574"/>Most of the operators in <a href="#ch11table01">Table 11.1</a> can be overloaded by using either member or nonmember functions. However, you can use <em>only</em> member functions to overload the following operators:</p>
<p class="image"><img src="graphics/574tab01.jpg" alt="Image"/></p>
<p class="caption"><a id="ch11table01"/><strong>Table 11.1. Operators That Can Be Overloaded</strong></p>
<p class="image"><img src="graphics/11tab01.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch11note02"/>Note</p>
<p class="notepara">This chapter does not cover every operator mentioned in the list of restrictions or in <a href="#ch11table01">Table 11.1</a>. However, <a href="app05.html#app05">Appendix E</a>, &#8220;<a href="app05.html#app05">Other Operators</a>,&#8221; summarizes the operators that are not covered in the main body of this text.</p>
<hr/></div>
<p>In addition to these formal restrictions, you should use sensible restraint in overloading operators. For example, you shouldn&#8217;t overload the <code>*</code> operator so that it swaps the data members of two <code>Time</code> objects. Nothing in the notation would suggest what the operator did, so it would be better to define a class method with an explanatory name such as <code>Swap()</code>.</p>
<h4 id="ch11lev2sec3">More Overloaded Operators</h4>
<p>Some other operations make sense for the <code>Time</code> class. For example, you might want to subtract one time from another or multiply a time by a factor. This suggests overloading the subtraction and multiplication operators. The technique is the same as for the addition operator: you create <code>operator-()</code> and <code>operator*()</code> methods. That is, you add the following prototypes to the class declaration:</p>
<p class="programlisting">Time operator-(const Time &#38; t) const;<br/>Time operator*(double n) const;</p>
<p><a id="page_575"/><a href="#ch11ex07">Listing 11.7</a> shows the new header file.</p>
<p class="caption1"><a id="ch11ex07"/><strong>Listing 11.7. <code>mytime2.h</code></strong></p><hr/>
<p class="programlisting1">// mytime2.h -- Time class after operator overloading<br/>#ifndef MYTIME2_H_<br/>#define MYTIME2_H_<br/><br/>class Time<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int hours;<br/>&#160;&#160;&#160;&#160;int minutes;<br/>public:<br/>&#160;&#160;&#160;&#160;Time();<br/>&#160;&#160;&#160;&#160;Time(int h, int m = 0);<br/>&#160;&#160;&#160;&#160;void AddMin(int m);<br/>&#160;&#160;&#160;&#160;void AddHr(int h);<br/>&#160;&#160;&#160;&#160;void Reset(int h = 0, int m = 0);<br/>&#160;&#160;&#160;&#160;Time operator+(const Time &#38; t) const;<br/>&#160;&#160;&#160;&#160;Time operator-(const Time &#38; t) const;<br/>&#160;&#160;&#160;&#160;Time operator*(double n) const;<br/>&#160;&#160;&#160;&#160;void Show() const;<br/>};<br/>#endif</p><hr/>
<p>Then you add definitions for the new methods to the implementation file, as shown in <a href="#ch11ex08">Listing 11.8</a>.</p>
<p class="caption1"><a id="ch11ex08"/><strong>Listing 11.8. <code>mytime2.cpp</code></strong></p><hr/>
<p class="programlisting1">// mytime2.cpp&#160;&#160;-- implementing Time methods<br/>#include &lt;iostream&gt;<br/>#include "mytime2.h"<br/><br/>Time::Time()<br/>{<br/>&#160;&#160;&#160;&#160;hours = minutes = 0;<br/>}<br/><br/>Time::Time(int h, int m )<br/>{<br/>&#160;&#160;&#160;&#160;hours = h;<br/>&#160;&#160;&#160;&#160;minutes = m;<br/>}<br/><br/>void Time::AddMin(int m)<br/>{<br/><a id="page_576"/>&#160;&#160;&#160;&#160;minutes += m;<br/>&#160;&#160;&#160;&#160;hours += minutes / 60;<br/>&#160;&#160;&#160;&#160;minutes %= 60;<br/>}<br/>void Time::AddHr(int h)<br/>{<br/>&#160;&#160;&#160;&#160;hours += h;<br/>}<br/><br/>void Time::Reset(int h, int m)<br/>{<br/>&#160;&#160;&#160;&#160;hours = h;<br/>&#160;&#160;&#160;&#160;minutes = m;<br/>}<br/><br/>Time Time::operator+(const Time &#38; t) const<br/>{<br/>&#160;&#160;&#160;&#160;Time sum;<br/>&#160;&#160;&#160;&#160;sum.minutes = minutes + t.minutes;<br/>&#160;&#160;&#160;&#160;sum.hours = hours + t.hours + sum.minutes / 60;<br/>&#160;&#160;&#160;&#160;sum.minutes %= 60;<br/>&#160;&#160;&#160;&#160;return sum;<br/>}<br/><br/>Time Time::operator-(const Time &#38; t) const<br/>{<br/>&#160;&#160;&#160;&#160;Time diff;<br/>&#160;&#160;&#160;&#160;int tot1, tot2;<br/>&#160;&#160;&#160;&#160;tot1 = t.minutes + 60 * t.hours;<br/>&#160;&#160;&#160;&#160;tot2 = minutes + 60 * hours;<br/>&#160;&#160;&#160;&#160;diff.minutes = (tot2 - tot1) % 60;<br/>&#160;&#160;&#160;&#160;diff.hours = (tot2 - tot1) / 60;<br/>&#160;&#160;&#160;&#160;return diff;<br/>}<br/><br/>Time Time::operator*(double mult) const<br/>{<br/>&#160;&#160;&#160;&#160;Time result;<br/>&#160;&#160;&#160;&#160;long totalminutes = hours * mult * 60 + minutes * mult;<br/>&#160;&#160;&#160;&#160;result.hours = totalminutes / 60;<br/>&#160;&#160;&#160;&#160;result.minutes = totalminutes % 60;<br/>&#160;&#160;&#160;&#160;return result;<br/>}<br/><br/>void Time::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; hours &lt;&lt; " hours, " &lt;&lt; minutes &lt;&lt; " minutes";<br/>}</p><hr/>
<p><a id="page_577"/>With these changes made, you can test the new definitions with the code shown in <a href="#ch11ex09">Listing 11.9</a>.</p>
<p class="caption1"><a id="ch11ex09"/><strong>Listing 11.9. <code>usetime2.cpp</code></strong></p><hr/>
<p class="programlisting1">// usetime2.cpp -- using the third draft of the Time class<br/>// compile usetime2.cpp and mytime2.cpp together<br/>#include &lt;iostream&gt;<br/>#include "mytime2.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;Time weeding(4, 35);<br/>&#160;&#160;&#160;&#160;Time waxing(2, 47);<br/>&#160;&#160;&#160;&#160;Time total;<br/>&#160;&#160;&#160;&#160;Time diff;<br/>&#160;&#160;&#160;&#160;Time adjusted;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "weeding time = ";<br/>&#160;&#160;&#160;&#160;weeding.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "waxing time = ";<br/>&#160;&#160;&#160;&#160;waxing.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "total work time = ";<br/>&#160;&#160;&#160;&#160;total = weeding + waxing;&#160;&#160;&#160;// use operator+()<br/>&#160;&#160;&#160;&#160;total.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;diff = weeding - waxing;&#160;&#160;&#160;&#160;// use operator-()<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "weeding time - waxing time = ";<br/>&#160;&#160;&#160;&#160;diff.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;adjusted = total * 1.5;&#160;&#160;&#160;&#160;&#160;&#160;// use operator+()<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "adjusted work time = ";<br/>&#160;&#160;&#160;&#160;adjusted.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_578"/>Here is the output of the program in <a href="#ch11ex07">Listings 11.7</a>, <a href="#ch11ex08">11.8</a>, and <a href="#ch11ex09">11.9</a>:</p>
<p class="programlisting">weeding time = 4 hours, 35 minutes<br/>waxing time = 2 hours, 47 minutes<br/>total work time = 7 hours, 22 minutes<br/>weeding time - waxing time = 1 hours, 48 minutes<br/>adjusted work time = 11 hours, 3 minutes</p>
<h3 id="ch11lev1sec3">Introducing Friends</h3>
<p>As you&#8217;ve seen, C++ controls access to the private portions of a class object. Usually, public class methods serve as the only access, but sometimes this restriction is too rigid to fit particular programming problems. In such cases, C++ provides another form of access: the <em>friend</em>. Friends come in three varieties:</p>
<p class="indenthandingB">&#8226; Friend functions</p>
<p class="indenthandingB">&#8226; Friend classes</p>
<p class="indenthandingB">&#8226; Friend member functions</p>
<p>By making a function a friend to a class, you allow the function the same access privileges that a member function of the class has. We&#8217;ll look into friend functions now, leaving the other two varieties to <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>.&#8221;</p>
<p>Before seeing how to make friends, let&#8217;s look into why they might be needed. Often, overloading a binary operator (that is, an operator with two arguments) for a class generates a need for friends. Multiplying a <code>Time</code> object by a real number provides just such a situation, so let&#8217;s study that case.</p>
<p>In the previous <code>Time</code> class example, the overloaded multiplication operator is different from the other two overloaded operators in that it combines two different types. That is, the addition and subtraction operators each combine two <code>Time</code> values, but the multiplication operator combines a <code>Time</code> value with a <code>double</code> value. This restricts how the operator can be used. Remember, the left operand is the invoking object. That is,</p>
<p class="programlisting">A = B * 2.75;</p>
<p>translates to the following member function call:</p>
<p class="programlisting">A = B.operator*(2.75);</p>
<p>But what about the following statement?</p>
<p class="programlisting">A = 2.75 * B;&#160;&#160;&#160;&#160;&#160;// cannot correspond to a member function</p>
<p>Conceptually, <code>2.75 * B</code> should be the same as <code>B * 2.75</code>, but the first expression cannot correspond to a member function because <code>2.75</code> is not a type <code>Time</code> object. Remember, the left operand is the invoking object, but <code>2.75</code> is not an object. So the compiler cannot replace the expression with a member function call.</p>
<p><a id="page_579"/>One way around this difficulty is to tell everyone (and to remember yourself) that you can only write <code>B * 2.75</code> but never write <code>2.75 * B</code>. This is a server-friendly, client-beware solution, and that&#8217;s not what OOP is about.</p>
<p>However, there is another possibility&#8212;using a nonmember function. (Remember, most operators can be overloaded using either member or nonmember functions.) A nonmember function is not invoked by an object; instead, any values it uses, including objects, are explicit arguments. Thus, the compiler could match the expression</p>
<p class="programlisting">A = 2.75 * B;&#160;&#160;&#160;&#160;&#160;// cannot correspond to a member function</p>
<p>to the following nonmember function call:</p>
<p class="programlisting">A = operator*(2.75, B);</p>
<p>The function would have this prototype:</p>
<p class="programlisting">Time operator*(double m, const Time &#38; t);</p>
<p>With the nonmember overloaded operator function, the left operand of an operator expression corresponds to the first argument of the operator function, and the right operand corresponds to the second argument. Meanwhile, the original member function handles operands in the opposite order&#8212;that is, a <code>Time</code> value multiplied by a <code>double</code> value.</p>
<p>Using a nonmember function solves the problem of getting the operands in the desired order (first <code>double</code> and then <code>Time</code>), but it raises a new problem: Nonmember functions can&#8217;t directly access private data in a class. Well, at least ordinary nonmember functions lack access. But there is a special category of nonmember functions, called <em>friends</em>, that can access private members of a class.</p>
<h4 id="ch11lev2sec4">Creating Friends</h4>
<p>The first step toward creating a friend function is to place a prototype in the class declaration and prefix the declaration with the keyword <code>friend</code>:</p>
<p class="programlisting">friend Time operator*(double m, const Time &#38; t);&#160;&#160;// goes in class declaration</p>
<p>This prototype has two implications:</p>
<p class="indenthandingB">&#8226; Although the <code>operator*()</code> function is declared in the class declaration, it is not a member function. So it isn&#8217;t invoked by using the membership operator.</p>
<p class="indenthandingB">&#8226; Although the <code>operator*()</code> function is not a member function, it has the same access rights as a member function.</p>
<p>The second step is to write the function definition. Because it is not a member function, you don&#8217;t use the <code>Time::</code> qualifier. Also you don&#8217;t use the <code>friend</code> keyword in the definition. The definition should look like this:</p>
<p class="programlisting">Time operator*(double m, const Time &#38; t)&#160;&#160;// friend not used in definition<br/>{<br/>&#160;&#160;&#160;&#160;Time result;<br/>&#160;&#160;&#160;&#160;long totalminutes = t.hours * mult * 60 +t. minutes * mult;<br/>&#160;&#160;&#160;&#160;result.hours = totalminutes / 60;<br/><a id="page_580"/>&#160;&#160;&#160;&#160;result.minutes = totalminutes % 60;<br/>&#160;&#160;&#160;&#160;return result;<br/>}</p>
<p>With this declaration and definition, the statement</p>
<p class="programlisting">A = 2.75 * B;</p>
<p>translates to the following and invokes the nonmember friend function just defined:</p>
<p class="programlisting">A = operator*(2.75, B);</p>
<p>In short, a friend function to a class is a nonmember function that has the same access rights as a member function.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch11sb01"/>Are Friends Unfaithful to OOP?</p>
<p class="sidebarpara">At first glance, it might seem that friends violate the OOP principle of data hiding because the friend mechanism allows nonmember functions to access private data. However, that&#8217;s an overly narrow view. Instead, you should think of friend functions as part of an extended interface for a class. For example, from a conceptual point of view, multiplying a <code>double</code> by a <code>Time</code> value is pretty much the same as multiplying a <code>Time</code> value by a <code>double</code>. That the first requires a friend function whereas the second can be done with a member function is the result of C++ syntax, not of a deep conceptual difference. By using both a friend function and a class method, you can express either operation with the same user interface. Also keep in mind that only a class declaration can decide which functions are friends, so the class declaration still controls which functions access private data. In short, class methods and friends are simply two different mechanisms for expressing a class interface.</p>
<hr/></div>
<p>Actually, you can write this particular friend function as a non-friend by altering the definition so that it switches which value comes first in the multiplication:</p>
<p class="programlisting">Time operator*(double m, const Time &#38; t)<br/>{<br/>&#160;&#160;&#160;&#160;return t * m;&#160;&#160;&#160;&#160;&#160;// use t.operator*(m)<br/>}</p>
<p>The original version accessed <code>t.minutes</code> and <code>t.hours</code> explicitly, so it had to be a friend. This version only uses the <code>Time</code> object <code>t</code> as a whole, letting a member function handle the private values, so this version doesn&#8217;t have to be a friend. Nonetheless, there are reasons to make this version a friend, too. Most importantly, it ties the function in as part of the official class interface. Second, if you later find a need for the function to access private data directly, you only have to change the function definition and not the class prototype.</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note03"/>Tip</p>
<p class="notepara">If you want to overload an operator for a class and you want to use the operator with a nonclass term as the first operand, you can use a friend function to reverse the operand order.</p>
<hr/></div>
<h4 id="ch11lev2sec5">A Common Kind of Friend: Overloading the <code>&lt;&lt;</code> Operator</h4>
<p><a id="page_581"/>One very useful feature of classes is that you can overload the <code>&lt;&lt;</code> operator so that you can use it with <code>cout</code> to display an object&#8217;s contents. In some ways, this overloading is a bit trickier than the earlier examples, so we&#8217;ll develop it in two steps instead of in one.</p>
<p>Suppose <code>trip</code> is a <code>Time</code> object. To display <code>Time</code> values, we&#8217;ve been using <code>Show()</code>. Wouldn&#8217;t it be nice, however, if you could do the following?</p>
<p class="programlisting">cout &lt;&lt; trip;&#160;&#160;// make cout recognize Time class?</p>
<p>You can do this because <code>&lt;&lt;</code> is one of the C++ operators that can be overloaded. In fact, it already is heavily overloaded. In its most basic incarnation, the <code>&lt;&lt;</code> operator is one of C and C++&#8217;s bit manipulation operators; it shifts bits left in a value (see <a href="app05.html#app05">Appendix E</a>). But the <code>ostream</code> class overloads the operator, converting it into an output tool. Recall that <code>cout</code> is an <code>ostream</code> object and that it is smart enough to recognize all the basic C++ types. That&#8217;s because the <code>ostream</code> class declaration includes an overloaded <code>operator&lt;&lt;()</code> definition for each of the basic types. That is, one definition uses an <code>int</code> argument, one uses a <code>double</code> argument, and so on. So one way to teach <code>cout</code> to recognize a <code>Time</code> object is to add a new function operator definition to the <code>ostream</code> class declaration. But it&#8217;s a dangerous idea to alter the <code>iostream</code> file and mess around with a standard interface. Instead, use the <code>Time</code> class declaration to teach the <code>Time</code> class how to use <code>cout</code>.</p>
<h5 id="ch11lev3sec1">The First Version of Overloading <code>&lt;&lt;</code></h5>
<p>To teach the <code>Time</code> class to use <code>cout</code>, you can use a friend function. Why? Because a statement like the following uses two objects, with the <code>ostream</code> class object (<code>cout</code>) first:</p>
<p class="programlisting">cout &lt;&lt; trip;</p>
<p>If you use a <code>Time</code> member function to overload <code>&lt;&lt;</code>, the <code>Time</code> object would come first, as it did when you overloaded the <code>*</code> operator with a member function. That means you would have to use the <code>&lt;&lt;</code> operator this way:</p>
<p class="programlisting">trip &lt;&lt; cout;&#160;&#160;&#160;// if operator&lt;&lt;() were a Time member function</p>
<p>This would be confusing. But by using a friend function, you can overload the operator this way:</p>
<p class="programlisting">void operator&lt;&lt;(ostream &#38; os, const Time &#38; t)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; t.hours &lt;&lt; " hours, " &lt;&lt; t.minutes &lt;&lt; " minutes";<br/>}</p>
<p>This lets you use</p>
<p class="programlisting">cout &lt;&lt; trip;</p>
<p>to print data in the following format:</p>
<p class="programlisting">4 hours, 23 minutes</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch11sb02"/><a id="page_582"/>Friend or No Friend?</p>
<p class="sidebarpara">The new <code>Time</code> class declaration makes the <code>operator&lt;&lt;()</code> function a friend function to the <code>Time</code> class. But this function, although not inimical to the <code>ostream</code> class, is not a friend to that class. The <code>operator&lt;&lt;()</code> function takes an <code>ostream</code> argument and a <code>Time</code> argument, so it might seem that this function has to be a friend to both classes. If you look at the code for the function, however, you&#8217;ll notice that the function accesses individual members of the <code>Time</code> object but only uses the <code>ostream</code> object as a whole. Because <code>operator&lt;&lt;()</code> accesses private <code>Time</code> object members directly, it has to be a friend to the <code>Time</code> class. But because it does not directly access private <code>ostream</code> object members, the function does not have to be a friend to the <code>ostream</code> class. That&#8217;s nice because it means you don&#8217;t have to tinker with the <code>ostream</code> definition.</p>
<hr/></div>
<p>Note that the new <code>operator&lt;&lt;()</code> definition uses the <code>ostream</code> reference <code>os</code> as its first argument. Normally, <code>os</code> refers to the <code>cout</code> object, as it does in the expression <code>cout &lt;&lt; trip</code>. But you could use the operator with other <code>ostream</code> objects, in which case <code>os</code> would refer to those objects.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch11sb03"/>What? You Don&#8217;t Know of Any Other <code>ostream</code> Objects?</p>
<p class="sidebarpara">Another <code>ostream</code> object is <code>cerr</code>, which routes output to the standard error stream, which, by default, is the display. But in Unix, Linux, and the Windows Command Line environment you can redirect the standard error stream to a file. Also recall that <a href="ch06.html#ch06">Chapter 6</a>, &#8220;<a href="ch06.html#ch06">Branching Statements and Logical Operators</a>,&#8221; introduces <code>ofstream</code> objects, which can be used to send output to a file. Through the magic of inheritance (see <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a href="ch13.html#ch13">Class Inheritance</a>&#8221;), <code>ofstream</code> objects can use <code>ostream</code> methods. Thus you can use the <code>operator&lt;&lt;()</code> definition to write <code>Time</code> data to files as well as to the screen. You just pass a suitably initialized <code>ofstream</code> object instead of <code>cout</code> as the first argument.</p>
<hr/></div>
<p>The call <code>cout &lt;&lt; trip</code> should use the <code>cout</code> object itself, not a copy, so the function passes the object as a reference instead of by value. Thus, the expression <code>cout &lt;&lt; trip</code> causes <code>os</code> to be an alias for <code>cout</code>, and the expression <code>cerr &lt;&lt; trip</code> causes <code>os</code> to be an alias for <code>cerr</code>. The <code>Time</code> object can be passed by value or by reference because either form makes the object values available to the function. Again, passing by reference uses less memory and time than passing by value.</p>
<h5 id="ch11lev3sec2">The Second Version of Overloading <code>&lt;&lt;</code></h5>
<p>The implementation just presented has a problem. Statements such as this work fine:</p>
<p class="programlisting">cout &lt;&lt; trip;</p>
<p>But the implementation doesn&#8217;t allow you to combine the redefined <code>&lt;&lt;</code> operator with the ones <code>cout</code> normally uses:</p>
<p class="programlisting">cout &lt;&lt; "Trip time: " &lt;&lt; trip &lt;&lt; " (Tuesday)\n"; // can't do</p>
<p>To understand why this doesn&#8217;t work and what must be done to make it work, you first need to know a bit more about how <code>cout</code> operates. Consider the following statements:</p>
<p class="programlisting"><a id="page_583"/>int x = 5;<br/>int y = 8;<br/>cout &lt;&lt; x &lt;&lt; y;</p>
<p>C++ reads the output statement from left to right, meaning it is equivalent to the following:</p>
<p class="programlisting">(cout &lt;&lt; x) &lt;&lt; y;</p>
<p>The <code>&lt;&lt;</code> operator, as defined in <code>iostream</code>, takes an <code>ostream</code> object to its left. Clearly, the expression <code>cout &lt;&lt; x</code> satisfies that requirement because <code>cout</code> is an <code>ostream</code> object. But the output statement also requires that the whole expression <code>(cout &lt;&lt; x)</code> be a type <code>ostream</code> object because that expression is to the left of <code>&lt;&lt; y</code>. Therefore, the <code>ostream</code> class implements the <code>operator&lt;&lt;()</code> function so that it returns a reference to an <code>ostream</code> object. In particular, it returns a reference to the invoking object&#8212;<code>cout</code>, in this case. Thus, the expression <code>(cout &lt;&lt; x)</code> is itself the <code>ostream</code> object <code>cout</code>, and it can be used to the left of the <code>&lt;&lt;</code> operator.</p>
<p>You can take the same approach with the friend function. You just revise the <code>operator&lt;&lt;()</code> function so that it returns a reference to an <code>ostream</code> object:</p>
<p class="programlisting">ostream &#38; operator&lt;&lt;(ostream &#38; os, const Time &#38; t)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; t.hours &lt;&lt; " hours, " &lt;&lt; t.minutes &lt;&lt; " minutes";<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p>Note that the return type is <code>ostream &#38;</code>. Recall that this means that the function returns a reference to an <code>ostream</code> object. Because a program passes an object reference to the function to begin with, the net effect is that the function&#8217;s return value is just the object passed to it. That is, the statement</p>
<p class="programlisting">cout &lt;&lt; trip;</p>
<p>becomes the following function call:</p>
<p class="programlisting">operator&lt;&lt;(cout, trip);</p>
<p>And that call returns the <code>cout</code> object. So now the following statement does work:</p>
<p class="programlisting">cout &lt;&lt; "Trip time: " &lt;&lt; trip &lt;&lt; " (Tuesday)\n"; // can do</p>
<p>Let&#8217;s break this into separate steps to see how it works. First, the following invokes the particular <code>ostream</code> definition of <code>&lt;&lt;</code> that displays a string and returns the <code>cout</code> object:</p>
<p class="programlisting">cout &lt;&lt; "Trip time: "</p>
<p>So the expression <code>cout &lt;&lt; "Trip time: "</code> displays the string and then is replaced by its return value, <code>cout</code>. This reduces the original statement to the following one:</p>
<p class="programlisting">cout &lt;&lt; trip &lt;&lt; " (Tuesday)\n";</p>
<p><a id="page_584"/>Next, the program uses the <code>Time</code> declaration of <code>&lt;&lt;</code> to display the trip values and to return the <code>cout</code> object again. This reduces the statement to the following:</p>
<p class="programlisting">cout &lt;&lt; " (Tuesday)\n";</p>
<p>The program now finishes up by using the <code>ostream</code> definition of <code>&lt;&lt;</code> for strings to display the final string.</p>
<p>As a point of interest, this version of <code>operator&lt;&lt;()</code> also can be used for file output:</p>
<p class="programlisting">#include &lt;fstream&gt;<br/>...<br/>ofstream fout;<br/>fout.open("savetime.txt");<br/>Time trip(12, 40);<br/>fout &lt;&lt; trip;</p>
<p>The last statement becomes this:</p>
<p class="programlisting">operator&lt;&lt;(fout, trip);</p>
<p>And as <a href="ch08.html#ch08">Chapter 8</a> points out, the properties of class inheritance allow an <code>ostream</code> reference to refer to <code>ostream</code> objects and to <code>ofstream</code> objects.</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note04"/>Tip</p>
<p class="notepara">In general, to overload the <code>&lt;&lt;</code> operator to display an object of class <em><code>c_name</code></em>, you use a friend function with a definition in this form:</p>
<p class="programlistingB">ostream &#38; operator&lt;&lt;(ostream &#38; os, const <span class="EmpItalic">c_name</span> &#38; obj)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; ... ;&#160;&#160;// display object contents<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<hr/></div>
<p><a href="#ch11ex10">Listing 11.10</a> shows the class definition as modified to include the two friend functions <code>operator*()</code> and <code>operator&lt;&lt;()</code>. It implements the first of these as an inline function because the code is so short. (When the definition is also the prototype, as in this case, you use the <code>friend</code> prefix.)</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note05"/>Caution</p>
<p class="notepara">You use the <code>friend</code> keyword only in the prototype found in the class declaration. You don&#8217;t use it in the function definition unless the definition is also the prototype.</p>
<hr/></div>
<p class="caption1"><a id="ch11ex10"/><strong>Listing 11.10. <code>mytime3.h</code></strong></p><hr/>
<p class="programlisting1">// mytime3.h -- Time class with friends<br/>#ifndef MYTIME3_H_<br/>#define MYTIME3_H_<br/>#include &lt;iostream&gt;<br/><br/>class Time<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int hours;<br/>&#160;&#160;&#160;&#160;int minutes;<br/>public:<br/>&#160;&#160;&#160;&#160;Time();<br/>&#160;&#160;&#160;&#160;Time(int h, int m = 0);<br/>&#160;&#160;&#160;&#160;void AddMin(int m);<br/>&#160;&#160;&#160;&#160;void AddHr(int h);<br/>&#160;&#160;&#160;&#160;void Reset(int h = 0, int m = 0);<br/>&#160;&#160;&#160;&#160;Time operator+(const Time &#38; t) const;<br/>&#160;&#160;&#160;&#160;Time operator-(const Time &#38; t) const;<br/>&#160;&#160;&#160;&#160;Time operator*(double n) const;<br/>&#160;&#160;&#160;&#160;friend Time operator*(double m, const Time &#38; t)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return t * m; }&#160;&#160;&#160;// inline definition<br/>&#160;&#160;&#160;&#160;friend std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const Time &#38; t);<br/>};<br/><br/>#endif</p><hr/>
<p><a id="page_585"/><a href="#ch11ex11">Listing 11.11</a> shows the revised set of definitions. Note again that the methods use the <code>Time::</code> qualifier, whereas the friend function does not. Also note that because <code>mytime3.h</code> includes <code>iostream</code> and provides the <code>using</code> declaration <code>std::ostream</code>, including <code>mytime3.h</code> in <code>mytime3.cpp</code> provides support for using <code>ostream</code> in the implementation file.</p>
<p class="caption1"><a id="ch11ex11"/><strong>Listing 11.11. <code>mytime3.cpp</code></strong></p><hr/>
<p class="programlisting1">// mytime3.cpp&#160;&#160;-- implementing Time methods<br/>#include "mytime3.h"<br/><br/>Time::Time()<br/>{<br/>&#160;&#160;&#160;&#160;hours = minutes = 0;<br/>}<br/><br/>Time::Time(int h, int m )<br/>{<br/>&#160;&#160;&#160;&#160;hours = h;<br/>&#160;&#160;&#160;&#160;minutes = m;<br/>}<br/><br/>void Time::AddMin(int m)<br/>{<br/>&#160;&#160;&#160;&#160;minutes += m;<br/>&#160;&#160;&#160;&#160;hours += minutes / 60;<br/>&#160;&#160;&#160;&#160;minutes %= 60;<br/>}<br/><br/><a id="page_586"/>void Time::AddHr(int h)<br/>{<br/>&#160;&#160;&#160;&#160;hours += h;<br/>}<br/><br/>void Time::Reset(int h, int m)<br/>{<br/>&#160;&#160;&#160;&#160;hours = h;<br/>&#160;&#160;&#160;&#160;minutes = m;<br/>}<br/><br/>Time Time::operator+(const Time &#38; t) const<br/>{<br/>&#160;&#160;&#160;&#160;Time sum;<br/>&#160;&#160;&#160;&#160;sum.minutes = minutes + t.minutes;<br/>&#160;&#160;&#160;&#160;sum.hours = hours + t.hours + sum.minutes / 60;<br/>&#160;&#160;&#160;&#160;sum.minutes %= 60;<br/>&#160;&#160;&#160;&#160;return sum;<br/>}<br/><br/>Time Time::operator-(const Time &#38; t) const<br/>{<br/>&#160;&#160;&#160;&#160;Time diff;<br/>&#160;&#160;&#160;&#160;int tot1, tot2;<br/>&#160;&#160;&#160;&#160;tot1 = t.minutes + 60 * t.hours;<br/>&#160;&#160;&#160;&#160;tot2 = minutes + 60 * hours;<br/>&#160;&#160;&#160;&#160;diff.minutes = (tot2 - tot1) % 60;<br/>&#160;&#160;&#160;&#160;diff.hours = (tot2 - tot1) / 60;<br/>&#160;&#160;&#160;&#160;return diff;<br/>}<br/><br/>Time Time::operator*(double mult) const<br/>{<br/>&#160;&#160;&#160;&#160;Time result;<br/>&#160;&#160;&#160;&#160;long totalminutes = hours * mult * 60 + minutes * mult;<br/>&#160;&#160;&#160;&#160;result.hours = totalminutes / 60;<br/>&#160;&#160;&#160;&#160;result.minutes = totalminutes % 60;<br/>&#160;&#160;&#160;&#160;return result;<br/>}<br/><br/>std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const Time &#38; t)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; t.hours &lt;&lt; " hours, " &lt;&lt; t.minutes &lt;&lt; " minutes";<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p><hr/>
<p><a id="page_587"/><a href="#ch11ex12">Listing 11.12</a> shows a sample program. Technically, <code>usetime3.cpp</code> doesn&#8217;t have to include <code>iostream</code> because <code>mytime3.h</code> already includes that file. However, as a user of the <code>Time</code> class, you don&#8217;t necessarily know which files are included in the class code, so you would take the responsibility of declaring those header files that you know your part of the code needs.</p>
<p class="caption1"><a id="ch11ex12"/><strong>Listing 11.12. <code>usetime3.cpp</code></strong></p><hr/>
<p class="programlisting1">//usetime3.cpp -- using the fourth draft of the Time class<br/>// compile usetime3.cpp and mytime3.cpp together<br/>#include &lt;iostream&gt;<br/>#include "mytime3.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;Time aida(3, 35);<br/>&#160;&#160;&#160;Time tosca(2, 48);<br/>&#160;&#160;&#160;Time temp;<br/><br/>&#160;&#160;&#160;cout &lt;&lt; "Aida and Tosca:\n";<br/>&#160;&#160;&#160;cout &lt;&lt; aida&lt;&lt;"; " &lt;&lt; tosca &lt;&lt; endl;<br/>&#160;&#160;&#160;temp = aida + tosca;&#160;&#160;&#160;&#160;&#160;// operator+()<br/>&#160;&#160;&#160;cout &lt;&lt; "Aida + Tosca: " &lt;&lt; temp &lt;&lt; endl;<br/>&#160;&#160;&#160;temp = aida* 1.17;&#160;&#160;// member operator*()<br/>&#160;&#160;&#160;cout &lt;&lt; "Aida * 1.17: " &lt;&lt; temp &lt;&lt; endl;<br/>&#160;&#160;&#160;cout &lt;&lt; "10.0 * Tosca: " &lt;&lt; 10.0 * tosca &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch11ex10">Listings 11.10</a>, <a href="#ch11ex11">11.11</a>, and <a href="#ch11ex12">11.12</a>:</p>
<p class="programlisting">Aida and Tosca:<br/>3 hours, 35 minutes; 2 hours, 48 minutes<br/>Aida + Tosca: 6 hours, 23 minutes<br/>Aida * 1.17: 4 hours, 11 minutes<br/>10.0 * Tosca: 28 hours, 0 minutes</p>
<h3 id="ch11lev1sec4">Overloaded Operators: Member Versus Nonmember Functions</h3>
<p>For many operators, you have a choice between using member functions or nonmember functions to implement operator overloading. Typically, the nonmember version is a friend <a id="page_588"/>function so that it can directly access the private data for a class. For example, consider the addition operator for the <code>Time</code> class. It has this prototype in the <code>Time</code> class declaration:</p>
<p class="programlisting">Time operator+(const Time &#38; t) const; // member version</p>
<p>Instead, the class could use the following prototype:</p>
<p class="programlisting">// nonmember version<br/>friend Time operator+(const Time &#38; t1, const Time &#38; t2);</p>
<p>The addition operator requires two operands. For the member function version, one is passed implicitly via the <code>this</code> pointer and the second is passed explicitly as a function argument. For the friend version, both are passed as arguments.</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note06"/>Note</p>
<p class="notepara">A nonmember version of an overloaded operator function requires as many formal parameters as the operator has operands. A member version of the same operator requires one fewer parameter because one operand is passed implicitly as the invoking object.</p>
<hr/></div>
<p>Either of these two prototypes matches the expression <code>T2 + T3</code>, where <code>T2</code> and <code>T3</code> are type <code>Time</code> objects. That is, the compiler can convert the statement</p>
<p class="programlisting">T1 = T2 + T3;</p>
<p>to either of the following:</p>
<p class="programlisting">T1 = T2.operator+(T3);&#160;&#160;&#160;&#160;// member function<br/>T1 = operator+(T2, T3);&#160;&#160;&#160;// nonmember function</p>
<p>Keep in mind that you must choose one or the other form when defining a given operator, but not both. Because both forms match the same expression, defining both forms is an ambiguity error, leading to a compilation error.</p>
<p>Which form, then, is it best to use? For some operators, as mentioned earlier, the member function is the only valid choice. Otherwise, it often doesn&#8217;t make much difference. Sometimes, depending on the class design, the nonmember version may have an advantage, particularly if you have defined type conversions for the class. The section &#8220;<a href="#ch11lev2sec12">Conversions and Friends</a>,&#8221; near the end of this chapter, discusses this situation further.</p>
<h3 id="ch11lev1sec5">More Overloading: A Vector Class</h3>
<p>Let&#8217;s look at another class design that uses operator overloading and friends&#8212;a class representing vectors. This class also illustrates further aspects of class design, such as incorporating two different ways of describing the same thing into an object. Even if you don&#8217;t care for vectors, you can use many of the new techniques shown here in other contexts. A <em>vector</em>, as the term is used in engineering and physics, is a quantity that has both a magnitude (size) and a direction. For example, if you push something, the effect depends on how hard you push (the magnitude) and in what direction you push. A push in one direction can save a tottering vase, whereas a push in another direction can hasten its rush to doom. To fully describe the motion of your car, you should give both the speed (the <a id="page_589"/>magnitude) and the direction; arguing with the highway patrol that you were driving under the speed limit carries little weight if you were traveling in the wrong direction. (Immunologists and computer scientists may use the term <em>vector</em> differently; ignore them, at least until <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library,&#8221; which looks at a computer science version, the <code>vector</code> template class.) The following sidebar tells you more about vectors, but understanding them completely isn&#8217;t necessary for following the C++ aspects of the examples.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch11sb04"/>Vectors</p>
<p class="sidebarpara">Say you&#8217;re a worker bee and have discovered a marvelous nectar cache. You rush back to the hive and announce that you&#8217;ve found nectar 120 yards away. &#8220;Not enough information,&#8221; buzz the other bees. &#8220;You have to tell us the direction, too!&#8221; You answer, &#8220;It&#8217;s 30 degrees north of the sun direction.&#8221; Knowing both the distance (magnitude) and the direction, the other bees rush to the sweet site. Bees know vectors.</p>
<p class="sidebarpara">Many quantities involve both a magnitude and a direction. The effect of a push, for example, depends on both its strength and direction. Moving an object on a computer screen involves a distance and a direction. You can describe such things by using vectors. For example, you can describe moving (displacing) an object onscreen with a vector, which you can visualize as an arrow drawn from the starting position to the final position. The length of the vector is its magnitude, and that describes how far the point has been displaced. The orientation of the arrow describes the direction (see <a href="#ch11fig01">Figure 11.1</a>). A vector representing such a change in position is called a <em>displacement vector</em>.</p>
<p class="caption"><a id="ch11fig01"/><strong>Figure 11.1. Describing a displacement with a vector.</strong></p>
<p class="image"><img src="graphics/11fig01.jpg" alt="Image"/></p>
<p class="sidebarpara">Now say you&#8217;re Lhanappa, the great mammoth hunter. Scouts report a mammoth herd 14.1 kilometers to the northwest. But because of a southeast wind, you don&#8217;t want to approach from the southeast. So you go 10 kilometers west and then 10 kilometers north, approaching the herd from the south. You know these two displacement vectors bring you to the same location as the single 14.1-kilometer vector pointing northwest. Lhanappa, the great mammoth hunter, also knows how to add vectors.</p>
<p class="sidebarpara">Adding two vectors has a simple geometric interpretation. First, draw one vector. Then draw the second vector, starting from the arrow end of the first vector. Finally, draw a vector from the starting point of the first vector to the endpoint of the second vector. This third vector represents the sum of the first two (see <a href="#ch11fig02">Figure 11.2</a>). Note that the length of the sum can be less than the sum of the individual lengths.</p>
<p class="caption"><a id="ch11fig02"/><strong>Figure 11.2. Adding two vectors.</strong></p>
<p class="image"><img src="graphics/11fig02.jpg" alt="Image"/></p>
<hr/></div>
<p><a id="page_590"/>Vectors are a natural choice for operator overloading. First, you can&#8217;t represent a vector with a single number, so it makes sense to create a class to represent vectors. Second, vectors have analogs to ordinary arithmetic operations such as addition and subtraction. This parallel suggests overloading the corresponding operators so you can use them with vectors.</p>
<p>To keep things simple, in this section we&#8217;ll implement a two-dimensional vector, such as a screen displacement, instead of a three-dimensional vector, such as might represent movement of a helicopter or a gymnast. You need just two numbers to describe a two-dimensional vector, but you have a choice of what set of two numbers:</p>
<p class="indenthandingB">&#8226; You can describe a vector by its magnitude (length) and direction (an angle).</p>
<p class="indenthandingB">&#8226; You can represent a vector by its x and y components.</p>
<p>The components are a horizontal vector (the x component) and a vertical vector (the y component), which add up to the final vector. For example, you can describe a motion as moving a point 30 units to the right and 40 units up (see <a href="#ch11fig03">Figure 11.3</a>). That motion puts the point at the same spot as moving 50 units at an angle of 53.1&#176; from the horizontal. Therefore, a vector with a magnitude of 50 and an angle of 53.1&#176; is equivalent to a vector having a horizontal component of 30 and a vertical component of 40. What counts with displacement vectors is where you start and where you end up, not the exact <a id="page_591"/>route taken to get there. This choice of representation is basically the same thing covered with the <a href="ch07.html#ch07">Chapter 7</a> program that converts between rectangular and polar coordinates.</p>
<p class="caption"><a id="ch11fig03"/><strong>Figure 11.3. The x and y components of a vector.</strong></p>
<p class="image"><img src="graphics/11fig03.jpg" alt="Image"/></p>
<p>Sometimes one form is more convenient, sometimes the other, so you&#8217;ll incorporate both representations into the class description. (See the sidebar &#8220;<a href="#ch11sb05">Multiple Representations and Classes</a>,&#8221; later in this chapter.) Also you&#8217;ll design the class so that if you alter one representation of a vector, the object automatically updates the other representation. The ability to build such intelligence into an object is another C++ class virtue. <a href="#ch11ex13">Listing 11.13</a> presents a class declaration. To refresh your memory about namespaces, the listing places the class declaration inside the <code>VECTOR</code> namespace. Also the program uses <code>enum</code> to create a couple constants (<code>RECT</code> and <code>POL</code>) for identifying the two representations. (We covered that technique in <a href="ch10.html#ch10">Chapter 10</a>, so we may as well use it!)</p>
<p class="caption1"><a id="ch11ex13"/><strong>Listing 11.13. <code>vect.h</code></strong></p><hr/>
<p class="programlisting1">// vect.h -- Vector class with &lt;&lt;, mode state<br/>#ifndef VECTOR_H_<br/>#define VECTOR_H_<br/>#include &lt;iostream&gt;<br/>namespace VECTOR<br/>{<br/>&#160;&#160;&#160;&#160;class Vector<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;enum Mode {RECT, POL};<br/>&#160;&#160;&#160;&#160;// RECT for rectangular, POL for Polar modes<br/>&#160;&#160;&#160;&#160;private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// horizontal value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double y;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// vertical value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double mag;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// length of vector<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double ang;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// direction of vector in degrees<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Mode mode;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// RECT or POL<br/>&#160;&#160;&#160;&#160;// private methods for setting values<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void set_mag();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void set_ang();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void set_x();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void set_y();<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Vector();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Vector(double n1, double n2, Mode form = RECT);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void reset(double n1, double n2, Mode form = RECT);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;~Vector();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double xval() const {return x;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;// report x value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double yval() const {return y;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;// report y value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double magval() const {return mag;}&#160;&#160;&#160;// report magnitude<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double angval() const {return ang;}&#160;&#160;&#160;// report angle<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void polar_mode();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set mode to POL<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void rect_mode();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set mode to RECT<br/>&#160;&#160;&#160;&#160;// operator overloading<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Vector operator+(const Vector &#38; b) const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Vector operator-(const Vector &#38; b) const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Vector operator-() const;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Vector operator*(double n) const;<br/>&#160;&#160;&#160;&#160;// friends<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;friend Vector operator*(double n, const Vector &#38; a);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;friend std::ostream &#38;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;operator&lt;&lt;(std::ostream &#38; os, const Vector &#38; v);<br/>&#160;&#160;&#160;&#160;};<br/><br/>}&#160;&#160;&#160;// end namespace VECTOR<br/>#endif</p><hr/>
<p><a id="page_592"/>Notice that the four functions in <a href="#ch11ex13">Listing 11.13</a> that report component values are defined in the class declaration. This automatically makes them inline functions. The fact that these functions are so short makes them excellent candidates for inlining. None of them should alter object data, so they are declared using the <code>const</code> modifier. As you may recall from <a href="ch10.html#ch10">Chapter 10</a>, this is the syntax for declaring a function that doesn&#8217;t modify the object it implicitly accesses.</p>
<p><a href="#ch11ex14">Listing 11.14</a> shows all the methods and friend functions declared in <a href="#ch11ex13">Listing 11.13</a>. The listing uses the open nature of namespaces to add the method definitions to the <code>VECTOR</code> namespace. Note how the constructor functions and the <code>reset()</code> function each set both the rectangular and the polar representations of the vector. Thus, either set of values is available immediately without further calculation, should you need them. Also as mentioned in <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; and <a href="ch07.html#ch07">Chapter 7</a>, C++&#8217;s built-in math functions use angles in radians, so the functions build conversion to and from degrees into the methods. The <code>Vector</code> class implementation hides such things as converting from polar coordinates to rectangular coordinates or converting radians to degrees from the user. <a id="page_593"/>All the user needs to know is that the class uses angles in degrees and that it makes a vector available in two equivalent representations.</p>
<p class="caption1"><a id="ch11ex14"/><strong>Listing 11.14. <code>vect.cpp</code></strong></p><hr/>
<p class="programlisting1">// vect.cpp -- methods for the Vector class<br/>#include &lt;cmath&gt;<br/>#include "vect.h"&#160;&#160;&#160;// includes &lt;iostream&gt;<br/>using std::sqrt;<br/>using std::sin;<br/>using std::cos;<br/>using std::atan;<br/>using std::atan2;<br/>using std::cout;<br/><br/>namespace VECTOR<br/>{<br/>&#160;&#160;&#160;&#160;// compute degrees in one radian<br/>&#160;&#160;&#160;&#160;const double Rad_to_deg = 45.0 / atan(1.0);<br/>&#160;&#160;&#160;&#160;// should be about 57.2957795130823<br/><br/>&#160;&#160;&#160;&#160;// private methods<br/>&#160;&#160;&#160;&#160;// calculates magnitude from x and y<br/>&#160;&#160;&#160;&#160;void Vector::set_mag()<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mag = sqrt(x * x + y * y);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;void Vector::set_ang()<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (x == 0.0 &#38;&#38; y == 0.0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ang = 0.0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ang = atan2(y, x);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// set x from polar coordinate<br/>&#160;&#160;&#160;&#160;void Vector::set_x()<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x = mag * cos(ang);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// set y from polar coordinate<br/>&#160;&#160;&#160;&#160;void Vector::set_y()<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y = mag * sin(ang);<br/>&#160;&#160;&#160;&#160;}<br/><br/><a id="page_594"/>&#160;&#160;&#160;&#160;// public methods<br/>&#160;&#160;&#160;&#160;Vector::Vector()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x = y = mag = ang = 0.0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode = RECT;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// construct vector from rectangular coordinates if form is r<br/>&#160;&#160;&#160;&#160;// (the default) or else from polar coordinates if form is p<br/>&#160;&#160;&#160;&#160;Vector::Vector(double n1, double n2, Mode form)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode = form;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (form == RECT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x = n1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y = n2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_mag();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_ang();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (form == POL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mag = n1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ang = n2 / Rad_to_deg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_x();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_y();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Incorrect 3rd argument to Vector() -- ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "vector set to 0\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x = y = mag = ang = 0.0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode = RECT;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// reset vector from rectangular coordinates if form is<br/>&#160;&#160;&#160;&#160;// RECT (the default) or else from polar coordinates if<br/>&#160;&#160;&#160;&#160;// form is POL<br/>&#160;&#160;&#160;&#160;void Vector:: reset(double n1, double n2, Mode form)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode = form;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (form == RECT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x = n1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y = n2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_mag();<br/><a id="page_595"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_ang();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (form == POL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mag = n1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ang = n2 / Rad_to_deg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_x();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_y();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Incorrect 3rd argument to Vector() -- ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "vector set to 0\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x = y = mag = ang = 0.0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode = RECT;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;Vector::~Vector()&#160;&#160;&#160;&#160;// destructor<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;void Vector::polar_mode()&#160;&#160;&#160;&#160;// set to polar mode<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode = POL;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;void Vector::rect_mode()&#160;&#160;&#160;&#160;&#160;// set to rectangular mode<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode = RECT;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// operator overloading<br/>&#160;&#160;&#160;&#160;// add two Vectors<br/>&#160;&#160;&#160;&#160;Vector Vector::operator+(const Vector &#38; b) const<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return Vector(x + b.x, y + b.y);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// subtract Vector b from a<br/>&#160;&#160;&#160;&#160;Vector Vector::operator-(const Vector &#38; b) const<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return Vector(x - b.x, y - b.y);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// reverse sign of Vector<br/>&#160;&#160;&#160;&#160;Vector Vector::operator-() const<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return Vector(-x, -y);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// multiply vector by n<br/>&#160;&#160;&#160;&#160;Vector Vector::operator*(double n) const<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return Vector(n * x, n * y);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// friend methods<br/>&#160;&#160;&#160;&#160;// multiply n by Vector a<br/>&#160;&#160;&#160;&#160;Vector operator*(double n, const Vector &#38; a)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return a * n;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// display rectangular coordinates if mode is RECT,<br/>&#160;&#160;&#160;&#160;// else display polar coordinates if mode is POL<br/>&#160;&#160;&#160;&#160;std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const Vector &#38; v)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (v.mode == Vector::RECT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; "(x,y) = (" &lt;&lt; v.x &lt;&lt; ", " &lt;&lt; v.y &lt;&lt; ")";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (v.mode == Vector::POL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; "(m,a) = (" &lt;&lt; v.mag &lt;&lt; ", "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; v.ang * Rad_to_deg &lt;&lt; ")";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; "Vector object mode is invalid";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return os;<br/>&#160;&#160;&#160;&#160;}<br/><br/>}&#160;&#160;// end namespace VECTOR</p><hr/>
<p><a id="page_596"/>You could design the class differently. For example, the object could store the rectangular coordinates and not the polar coordinates. In that case, the computation of polar coordinates could be moved to the <code>magval()</code> and <code>angval()</code> methods. For applications in which conversions are seldom used, this could be a more efficient design. Also the <code>reset()</code> method isn&#8217;t really needed. Suppose <code>shove</code> is a <code>Vector</code> object and that you have the following code:</p>
<p class="programlisting">shove.reset(100,300);</p>
<p><a id="page_597"/>You can get the same result by using a constructor instead:</p>
<p class="programlisting">shove = Vector(100,300);&#160;&#160;&#160;&#160;// create and assign a temporary object</p>
<p>However, the <code>set()</code> method alters the contents of <code>shove</code> directly, whereas using the constructor adds the extra steps of creating a temporary object and assigning it to <code>shove</code>.</p>
<p>These design decisions follow the OOP tradition of having the class interface concentrate on the essentials (the abstract model) while hiding the details. Thus, when you use the <code>Vector</code> class, you can think about a vector&#8217;s general features, such as that they can represent displacements and that you can add two vectors. Whether you express a vector in component notation or in magnitude, direction notation becomes secondary because you can set a vector&#8217;s values and display them in whichever format is most convenient at the time.</p>
<p>We&#8217;ll look at some of the features the <code>Vector</code> class in more detail next.</p>
<h4 id="ch11lev2sec6">Using a State Member</h4>
<p>The Vector class stores both the rectangular coordinates and the polar coordinates for a vector. It uses a member called <code>mode</code> to control which form the constructor, the <code>reset()</code> method, and the overloaded <code>operator&lt;&lt;()</code> function use, with the enumerations <code>RECT</code> representing the rectangular mode (the default) and <code>POL</code> the polar mode. Such a member is termed a <em>state member</em> because it describes the state an object is in. To see what this means, look at the code for the constructor:</p>
<p class="programlisting">Vector::Vector(double n1, double n2, Mode form)<br/>{<br/>&#160;&#160;&#160;&#160;mode = form;<br/>&#160;&#160;&#160;&#160;if (form == RECT)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x = n1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y = n2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_mag();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_ang();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else if (form == POL)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mag = n1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ang = n2 / Rad_to_deg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_x();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_y();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Incorrect 3rd argument to Vector() -- ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "vector set to 0\n";<br/><a id="page_598"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x = y = mag = ang = 0.0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mode = RECT;<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<p>If the third argument is <code>RECT</code> or if it is omitted (in which case the prototype assigns a default value of <code>RECT</code>), the inputs are interpreted as rectangular coordinates, whereas a value of <code>POL</code> causes them to be interpreted as polar coordinates:</p>
<p class="programlisting">Vector folly(3.0, 4.0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set x = 3, y = 4<br/>Vector foolery(20.0, 30.0, VECTOR::Vector::POL);&#160;&#160;&#160;// set mag = 20, ang = 30</p>
<p>The identifier <code>POL</code> has class scope, so class definitions can just use the unqualified name. But the fully qualified name is <code>VECTOR::Vector::POL</code> because <code>POL</code> is defined in the <code>Vector</code> class, and <code>Vector</code> is defined in the <code>VECTOR</code> namespace. Note that the constructor uses the private methods <code>set_mag()</code> and <code>set_ang()</code> to set the magnitude and angle values if you provide x and y values, and it uses the private <code>set_x()</code> and <code>set_y()</code> methods to set x and y values if you provide magnitude and angle values. Also note that the constructor delivers a warning message and sets the state to <code>RECT</code> if something other than <code>RECT</code> or <code>POL</code> is specified.</p>
<p>Now it may seem rather difficult to sneak something other than <code>RECT</code> or <code>POL</code> to the constructor because the third argument is type <code>VECTOR::Vector::Mode</code>. A call such as the following won&#8217;t compile because an integer like <code>2</code> can&#8217;t implicitly be converted to an <code>enum</code> type:</p>
<p class="programlisting">Vector rector(20.0, 30.0, 2);&#160;&#160;// type mismatch&#160;&#160;- 2 not an enum type</p>
<p>Still, the resourceful and curious user could try something like the following to see what happens:</p>
<p class="programlisting">Vector rector(20.0, 30.0, VECTOR::Vector::Mode (2));&#160;&#160;// type cast</p>
<p>In this case, he gets admonished.</p>
<p>Next, the <code>operator&lt;&lt;()</code> function uses the mode to determine how values are displayed:</p>
<p class="programlisting">// display rectangular coordinates if mode is RECT,<br/>// else display polar coordinates if mode is POL<br/>std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os, const Vector &#38; v)<br/>{<br/>&#160;&#160;&#160;&#160;if (v.mode == Vector::RECT)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; "(x,y) = (" &lt;&lt; v.x &lt;&lt; ", " &lt;&lt; v.y &lt;&lt; ")";<br/>&#160;&#160;&#160;&#160;else if (v.mode == Vector::POL)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; "(m,a) = (" &lt;&lt; v.mag &lt;&lt; ", "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; v.ang * Rad_to_deg &lt;&lt; ")";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; "Vector object mode is invalid";<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p><a id="page_599"/>Because <code>operator&lt;&lt;()</code> is a friend function and not part of the class scope, it has to use <code>Vector::RECT</code> instead of just <code>RECT</code>. But it is in the <code>VECTOR</code> namespace, so it doesn&#8217;t need to use the fully qualified name of <code>VECTOR::Vector::RECT</code>.</p>
<p>The various methods that can set the mode are careful to accept only <code>RECT</code> and <code>POL</code> as valid values, so the final <code>else</code> in this function should never be reached. Still, it&#8217;s often a good idea to check; such a check can help catch an otherwise obscure programming error.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch11sb05"/>Multiple Representations and Classes</p>
<p class="sidebarpara">Quantities that have different, but equivalent, representations are common. For example, you can measure gasoline consumption in miles per gallon, as done in the United States, or in liters per 100 kilometers, as done in Europe. You can represent a number in string form or numeric form, and you can represent intelligence as an IQ or in kiloturkeys. Classes lend themselves nicely to encompassing different aspects and representations of an entity in a single object. First, you can store multiple representations in one object. Second, you can write the class functions so that assigning values for one representation automatically assigns values for the other representation(s). For example, the <code>set_by_polar()</code> method for the <code>Vector</code> class sets the <code>mag</code> and <code>ang</code> members to the function arguments, but it also sets the <code>x</code> and <code>y</code> members. Or you can store a single representation and use methods to make other representations available. By handling conversions internally, a class can help you think of a quantity in terms of its essential nature rather than in terms of its representation.</p>
<hr/></div>
<h4 id="ch11lev2sec7">Overloading Arithmetic Operators for the <code>Vector</code> Class</h4>
<p>Adding two vectors is very simple when you use x,y coordinates. You just add the two x components to get the x component of the answer and add the two y components to get the y component of the answer. From this description, you might be tempted to use this code:</p>
<p class="programlisting">Vector Vector::operator+(const Vector &#38; b) const<br/>{<br/>&#160;&#160;&#160;&#160;Vector sum;<br/>&#160;&#160;&#160;&#160;sum.x = x + b.x;<br/>&#160;&#160;&#160;&#160;sum.y = y + b.y;<br/>&#160;&#160;&#160;&#160;return sum;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// incomplete version<br/>}</p>
<p>And this would be fine if the object stored only the x and y components. Unfortunately, this version of the code fails to set the polar values. You could fix this problem by adding more code:</p>
<p class="programlisting">Vector Vector::operator+(const Vector &#38; b) const<br/>{<br/>&#160;&#160;&#160;&#160;Vector sum;<br/>&#160;&#160;&#160;&#160;sum.x = x + b.x;<br/>&#160;&#160;&#160;&#160;sum.y = y + b.y;<br/>&#160;&#160;&#160;&#160;sum.set_ang(sum.x, sum.y);<br/><a id="page_600"/>&#160;&#160;&#160;&#160;sum.set_mag(sum.x, sum.y);<br/>&#160;&#160;&#160;&#160;return sum;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// version duplicates needlessly<br/>}</p>
<p>But it is much simpler and more reliable to let a constructor do the work:</p>
<p class="programlisting">Vector Vector::operator+(const Vector &#38; b) const<br/>{<br/>&#160;&#160;&#160;&#160;return Vector(x + b.x, y + b.y);&#160;&#160;&#160;&#160;&#160;&#160;// return the constructed Vector<br/>}</p>
<p>Here, the code hands the <code>Vector</code> constructor the two new values for the x and y components. The constructor then creates a nameless new object, using these values, and the function returns a copy of that object. This way, you guarantee that the new <code>Vector</code> object is created according to the standard rules you lay down in the constructor.</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note07"/>Tip</p>
<p class="notepara">If a method needs to compute a new class object, you should see if you can use a class constructor to do the work. Not only does that save you trouble, it ensures that the new object is constructed in the proper fashion.</p>
<hr/></div>
<h5 id="ch11lev3sec3">Multiplication</h5>
<p>In visual terms, multiplying a vector by a number makes the vector longer or shorter by that factor. So multiplying a vector by 3 produces a vector with three times the length, but still pointed in the same direction. It&#8217;s easy to translate that image into how the <code>Vector</code> class represents a vector. In polar terms, you multiply the magnitude and leave the angle alone. In rectangular terms, you multiply a vector by a number by multiplying its x and y components separately by the number. That is, if a vector has components of 5 and 12, multiplying by 3 makes the components 15 and 36. And that is what the overloaded multiplication operator does:</p>
<p class="programlisting">Vector Vector::operator*(double n) const<br/>{<br/>&#160;&#160;&#160;&#160;return Vector(n * x, n * y);<br/>}</p>
<p>As with overloaded addition, the code lets a constructor create the correct <code>Vector</code> object from the new x and y components. This handles multiplying a <code>Vector</code> value by a <code>double</code> value. Just as in the <code>Time</code> example, you can use an inline friend function to handle <code>double</code> times <code>Vector</code>:</p>
<p class="programlisting">Vector operator*(double n, const Vector &#38; a)&#160;&#160;// friend function<br/>{<br/>&#160;&#160;&#160;&#160;return a * n;&#160;&#160;&#160;// convert double times Vector to Vector times double<br/>}</p>
<h5 id="ch11lev3sec4">More Refinement: Overloading an Overloaded Operator</h5>
<p><a id="page_601"/>In ordinary C++, the <code>-</code> operator already has two meanings. First, when used with two operands, it&#8217;s the subtraction operator. The subtraction operator is termed a <em>binary operator</em> because it has exactly two operands. Second, when used with one operand, as in <code>-x</code>, it&#8217;s a minus sign operator. This form is termed a <em>unary operator</em>, meaning it has exactly one operand. Both operations&#8212;subtraction and sign reversal&#8212;make sense for vectors, too, so the <code>Vector</code> class has both.</p>
<p>To subtract Vector B from Vector A, you simply subtract components, so the definition for overloading subtraction is quite similar to the one for addition:</p>
<p class="programlisting">Vector operator-(const Vector &#38; b) const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prototype<br/>Vector Vector::operator-(const Vector &#38; b) const&#160;&#160;&#160;&#160;&#160;// definition<br/>{<br/>&#160;&#160;&#160;&#160;return Vector(x - b.x, y - b.y);&#160;&#160;// return the constructed Vector<br/>}</p>
<p>Here, it&#8217;s important to get the correct order. Consider the following statement:</p>
<p class="programlisting">diff = v1 - v2;</p>
<p>It&#8217;s converted to a member function call:</p>
<p class="programlisting">diff = v1.operator-(v2);</p>
<p>This means the vector that is passed as the explicit argument is subtracted from the implicit vector argument, so you should use <code>x - b.x</code> and not <code>b.x - x</code>.</p>
<p>Next, consider the unary minus operator, which takes just one operand. Applying this operator to a regular number, as in -x, changes the sign of the value. Thus, applying this operator to a vector reverses the sign of each component. More precisely, the function should return a new vector that is the reverse of the original. (In polar terms, negation leaves the magnitude unchanged but reverses the direction. Many politicians with little or no mathematical training nonetheless have an intuitive mastery of this operation.) Here are the prototype and definition for overloading negation:</p>
<p class="programlisting">Vector operator-() const;<br/>Vector Vector::operator-() const<br/>{<br/>&#160;&#160;&#160;&#160;return Vector (-x, -y);<br/>}</p>
<p>Note that now there are two separate definitions for <code>operator-()</code>. That&#8217;s fine because the two definitions have different signatures. You can define both binary and unary versions of the <code>-</code> operator because C++ provides both binary and unary versions of that operator to begin with. An operator that has only a binary form, such as division (<code>/</code>), can only be overloaded as a binary operator.</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note08"/><a id="page_602"/>Note</p>
<p class="notepara">Because operator overloading is implemented with functions, you can overload the same operator many times, as long as each operator function has a distinct signature and as long as each operator function has the same number of operands as the corresponding built-in C++ operator.</p>
<hr/></div>
<h4 id="ch11lev2sec8">An Implementation Comment</h4>
<p>The implementation described in the preceding sections stores both rectangular and polar coordinates for a vector in the <code>Vector</code> object. However, the public interface doesn&#8217;t depend on this fact. All the interface calls for is that both representations can be displayed and that individual values can be returned. The internal implementation could be quite different. As mentioned earlier, the object could store just the x and y components. Then, say, the <code>magval()</code> method, which returns the value of the magnitude of the vector, could calculate the magnitude from the x and y values instead of just looking up the value as stored in the object. Such an approach changes the implementation but leaves the user interface unchanged. This separation of interface from implementation is one of the goals of OOP. It lets you fine-tune an implementation without changing the code in programs that use the class.</p>
<p>Both of these implementations have advantages and disadvantages. Storing the data means that the object occupies more memory and that code has to be careful to update both rectangular and polar representations each time a <code>Vector</code> object is changed. But data look-up is faster. If an application often needs to access both representations of a vector, the implementation used in this example would be preferable; if polar data were needed only infrequently, the other implementation would be better. You could choose to use one implementation in one program and the second implementation in another, yet retain the same user interface for both.</p>
<h4 id="ch11lev2sec9">Taking the <code>Vector</code> Class on a Random Walk</h4>
<p><a href="#ch11ex15">Listing 11.15</a> provides a short program that uses the revised <code>Vector</code> class. It simulates the famous Drunkard&#8217;s Walk problem. Actually, now that drunks are recognized as people with a serious health problem rather than as a source of amusement, it&#8217;s usually called the Random Walk problem. The idea is that you place someone at a lamppost. The person begins walking, but the direction of each step varies randomly from the direction of the preceding step. One way of phrasing the problem is this: How many steps does it take the random walker to travel, say, 50 feet away from the post? In terms of vectors, this amounts to adding a bunch of randomly oriented vectors until the sum exceeds 50 feet.</p>
<p><a href="#ch11ex15">Listing 11.15</a> lets you select the target distance to be traveled and the length of the wanderer&#8217;s step. It maintains a running total that represents the position after each step (represented as a vector) and reports the number of steps needed to reach the target distance, along with the walker&#8217;s location (in both formats). As you&#8217;ll see, the walker&#8217;s progress is quite inefficient. A journey of 1,000 steps, each 2 feet long, may carry the walker only 50 feet from the starting point. The program divides the net distance traveled (50 feet, in this case) by the number of steps to provide a measure of the walker&#8217;s <a id="page_603"/>inefficiency. All the random direction changes make this average much smaller than the length of a single step. To select directions randomly, the program uses the standard library functions <code>rand()</code>, <code>srand()</code>, and <code>time()</code>, described in the following &#8220;<a href="#ch11lev3sec5">Program Notes</a>&#8221; section. Be sure to compile <a href="#ch11ex14">Listing 11.14</a> along with <a href="#ch11ex15">Listing 11.15</a>.</p>
<p class="caption1"><a id="ch11ex15"/><strong>Listing 11.15. <code>randwalk.cpp</code></strong></p><hr/>
<p class="programlisting1">// randwalk.cpp -- using the Vector class<br/>// compile with the vect.cpp file<br/>#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt;&#160;&#160;&#160;&#160;&#160;&#160;// rand(), srand() prototypes<br/>#include &lt;ctime&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// time() prototype<br/>#include "vect.h"<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;using VECTOR::Vector;<br/>&#160;&#160;&#160;&#160;srand(time(0));&#160;&#160;&#160;&#160;&#160;// seed random-number generator<br/>&#160;&#160;&#160;&#160;double direction;<br/>&#160;&#160;&#160;&#160;Vector step;<br/>&#160;&#160;&#160;&#160;Vector result(0.0, 0.0);<br/>&#160;&#160;&#160;&#160;unsigned long steps = 0;<br/>&#160;&#160;&#160;&#160;double target;<br/>&#160;&#160;&#160;&#160;double dstep;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter target distance (q to quit): ";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; target)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter step length: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!(cin &gt;&gt; dstep))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (result.magval() &lt; target)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;direction = rand() % 360;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;step.reset(dstep, direction, Vector::POL);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = result + step;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;steps++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "After " &lt;&lt; steps &lt;&lt; " steps, the subject "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"has the following location:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; result &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result.polar_mode();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; " or\n" &lt;&lt; result &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Average outward distance per step = "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; result.magval()/steps &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;steps = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result.reset(0.0, 0.0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter target distance (q to quit): ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye!\n";<br/>&#160;&#160;&#160;&#160;cin.clear();<br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_604"/>Because the program has a <code>using</code> declaration bringing <code>Vector</code> into scope, the program can use <code>Vector::POL</code> instead of <code>VECTOR::Vector::POL</code>.</p>
<p>Here is a sample run of the program in <a href="#ch11ex13">Listings 11.13</a>, <a href="#ch11ex14">11.14</a>, and <a href="#ch11ex15">11.15</a>:</p>
<p class="programlisting">Enter target distance (q to quit): <span class="EmpStrong">50</span><br/>Enter step length: <span class="EmpStrong">2</span><br/>After 253 steps, the subject has the following location:<br/>(x,y) = (46.1512, 20.4902)<br/>&#160;or<br/>(m,a) = (50.495, 23.9402)<br/>Average outward distance per step = 0.199587<br/>Enter target distance (q to quit): <span class="EmpStrong">50</span><br/>Enter step length: <span class="EmpStrong">2</span><br/>After 951 steps, the subject has the following location:<br/>(x,y) = (-21.9577, 45.3019)<br/>&#160;or<br/>(m,a) = (50.3429, 115.8593)<br/>Average outward distance per step = 0.0529362<br/>Enter target distance (q to quit): <span class="EmpStrong">50</span><br/>Enter step length: <span class="EmpStrong">1</span><br/>After 1716 steps, the subject has the following location:<br/>(x,y) = (40.0164, 31.1244)<br/>&#160;or<br/>(m,a) = (50.6956, 37.8755)<br/>Average outward distance per step = 0.0295429<br/>Enter target distance (q to quit): <span class="EmpStrong">q</span><br/>Bye!</p>
<p>The random nature of the process produces considerable variation from trial to trial, even if the initial conditions are the same. On average, however, halving the step size quadruples the number of steps needed to cover a given distance. Probability theory suggests that, on average, the number of steps (<em>N</em>) of length <em>s</em> needed to reach a net distance of <em>D</em> is given by the following equation:</p>
<p class="indenthanding"><em>N</em> <code>= (</code><em>D</em><code>/</code><em>s</em><code>)<sup>2</sup></code></p>
<p>This is just an average, but there will be considerable variations from trial to trial. For example, 1,000 trials of attempting to travel 50 feet in 2-foot steps yielded an average of 636 steps (close to the theoretical value of 625) to travel that far, but the range was from <a id="page_605"/>91 to 3,951. Similarly, 1,000 trials of traveling 50 feet in 1-foot steps averaged 2,557 steps (close to the theoretical value of 2,500), with a range of 345 to 10,882. So if you find yourself walking randomly, be confident and take long steps. You still won&#8217;t have any control over the direction you wind up going, but at least you&#8217;ll get farther.</p>
<h5 id="ch11lev3sec5">Program Notes</h5>
<p>First, let&#8217;s note how painless it was to use the <code>VECTOR</code> namespace in <a href="#ch11ex15">Listing 11.15</a>. The following <code>using</code> declaration places the name of the <code>Vector</code> class in scope:</p>
<p class="programlisting">using VECTOR::Vector;</p>
<p>Because all the <code>Vector</code> class methods have class scope, importing the class name also makes the <code>Vector</code> methods available, without the need for any further <code>using</code> declarations.</p>
<p>Next, let&#8217;s talk about random numbers. The standard ANSI C library, which also comes with C++, includes a <code>rand()</code> function that returns a random integer in the range from 0 to some implementation-dependent value. The random walk program uses the modulus operator to get an angle value in the range 0 to 359. The <code>rand()</code> function works by applying an algorithm to an initial seed value to get a random value. That value is used as the seed for the next function call, and so on. The numbers are really <em>pseudorandom</em> because 10 consecutive calls normally produce the same set of 10 random numbers. (The exact values depend on the implementation.) However, the <code>srand()</code> function lets you override the default seed value and initiate a different sequence of random numbers. This program uses the return value of <code>time(0)</code> to set the seed. The <code>time(0)</code> function returns the current calendar time, often implemented as the number of seconds since some specific date. (More generally, <code>time()</code> takes the address of a type <code>time_t</code> variable and puts the time into that variable and also returns it. Using <code>0</code> for the address argument obviates the need for an otherwise unneeded <code>time_t</code> variable.) Thus, the following statement sets a different seed each time you run the program, making the random output appear even more random:</p>
<p class="programlisting">srand(time(0));</p>
<p>The <code>cstdlib</code> header file (formerly <code>stdlib.h</code>) contains the prototypes for <code>srand()</code> and <code>rand()</code>, whereas <code>ctime</code> (formerly <code>time.h</code>) contains the <code>time()</code> prototype. (C++11 provides more extensive random number support with functions supported by the <code>random</code> header file.)</p>
<p>The program uses the <code>result</code> vector to keep track of the walker&#8217;s progress. On each cycle of the inner loop, the program sets the <code>step</code> vector to a new direction and adds it to the current <code>result</code> vector. When the magnitude of <code>result</code> exceeds the target distance, the loop terminates.</p>
<p>By setting the vector mode, the program displays the final position in rectangular terms and in polar terms.</p>
<p>Incidentally, the following statement has the effect of placing <code>result</code> in the <code>RECT</code> mode, regardless of the initial modes of <code>result</code> and <code>step</code>:</p>
<p class="programlisting">result = result + step;</p>
<p><a id="page_606"/>Here&#8217;s why. First, the addition operator function creates and returns a new vector that holds the sum of the two arguments. The function creates that vector by using the default constructor, which creates vectors in the <code>RECT</code> mode. Thus, the vector being assigned to <code>result</code> is in the <code>RECT</code> mode. By default, assignment assigns each member variable individually, so <code>RECT</code> is assigned to <code>result.mode</code>. If you would prefer some other behavior, such as <code>result</code> retaining its original mode, you can override default assignment by defining an assignment operator for the class. <a href="ch12.html#ch12">Chapter 12</a> shows examples of this.</p>
<p>By the way, it&#8217;s a simple matter to save successive positions in a file. First, you include <code>&lt;fstream&gt;</code>, declare an <code>ofstream</code> object, and associate the object with a file:</p>
<p class="programlisting">#include &lt;fstream&gt;<br/>...<br/>ofstream fout;<br/>fout.open("thewalk.txt");</p>
<p>Then, in the loop that calculates the result, you insert something like this:</p>
<p class="programlisting">fout &lt;&lt; result &lt;&lt; endl;</p>
<p>This invokes the friend function call <code>operator&lt;&lt;(fout, result)</code>, causing the <code>os</code> reference parameter to refer to <code>fout</code>, thus sending output to the file. You could also use <code>fout</code> to write other information to the file, such as the summary information currently displayed by <code>cout</code>.</p>
<h3 id="ch11lev1sec6">Automatic Conversions and Type Casts for Classes</h3>
<p>The next topic on the class menu is type conversion. We&#8217;ll look into how C++ handles conversions to and from user-defined types. To set the stage, let&#8217;s first review how C++ handles conversions for its built-in types. When you make a statement that assigns a value of one standard type to a variable of another standard type, C++ automatically converts the value to the same type as the receiving variable, provided that the two types are compatible. For example, the following statements all generate numeric type conversions:</p>
<p class="programlisting">long count = 8;&#160;&#160;&#160;&#160;&#160;&#160;// int value 8 converted to type long<br/>double time = 11;&#160;&#160;&#160;&#160;// int value 11 converted to type double<br/>int side = 3.33;&#160;&#160;&#160;&#160;&#160;// double value 3.33 converted to type int 3</p>
<p>These assignments work because C++ recognizes that the diverse numeric types all represent the same basic thing&#8212;a number&#8212;and because C++ incorporates built-in rules for making the conversions. Recall from <a href="ch03.html#ch03">Chapter 3</a>, &#8220;<a href="ch03.html#ch03">Dealing with Data</a>,&#8221; however, that you can lose some precision in these conversions. For example, assigning <code>3.33</code> to the <code>int</code> variable <code>side</code> results in <code>side</code> getting the value <code>3</code>, losing the <code>0.33</code> part.</p>
<p>The C++ language does not automatically convert types that are not compatible. For example, the following statement fails because the left side is a pointer type, whereas the right side is a number:</p>
<p class="programlisting">int * p = 10;&#160;&#160;// type clash</p>
<p><a id="page_607"/>And even though a computer may represent an address internally with an integer, integers and pointers are conceptually quite different. For example, you wouldn&#8217;t square a pointer. However, when automatic conversions fail, you may use a type cast:</p>
<p class="programlisting">int * p = (int *) 10;&#160;&#160;// ok, p and (int *) 10 both pointers</p>
<p>This sets a pointer to the address <code>10</code> by type casting <code>10</code> to type pointer-to-<code>int</code> (that is, type <code>int *</code>). Whether this assignment makes sense is another matter.</p>
<p>You may define a class sufficiently related to a basic type or to another class that it makes sense to convert from one form to another. In such a case, you can tell C++ how to make such conversions automatically or, perhaps, via a type cast. To see how that works, you can recast the pounds-to-stone program from <a href="ch03.html#ch03">Chapter 3</a> into class form. First, you need to design an appropriate type. Fundamentally, you&#8217;re representing one thing (a weight) two ways (pounds and stone). A class provides an excellent way to incorporate two representations of one concept into a single entity. Therefore, it makes sense to place both representations of weight into the same class and then provide class methods for expressing the weight in different forms. <a href="#ch11ex16">Listing 11.16</a> provides the class header.</p>
<p class="caption1"><a id="ch11ex16"/><strong>Listing 11.16. <code>stonewt.h</code></strong></p><hr/>
<p class="programlisting1">// stonewt.h -- definition for the Stonewt class<br/>#ifndef STONEWT_H_<br/>#define STONEWT_H_<br/>class Stonewt<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {Lbs_per_stn = 14};&#160;&#160;&#160;&#160;&#160;&#160;// pounds per stone<br/>&#160;&#160;&#160;&#160;int stone;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// whole stones<br/>&#160;&#160;&#160;&#160;double pds_left;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// fractional pounds<br/>&#160;&#160;&#160;&#160;double pounds;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// entire weight in pounds<br/>public:<br/>&#160;&#160;&#160;&#160;Stonewt(double lbs);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// constructor for double pounds<br/>&#160;&#160;&#160;&#160;Stonewt(int stn, double lbs); // constructor for stone, lbs<br/>&#160;&#160;&#160;&#160;Stonewt();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>&#160;&#160;&#160;&#160;~Stonewt();<br/>&#160;&#160;&#160;&#160;void show_lbs() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// show weight in pounds format<br/>&#160;&#160;&#160;&#160;void show_stn() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// show weight in stone format<br/>};<br/>#endif</p><hr/>
<p>As mentioned in <a href="ch10.html#ch10">Chapter 10</a>, <code>enum</code> provides a convenient way to define class-specific constants, provided that they are integers. Or you could use the following alternative:</p>
<p class="programlisting">static const int Lbs_per_stn = 14;</p>
<p><a id="page_608"/>Note that the <code>Stonewt</code> class has three constructors. They allow you to initialize a <code>Stonewt</code> object to a floating-point number of pounds or to a combination of stone and pounds. Or you can create a <code>Stonewt</code> object without initializing it:</p>
<p class="programlisting">Stonewt blossem(132.5);&#160;&#160;&#160;// weight = 132.5 pounds<br/>Stonewt buttercup(10, 2); // weight = 10 stone, 2 pounds<br/>Stonewt bubbles;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// weight = default value</p>
<p>The class doesn&#8217;t really need to declare a destructor because the automatic default constructor is fine for this case. On the other hand, providing an explicit declaration prepares you for the future, when you will have to define constructors.</p>
<p>Also the <code>Stonewt</code> class provides two display functions. One displays the weight in pounds, and the other displays the weight in stone and pounds. <a href="#ch11ex17">Listing 11.17</a> shows the class methods implementation. Note that each constructor assigns values to all three private members. Thus, creating a <code>Stonewt</code> object automatically sets both representations of weight.</p>
<p class="caption1"><a id="ch11ex17"/><strong>Listing 11.17. <code>stonewt.cpp</code></strong></p><hr/>
<p class="programlisting1">// stonewt.cpp -- Stonewt methods<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>#include "stonewt.h"<br/><br/>// construct Stonewt object from double value<br/>Stonewt::Stonewt(double lbs)<br/>{<br/>&#160;&#160;&#160;&#160;stone = int (lbs) / Lbs_per_stn;&#160;&#160;&#160;&#160;// integer division<br/>&#160;&#160;&#160;&#160;pds_left = int (lbs) % Lbs_per_stn + lbs - int(lbs);<br/>&#160;&#160;&#160;&#160;pounds = lbs;<br/>}<br/><br/>// construct Stonewt object from stone, double values<br/>Stonewt::Stonewt(int stn, double lbs)<br/>{<br/>&#160;&#160;&#160;&#160;stone = stn;<br/>&#160;&#160;&#160;&#160;pds_left = lbs;<br/>&#160;&#160;&#160;&#160;pounds =&#160;&#160;stn * Lbs_per_stn +lbs;<br/>}<br/><br/>Stonewt::Stonewt()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor, wt = 0<br/>{<br/>&#160;&#160;&#160;&#160;stone = pounds = pds_left = 0;<br/>}<br/><br/>Stonewt::~Stonewt()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// destructor<br/>{<br/>}<br/><br/>// show weight in stones<br/>void Stonewt::show_stn() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; stone &lt;&lt; " stone, " &lt;&lt; pds_left &lt;&lt; " pounds\n";<br/>}<br/><br/>// show weight in pounds<br/>void Stonewt::show_lbs() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pounds &lt;&lt; " pounds\n";<br/>}</p><hr/>
<p><a id="page_609"/>Because a <code>Stonewt</code> object represents a single weight, it makes sense to provide ways to convert an integer or a floating-point value to a <code>Stonewt</code> object. And you have already done so! In C++, any constructor that takes a single argument acts as a blueprint for converting a value of that argument type to the class type. Thus the following constructor serves as instructions for converting a type <code>double</code> value to a type <code>Stonewt</code> value:</p>
<p class="programlisting">Stonewt(double lbs);&#160;&#160;// template for double-to-Stonewt conversion</p>
<p>That is, you can write code like the following:</p>
<p class="programlisting">Stonewt myCat;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create a Stonewt object<br/>myCat = 19.6;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use Stonewt(double) to convert 19.6 to Stonewt</p>
<p>The program uses the <code>Stonewt(double)</code> constructor to construct a temporary <code>Stonewt</code> object, using <code>19.6</code> as the initialization value. Then memberwise assignment copies the contents of the temporary object into <code>myCat</code>. This process is termed an <em>implicit conversion</em> because it happens automatically, without the need of an explicit type cast.</p>
<p>Only a constructor that can be used with just one argument works as a conversion function. The following constructor has two arguments, so it cannot be used to convert types:</p>
<p class="programlisting">Stonewt(int stn, double lbs);&#160;&#160;// not a conversion function</p>
<p>However, it would act as a guide to <code>int</code> conversion if it provided a default value for the second parameter:</p>
<p class="programlisting">Stonewt(int stn, double lbs = 0);&#160;&#160;// int-to-Stonewt conversion</p>
<p>Having a constructor work as an automatic type-conversion function seems like a nice feature. As programmers acquired more experience working with C++, however, they found that the automatic aspect isn&#8217;t always desirable because it can lead to unexpected conversions. So C++ added a new keyword, <code>explicit</code>, to turn off the automatic aspect. That is, you can declare the constructor this way:</p>
<p class="programlisting">explicit Stonewt(double lbs);&#160;&#160;&#160;// no implicit conversions allowed</p>
<p>This turns off implicit conversions such as the preceding example but still allows explicit conversions&#8212;that is, conversions using explicit type casts:</p>
<p class="programlisting"><a id="page_610"/>Stonewt myCat;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create a Stonewt object<br/>myCat = 19.6;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not valid if Stonewt(double) is declared as explicit<br/>mycat = Stonewt(19.6);&#160;&#160;// ok, an explicit conversion<br/>mycat = (Stonewt) 19.6; // ok, old form for explicit typecast</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note09"/>Note</p>
<p class="notepara">A C++ constructor that contains one argument defines a type conversion from the argument type to the class type. If the constructor is qualified with the keyword <code>explicit</code>, the constructor is used for explicit conversions only; otherwise, it is also used for implicit conversions.</p>
<hr/></div>
<p>When does the compiler use the <code>Stonewt(double)</code> function? If the keyword <code>explicit</code> is used in the declaration, <code>Stonewt(double)</code> is used only for an explicit type cast; otherwise, it is also used for the following implicit conversions:</p>
<p class="indenthandingB">&#8226; When you initialize a <code>Stonewt</code> object to a type <code>double</code> value</p>
<p class="indenthandingB">&#8226; When you assign a type <code>double</code> value to a <code>Stonewt</code> object</p>
<p class="indenthandingB">&#8226; When you pass a type <code>double</code> value to a function that expects a <code>Stonewt</code> argument</p>
<p class="indenthandingB">&#8226; When a function that&#8217;s declared to return a <code>Stonewt</code> value tries to return a <code>double</code> value</p>
<p class="indenthandingB">&#8226; When any of the preceding situations use a built-in type that can unambiguously be converted to type <code>double</code></p>
<p>Let&#8217;s look at the last point in more detail. The argument-matching process provided by function prototyping lets the <code>Stonewt(double)</code> constructor act as conversions for other numerical types. That is, both of the following statements work by first converting <code>int</code> to <code>double</code> and then using the <code>Stonewt(double)</code> constructor:</p>
<p class="programlisting">Stonewt Jumbo(7000);&#160;&#160;&#160;// uses Stonewt(double), converting int to double<br/>Jumbo = 7300;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// uses Stonewt(double), converting int to double</p>
<p>However, this two-step conversion process works only if there is an unambiguous choice. That is, if the class also defined a <code>Stonewt(long)</code> constructor, the compiler would reject these statements, probably pointing out that an <code>int</code> can be converted to either a <code>long</code> or a <code>double</code>, so the call is ambiguous.</p>
<p><a href="#ch11ex18">Listing 11.18</a> uses the class constructors to initialize some <code>Stonewt</code> objects and to handle type conversions. Be sure to compile <a href="#ch11ex17">Listing 11.17</a> along with <a href="#ch11ex18">Listing 11.18</a>.</p>
<p class="caption1"><a id="ch11ex18"/><strong>Listing 11.18. <code>stone.cpp</code></strong></p><hr/>
<p class="programlisting1">// stone.cpp -- user-defined conversions<br/>// compile with stonewt.cpp<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>#include "stonewt.h"<br/>void display(const Stonewt &#38; st, int n);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Stonewt incognito = 275; // uses constructor to initialize<br/>&#160;&#160;&#160;&#160;Stonewt wolfe(285.7);&#160;&#160;&#160;&#160;// same as Stonewt wolfe = 285.7;<br/>&#160;&#160;&#160;&#160;Stonewt taft(21, 8);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The celebrity weighed ";<br/>&#160;&#160;&#160;&#160;incognito.show_stn();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The detective weighed ";<br/>&#160;&#160;&#160;&#160;wolfe.show_stn();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The President weighed ";<br/>&#160;&#160;&#160;&#160;taft.show_lbs();<br/>&#160;&#160;&#160;&#160;incognito = 276.8;&#160;&#160;&#160;&#160;&#160;&#160;// uses constructor for conversion<br/>&#160;&#160;&#160;&#160;taft = 325;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// same as taft = Stonewt(325);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After dinner, the celebrity weighed ";<br/>&#160;&#160;&#160;&#160;incognito.show_stn();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After dinner, the President weighed ";<br/>&#160;&#160;&#160;&#160;taft.show_lbs();<br/>&#160;&#160;&#160;&#160;display(taft, 2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The wrestler weighed even more.\n";<br/>&#160;&#160;&#160;&#160;display(422, 2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "No stone left unearned\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void display(const Stonewt &#38; st, int n)<br/>{<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Wow! ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.show_stn();<br/>&#160;&#160;&#160;&#160;}<br/>}</p><hr/>
<p><a id="page_611"/>Here is the output of the program in <a href="#ch11ex18">Listing 11.18</a>:</p>
<p class="programlisting">The celebrity weighed 19 stone, 9 pounds<br/>The detective weighed 20 stone, 5.7 pounds<br/>The President weighed 302 pounds<br/>After dinner, the celebrity weighed 19 stone, 10.8 pounds<br/>After dinner, the President weighed 325 pounds<br/>Wow! 23 stone, 3 pounds<br/>Wow! 23 stone, 3 pounds<br/>The wrestler weighed even more.<br/>Wow! 30 stone, 2 pounds<br/>Wow! 30 stone, 2 pounds<br/>No stone left unearned</p>
<h4 id="ch11lev2sec10">Program Notes</h4>
<p><a id="page_612"/>Note that when a constructor has a single argument, you can use the following form when initializing a class object:</p>
<p class="programlisting">// a syntax for initializing a class object when<br/>// using a constructor with one argument<br/>Stonewt incognito = 275;</p>
<p>This is equivalent to the other two forms shown earlier:</p>
<p class="programlisting">// standard syntax forms for initializing class objects<br/>Stonewt incognito(275);<br/>Stonewt incognito = Stonewt(275);</p>
<p>However, the last two forms can also be used with constructors that have multiple arguments.</p>
<p>Next, note the following two assignments from <a href="#ch11ex18">Listing 11.18</a>:</p>
<p class="programlisting">incognito = 276.8;<br/>taft = 325;</p>
<p>The first of these assignments uses the constructor with a type <code>double</code> argument to convert <code>276.8</code> to a type <code>Stonewt</code> value. This sets the <code>pounds</code> member of <code>incognito</code> to <code>276.8</code>. Because it uses the constructor, this assignment also sets the <code>stone</code> and <code>pds_left</code> members of the class. Similarly, the second assignment converts a type <code>int</code> value to type <code>double</code> and then uses <code>Stonewt(double)</code> to set all three member values in the process.</p>
<p>Finally, note the following function call:</p>
<p class="programlisting">display(422, 2);&#160;&#160;&#160;&#160;// convert 422 to double, then to Stonewt</p>
<p>The prototype for <code>display()</code> indicates that its first argument should be the <code>Stonewt</code> object. (Either a <code>Stonewt</code> or a <code>Stonewt &#38;</code> formal parameter matches a <code>Stonewt</code> argument.) Confronted with an <code>int</code> argument, the compiler looks for a <code>Stonewt(int)</code> constructor to convert the <code>int</code> to the desired <code>Stonewt</code> type. Failing to find that constructor, the compiler looks for a constructor with some other built-in type to which an <code>int</code> can be converted. The <code>Stonewt(double)</code> constructor fits the bill. So the compiler converts <code>int</code> to <code>double</code> and then uses <code>Stonewt(double)</code> to convert the result to a <code>Stonewt</code> object.</p>
<h4 id="ch11lev2sec11">Conversion Functions</h4>
<p><a href="#ch11ex18">Listing 11.18</a> converts a number to a <code>Stonewt</code> object. Can you do the reverse? That is, can you convert a <code>Stonewt</code> object to a <code>double</code> value, as in the following?</p>
<p class="programlisting">Stonewt wolfe(285.7);<br/>double host = wolfe;&#160;&#160;// ?? possible ??</p>
<p>The answer is that you can do this&#8212;but not by using constructors. Constructors only provide for converting another type <em>to</em> the class type. To do the reverse, you have to use a special form of a C++ operator function called a <em>conversion function</em>.</p>
<p><a id="page_613"/>Conversion functions are user-defined type casts, and you can use them the way you would use a type cast. For example, if you define a <code>Stonewt</code>-to-<code>double</code> conversion function, you can use the following conversions:</p>
<p class="programlisting">Stonewt wolfe(285.7);<br/>double host = double (wolfe);&#160;&#160;&#160;&#160;&#160;&#160;// syntax #1<br/>double thinker = (double) wolfe;&#160;&#160;&#160;// syntax #2</p>
<p>Or you can let the compiler figure out what to do:</p>
<p class="programlisting">Stonewt wells(20, 3);<br/>double star = wells;&#160;&#160;&#160;// implicit use of conversion function</p>
<p>The compiler, noting that the right side is type <code>Stonewt</code> and the left side is type <code>double</code>, looks to see if you&#8217;ve defined a conversion function that matches this description. (If it can&#8217;t find such a definition, the compiler generates an error message to the effect that it can&#8217;t assign a <code>Stonewt</code> to a <code>double</code>.)</p>
<p>So how do you create a conversion function? To convert to type <em><code>typeName</code></em>, you use a conversion function in this form:</p>
<p class="programlisting">operator <span class="EmpItalic">typeName</span>();</p>
<p>Note the following points:</p>
<p class="indenthandingB">&#8226; The conversion function must be a class method.</p>
<p class="indenthandingB">&#8226; The conversion function must not specify a return type.</p>
<p class="indenthandingB">&#8226; The conversion function must have no arguments.</p>
<p>For example, a function to convert to type <code>double</code> would have this prototype:</p>
<p class="programlisting">operator double();</p>
<p>The <em><code>typeName</code></em> part (in this case <em><code>typeName</code></em> is <code>double</code>) tells the conversion the type to which to convert, so no return type is needed. The fact that the function is a class method means it has to be invoked by a particular class object, and that tells the function which value to convert. Thus, the function doesn&#8217;t need arguments.</p>
<p>To add functions that convert <code>stone_wt</code> objects to type <code>int</code> and to type <code>double</code>, then, requires adding the following prototypes to the class declaration:</p>
<p class="programlisting">operator int();<br/>operator double();</p>
<p><a href="#ch11ex19">Listing 11.19</a> shows the modified class declaration.</p>
<p class="caption1"><a id="ch11ex19"/><strong>Listing 11.19. <code>stonewt1.h</code></strong></p><hr/>
<p class="programlisting1">// stonewt1.h -- revised definition for the Stonewt class<br/>#ifndef STONEWT1_H_<br/>#define STONEWT1_H_<br/>class Stonewt<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {Lbs_per_stn = 14};&#160;&#160;&#160;&#160;&#160;&#160;// pounds per stone<br/>&#160;&#160;&#160;&#160;int stone;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// whole stones<br/>&#160;&#160;&#160;&#160;double pds_left;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// fractional pounds<br/>&#160;&#160;&#160;&#160;double pounds;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// entire weight in pounds<br/>public:<br/>&#160;&#160;&#160;&#160;Stonewt(double lbs);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// construct from double pounds<br/>&#160;&#160;&#160;&#160;Stonewt(int stn, double lbs); // construct from stone, lbs<br/>&#160;&#160;&#160;&#160;Stonewt();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>&#160;&#160;&#160;&#160;~Stonewt();<br/>&#160;&#160;&#160;&#160;void show_lbs() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// show weight in pounds format<br/>&#160;&#160;&#160;&#160;void show_stn() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// show weight in stone format<br/>// conversion functions<br/>&#160;&#160;&#160;&#160;operator int() const;<br/>&#160;&#160;&#160;&#160;operator double() const;<br/>};<br/>#endif</p><hr/>
<p><a id="page_614"/><a href="#ch11ex20">Listing 11.20</a> shows <a href="#ch11ex18">Listing 11.18</a> modified to include the definitions for these two conversion functions. Note that each function returns the desired value, even though there is no declared return type. Also note that the <code>int</code> conversion definition rounds to the nearest integer rather than truncating. For example, if <code>pounds</code> is <code>114.4</code>, then <code>pounds + 0.5</code> is <code>114.9</code>, and <code>int (114.9)</code> is <code>114</code>. But if <code>pounds</code> is <code>114.6</code>, <code>pounds + 0.5</code> is <code>115.1</code>, and <code>int (115.1)</code> is <code>115</code>.</p>
<p class="caption1"><a id="ch11ex20"/><strong>Listing 11.20. <code>stonewt1.cpp</code></strong></p><hr/>
<p class="programlisting1">// stonewt1.cpp -- Stonewt class methods + conversion functions<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>#include "stonewt1.h"<br/><br/>// construct Stonewt object from double value<br/>Stonewt::Stonewt(double lbs)<br/>{<br/>&#160;&#160;&#160;&#160;stone = int (lbs) / Lbs_per_stn;&#160;&#160;&#160;&#160;// integer division<br/>&#160;&#160;&#160;&#160;pds_left = int (lbs) % Lbs_per_stn + lbs - int(lbs);<br/>&#160;&#160;&#160;&#160;pounds = lbs;<br/>}<br/><br/>// construct Stonewt object from stone, double values<br/>Stonewt::Stonewt(int stn, double lbs)<br/>{<br/>&#160;&#160;&#160;&#160;stone = stn;<br/>&#160;&#160;&#160;&#160;pds_left = lbs;<br/>&#160;&#160;&#160;&#160;pounds =&#160;&#160;stn * Lbs_per_stn +lbs;<br/>}<br/><br/>Stonewt::Stonewt()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor, wt = 0<br/>{<br/>&#160;&#160;&#160;&#160;stone = pounds = pds_left = 0;<br/>}<br/><br/>Stonewt::~Stonewt()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// destructor<br/>{<br/>}<br/><br/>// show weight in stones<br/>void Stonewt::show_stn() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; stone &lt;&lt; " stone, " &lt;&lt; pds_left &lt;&lt; " pounds\n";<br/>}<br/><br/>// show weight in pounds<br/>void Stonewt::show_lbs() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pounds &lt;&lt; " pounds\n";<br/>}<br/><br/>// conversion functions<br/>Stonewt::operator int() const<br/>{<br/><br/>&#160;&#160;&#160;&#160;return int (pounds + 0.5);<br/><br/>}<br/><br/>Stonewt::operator double()const<br/>{<br/>&#160;&#160;&#160;&#160;return pounds;<br/>}</p><hr/>
<p><a id="page_615"/><a href="#ch11ex21">Listing 11.21</a> tests the new conversion functions. The assignment statement in the program uses an implicit conversion, whereas the final <code>cout</code> statement uses an explicit type cast. Be sure to compile <a href="#ch11ex20">Listing 11.20</a> along with <a href="#ch11ex21">Listing 11.21</a>.</p>
<p class="caption1"><a id="ch11ex21"/><strong>Listing 11.21. <code>stone1.cpp</code></strong></p><hr/>
<p class="programlisting1">// stone1.cpp -- user-defined conversion functions<br/>// compile with stonewt1.cpp<br/>#include &lt;iostream&gt;<br/>#include "stonewt1.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;Stonewt poppins(9,2.8);&#160;&#160;&#160;&#160;&#160;// 9 stone, 2.8 pounds<br/>&#160;&#160;&#160;&#160;double p_wt = poppins;&#160;&#160;&#160;&#160;&#160;&#160;// implicit conversion<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Convert to double =&gt; ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Poppins: " &lt;&lt; p_wt &lt;&lt; " pounds.\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Convert to int =&gt; ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Poppins: " &lt;&lt; int (poppins) &lt;&lt; " pounds.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_616"/>Here&#8217;s the output from the program in <a href="#ch11ex19">Listings 11.19</a>, <a href="#ch11ex20">11.20</a>, and <a href="#ch11ex21">11.21</a>, which shows the result of converting the type <code>Stonewt</code> object to type <code>double</code> and to type <code>int</code>:</p>
<p class="programlisting">Convert to double =&gt; Poppins: 128.8 pounds.<br/>Convert to int =&gt; Poppins: 129 pounds.</p>
<h5 id="ch11lev3sec6">Applying Type Conversions Automatically</h5>
<p><a href="#ch11ex21">Listing 11.21</a> uses <code>int (poppins)</code> with <code>cout</code>. Suppose that, instead, it omitted the explicit type cast:</p>
<p class="programlisting">cout &lt;&lt; "Poppins: " &lt;&lt; poppins &lt;&lt; " pounds.\n";</p>
<p>Would the program use an implicit conversion, as in the following statement?</p>
<p class="programlisting">double p_wt = poppins;</p>
<p>The answer is no. In the <code>p_wt</code> example, the context indicates that <code>poppins</code> should be converted to type <code>double</code>. But in the <code>cout</code> example, nothing indicates whether the conversion should be to <code>int</code> or to <code>double</code>. Facing this lack of information, the compiler would complain that you were using an ambiguous conversion. Nothing in the statement indicates what type to use.</p>
<p>Interestingly, if the class defined only the <code>double</code> conversion function, the compiler would accept the statement. That&#8217;s because with only one conversion possible, there is no ambiguity.</p>
<p>You can have a similar situation with assignment. With the current class declarations, the compiler rejects the following statement as being ambiguous:</p>
<p class="programlisting">long gone = poppins;&#160;&#160;&#160;// ambiguous</p>
<p>In C++, you can assign both <code>int</code> and <code>double</code> values to a <code>long</code> variable, so the compiler legitimately can use either conversion function. The compiler doesn&#8217;t want the responsibility of choosing which. But if you eliminate one of the two conversion functions, the compiler accepts the statement. For example, suppose you omit the <code>double</code> definition. Then the compiler will use the <code>int</code> conversion to convert <code>poppins</code> to a type <code>int</code> value. Then it converts the <code>int</code> value to type <code>long</code> when assigning it to <code>gone</code>.</p>
<p>When the class defines two or more conversions, you can still use an explicit type cast to indicate which conversion function to use. You can use either of these type cast notations:</p>
<p class="programlisting"><a id="page_617"/>long gone = (double) poppins;&#160;&#160;// use double conversion<br/>long gone = int (poppins);&#160;&#160;&#160;&#160;&#160;// use int conversion</p>
<p>The first of these statements converts <code>poppins</code> weight to a <code>double</code> value, and then assignment converts the <code>double</code> value to type <code>long</code>. Similarly, the second statement converts <code>poppins</code> first to type <code>int</code> and then to <code>long</code>.</p>
<p>Like conversion constructors, conversion functions can be a mixed blessing. The problem with providing functions that make automatic, implicit conversions is that they may make conversions when you don&#8217;t expect them. Suppose, for example, that you happen to write the following code when you&#8217;re sleep deprived:</p>
<p class="programlisting">int ar[20];<br/>...<br/>Stonewt temp(14, 4);<br/>...<br/>int Temp = 1;<br/>...<br/>cout &lt;&lt; ar[temp] &lt;&lt; "!\n";&#160;&#160;// used temp instead of Temp</p>
<p>Normally, you&#8217;d expect the compiler to catch a blunder such as using an object instead of an integer as an array index. But the <code>Stonewt</code> class defines an <code>operator int()</code>, so the <code>Stonewt</code> object <code>temp</code> is converted to the <code>int 200</code> and be used as an array index. The moral is that often it&#8217;s best to use explicit conversions and exclude the possibility of implicit conversions. In C++98, the keyword <code>explicit</code> doesn&#8217;t work with conversion functions, but C++11 removes that limitation. So with C++11, you can declare a conversion operator as explicit:</p>
<p class="programlisting">class Stonewt<br/>{<br/>...<br/>// conversion functions<br/>&#160;&#160;&#160;&#160;explicit operator int() const;<br/>&#160;&#160;&#160;&#160;explicit operator double() const;<br/>};</p>
<p>With these declarations in place, you would use a type cast to invoke the operators.</p>
<p>Another approach is to replace a conversion function with a nonconversion function that does the same task&#8212;but only if called explicitly. That is, you can replace</p>
<p class="programlisting">Stonewt::operator int() { return int (pounds + 0.5); }</p>
<p>with</p>
<p class="programlisting">int Stonewt::Stone_to_Int() { return int (pounds + 0.5); }</p>
<p>This disallows the following:</p>
<p class="programlisting">int plb = poppins;</p>
<p><a id="page_618"/>But if you really need a conversion, it allows the following:</p>
<p class="programlisting">int plb = poppins.Stone_to_Int();</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note10"/>Caution</p>
<p class="notepara">You should use implicit conversion functions with care. Often a function that can only be invoked explicitly is the best choice.</p>
<hr/></div>
<p>In summary, then, C++ provides the following type conversions for classes:</p>
<p class="indenthandingB">&#8226; A class constructor that has but a single argument serves as an instruction for converting a value of the argument type to the class type. For example, the <code>Stonewt</code> class constructor with a type <code>int</code> argument is invoked automatically when you assign a type <code>int</code> value to a <code>Stonewt</code> object. However, using <code>explicit</code> in the constructor declaration eliminates implicit conversions and allows only explicit conversions.</p>
<p class="indenthandingB">&#8226; A special class member operator function called a <em>conversion function</em> serves as an instruction for converting a class object to some other type. The conversion function is a class member, has no declared return type, has no arguments, and is called <code>operator</code> <em><code>typeName</code></em><code>()</code>, where <em><code>typeName</code></em> is the type to which the object is to be converted. This conversion function is invoked automatically when you assign a class object to a variable of that type or use the type cast operator to that type.</p>
<h4 id="ch11lev2sec12">Conversions and Friends</h4>
<p>Let&#8217;s bring addition to the <code>Stonewt</code> class. As mentioned in the discussion of the <code>Time</code> class, you can use either a member function or a friend function to overload addition. (To simplify matters, assume that no conversion functions of the <code>operator double()</code> form are defined.) You can implement addition with the following member function:</p>
<p class="programlisting">Stonewt Stonewt::operator+(const Stonewt &#38; st) const<br/>{<br/>&#160;&#160;&#160;&#160;double pds = pounds + st.pounds;<br/>&#160;&#160;&#160;&#160;Stonewt sum(pds);<br/>&#160;&#160;&#160;&#160;return sum;<br/>}</p>
<p>Or you can implement addition as a friend function this way:</p>
<p class="programlisting">Stonewt operator+(const Stonewt &#38; st1, const Stonewt &#38; st2)<br/>{<br/>&#160;&#160;&#160;&#160;double pds = st1.pounds + st2.pounds;<br/>&#160;&#160;&#160;&#160;Stonewt sum(pds);<br/>&#160;&#160;&#160;&#160;return sum;<br/>}</p>
<p>Remember, you can provide the method definition or the friend definition but not both. Either form lets you do the following:</p>
<p class="programlisting"><a id="page_619"/>Stonewt jennySt(9, 12);<br/>Stonewt bennySt(12, 8);<br/>Stonewt total;<br/>total = jennySt + bennySt;</p>
<p>Also given the <code>Stonewt(double)</code> constructor, each form lets you do the following:</p>
<p class="programlisting">Stonewt jennySt(9, 12);<br/>double kennyD = 176.0;<br/>Stonewt total;<br/>total = jennySt + kennyD;</p>
<p>But only the friend function lets you do this:</p>
<p class="programlisting">Stonewt jennySt(9, 12);<br/>double pennyD = 146.0;<br/>Stonewt total;<br/>total = pennyD + jennySt;</p>
<p>To see why, you can translate each addition into the corresponding function calls. First,</p>
<p class="programlisting">total = jennySt + bennySt;</p>
<p>becomes</p>
<p class="programlisting">total = jennySt.operator+(bennySt);&#160;&#160;&#160;// member function</p>
<p>or else</p>
<p class="programlisting">total = operator+(jennySt, bennySt);&#160;&#160;// friend function</p>
<p>In either case, the actual argument types match the formal arguments. Also the member function is invoked, as required, by a <code>Stonewt</code> object.</p>
<p>Next,</p>
<p class="programlisting">total = jennySt + kennyD;</p>
<p>becomes</p>
<p class="programlisting">total = jennySt.operator+(kennyD);&#160;&#160;&#160;// member function</p>
<p>or else</p>
<p class="programlisting">total = operator+(jennySt, kennyD);&#160;&#160;// friend function</p>
<p>Again, the member function is invoked, as required, by a <code>Stonewt</code> object. This time, in each case, one argument (<code>kennyD</code>) is type <code>double</code>, which invokes the <code>Stonewt(double)</code> constructor to convert the argument to a <code>Stonewt</code> object.</p>
<p>By the way, having an <code>operator double()</code> member function defined would create confusion at this point because that would create another option for interpretation. Instead of converting <code>kennyD</code> to <code>double</code> and performing <code>Stonewt</code> addition, the compiler could convert <code>jennySt</code> to <code>double</code> and perform <code>double</code> addition. Having too many conversion functions creates ambiguities.</p>
<p><a id="page_620"/>Finally,</p>
<p class="programlisting">total = pennyD + jennySt;</p>
<p>becomes</p>
<p class="programlisting">total = operator+(pennyD, jennySt);&#160;&#160;// friend function</p>
<p>Here, both arguments are type <code>double</code>, which invokes the <code>Stonewt(double)</code> constructor to convert them to <code>Stonewt</code> objects.</p>
<p>However, the member function version wouldn&#8217;t be able to a<code>dd jennySt</code> to <code>pennyD</code>. Converting the addition syntax to a function call would look like this:</p>
<p class="programlisting">total = pennyD.operator+(jennySt);&#160;&#160;&#160;// not meaningful</p>
<p>But this is meaningless because only a class object can invoke a member function. C++ does not attempt to convert <code>pennyD</code> to a <code>Stonewt</code> object. Conversion takes place for member function arguments, not for member function invokers.</p>
<p>The lesson here is that defining addition as a friend makes it easier for a program to accommodate automatic type conversions. The reason is that both operands become function arguments, so function prototyping comes into play for both operands.</p>
<h5 id="ch11lev3sec7">Choices in Implementing Addition</h5>
<p>Given that you want to add <code>double</code> quantities to <code>Stonewt</code> quantities, you have a couple choices. The first, as you just saw, is to define the following as a friend function and have the <code>Stonewt(double)</code> constructor handle conversions of type <code>double</code> arguments to type <code>Stonewt</code> arguments:</p>
<p class="programlisting">operator+(const Stonewt &#38;, const Stonewt &#38;)</p>
<p>The second choice is to further overload the addition operator with functions that explicitly use one type <code>double</code> argument:</p>
<p class="programlisting">Stonewt operator+(double x);&#160;&#160;// member function<br/>friend Stonewt operator+(double x, Stonewt &#38; s);</p>
<p>That way, the following statement exactly matches the <code>operator+(double x)</code> member function:</p>
<p class="programlisting">total = jennySt + kennyD; // Stonewt + double</p>
<p>And the following statement exactly matches the <code>operator+(double x, Stonewt &#38; s)</code> friend function:</p>
<p class="programlisting">total = pennyD + jennySt; // double + Stonewt</p>
<p>Earlier, we did something similar for <code>Vector</code> multiplication.</p>
<p>Each choice has advantages. The first choice (relying on implicit conversions) results in a shorter program because you define fewer functions. That also implies less work for you and fewer chances to mess up. The disadvantage is the added overhead in time and memory needed to invoke the conversion constructor whenever a conversion is needed. The <a id="page_621"/>second choice (additional functions explicitly matching the types), however, is the mirror image. It makes for a longer program and more work on your part, but it runs a bit faster.</p>
<p>If your program makes intensive use of adding <code>double</code> values to <code>Stonewt</code> objects, it may pay to overload addition to handle such cases directly. If the program uses such addition only occasionally, it&#8217;s simpler to rely on automatic conversions, or if you want to be more careful, on explicit conversions.</p>
<h3 id="ch11lev1sec7">Summary</h3>
<p>This chapter covers many important aspects of defining and using classes. Some of the material in this chapter may seem vague to you until your own experiences enrich your understanding.</p>
<p>Normally, the only way you can access private class members is by using a class method. C++ alleviates that restriction with friend functions. To make a function a friend function, you declare the function in the class declaration and preface the declaration with the keyword <code>friend</code>.</p>
<p>C++ extends overloading to operators by letting you define special operator functions that describe how particular operators relate to a particular class. An operator function can be a class member function or a friend function. (A few operators can only be class member functions.) C++ lets you invoke an operator function either by calling the function or by using the overloaded operator with its usual syntax. An operator function for the operator <em><code>op</code></em> has this form:</p>
<p class="programlisting">operator<span class="EmpItalic">op</span>(<span class="EmpItalic">argument-list</span>)</p>
<p><em><code>argument-list</code></em> represents operands for the operator. If the operator function is a class member function, then the first operand is the invoking object and isn&#8217;t part of <em><code>argument-list</code></em>. For example, this chapter overloaded addition by defining an <code>operator+()</code> member function for the <code>Vector</code> class. If <code>up</code>, <code>right</code>, and <code>result</code> are three vectors, you can use either of the following statements to invoke vector addition:</p>
<p class="programlisting">result = up.operator+(right);<br/>result = up + right;</p>
<p>For the second version, the fact that the operands <code>up</code> and <code>right</code> are type <code>Vector</code> tells C++ to use the <code>Vector</code> definition of addition.</p>
<p>When an operator function is a member function, the first operand is the object invoking the function. In the preceding statements, for example, the <code>up</code> object is the invoking object. If you want to define an operator function so that the first operand is not a class object, you must use a friend function. Then you can pass the operands to the function definition in whichever order you want.</p>
<p>One of the most common tasks for operator overloading is defining the <code>&lt;&lt;</code> operator so that it can be used in conjunction with the <code>cout</code> object to display an object&#8217;s contents. To allow an <code>ostream</code> object to be the first operand, you define the operator function as a <a id="page_622"/>friend. To allow the redefined operator to be concatenated with itself, you make the return type <code>ostream &#38;</code>. Here&#8217;s a general form that satisfies those requirements:</p>
<p class="programlisting">ostream &#38; operator&lt;&lt;(ostream &#38; os, const <span class="EmpItalic">c_name</span> &#38; obj)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; ... ;&#160;&#160;// display object contents<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p>If, however, the class has methods that return values for the data members you want to display, you can use those methods instead of direct access in <code>operator&lt;&lt;()</code>. In that case, the function needn&#8217;t (and shouldn&#8217;t) be a friend.</p>
<p>C++ lets you establish conversions to and from class types. First, any class constructor that takes a single argument acts as a conversion function, converting values of the argument type to the class type. C++ invokes the constructor automatically if you assign a value of the argument type to an object. For example, suppose you have a <code>String</code> class with a constructor that takes a <code>char *</code> value as its sole argument. Then, if <code>bean</code> is a <code>String</code> object, you can use the following statement:</p>
<p class="programlisting">bean = "pinto";&#160;&#160;&#160;// converts type char * to type String</p>
<p>If, however, you precede the constructor declaration with the keyword <code>explicit</code>, the constructor can be used only for explicit conversions:</p>
<p class="programlisting">bean = String("pinto");&#160;&#160;&#160;// converts type char * to type String explicitly</p>
<p>To convert from a class to another type, you must define a conversion function and provide instruction about how to make the conversion. A conversion function must be a member function. If it is to convert to type <em><code>typeName</code></em>, it should have the following prototype:</p>
<p class="programlisting">operator <span class="EmpItalic">typeName()</span>;</p>
<p>Note that it must have no declared return type, must have no arguments, and must (despite having no declared return type) return the converted value. For example, a function to convert type <code>Vector</code> to type <code>double</code> would have this function form:</p>
<p class="programlisting">Vector::operator double()<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;return a_double_value;<br/>}</p>
<p>Experience has shown that often it is better not to rely on such implicit conversion functions.</p>
<p>As you might have noticed, classes require much more care and attention to detail than do simple C-style structures. In return, they do much more for you.</p>
<h3 id="ch11lev1sec8">Chapter Review</h3>
<p class="question"><a id="page_623"/><a id="ch11qa1q1" href="app10.html#ch11qa1a1"><strong>1.</strong></a> Use a member function to overload the multiplication operator for the <code>Stonewt</code> class; have the operator multiply the data members by a type <code>double</code> value. Note that this will require carryover for the stone&#8211;pound representation. That is, twice 10 stone 8 pounds is 21 stone 2 pounds.</p>
<p class="question"><a id="ch11qa1q2" href="app10.html#ch11qa1a2"><strong>2.</strong></a> What are the differences between a friend function and a member function?</p>
<p class="question"><a id="ch11qa1q3" href="app10.html#ch11qa1a3"><strong>3.</strong></a> Does a nonmember function have to be a friend to access a class&#8217;s members?</p>
<p class="question"><a id="ch11qa1q4" href="app10.html#ch11qa1a4"><strong>4.</strong></a> Use a friend function to overload the multiplication operator for the <code>Stonewt</code> class; have the operator multiply the <code>double</code> value by the <code>Stone</code> value.</p>
<p class="question"><a id="ch11qa1q5" href="app10.html#ch11qa1a5"><strong>5.</strong></a> Which operators cannot be overloaded?</p>
<p class="question"><a id="ch11qa1q6" href="app10.html#ch11qa1a6"><strong>6.</strong></a> What restriction applies to overloading the following operators? <code>=</code>, <code>()</code>, <code>[]</code>, and <code>-&gt;</code></p>
<p class="question"><a id="ch11qa1q7" href="app10.html#ch11qa1a7"><strong>7.</strong></a> Define a conversion function for the <code>Vector</code> class that converts a <code>Vector</code> object to a type <code>double</code> value that represents the vector&#8217;s magnitude.</p>
<h3 id="ch11lev1sec9">Programming Exercises</h3>
<p class="question"><a id="ch11qa2q1"/><strong>1.</strong> Modify <a href="#ch11ex15">Listing 11.15</a> so that it writes the successive locations of the random walker into a file. Label each position with the step number. Also have the program write the initial conditions (target distance and step size) and the summarized results to the file. The file contents might look like this:</p>
<p class="programlistingB">Target Distance: 100, Step Size: 20<br/>0: (x,y) = (0, 0)<br/>1: (x,y) = (-11.4715, 16.383)<br/>2: (x,y) = (-8.68807, -3.42232)<br/>...<br/>26: (x,y) = (42.2919, -78.2594)<br/>27: (x,y) = (58.6749, -89.7309)<br/>After 27 steps, the subject has the following location:<br/>(x,y) = (58.6749, -89.7309)<br/>&#160;or<br/>(m,a) = (107.212, -56.8194)<br/>Average outward distance per step = 3.97081</p>
<p class="question"><a id="ch11qa2q2"/><strong>2.</strong> Modify the <code>Vector</code> class header and implementation files (<a href="#ch11ex13">Listings 11.13</a> and <a href="#ch11ex14">11.14</a>) so that the magnitude and angle are no longer stored as data components. Instead, they should be calculated on demand when the <code>magval()</code> and <code>angval()</code> methods are called. You should leave the public interface unchanged (the same public methods with the same arguments) but alter the private section, including some of the private method and the method implementations. Test the modified version with <a id="page_624"/><a href="#ch11ex15">Listing 11.15</a>, which should be left unchanged because the public interface of the <code>Vector</code> class is unchanged.</p>
<p class="question"><a id="ch11qa2q3"/><strong>3.</strong> Modify <a href="#ch11ex15">Listing 11.15</a> so that instead of reporting the results of a single trial for a particular target/step combination, it reports the highest, lowest, and average number of steps for <em>N</em> trials, where <em>N</em> is an integer entered by the user.</p>
<p class="question"><a id="ch11qa2q4"/><strong>4.</strong> Rewrite the final <code>Time</code> class example (<a href="#ch11ex10">Listings 11.10</a>, <a href="#ch11ex11">11.11</a>, and <a href="#ch11ex12">11.12</a>) so that all the overloaded operators are implemented using friend functions.</p>
<p class="question"><a id="ch11qa2q5"/><strong>5.</strong> Rewrite the <code>Stonewt</code> class (<a href="#ch11ex16">Listings 11.16</a> and <a href="#ch11ex17">11.17</a>) so that it has a state member that governs whether the object is interpreted in stone form, integer pounds form, or floating-point pounds form. Overload the <code>&lt;&lt;</code> operator to replace the <code>show_stn()</code> and <code>show_lbs()</code> methods. Overload the addition, subtraction, and multiplication operators so that one can add, subtract, and multiply <code>Stonewt</code> values. Test your class with a short program that uses all the class methods and friends.</p>
<p class="question"><a id="ch11qa2q6"/><strong>6.</strong> Rewrite the <code>Stonewt</code> class (<a href="#ch11ex16">Listings 11.16</a> and <a href="#ch11ex17">11.17</a>) so that it overloads all six relational operators. The operators should compare the <code>pounds</code> members and return a type <code>bool</code> value. Write a program that declares an array of six <code>Stonewt</code> objects and initializes the first three objects in the array declaration. Then it should use a loop to read in values used to set the remaining three array elements. Then it should report the smallest element, the largest element, and how many elements are greater or equal to 11 stone. (The simplest approach is to create a <code>Stonewt</code> object initialized to 11 stone and to compare the other objects with that object.)</p>
<p class="question"><a id="ch11qa2q7"/><strong>7.</strong> A complex number has two parts: a real part and an imaginary part. One way to write an imaginary number is this: (3.0, 4.0). Here 3.0 is the real part and 4.0 is the imaginary part. Suppose a = (A,Bi) and c = (C,Di). Here are some complex operations:</p>
<p class="indenthandingNB">&#8226; Addition: a + c = (A + C, (B + D)i)</p>
<p class="indenthandingNB">&#8226; Subtraction: a - c = (A - C, (B - D)i)</p>
<p class="indenthandingNB">&#8226; Multiplication: a &#215; c = (A &#215; C - B&#215;D, (A&#215;D + B&#215;C)i)</p>
<p class="indenthandingNB">&#8226; Multiplication: (x a real number): x &#215; c = (x&#215;C,x&#215;Di)</p>
<p class="indenthandingNB">&#8226; Conjugation: ~a = (A, - Bi)</p>
<p class="questionp">Define a complex class so that the following program can use it with correct results:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/>#include "complex0.h"&#160;&#160;// to avoid confusion with complex.h<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;complex a(3.0, 4.0);&#160;&#160;&#160;// initialize to (3,4i)<br/><a id="page_625"/>&#160;&#160;&#160;&#160;complex c;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a complex number (q to quit):\n";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; c)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "c is " &lt;&lt; c &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "complex conjugate is " &lt;&lt; ~c &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "a is " &lt;&lt; a &lt;&lt; '\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "a + c is " &lt;&lt; a + c &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "a - c is " &lt;&lt; a - c &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "a * c is " &lt;&lt; a * c &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "2 * c is " &lt;&lt; 2 * c &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a complex number (q to quit):\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="questionp">Note that you have to overload the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators. Standard C++ already has complex support&#8212;rather more extensive than in this example&#8212;in a <code>complex</code> header file, so use <code>complex0.h</code> to avoid conflicts. Use <code>const</code> whenever warranted.</p>
<p class="questionp">Here is a sample run of the program:</p>
<p class="programlistingB">Enter a complex number (q to quit):<br/>real: <span class="EmpStrong">10</span><br/>imaginary: <span class="EmpStrong">12</span><br/>c is (10,12i)<br/>complex conjugate is (10,-12i)<br/>a is (3,4i)<br/>a + c is (13,16i)<br/>a - c is (-7,-8i)<br/>a * c is (-18,76i)<br/>2 * c is (20,24i)<br/>Enter a complex number (q to quit):<br/>real: <span class="EmpStrong">q</span><br/>Done!</p>
<p class="questionp">Note that <code>cin &gt;&gt; c</code>, through overloading, now prompts for real and imaginary parts.</p>
</body>
</html>
