<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>8. Adventures in Functions</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch08">8. Adventures in Functions</h2>
<p><a id="page_379"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Inline functions</p>
<p class="indenthandingB">&#8226; Reference variables</p>
<p class="indenthandingB">&#8226; How to pass function arguments by reference</p>
<p class="indenthandingB">&#8226; Default arguments</p>
<p class="indenthandingB">&#8226; Function overloading</p>
<p class="indenthandingB">&#8226; Function templates</p>
<p class="indenthandingB">&#8226; Function template specializations</p>
<p>With <a href="ch07.html#ch07">Chapter 7</a>, &#8220;<a href="ch07.html#ch07">Functions: C++&#8217;s Programming Modules</a>,&#8221; under your belt, you now know a lot about C++ functions, but there&#8217;s much more to come. C++ provides many new function features that separate C++ from its C heritage. The new features include inline functions, by-reference variable passing, default argument values, function overloading (polymorphism), and template functions. This chapter, more than any other you&#8217;ve read so far, explores features found in C++ but not C, so it marks your first major foray into plus-plussedness.</p>
<h3 id="ch08lev1sec1">C++ Inline Functions</h3>
<p><em>Inline functions</em> are a C++ enhancement designed to speed up programs. The primary distinction between normal functions and inline functions is not in how you code them but in how the C++ compiler incorporates them into a program. To understand the distinction between inline functions and normal functions, you need to peer more deeply into a program&#8217;s innards than we have so far. Let&#8217;s do that now.</p>
<p>The final product of the compilation process is an executable program, which consists of a set of machine language instructions. When you start a program, the operating system loads these instructions into the computer&#8217;s memory so that each instruction has a particular memory address. The computer then goes through these instructions step-by-step. Sometimes, as when you have a loop or a branching statement, program execution skips <a id="page_380"/>over instructions, jumping backward or forward to a particular address. Normal function calls also involve having a program jump to another address (the function&#8217;s address) and then jump back when the function terminates. Let&#8217;s look at a typical implementation of that process in a little more detail. When a program reaches the function call instruction, the program stores the memory address of the instruction immediately following the function call, copies function arguments to the stack (a block of memory reserved for that purpose), jumps to the memory location that marks the beginning of the function, executes the function code (perhaps placing a return value in a register), and then jumps back to the instruction whose address it saved.<sup><a id="ch08fn01" href="footnotes.html#ftn.ch08fn01">1</a></sup> Jumping back and forth and keeping track of where to jump means that there is an overhead in elapsed time to using functions.</p>
<p>C++ inline functions provide an alternative. In an inline function, the compiled code is &#8220;in line&#8221; with the other code in the program. That is, the compiler replaces the function call with the corresponding function code. With inline code, the program doesn&#8217;t have to jump to another location to execute the code and then jump back. Inline functions thus run a little faster than regular functions, but they come with a memory penalty. If a program calls an inline function at ten separate locations, then the program winds up with ten copies of the function inserted into the code (see <a href="#ch08fig01">Figure 8.1</a>).</p>
<p class="caption"><a id="ch08fig01"/><strong>Figure 8.1. Inline functions versus regular functions.</strong></p>
<p class="image"><img src="graphics/08fig01.jpg" alt="Image"/></p>
<p>You should be selective about using inline functions. If the time needed to execute the function code is long compared to the time needed to handle the function call mechanism, then the time saved is a relatively small portion of the entire process. If the code execution time is short, then an inline call can save a large portion of the time used by the non-inline call. On the other hand, you are now saving a large portion of a relatively quick process, so the absolute time savings may not be that great unless the function is called frequently.</p>
<p>To use this feature, you must take at least one of two actions:</p>
<p class="indenthandingB">&#8226; Preface the function declaration with the keyword <code>inline</code>.</p>
<p class="indenthandingB">&#8226; Preface the function definition with the keyword <code>inline</code>.</p>
<p>A common practice is to omit the prototype and to place the entire definition (meaning the function header and all the function code) where the prototype would normally go.</p>
<p>The compiler does not have to honor your request to make a function inline. It might decide the function is too large or notice that it calls itself (recursion is not allowed or indeed possible for inline functions), or the feature might not be turned on or implemented for your particular compiler.</p>
<p><a id="page_381"/><a href="#ch08ex01">Listing 8.1</a> illustrates the inline technique with an inline <code>square()</code> function that squares its argument. Note that the entire definition is on one line. That&#8217;s not required, but if the definition doesn&#8217;t fit on one or two lines (assuming you don&#8217;t have lengthy identifiers), the function is probably a poor candidate for an inline function.</p>
<p class="caption1"><a id="ch08ex01"/><strong>Listing 8.1. <code>inline.cpp</code></strong></p><hr/>
<p class="programlisting1">// inline.cpp -- using an inline function<br/>#include &lt;iostream&gt;<br/><br/>// an inline function definition<br/>inline double square(double x) { return x * x; }<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double a, b;<br/>&#160;&#160;&#160;&#160;double c = 13.0;<br/><br/>&#160;&#160;&#160;&#160;a = square(5.0);<br/>&#160;&#160;&#160;&#160;b = square(4.5 + 7.5);&#160;&#160;&#160;// can pass expressions<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "c = " &lt;&lt; c;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", c squared = " &lt;&lt; square(c++) &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Now c = " &lt;&lt; c &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_382"/>Here&#8217;s the output of the program in <a href="#ch08ex01">Listing 8.1</a>:</p>
<p class="programlisting">a = 25, b = 144<br/>c = 13, c squared = 169<br/>Now c = 14</p>
<p>This output illustrates that inline functions pass arguments by value just like regular functions do. If the argument is an expression, such as <code>4.5 + 7.5</code>, the function passes the value of the expression&#8212;<code>12</code> in this case. This makes C++&#8217;s inline facility far superior to C&#8217;s macro definitions. See the &#8220;<a href="#ch08sb01">Inline Versus Macros</a>&#8221; sidebar.</p>
<p>Even though the program doesn&#8217;t provide a separate prototype, C++&#8217;s prototyping features are still in play. That&#8217;s because the entire definition, which comes before the function&#8217;s first use, serves as a prototype. This means you can use <code>square()</code> with an <code>int</code> argument or a <code>long</code> argument, and the program automatically type casts the value to type <code>double</code> before passing it to the function.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch08sb01"/>Inline Versus Macros</p>
<p class="sidebarpara">The <code>inline</code> facility is an addition to C++. C uses the preprocessor <code>#define</code> statement to provide <em>macros</em>, which are crude implementations of inline code. For example, here&#8217;s a macro for squaring a number:</p>
<p class="programlistingB">#define SQUARE(X) X*X</p>
<p class="sidebarpara">This works not by passing arguments but through text substitution, with the <code>X</code> acting as a symbolic label for the &#8220;argument&#8221;:</p>
<p class="programlistingB">a = SQUARE(5.0); is replaced by a = 5.0*5.0;<br/>b = SQUARE(4.5 + 7.5); is replaced by b = 4.5 + 7.5 * 4.5 + 7.5;<br/>d = SQUARE(c++); is replaced by d = c++*c++;</p>
<p class="sidebarpara">Only the first example here works properly. You can improve matters with a liberal application of parentheses:</p>
<p class="programlistingB">#define SQUARE(X) ((X)*(X))</p>
<p class="sidebarpara">Still, the problem remains that macros don&#8217;t pass by value. Even with this new definition, <code>SQUARE(c++)</code> increments <code>c</code> twice, but the inline <code>square()</code> function in <a href="#ch08ex01">Listing 8.1</a> evaluates <code>c</code>, passes that value to be squared, and then increments <code>c</code> once.</p>
<p class="sidebarpara">The intent here is not to show you how to write C macros. Rather, it is to suggest that if you have been using C macros to perform function-like services, you should consider converting them to C++ inline functions.</p>
<hr/></div>
<h3 id="ch08lev1sec2">Reference Variables</h3>
<p><a id="page_383"/>C++ adds a new compound type to the language&#8212;the reference variable. A <em>reference</em> is a name that acts as an alias, or an alternative name, for a previously defined variable. For example, if you make <code>twain</code> a reference to the <code>clemens</code> variable, you can use <code>twain</code> and <code>clemens</code> interchangeably to represent that variable. Of what use is such an alias? Is it to help people who are embarrassed by their choice of variable names? Maybe, but the main use for a reference variable is as a formal argument to a function. If you use a reference as an argument, the function works with the original data instead of with a copy. References provide a convenient alternative to pointers for processing large structures with a function, and they are essential for designing classes. Before you see how to use references with functions, however, let&#8217;s examine the basics of defining and using a reference. Keep in mind that the purpose of the following discussion is to illustrate how references work, not how they are typically used.</p>
<h4 id="ch08lev2sec1">Creating a Reference Variable</h4>
<p>You might recall that C and C++ use the <code>&#38;</code> symbol to indicate the address of a variable. C++ assigns an additional meaning to the <code>&#38;</code> symbol and presses it into service for declaring references. For example, to make <code>rodents</code> an alternative name for the variable <code>rats</code>, you could do the following:</p>
<p class="programlisting">int rats;<br/>int &#38; rodents = rats;&#160;&#160;&#160;&#160;// makes rodents an alias for rats</p>
<p>In this context, <code>&#38;</code> is not the address operator. Instead, it serves as part of the type identifier. Just as <code>char *</code> in a declaration means pointer-to-<code>char</code>, <code>int &#38;</code> means reference-to-<code>int</code>. The reference declaration allows you to use <code>rats</code> and <code>rodents</code> interchangeably; both refer to the same value and the same memory location. <a href="#ch08ex02">Listing 8.2</a> illustrates the truth of this claim.</p>
<p class="caption1"><a id="ch08ex02"/><strong>Listing 8.2. <code>firstref.cpp</code></strong></p><hr/>
<p class="programlisting1">// firstref.cpp -- defining and using a reference<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int rats = 101;<br/>&#160;&#160;&#160;&#160;int &#38; rodents = rats;&#160;&#160;&#160;// rodents is a reference<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "rats = " &lt;&lt; rats;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", rodents = " &lt;&lt; rodents &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;rodents++;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "rats = " &lt;&lt; rats;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", rodents = " &lt;&lt; rodents &lt;&lt; endl;<br/><br/>// some implementations require type casting the following<br/>// addresses to type unsigned<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "rats address = " &lt;&lt; &#38;rats;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", rodents address = " &lt;&lt; &#38;rodents &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_384"/>Note that the <code>&#38;</code> operator in the following statement <em>is not</em> the address operator but declares that <code>rodents</code> is of type <code>int &#38;</code> (that is, it is a reference to an <code>int</code> variable):</p>
<p class="programlisting">int &#38; rodents = rats;</p>
<p>But the <code>&#38;</code> operator in the next statement <em>is</em> the address operator, with <code>&#38;rodents</code> representing the address of the variable to which <code>rodents</code> refers:</p>
<p class="programlisting">cout &lt;&lt;", rodents address = " &lt;&lt; &#38;rodents &lt;&lt; endl;</p>
<p>Here is the output of the program in <a href="#ch08ex02">Listing 8.2</a>:</p>
<p class="programlisting">rats = 101, rodents = 101<br/>rats = 102, rodents = 102<br/>rats address = 0x0065fd48, rodents address = 0x0065fd48</p>
<p>As you can see, both <code>rats</code> and <code>rodents</code> have the same value and the same address. (The address values and display format vary from system to system.) Incrementing <code>rodents</code> by one affects both variables. More precisely, the <code>rodents++</code> operation increments a single variable for which there are two names. (Again, keep in mind that although this example shows you how a reference works, it doesn&#8217;t represent the typical use for a reference, which is as a function parameter, particularly for structure and object arguments. We&#8217;ll look into these uses pretty soon.)</p>
<p>References tend to be a bit confusing at first to C veterans coming to C++ because they are tantalizingly reminiscent of pointers, yet somehow different. For example, you can create both a reference and a pointer to refer to <code>rats</code>:</p>
<p class="programlisting">int rats = 101;<br/>int &#38; rodents = rats;&#160;&#160;&#160;// rodents a reference<br/>int * prats = &#38;rats;&#160;&#160;&#160;&#160;// prats a pointer</p>
<p>Then you could use the expressions <code>rodents</code> and <code>*prats</code> interchangeably with <code>rats</code> and use the expressions <code>&#38;rodents</code> and <code>prats</code> interchangeably with <code>&#38;rats</code>. From this standpoint, a reference looks a lot like a pointer in disguised notation in which the <code>*</code> dereferencing operator is understood implicitly. And, in fact, that&#8217;s more or less what a reference is. But there are differences besides those of notation. For one, it is necessary to <a id="page_385"/>initialize the reference when you declare it; you can&#8217;t declare the reference and then assign it a value later the way you can with a pointer:</p>
<p class="programlisting">int rat;<br/>int &#38; rodent;<br/>rodent = rat;&#160;&#160;&#160;// No, you can't do this.</p>
<div class="note"><hr/>
<p class="title"><a id="ch08note01"/>Note</p>
<p class="notepara">You should initialize a reference variable when you declare it.</p>
<hr/></div>
<p>A reference is rather like a <code>const</code> pointer; you have to initialize it when you create it, and when a reference pledges its allegiance to a particular variable, it sticks to its pledge. That is,</p>
<p class="programlisting">int &#38; rodents = rats;</p>
<p>is, in essence, a disguised notation for something like this:</p>
<p class="programlisting">int * const pr = &#38;rats;</p>
<p>Here, the reference <code>rodents</code> plays the same role as the expression <code>*pr</code>.</p>
<p><a href="#ch08ex03">Listing 8.3</a> shows what happens if you try to make a reference change allegiance from a <code>rats</code> variable to a <code>bunnies</code> variable.</p>
<p class="caption1"><a id="ch08ex03"/><strong>Listing 8.3. <code>secref.cpp</code></strong></p><hr/>
<p class="programlisting1">// secref.cpp -- defining and using a reference<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int rats = 101;<br/>&#160;&#160;&#160;&#160;int &#38; rodents = rats;&#160;&#160;&#160;// rodents is a reference<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "rats = " &lt;&lt; rats;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", rodents = " &lt;&lt; rodents &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "rats address = " &lt;&lt; &#38;rats;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", rodents address = " &lt;&lt; &#38;rodents &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;int bunnies = 50;<br/>&#160;&#160;&#160;&#160;rodents = bunnies;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// can we change the reference?<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "bunnies = " &lt;&lt; bunnies;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", rats = " &lt;&lt; rats;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", rodents = " &lt;&lt; rodents &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "bunnies address = " &lt;&lt; &#38;bunnies;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", rodents address = " &lt;&lt; &#38;rodents &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_386"/>Here&#8217;s the output of the program in <a href="#ch08ex03">Listing 8.3</a>:</p>
<p class="programlisting">rats = 101, rodents = 101<br/>rats address = 0x0065fd44, rodents address = 0x0065fd44<br/>bunnies = 50, rats = 50, rodents = 50<br/>bunnies address = 0x0065fd48, rodents address = 0x0065fd4</p>
<p>Initially, <code>rodents</code> refers to <code>rats</code>, but then the program apparently attempts to make <code>rodents</code> a reference to <code>bunnies</code>:</p>
<p class="programlisting">rodents = bunnies;</p>
<p>For a moment, it looks as if this attempt has succeeded because the value of <code>rodents</code> changes from <code>101</code> to <code>50</code>. But closer inspection reveals that <code>rats</code> also has changed to <code>50</code> and that <code>rats</code> and <code>rodents</code> still share the same address, which differs from the <code>bunnies</code> address. Because <code>rodents</code> is an alias for <code>rats</code>, the assignment statement really means the same as the following:</p>
<p class="programlisting">rats = bunnies;</p>
<p>That is, it means &#8220;Assign the value of the <code>bunnies</code> variable to the <code>rat</code> variable.&#8221; In short, you can set a reference by an initializing declaration, not by assignment.</p>
<p>Suppose you tried the following:</p>
<p class="programlisting">int rats = 101;<br/>int * pt = &#38;rats;<br/>int &#38; rodents = *pt;<br/>int bunnies = 50;<br/>pt = &#38;bunnies;</p>
<p>Initializing <code>rodents</code> to <code>*pt</code> makes <code>rodents</code> refer to <code>rats</code>. Subsequently altering <code>pt</code> to point to <code>bunnies</code> does not alter the fact that <code>rodents</code> refers to <code>rats</code>.</p>
<h4 id="ch08lev2sec2">References as Function Parameters</h4>
<p>Most often, references are used as function parameters, making a variable name in a function an alias for a variable in the calling program. This method of passing arguments is called <em>passing by reference</em>. Passing by reference allows a called function to access variables in the calling function. C++&#8217;s addition of the feature is a break from C, which only passes by value. Passing by value, recall, results in the called function working with copies of values from the calling program (see <a href="#ch08fig02">Figure 8.2</a>). Of course, C lets you get around the passing by value limitation by using pointers.</p>
<p class="caption"><a id="ch08fig02"/><strong>Figure 8.2. Passing by value and passing by reference.</strong></p>
<p class="image"><img src="graphics/08fig02.jpg" alt="Image"/></p>
<p>Let&#8217;s compare using references and using pointers in a common computer problem: swapping the values of two variables. A swapping function has to be able to alter values of variables in the calling program. That means the usual approach of passing variables by value won&#8217;t work because the function will end up swapping the contents of copies of the original variables instead of the variables themselves. If you pass references, however, the function can work with the original data. Alternatively, you can pass pointers in order to access the original data. <a href="#ch08ex04">Listing 8.4</a> shows all three methods, including the one that doesn&#8217;t work, so that you can compare them.</p>
<p class="caption1"><a id="page_387"/><a id="ch08ex04"/><strong>Listing 8.4. <code>swaps.cpp</code></strong></p><hr/>
<p class="programlisting1">// swaps.cpp -- swapping with references and with pointers<br/>#include &lt;iostream&gt;<br/>void swapr(int &#38; a, int &#38; b);&#160;&#160;&#160;// a, b are aliases for ints<br/>void swapp(int * p, int * q);&#160;&#160;&#160;// p, q are addresses of ints<br/>void swapv(int a, int b);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a, b are new variables<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int wallet1 = 300;<br/>&#160;&#160;&#160;&#160;int wallet2 = 350;<br/><br/><a id="page_388"/>&#160;&#160;&#160;&#160;cout &lt;&lt; "wallet1 = $" &lt;&lt; wallet1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " wallet2 = $" &lt;&lt; wallet2 &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using references to swap contents:\n";<br/>&#160;&#160;&#160;&#160;swapr(wallet1, wallet2);&#160;&#160;&#160;// pass variables<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "wallet1 = $" &lt;&lt; wallet1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " wallet2 = $" &lt;&lt; wallet2 &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using pointers to swap contents again:\n";<br/>&#160;&#160;&#160;&#160;swapp(&#38;wallet1, &#38;wallet2); // pass addresses of variables<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "wallet1 = $" &lt;&lt; wallet1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " wallet2 = $" &lt;&lt; wallet2 &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Trying to use passing by value:\n";<br/>&#160;&#160;&#160;&#160;swapv(wallet1, wallet2);&#160;&#160;&#160;// pass values of variables<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "wallet1 = $" &lt;&lt; wallet1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " wallet2 = $" &lt;&lt; wallet2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void swapr(int &#38; a, int &#38; b)&#160;&#160;&#160;&#160;// use references<br/>{<br/>&#160;&#160;&#160;&#160;int temp;<br/><br/>&#160;&#160;&#160;&#160;temp = a;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use a, b for values of variables<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}<br/><br/>void swapp(int * p, int * q)&#160;&#160;&#160;&#160;// use pointers<br/>{<br/>&#160;&#160;&#160;&#160;int temp;<br/><br/>&#160;&#160;&#160;&#160;temp = *p;&#160;&#160;&#160;&#160;&#160;&#160;// use *p, *q for values of variables<br/>&#160;&#160;&#160;&#160;*p = *q;<br/>&#160;&#160;&#160;&#160;*q = temp;<br/>}<br/><br/>void swapv(int a, int b)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// try using values<br/>{<br/>&#160;&#160;&#160;&#160;int temp;<br/><br/>&#160;&#160;&#160;&#160;temp = a;&#160;&#160;&#160;&#160;&#160;&#160;// use a, b for values of variables<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}</p><hr/>
<p><a id="page_389"/>Here&#8217;s the output of the program in <a href="#ch08ex04">Listing 8.4</a>:</p>
<p class="programlisting">wallet1 = $300 wallet2 = $350&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; <span class="romanAlt">original values</span><br/>Using references to swap contents:<br/>wallet1 = $350 wallet2 = $300&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; <span class="romanAlt">values swapped</span><br/>Using pointers to swap contents again:<br/>wallet1 = $300 wallet2 = $350&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; <span class="romanAlt">values swapped again</span><br/>Trying to use passing by value:<br/>wallet1 = $300 wallet2 = $350&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; <span class="romanAlt">swap failed</span></p>
<p>As you&#8217;d expect, the reference and pointer methods both successfully swap the contents of the two wallets, whereas the passing by value method fails.</p>
<h5 id="ch08lev3sec1">Program Notes</h5>
<p>First, note how each function in <a href="#ch08ex04">Listing 8.4</a> is called:</p>
<p class="programlisting">swapr(wallet1, wallet2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pass variables<br/>swapp(&#38;wallet1, &#38;wallet2);&#160;&#160;&#160;&#160;&#160;&#160;// pass addresses of variables<br/>swapv(wallet1, wallet2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pass values of variables</p>
<p>Passing by reference (<code>swapr(wallet1, wallet2)</code>) and passing by value (<code>swapv(wallet1, wallet2)</code>) look identical. The only way you can tell that <code>swapr()</code> passes by reference is by looking at the prototype or the function definition. However, the presence of the address operator (<code>&#38;</code>) makes it obvious when a function passes by address (<code>(swapp(&#38;wallet1, &#38;wallet2)</code>). (Recall that the type declaration <code>int *p</code> means that <code>p</code> is a pointer to an <code>int</code> and therefore the argument corresponding to <code>p</code> should be an address, such as <code>&#38;wallet1</code>.)</p>
<p>Next, compare the code for the functions <code>swapr()</code> (passing by reference) and <code>swapv()</code> (passing by value). The only outward difference between the two is how the function parameters are declared:</p>
<p class="programlisting">void swapr(int &#38; a, int &#38; b)<br/>void swapv(int a, int b)</p>
<p>The internal difference, of course, is that in <code>swapr()</code> the variables <code>a</code> and <code>b</code> serve as aliases for <code>wallet1</code> and <code>wallet2</code>, so swapping <code>a</code> and <code>b</code> swaps <code>wallet1</code> and <code>wallet2</code>. But in <code>swapv()</code>, the variables <code>a</code> and <code>b</code> are new variables that copy the values of <code>wallet1</code> and <code>wallet2</code>, so swapping <code>a</code> and <code>b</code> has no effect on <code>wallet1</code> and <code>wallet2</code>.</p>
<p>Finally, compare the functions <code>swapr()</code> (passing a reference) and <code>swapp()</code> (passing a pointer). The first difference is in how the function parameters are declared:</p>
<p class="programlisting">void swapr(int &#38; a, int &#38; b)<br/>void swapp(int * p, int * q)</p>
<p>The second difference is that the pointer version requires using the <code>*</code> dereferencing operator throughout when the function uses <code>p</code> and <code>q</code>.</p>
<p>Earlier, I said you should initialize a reference variable when you define it. A function call initializes its parameters with argument values from the function call. So reference function arguments are initialized to the argument passed by the function call. That is, the <a id="page_390"/>following function call initializes the formal parameter <code>a</code> to <code>wallet1</code> and the formal parameter <code>b</code> to <code>wallet2</code>:</p>
<p class="programlisting">swapr(wallet1, wallet2);</p>
<h4 id="ch08lev2sec3">Reference Properties and Oddities</h4>
<p>Using reference arguments has several twists you need to know about. First, consider <a href="#ch08ex05">Listing 8.5</a>. It uses two functions to cube an argument. One takes a type <code>double</code> argument, and the other takes a reference to <code>double</code>. The actual code for cubing is purposefully a bit odd to illustrate a point.</p>
<p class="caption1"><a id="ch08ex05"/><strong>Listing 8.5. <code>cubes.cpp</code></strong></p><hr/>
<p class="programlisting1">// cubes.cpp -- regular and reference arguments<br/>#include &lt;iostream&gt;<br/>double cube(double a);<br/>double refcube(double &#38;ra);<br/>int main ()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double x = 3.0;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; cube(x);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " = cube of " &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; refcube(x);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " = cube of " &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>double cube(double a)<br/>{<br/>&#160;&#160;&#160;&#160;a *= a * a;<br/>&#160;&#160;&#160;&#160;return a;<br/>}<br/><br/>double refcube(double &#38;ra)<br/>{<br/>&#160;&#160;&#160;&#160;ra *= ra * ra;<br/>&#160;&#160;&#160;&#160;return ra;<br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch08ex05">Listing 8.5</a>:</p>
<p class="programlisting">27 = cube of 3<br/>27 = cube of 27</p>
<p><a id="page_391"/>Note that the <code>refcube()</code> function modifies the value of <code>x</code> in <code>main()</code> and <code>cube()</code> doesn&#8217;t, which reminds you why passing by value is the norm. The variable <code>a</code> is local to <code>cube()</code>. It is initialized to the value of <code>x</code>, but changing <code>a</code> has no effect on <code>x</code>. But because <code>refcube()</code> uses a reference argument, the changes it makes to <code>ra</code> are actually made to <code>x</code>. If your intent is that a function use the information passed to it without modifying the information, and if you&#8217;re using a reference, you should use a constant reference. Here, for example, you should use <code>const</code> in the function prototype and function header:</p>
<p class="programlisting">double refcube(const double &#38;ra);</p>
<p>If you do this, the compiler generates an error message when it finds code altering the value of <code>ra</code>.</p>
<p>Incidentally, if you need to write a function along the lines of this example (that is, using a basic numeric type), you should use passing by value rather than the more exotic passing by reference. Reference arguments become useful with larger data units, such as structures and classes, as you&#8217;ll soon see.</p>
<p>Functions that pass by value, such as the <code>cube()</code> function in <a href="#ch08ex05">Listing 8.5</a>, can use many kinds of actual arguments. For example, all the following calls are valid:</p>
<p class="programlisting">double z = cube(x + 2.0);&#160;&#160;&#160;&#160;&#160;// evaluate x + 2.0, pass value<br/>z = cube(8.0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pass the value 8.0<br/>int k = 10;<br/>z = cube(k);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// convert value of k to double, pass value<br/>double yo[3] = { 2.2, 3.3, 4.4};<br/>z = cube (yo[2]);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pass the value 4.4</p>
<p>Suppose you try similar arguments for a function with a reference parameter. It would seem that passing a reference should be more restrictive. After all, if <code>ra</code> is the alternative name for a variable, then the actual argument should be that variable. Something like the following doesn&#8217;t appear to make sense because the expression <code>x + 3.0</code> is not a variable:</p>
<p class="programlisting">double z = refcube(x + 3.0);&#160;&#160;// should not compile</p>
<p>For example, you can&#8217;t assign a value to such an expression:</p>
<p class="programlisting">x + 3.0 = 5.0;&#160;&#160;// nonsensical</p>
<p>What happens if you try a function call like <code>refcube(x + 3.0)</code>? In contemporary C++, that&#8217;s an error, and most compilers will tell you so. Some older ones give you a warning along the following lines:</p>
<p class="programlisting">Warning: Temporary used for parameter 'ra' in call to refcube(double &#38;)</p>
<p>The reason for this milder response is that C++, in its early years, did allow you to pass expressions to a reference variable. In some cases, it still does. What happens is that because <code>x + 3.0</code> is not a type <code>double</code> variable, the program creates a temporary, nameless variable, initializing it to the value of the expression <code>x + 3.0</code>. Then <code>ra</code> becomes a reference to that temporary variable. Let&#8217;s take a closer look at temporary variables and see when they are and are not created.</p>
<h5 id="ch08lev3sec2">Temporary Variables, Reference Arguments, and <code>const</code></h5>
<p><a id="page_392"/>C++ can generate a temporary variable if the actual argument doesn&#8217;t match a reference argument. Currently, C++ permits this only if the argument is a <code>const</code> reference, but this was not always the case. Let&#8217;s look at the cases in which C++ does generate temporary variables and see why the restriction to a <code>const</code> reference makes sense.</p>
<p>First, when is a temporary variable created? Provided that the reference parameter is a <code>const</code>, the compiler generates a temporary variable in two kinds of situations:</p>
<p class="indenthandingB">&#8226; When the actual argument is the correct type but isn&#8217;t an <em>lvalue</em></p>
<p class="indenthandingB">&#8226; When the actual argument is of the wrong type, but it&#8217;s of a type that can be converted to the correct type</p>
<p>What is an lvalue? An argument that&#8217;s an lvalue is a data object that can be referenced by address. For example, a variable, an array element, a structure member, a reference, and a dereferenced pointer are lvalues. Non-lvalues include literal constants (aside from quoted strings, which are represented by their addresses) and expressions with multiple terms. The term <em>lvalue</em> in C originally meant entities that could appear on the left side of an assignment statement, but that was before the <code>const</code> keyword was introduced. Now both a regular variable and a <code>const</code> variable would be considered lvalues because both can be accessed by address. But the regular variable can be further characterized as being a <em>modifiable lvalue</em> and the <code>const</code> variable as a <em>non-modifiable lvalue</em>.</p>
<p>Now, to return to our example, suppose you redefine <code>refcube()</code> so that it has a constant reference argument:</p>
<p class="programlisting">double refcube(const double &#38;ra)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;return ra * ra * ra;<br/>}</p>
<p>Next, consider the following code:</p>
<p class="programlisting">double side = 3.0;<br/>double * pd = &#38;side;<br/>double &#38; rd = side;<br/>long edge = 5L;<br/>double lens[4] = { 2.0, 5.0, 10.0, 12.0};<br/>double c1 = refcube(side);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ra is side<br/>double c2 = refcube(lens[2]);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ra is lens[2]<br/>double c3 = refcube(rd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ra is rd is side<br/>double c4 = refcube(*pd);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ra is *pd is side<br/>double c5 = refcube(edge);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ra is temporary variable<br/>double c6 = refcube(7.0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ra is temporary variable<br/>double c7 = refcube(side + 10.0);&#160;&#160;&#160;// ra is temporary variable</p>
<p>The arguments <code>side</code>, <code>lens[2]</code>, <code>rd</code>, and <code>*pd</code> are type <code>double</code> data objects with names, so it is possible to generate a reference for them, and no temporary variables are needed. (Recall that an element of an array behaves like a variable of the same type as the <a id="page_393"/>element.) But although <code>edge</code> is a variable, it is of the wrong type. A reference to a <code>double</code> can&#8217;t refer to a <code>long</code>. The arguments <code>7.0</code> and <code>side + 10.0</code>, on the other hand, are the right type, but they are not named data objects. In each of these cases, the compiler generates a temporary, anonymous variable and makes <code>ra</code> refer to it. These temporary variables last for the duration of the function call, but then the compiler is free to dump them.</p>
<p>So why is this behavior okay for constant references but not otherwise? Recall the <code>swapr()</code> function from <a href="#ch08ex04">Listing 8.4</a>:</p>
<p class="programlisting">void swapr(int &#38; a, int &#38; b)&#160;&#160;// use references<br/>{<br/>&#160;&#160;&#160;&#160;int temp;<br/><br/>&#160;&#160;&#160;&#160;temp = a;&#160;&#160;&#160;&#160;&#160;&#160;// use a, b for values of variables<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}</p>
<p>What would happen if you did the following under the freer rules of early C++?</p>
<p class="programlisting">long a = 3, b = 5;<br/>swapr(a, b);</p>
<p>Here there is a type mismatch, so the compiler would create two temporary <code>int</code> variables, initialize them to <code>3</code> and <code>5</code>, and then swap the contents of the temporary variables, leaving <code>a</code> and <code>b</code> unaltered.</p>
<p>In short, if the intent of a function with reference arguments is to modify variables passed as arguments, situations that create temporary variables thwart that purpose. The solution is to prohibit creating temporary variables in these situations, and that is what the C++ Standard now does. (However, some compilers still, by default, issue warnings instead of error messages, so if you see a warning about temporary variables, don&#8217;t ignore it.)</p>
<p>Now think about the <code>refcube()</code> function. Its intent is merely to use passed values, not to modify them, so temporary variables cause no harm and make the function more general in the sorts of arguments it can handle. Therefore, if the declaration states that a reference is <code>const</code>, C++ generates temporary variables when necessary. In essence, a C++ function with a <code>const</code> reference formal argument and a nonmatching actual argument mimics the traditional passing by value behavior, guaranteeing that the original data is unaltered and using a temporary variable to hold the value.</p>
<div class="note"><hr/>
<p class="title"><a id="ch08note02"/>Note</p>
<p class="notepara">If a function call argument isn&#8217;t an <code>lvalue</code> or does not match the type of the corresponding <code>const</code> reference parameter, C++ creates an anonymous variable of the correct type, assigns the value of the function call argument to the anonymous variable, and has the parameter refer to that variable.</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch08sb02"/><a id="page_394"/>Use <code>const</code> When You Can</p>
<p class="sidebarpara">There are three strong reasons to declare reference arguments as references to constant data:</p>
<p class="indenthandingB">&#8226; Using <code>const</code> protects you against programming errors that inadvertently alter data.</p>
<p class="indenthandingB">&#8226; Using <code>const</code> allows a function to process both <code>const</code> and non-<code>const</code> actual arguments, whereas a function that omits <code>const</code> in the prototype only can accept non-<code>const</code> data.</p>
<p class="indenthandingB">&#8226; Using a <code>const</code> reference allows the function to generate and use a temporary variable appropriately.</p>
<p class="sidebarpara">You should declare formal reference arguments as <code>const</code> whenever it&#8217;s appropriate to do so.</p>
<hr/></div>
<p>C++11 introduces a second kind of reference, called an <em>rvalue reference</em>, that can refer to an rvalue. It&#8217;s declared using <code>&#38;&#38;</code>:</p>
<p class="programlisting">double &#38;&#38; rref = std::sqrt(36.00);&#160;&#160;// not allowed for double &#38;<br/>double j = 15.0;<br/>double &#38;&#38; jref = 2.0* j + 18.5;&#160;&#160;&#160;&#160;&#160;// not allowed for double &#38;<br/>std::cout &lt;&lt; rref &lt;&lt; '\n';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// display 6.0<br/>std::cout &lt;&lt; jref &lt;&lt; '\n';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// display 48.5;</p>
<p>The rvalue reference was introduced mainly to help library designers provide more efficient implementations of certain operations. <a href="ch18.html#ch18">Chapter 18</a>, &#8220;Visiting will the New C++ Standard,&#8221; discusses how rvalue references are used to implement an approach called move semantics. The original reference type (the one declared using a single <code>&#38;</code>) is now called an lvalue reference.</p>
<h4 id="ch08lev2sec4">Using References with a Structure</h4>
<p>References work wonderfully with structures and classes, C++&#8217;s user-defined types. Indeed, references were introduced primarily for use with these types, not for use with the basic built-in types.</p>
<p>The method for using a reference to a structure as a function parameter is the same as the method for using a reference to a basic variable: You just use the <code>&#38;</code> reference operator when declaring a structure parameter. For example, suppose we have the following definition of a structure:</p>
<p class="programlisting">struct free_throws<br/>{<br/>&#160;&#160;&#160;&#160;std::string name;<br/>&#160;&#160;&#160;&#160;int made;<br/>&#160;&#160;&#160;&#160;int attempts;<br/>&#160;&#160;&#160;&#160;float percent;<br/>};</p>
<p>Then a function using a reference to this type could be prototyped as follows:</p>
<p class="programlisting">void set_pc(free_throws &#38; ft);&#160;&#160;&#160;// use a reference to a structure</p>
<p>If the intent is that the function doesn&#8217;t alter the structure, use <code>const</code>:</p>
<p class="programlisting">void display(const free_throws &#38; ft);&#160;&#160;// don't allow changes to structure</p>
<p><a id="page_395"/>The program in <a href="#ch08ex06">Listing 8.6</a> does exactly these things. It also adds an interesting twist by having a function return a reference to the structure. This works a bit differently from returning a structure. There are some cautions to note, which we&#8217;ll get to shortly.</p>
<p class="caption1"><a id="ch08ex06"/><strong>Listing 8.6. <code>strc_ref.cpp</code></strong></p><hr/>
<p class="programlisting1">//strc_ref.cpp -- using structure references<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>struct free_throws<br/>{<br/>&#160;&#160;&#160;&#160;std::string name;<br/>&#160;&#160;&#160;&#160;int made;<br/>&#160;&#160;&#160;&#160;int attempts;<br/>&#160;&#160;&#160;&#160;float percent;<br/>};<br/><br/>void display(const free_throws &#38; ft);<br/>void set_pc(free_throws &#38; ft);<br/>free_throws &#38; accumulate(free_throws &#38; target, const free_throws &#38; source);<br/><br/>int main()<br/>{<br/>// partial initializations &#8211; remaining members set to 0<br/>&#160;&#160;&#160;&#160;free_throws one = {"Ifelsa Branch", 13, 14};<br/>&#160;&#160;&#160;&#160;free_throws two = {"Andor Knott", 10, 16};<br/>&#160;&#160;&#160;&#160;free_throws three = {"Minnie Max", 7, 9};<br/>&#160;&#160;&#160;&#160;free_throws four = {"Whily Looper", 5, 9};<br/>&#160;&#160;&#160;&#160;free_throws five = {"Long Long", 6, 14};<br/>&#160;&#160;&#160;&#160;free_throws team = {"Throwgoods", 0, 0};<br/>// no initialization<br/>&#160;&#160;&#160;&#160;free_throws dup;<br/><br/>&#160;&#160;&#160;&#160;set_pc(one);<br/>&#160;&#160;&#160;&#160;display(one);<br/>&#160;&#160;&#160;&#160;accumulate(team, one);<br/>&#160;&#160;&#160;&#160;display(team);<br/>// use return value as argument<br/>&#160;&#160;&#160;&#160;display(accumulate(team, two));<br/>&#160;&#160;&#160;&#160;accumulate(accumulate(team, three), four);<br/>&#160;&#160;&#160;&#160;display(team);<br/>// use return value in assignment<br/>&#160;&#160;&#160;&#160;dup = accumulate(team,five);<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Displaying team:\n";<br/>&#160;&#160;&#160;&#160;display(team);<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Displaying dup after assignment:\n";<br/>&#160;&#160;&#160;&#160;display(dup);<br/>&#160;&#160;&#160;&#160;set_pc(four);<br/>// ill-advised assignment<br/>&#160;&#160;&#160;&#160;accumulate(dup,five) = four;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Displaying dup after ill-advised assignment:\n";<br/>&#160;&#160;&#160;&#160;display(dup);<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void display(const free_throws &#38; ft)<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: " &lt;&lt; ft.name &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;Made: " &lt;&lt; ft.made &lt;&lt; '\t';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Attempts: " &lt;&lt; ft.attempts &lt;&lt; '\t';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Percent: " &lt;&lt; ft.percent &lt;&lt; '\n';<br/>}<br/>void set_pc(free_throws &#38; ft)<br/>{<br/>&#160;&#160;&#160;&#160;if (ft.attempts != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ft.percent = 100.0f *float(ft.made)/float(ft.attempts);<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ft.percent = 0;<br/>}<br/><br/>free_throws &#38; accumulate(free_throws &#38; target, const free_throws &#38; source)<br/>{<br/>&#160;&#160;&#160;&#160;target.attempts += source.attempts;<br/>&#160;&#160;&#160;&#160;target.made += source.made;<br/>&#160;&#160;&#160;&#160;set_pc(target);<br/>&#160;&#160;&#160;&#160;return target;<br/>}</p><hr/>
<p><a id="page_396"/>Here is the program output:</p>
<p class="programlisting">Name: Ifelsa Branch<br/>&#160;&#160;Made: 13&#160;&#160;&#160;&#160;&#160;&#160;Attempts: 14&#160;&#160;&#160;&#160;Percent: 92.8571<br/>Name: Throwgoods<br/>&#160;&#160;Made: 13&#160;&#160;&#160;&#160;&#160;&#160;Attempts: 14&#160;&#160;&#160;&#160;Percent: 92.8571<br/>Name: Throwgoods<br/>&#160;&#160;Made: 23&#160;&#160;&#160;&#160;&#160;&#160;Attempts: 30&#160;&#160;&#160;&#160;Percent: 76.6667<br/>Name: Throwgoods<br/>&#160;&#160;Made: 35&#160;&#160;&#160;&#160;&#160;&#160;Attempts: 48&#160;&#160;&#160;&#160;Percent: 72.9167<br/>Displaying team:<br/>Name: Throwgoods<br/>&#160;&#160;Made: 41&#160;&#160;&#160;&#160;&#160;&#160;Attempts: 62&#160;&#160;&#160;&#160;Percent: 66.129<br/>Displaying dup after assignment:<br/>Name: Throwgoods<br/><a id="page_397"/>&#160;&#160;Made: 41&#160;&#160;&#160;&#160;&#160;&#160;Attempts: 62&#160;&#160;&#160;&#160;Percent: 66.129<br/>Displaying dup after ill-advised assignment:<br/>Name: Whily Looper<br/>&#160;&#160;Made: 5&#160;&#160;&#160;&#160;&#160;&#160;&#160;Attempts: 9&#160;&#160;&#160;&#160;&#160;Percent: 55.5556</p>
<h5 id="ch08lev3sec3">Program Notes</h5>
<p>The program begins by initializing several structure objects. Recall that if there are fewer initializers than members, the remaining members (just the <code>percent</code> members in this case) are set to 0. The first function call is this:</p>
<p class="programlisting">set_pc(one);</p>
<p>Because the formal parameter <code>ft</code> in <code>set_pc()</code> is a reference, <code>ft</code> refers to <code>one</code>, and the code in <code>set_pc()</code> sets the <code>one.percent</code> member. Passing by value would not work in this case because that would result in setting the <code>percent</code> member of a temporary copy of <code>one</code>. The alternative, as you may recall from the previous chapter, is using a pointer parameter and passing an address, but the form is slightly more complicated:</p>
<p class="programlisting">set_pcp(&#38;one);&#160;&#160;&#160;&#160;// using pointers instead - &#38;one instead of one<br/>...<br/>void set_pcp(free_throws * pt)<br/>{<br/>&#160;&#160;&#160;&#160;if (pt-&gt;attempts != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pt-&gt;percent = 100.0f *float(pt-&gt;made)/float(pt-&gt;attempts);<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pt-&gt;percent = 0;<br/>}</p>
<p>The next function call is this:</p>
<p class="programlisting">display(one);</p>
<p>Because <code>display()</code> displays the contents of the structure without altering them, the function uses a <code>const</code> reference parameter. In this case, one could have passed the structure by value, but using a reference is more economical in time and memory than making a copy of the original structure.</p>
<p>The next function call is this:</p>
<p class="programlisting">accumulate(team, one);</p>
<p>The <code>accumulate()</code> function takes two structure arguments. It adds data from the <code>attempts</code> and <code>made</code> members of the second structure to the corresponding members of the first structure. Only the first structure is modified, so the first parameter is a reference, whereas the second parameter is a <code>const</code> reference:</p>
<p class="programlisting">free_throws &#38; accumulate(free_throws &#38; target, const free_throws &#38; source);</p>
<p><a id="page_398"/>What about the return value? The function call we just discussed didn&#8217;t use it; as far as that use went, the function could have been type <code>void</code>. But look at this function call:</p>
<p class="programlisting">display(accumulate(team, two));</p>
<p>What&#8217;s going on here? Let&#8217;s follow the structure object <code>team</code>. First, <code>team</code> is passed to <code>accumulate()</code> as its first argument. That means that the <code>target</code> object in <code>accumulate()</code> really is <code>team</code>. The <code>accumulate()</code> function modifies <code>team</code>, then returns it as a reference. Note that the actual return statement looks like this:</p>
<p class="programlisting">return target;</p>
<p>Nothing in this statement indicates that a reference is being returned. That information comes from the function header (and, also, from the prototype):</p>
<p class="programlisting">free_throws &#38; accumulate(free_throws &#38; target, const free_throws &#38; source)</p>
<p>If the return type were declared <code>free_throws</code> instead of <code>free_throws &#38;</code>, the same return statement would return a copy of <code>target</code> (and hence a copy of <code>team</code>). But the return type is a reference, so that means the return value is the original <code>team</code> object first passed to <code>accumulate()</code>.</p>
<p>What happens next? The <code>accumulate()</code> return value is the first argument to <code>display()</code>, so that means <code>team</code> is the first argument to <code>display()</code>. Because the <code>display()</code> parameter is a reference, that means the <code>ft</code> object in <code>display()</code> really is <code>team</code>. Therefore, the contents of <code>team</code> get displayed. The net effect of</p>
<p class="programlisting">display(accumulate(team, two));</p>
<p>is the same as that of the following:</p>
<p class="programlisting">accumulate(team, two);<br/>display(team);</p>
<p>The same logic applies to this statement:</p>
<p class="programlisting">accumulate(accumulate(team, three), four);</p>
<p>This has the same effect as the following:</p>
<p class="programlisting">accumulate(team, three);<br/>accumulate(team, four);</p>
<p>Next, the program uses an assignment statement:</p>
<p class="programlisting">dup = accumulate(team,five);</p>
<p>As you might expect, this copies the values in <code>team</code> to <code>dup</code>.</p>
<p>Finally, the program uses <code>accumulate()</code> in a manner for which it was not intended:</p>
<p class="programlisting">accumulate(dup,five) = four;</p>
<p>This statement&#8212;that is, assigning a value to a function call&#8212;works because the return value is a reference. The code won&#8217;t compile if <code>accumulate()</code> returns by value. Because the return value is a reference to <code>dup</code>, this code has the same effect as the following:</p>
<p class="programlisting"><a id="page_399"/>accumulate(dup,five); // add five's data to dup<br/>dup = four;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overwrite the contents of dup with the contents of four</p>
<p>The second statement wipes out the work accomplished by the first, so the original assignment statement was not a good use of <code>accumulate()</code>.</p>
<h5 id="ch08lev3sec4">Why Return a Reference?</h5>
<p>Let&#8217;s look a bit further at how returning a reference is different from the traditional return mechanism. The latter works much like passing by value does with function parameters. The expression following the return is evaluated, and that value is passed back to the calling function. Conceptually, this value is copied to a temporary location and the calling program uses the value. Consider the following:</p>
<p class="programlisting">double m = sqrt(16.0);<br/>cout &lt;&lt; sqrt(25.0);</p>
<p>In the first statement, the value <code>4.0</code> is copied to a temporary location and then the value in that location is copied to <code>m</code>. In the second statement, the value <code>5.0</code> is copied to a temporary location, then the contents of that location are passed on to <code>cout</code>. (This is the conceptual description. In practice, an optimizing compiler might consolidate some of the steps.)</p>
<p>Now consider this statement:</p>
<p class="programlisting">dup = accumulate(team,five);</p>
<p>If <code>accumulate()</code> returned a structure instead of a reference to a structure, this could involve copying the entire structure to a temporary location and then copying that copy to <code>dup</code>. But with a reference return value, <code>team</code> is copied directly to <code>dup</code>, a more efficient approach.</p>
<div class="note"><hr/>
<p class="title"><a id="ch08note03"/>Note</p>
<p class="notepara">A function that returns a reference is actually an alias for the referred-to variable.</p>
<hr/></div>
<h5 id="ch08lev3sec5">Being Careful About What a Return Reference Refers To</h5>
<p>The single most important point to remember when returning a reference is to avoid returning a reference to a memory location that ceases to exist when the function terminates. What you want to avoid is code along these lines:</p>
<p class="programlisting">const free_throws &#38; clone2(free_throws &#38; ft)<br/>{<br/>&#160;&#160;&#160;&#160;free_throws newguy;&#160;&#160;// first step to big error<br/>&#160;&#160;&#160;&#160;newguy = ft;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// copy info<br/>&#160;&#160;&#160;&#160;return newguy;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// return reference to copy<br/>}</p>
<p>This has the unfortunate effect of returning a reference to a temporary variable (<code>newguy</code>) that passes from existence as soon as the function terminates. (<a href="ch09.html#ch09">Chapter 9</a>, &#8220;<a href="ch09.html#ch09">Memory Models and Namespaces</a>,&#8221; discusses the persistence of various kinds of variables.) Similarly, you should avoid returning pointers to such temporary variables.</p>
<p><a id="page_400"/>The simplest way to avoid this problem is to return a reference that was passed as an argument to the function. A reference parameter will refer to data used by the calling function; hence, the returned reference will refer to that same data. This, for example, is what <code>accumulate()</code> does in <a href="#ch08ex06">Listing 8.6</a>.</p>
<p>A second method is to use <code>new</code> to create new storage. You&#8217;ve already seen examples in which <code>new</code> creates space for a string and the function returns a pointer to that space. Here&#8217;s how you could do something similar with a reference:</p>
<p class="programlisting">const free_throws &#38; clone(free_throws &#38; ft)<br/>{<br/>&#160;&#160;&#160;&#160;free_throws * pt;<br/>&#160;&#160;&#160;&#160;*pt = ft;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// copy info<br/>&#160;&#160;&#160;&#160;return *pt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// return reference to copy<br/>}</p>
<p>The first statement creates a nameless <code>free_throws</code> structure. The pointer <code>pt</code> points to the structure, so <code>*pt</code> is the structure. The code appears to return the structure, but the function declaration indicates that the function really returns a reference to this structure. You could then use the function this way:</p>
<p class="programlisting">free_throws &#38; jolly = clone(three);</p>
<p>This makes <code>jolly</code> a reference to the new structure. There is a problem with this approach: You should use <code>delete</code> to free memory allocated by <code>new</code> when the memory is no longer needed. A call to <code>clone()</code> conceals the call to <code>new</code>, making it simpler to forget to use <code>delete</code> later. The <code>auto_ptr</code> template or, better, the C++11 <code>unique_ptr</code> discussed in <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library,&#8221; can help automate the deletion process.</p>
<h5 id="ch08lev3sec6">Why Use <code>const</code> with a Reference Return?</h5>
<p><a href="#ch08ex06">Listing 8.6</a>, as you&#8217;ll recall, had this statement:</p>
<p class="programlisting">accumulate(dup,five) = four;</p>
<p>It had the effect of first adding data from <code>five</code> to <code>dup</code>, then overwriting the contents of <code>dup</code> with the contents of <code>four</code>. Why does this statement compile? Assignment requires a modifiable lvalue on the left. That is, the subexpression on the left of an assignment expression should identify a block of memory that can be modified. In this case, the function returned a reference to <code>dup</code>, which does identify such a block of memory. So the statement is valid.</p>
<p>Regular (non reference) return types, on the other hand, are <em>rvalues</em>, values that can&#8217;t be accessed by address. Such expressions can appear on the right side of an assignment statement but not the left. Other examples of rvalues include literals, such as <code>10.0</code>, and expressions such as <code>x + y</code>. Clearly, it doesn&#8217;t make sense to try to take the address of a literal such as <code>10.0</code>, but why is a normal function return value an rvalue? It&#8217;s because the return value, you&#8217;ll recall, resides in a temporary memory location that doesn&#8217;t necessarily persist even until the next statement.</p>
<p><a id="page_401"/>Suppose you want to use a reference return value but don&#8217;t want to permit behavior such as assigning a value to <code>accumulate()</code>. Just make the return type a <code>const</code> reference:</p>
<p class="programlisting">const free_throws &#38;<br/>&#160;&#160;&#160;&#160;accumulate(free_throws &#38; target, const free_throws &#38; source);</p>
<p>The return type now is <code>const</code>, hence a nonmodifiable lvalue. Therefore, the assignment no longer is allowed:</p>
<p class="programlisting">accumulate(dup,five) = four;&#160;&#160;// not allowed for const reference return</p>
<p>What about the other function calls in the program? With a <code>const</code> reference return type, the following statement would still be allowed:</p>
<p class="programlisting">display(accumulate(team, two));</p>
<p>That&#8217;s because the formal parameter for <code>display()</code> also is type <code>const free_thows &#38;</code>. But the following statement would not be allowed because the first formal parameter for <code>accumulate()</code> is not <code>const</code>:</p>
<p class="programlisting">accumulate(accumulate(team, three), four);</p>
<p>Is this a great loss? Not in this case because you still can do the following:</p>
<p class="programlisting">accumulate(team, three);<br/>accumulate(team, four);</p>
<p>And of course you still could use <code>accumulate()</code> on the right side of an assignment statement.</p>
<p>By omitting <code>const</code>, you can write shorter but more obscure-looking code.</p>
<p>Usually, you&#8217;re better off avoiding the addition of obscure features to a design because obscure features often expand the opportunities for obscure errors. Making the return type a <code>const</code> reference therefore protects you from the temptation of obfuscation. Occasionally, however, omitting <code>cons</code>t does make sense. The overloaded <code>&lt;&lt;</code> operator discussed in <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>,&#8221; is an example.</p>
<h4 id="ch08lev2sec5">Using References with a Class Object</h4>
<p>The usual C++ practice for passing class objects to a function is to use references. For instance, you would use reference parameters for functions taking objects of the <code>string</code>, <code>ostream</code>, <code>istream</code>, <code>ofstream</code>, and <code>ifstream</code> classes as arguments.</p>
<p>Let&#8217;s look at an example that uses the <code>string</code> class and illustrates some different design choices, some of them bad. The general idea is to create a function that adds a given string to each end of another string. <a href="#ch08ex07">Listing 8.7</a> provides three functions that are intended to do this. However, one of the designs is so flawed that it may cause the program to crash or even not compile.</p>
<p class="caption1"><a id="page_402"/><a id="ch08ex07"/><strong>Listing 8.7. <code>strquote.cpp</code></strong></p><hr/>
<p class="programlisting1">// strquote.cpp -- different designs<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>using namespace std;<br/>string version1(const string &#38; s1, const string &#38; s2);<br/>const string &#38; version2(string &#38; s1, const string &#38; s2);&#160;&#160;// has side effect<br/>const string &#38; version3(string &#38; s1, const string &#38; s2);&#160;&#160;// bad design<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;string input;<br/>&#160;&#160;&#160;&#160;string copy;<br/>&#160;&#160;&#160;&#160;string result;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a string: ";<br/>&#160;&#160;&#160;&#160;getline(cin, input);<br/>&#160;&#160;&#160;&#160;copy = input;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your string as entered: " &lt;&lt; input &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;result = version1(input, "***");<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your string enhanced: " &lt;&lt; result &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your original string: " &lt;&lt; input &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;result = version2(input, "###");<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your string enhanced: " &lt;&lt; result &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your original string: " &lt;&lt; input &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Resetting original string.\n";<br/>&#160;&#160;&#160;&#160;input = copy;<br/>&#160;&#160;&#160;&#160;result = version3(input, "@@@");<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your string enhanced: " &lt;&lt; result &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your original string: " &lt;&lt; input &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>string version1(const string &#38; s1, const string &#38; s2)<br/>{<br/>&#160;&#160;&#160;&#160;string temp;<br/><br/>&#160;&#160;&#160;&#160;temp = s2 + s1 + s2;<br/>&#160;&#160;&#160;&#160;return temp;<br/>}<br/><br/>const string &#38; version2(string &#38; s1, const string &#38; s2)&#160;&#160;&#160;// has side effect<br/>{<br/>&#160;&#160;&#160;&#160;s1 = s2 + s1 + s2;<br/>// safe to return reference passed to function<br/>&#160;&#160;&#160;&#160;return s1;<br/>}<br/><br/>const string &#38; version3(string &#38; s1, const string &#38; s2)&#160;&#160;&#160;// bad design<br/>{<br/>&#160;&#160;&#160;&#160;string temp;<br/><br/>&#160;&#160;&#160;&#160;temp = s2 + s1 + s2;<br/>// unsafe to return reference to local variable<br/>&#160;&#160;&#160;&#160;return temp;<br/>}</p><hr/>
<p><a id="page_403"/>Here is a sample run of the program in <a href="#ch08ex07">Listing 8.7</a>:</p>
<p class="programlisting">Enter a string: <span class="EmpStrong">It's not my fault.</span><br/>Your string as entered: It's not my fault.<br/>Your string enhanced: ***It's not my fault.***<br/>Your original string: It's not my fault.<br/>Your string enhanced: ###It's not my fault.###<br/>Your original string: ###It's not my fault.###<br/>Resetting original string.</p>
<p>At this point the program crashed.</p>
<h5 id="ch08lev3sec7">Program Notes</h5>
<p>Version 1 of the function in <a href="#ch08ex07">Listing 8.7</a> is the most straightforward of the three:</p>
<p class="programlisting">string version1(const string &#38; s1, const string &#38; s2)<br/>{<br/>&#160;&#160;&#160;&#160;string temp;<br/><br/>&#160;&#160;&#160;&#160;temp = s2 + s1 + s2;<br/>&#160;&#160;&#160;&#160;return temp;<br/>}</p>
<p>It takes two <code>string</code> arguments and uses <code>string</code> class addition to create a new string that has the desired properties. Note that the two function arguments are <code>const</code> references. The function would produce the same end result if it just passed <code>string</code> objects:</p>
<p class="programlisting">string version4(string s1, string&#160;&#160;s2)&#160;&#160;// would work the same</p>
<p>In this case, <code>s1</code> and <code>s2</code> would be brand-new <code>string</code> objects. Thus, using references is more efficient because the function doesn&#8217;t have to create new objects and copy data from the old objects to the new. The use of the <code>const</code> qualifier indicates that this function will use, but not modify, the original strings.</p>
<p>The <code>temp</code> object is a new object, local to the <code>version1()</code> function, and it ceases to exist when the function terminates. Thus, returning <code>temp</code> as a reference won&#8217;t work, so the <a id="page_404"/>function type is <code>string</code>. This means the contents of <code>temp</code> will be copied to a temporary return location. Then, in <code>main()</code>, the contents of the return location are copied to the string named <code>result</code>:</p>
<p class="programlistingB">result = version1(input, "***");</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch08sb03"/>Passing a C-Style String Argument to a <code>string</code> Object Reference Parameter</p>
<p class="sidebarpara">You may have noticed a rather interesting fact about the v<code>ersion1()</code> function: Both formal parameters (<code>s1</code> and <code>s2</code>) are type <code>const string &#38;</code>, but the actual arguments (<code>input</code> and <code>"***"</code>) are type <code>string</code> and <code>const char *</code>, respectively. Because <code>input</code> is type <code>string</code>, there is no problem having <code>s1</code> refer to it. But how is it that the program accepts passing a pointer-to-<code>char</code> argument to a <code>string</code> reference?</p>
<p class="sidebarpara">Two things are going on here. One is that the <code>string</code> class defines a <code>char *</code>-to-<code>string</code> conversion, which makes it possible to initialize a <code>string</code> object to a C-style string. The second is a property of <code>const</code> reference formal parameters that is discussed earlier in this chapter. Suppose the actual argument type doesn&#8217;t match the reference parameter type but can be converted to the reference type. Then the program creates a temporary variable of the correct type, initializes it to the converted value, and passes a reference to the temporary variable. Earlier this chapter you saw, for instance, that a <code>const double &#38;</code> parameter can handle an <code>int</code> argument in this fashion. Similarly, a <code>const string &#38;</code> parameter can handle a <code>char *</code> or <code>const char *</code> argument in this fashion.</p>
<p class="sidebarpara">The convenient outcome of this is that if the formal parameter is type <code>const string &#38;</code>, the actual argument used in the function call can be a <code>string</code> object or a C-style string, such as a quoted string literal, a null-terminated array of <code>char</code>, or a pointer variable that points to a <code>char</code>. Hence the following works fine:</p>
<p class="programlistingB">result = version1(input, "***");</p>
<hr/></div>
<p>The <code>version2()</code> function doesn&#8217;t create a temporary string. Instead, it directly alters the original string:</p>
<p class="programlisting">const string &#38; version2(string &#38; s1, const string &#38; s2)&#160;&#160;&#160;// has side effect<br/>{<br/>&#160;&#160;&#160;&#160;s1 = s2 + s1 + s2;<br/>// safe to return reference passed to function<br/>&#160;&#160;&#160;&#160;return s1;<br/>}</p>
<p>This function is allowed to alter <code>s1</code> because <code>s1</code>, unlike <code>s2</code>, is not declared using <code>const</code>.</p>
<p>Because <code>s1</code> is a reference to an object (<code>input</code>) in <code>main()</code>, it&#8217;s safe to return <code>s1</code> as a reference. Because <code>s1</code> is a reference to <code>input</code>, the line</p>
<p class="programlisting">result = version2(input, "###");</p>
<p>essentially becomes equivalent to the following:</p>
<p class="programlisting">version2(input, "###");&#160;&#160;&#160;&#160;&#160;// input altered directly by version2()<br/>result = input;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// reference to s1 is reference to input</p>
<p><a id="page_405"/>However, because <code>s1</code> is a reference to <code>input</code>, calling this function has the side effect of altering <code>input</code> also:</p>
<p class="programlisting">Your original string: It's not my fault.<br/>Your string enhanced: ###It's not my fault.###<br/>Your original string: ###It's not my fault.###</p>
<p>Thus, if you want to keep the original string unaltered, this is the wrong design.</p>
<p>The third version in <a href="#ch08ex07">Listing 8.7</a> is a reminder of what not to do:</p>
<p class="programlisting">const string &#38; version3(string &#38; s1, const string &#38; s2)&#160;&#160;&#160;// bad design<br/>{<br/>&#160;&#160;&#160;&#160;string temp;<br/><br/>&#160;&#160;&#160;&#160;temp = s2 + s1 + s2;<br/>// unsafe to return reference to local variable<br/>&#160;&#160;&#160;&#160;return temp;<br/>}</p>
<p>It has the fatal flaw of returning a reference to a variable declared locally inside <code>version3()</code>. This function compiles (with a warning), but the program crashes when attempting to execute the function. Specifically, the following assignment aspect causes the problem:</p>
<p class="programlisting">result = version3(input, "@@@");</p>
<p>The program attempts to refer to memory that is no longer in use.</p>
<h4 id="ch08lev2sec6">Another Object Lesson: Objects, Inheritance, and References</h4>
<p>The <code>ostream</code> and <code>ofstream</code> classes bring an interesting property of references to the fore. As you may recall from <a href="ch06.html#ch06">Chapter 6</a>, &#8220;<a href="ch06.html#ch06">Branching Statements and Logical Operators</a>,&#8221; objects of the <code>ofstream</code> type can use <code>ostream</code> methods, allowing file input/output to use the same forms as console input/output. The language feature that makes it possible to pass features from one class to another is called <em>inheritance</em>, and <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a href="ch13.html#ch13">Class Inheritance</a>,&#8221; discusses this feature in detail. In brief, <code>ostream</code> is termed a base class (because the <code>ofstream</code> class is based on it) and <code>ofstream</code> is termed a <em>derived class</em> (because it is derived from <code>ostream</code>). A derived class inherits the base class methods, which means that an <code>ofstream</code> object can use base class features such as the <code>precision()</code> and <code>setf()</code> formatting methods.</p>
<p>Another aspect of inheritance is that a base class reference can refer to a derived class object without requiring a type cast. The practical upshot of this is that you can define a function having a base class reference parameter, and that function can be used with base class objects and also with derived objects. For example, a function with a type <code>ostream &#38;</code> parameter can accept an <code>ostream</code> object, such as <code>cout</code>, or an <code>ofstream</code> object, such as you might declare, equally well.</p>
<p><a href="#ch08ex08">Listing 8.8</a> demonstrates this point by using the same function to write data to a file and to display the data onscreen; only the function call argument is changed. This program <a id="page_406"/>solicits the focal length of a telescope objective (its main mirror or lens) and of some eyepieces. Then it calculates and displays the magnification each eyepiece would produce in that telescope. The magnification equals the focal length of the telescope divided by the focal length of the eyepiece used, so the calculation is simple. The program also uses some formatting methods, which, as promised, work equally well with <code>cout</code> and with <code>ofstream</code> objects (<code>fout</code>, in this example).</p>
<p class="caption1"><a id="ch08ex08"/><strong>Listing 8.8. <code>filefunc.cpp</code></strong></p><hr/>
<p class="programlisting1">//filefunc.cpp -- function with ostream &#38; parameter<br/>#include &lt;iostream&gt;<br/>#include &lt;fstream&gt;<br/>#include &lt;cstdlib&gt;<br/>using namespace std;<br/><br/>void file_it(ostream &#38; os, double fo, const double fe[],int n);<br/>const int LIMIT = 5;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;ofstream fout;<br/>&#160;&#160;&#160;&#160;const char * fn = "ep-data.txt";<br/>&#160;&#160;&#160;&#160;fout.open(fn);<br/>&#160;&#160;&#160;&#160;if (!fout.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Can't open " &lt;&lt; fn &lt;&lt; ". Bye.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;double objective;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the focal length of your "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"telescope objective in mm: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; objective;<br/>&#160;&#160;&#160;&#160;double eps[LIMIT];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the focal lengths, in mm, of " &lt;&lt; LIMIT<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " eyepieces:\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; LIMIT; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Eyepiece #" &lt;&lt; i + 1 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; eps[i];<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;file_it(fout, objective, eps, LIMIT);<br/>&#160;&#160;&#160;&#160;file_it(cout, objective, eps, LIMIT);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void file_it(ostream &#38; os, double fo, const double fe[],int n)<br/>{<br/>&#160;&#160;&#160;&#160;ios_base::fmtflags initial;<br/>&#160;&#160;&#160;&#160;initial = os.setf(ios_base::fixed); // save initial formatting state<br/>&#160;&#160;&#160;&#160;os.precision(0);<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Focal length of objective: " &lt;&lt; fo &lt;&lt; " mm\n";<br/>&#160;&#160;&#160;&#160;os.setf(ios::showpoint);<br/>&#160;&#160;&#160;&#160;os.precision(1);<br/>&#160;&#160;&#160;&#160;os.width(12);<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "f.l. eyepiece";<br/>&#160;&#160;&#160;&#160;os.width(15);<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "magnification" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os.width(12);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; fe[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os.width(15);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; int (fo/fe[i] + 0.5) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;os.setf(initial);&#160;&#160;&#160;// restore initial formatting state<br/>}</p><hr/>
<p><a id="page_407"/>Here is a sample run of the program in <a href="#ch08ex08">Listing 8.8</a>:</p>
<p class="programlisting">Enter the focal length of your telescope objective in mm: <span class="EmpStrong">1800</span><br/>Enter the focal lengths, in mm, of 5 eyepieces:<br/>Eyepiece #1: <span class="EmpStrong">30</span><br/>Eyepiece #2: <span class="EmpStrong">19</span><br/>Eyepiece #3: <span class="EmpStrong">14</span><br/>Eyepiece #4: <span class="EmpStrong">8.8</span><br/>Eyepiece #5: <span class="EmpStrong">7.5</span><br/>Focal length of objective: 1800 mm<br/>f.l. eyepiece&#160;&#160;magnification<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;30.0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;60<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;95<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;129<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.8&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;205<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;240<br/>Done</p>
<p>The following line writes the eyepiece data to the file <code>ep-data.txt</code>:</p>
<p class="programlisting">file_it(fout, objective, eps, LIMIT);</p>
<p>And this line writes the identical information in the identical format to the screen:</p>
<p class="programlisting">file_it(cout, objective, eps, LIMIT);</p>
<h5 id="ch08lev3sec8">Program Notes</h5>
<p><a id="page_408"/>The main point of <a href="#ch08ex08">Listing 8.8</a> is that the <code>os</code> parameter, which is type <code>ostream &#38;</code>, can refer to an <code>ostream</code> object such as <code>cout</code> and to an <code>ofstream</code> object such as <code>fout</code>. But the program also illustrates how <code>ostream</code> formatting methods can be used for both types. Let&#8217;s review, or, in some cases, examine for the first time, some of these methods. (<a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>,&#8221; provides a fuller discussion.)</p>
<p>The <code>setf()</code> method allows you to set various formatting states. For example, the method call <code>setf(ios_base::fixed)</code> places an object in the mode of using fixed decimal-point notation. The call <code>setf(ios_base:showpoint)</code> places an object in the mode of showing a trailing decimal point, even if the following digits are zeros. The <code>precision()</code> method indicates the number of figures to be shown to the right of the decimal (provided that the object is in <code>fixed</code> mode). All these settings stay in place unless they&#8217;re reset by another method call. The <code>width()</code> call sets the field width to be used for the next output action. This setting holds for displaying one value only, and then it reverts to the default. (The default is a field width of zero, which is then expanded to just fit the actual quantity being displayed.)</p>
<p>The <code>file_it()</code> function uses an interesting pair of method calls:</p>
<p class="programlisting">ios_base::fmtflags initial;<br/>initial = os.setf(ios_base::fixed); // save initial formatting state<br/>...<br/>os.setf(initial);&#160;&#160;&#160;// restore initial formatting state</p>
<p>The <code>setf()</code> method returns a copy of all the formatting settings in effect before the call was made. <code>ios_base::fmtflags</code> is a fancy name for the type needed to store this information. So the assignment to <code>initial</code> stores the settings that were in place before the <code>file_it()</code> function was called. The <code>initial</code> variable can then be used as an argument to <code>setf()</code> to reset all the formatting settings to this original value. Thus, the function restores the object to the state it had before being passed to <code>file_it()</code>.</p>
<p>Knowing more about classes will help you understand better how these methods work and, why, for example, <code>ios_base</code> keeps popping up. But you don&#8217;t have to wait until <a href="ch17.html#ch17">Chapter 17</a> to use these methods.</p>
<p>One final point: Each object stores its own formatting settings. So when the program passes <code>cout</code> to <code>file_it()</code>, <code>cout</code>&#8217;s settings are altered and then restored. When the program passes <code>fout</code> to <code>file_it()</code>, <code>fout</code>&#8217;s settings are altered and then restored.</p>
<h4 id="ch08lev2sec7">When to Use Reference Arguments</h4>
<p>There are two main reasons for using reference arguments:</p>
<p class="indenthandingB">&#8226; To allow you to alter a data object in the calling function</p>
<p class="indenthandingB">&#8226; To speed up a program by passing a reference instead of an entire data object</p>
<p>The second reason is most important for larger data objects, such as structures and class objects. These two reasons are the same reasons you might have for using a pointer argument. This makes sense because reference arguments are really just a different interface for <a id="page_409"/>pointer-based code. So when should you use a reference? Use a pointer? Pass by value? The following are some guidelines.</p>
<p>A function uses passed data without modifying it:</p>
<p class="indenthandingB">&#8226; If the data object is small, such as a built-in data type or a small structure, pass it by value.</p>
<p class="indenthandingB">&#8226; If the data object is an array, use a pointer because that&#8217;s your only choice. Make the pointer a pointer to <code>const</code>.</p>
<p class="indenthandingB">&#8226; If the data object is a good-sized structure, use a <code>const</code> pointer or a <code>const</code> reference to increase program efficiency. You save the time and space needed to copy a structure or a class design. Make the pointer or reference <code>const</code>.</p>
<p class="indenthandingB">&#8226; If the data object is a class object, use a <code>const</code> reference. The semantics of class design often require using a reference, which is the main reason C++ added this feature. Thus, the standard way to pass class object arguments is by reference.</p>
<p>A function modifies data in the calling function:</p>
<p class="indenthandingB">&#8226; If the data object is a built-in data type, use a pointer. If you spot code like <code>fixit(&#38;x)</code>, where <code>x</code> is an <code>int</code>, it&#8217;s pretty clear that this function intends to modify <code>x</code>.</p>
<p class="indenthandingB">&#8226; If the data object is an array, use your only choice: a pointer.</p>
<p class="indenthandingB">&#8226; If the data object is a structure, use a reference or a pointer.</p>
<p class="indenthandingB">&#8226; If the data object is a class object, use a reference.</p>
<p>Of course, these are just guidelines, and there might be reasons for making different choices. For example, <code>cin</code> uses references for basic types so that you can use <code>cin &gt;&gt; n</code> instead of <code>cin &gt;&gt; &#38;n</code>.</p>
<h3 id="ch08lev1sec3">Default Arguments</h3>
<p>Let&#8217;s look at another topic from C++&#8217;s bag of new tricks: the default argument. A <em>default argument</em> is a value that&#8217;s used automatically if you omit the corresponding actual argument from a function call. For example, if you set up <code>void wow(int n)</code> so that <code>n</code> has a default value of <code>1</code>, the function call <code>wow()</code> is the same as <code>wow(1)</code>. This gives you flexibility in how you use a function. Suppose you have a function called <code>left()</code> that returns the first <code>n</code> characters of a string, with the string and <code>n</code> as arguments. More precisely, the function returns a pointer to a new string consisting of the selected portion of the original string. For example, the call <code>left("theory", 3)</code> constructs a new string <code>"the"</code> and returns a pointer to it. Now suppose you establish a default value of <code>1</code> for the second argument. The call <code>left("theory", 3)</code> would work as before, with your choice of <code>3</code> overriding the default. But the call <code>left("theory")</code>, instead of being an error, would assume a second argument of <code>1</code> and return a pointer to the string <code>"t"</code>. This kind of default is helpful if your program often needs to extract a one-character string but occasionally needs to extract longer strings.</p>
<p><a id="page_410"/>How do you establish a default value? You must use the function prototype. Because the compiler looks at the prototype to see how many arguments a function uses, the function prototype also has to alert the program to the possibility of default arguments. The method is to assign a value to the argument in the prototype. For example, here&#8217;s the prototype fitting this description of <code>left()</code>:</p>
<p class="programlisting">char * left(const char * str, int n = 1);</p>
<p>You want the function to return a new string, so its type is <code>char*</code>, or pointer-to-<code>char</code>. You want to leave the original string unaltered, so you use the <code>const</code> qualifier for the first argument. You want <code>n</code> to have a default value of <code>1</code>, so you assign that value to <code>n</code>. A default argument value is an initialization value. Thus, the preceding prototype initializes <code>n</code> to the value <code>1</code>. If you leave <code>n</code> alone, it has the value <code>1</code>, but if you pass an argument, the new value overwrites the <code>1</code>.</p>
<p>When you use a function with an argument list, you must add defaults from right to left. That is, you can&#8217;t provide a default value for a particular argument unless you also provide defaults for all the arguments to its right:</p>
<p class="programlisting">int harpo(int n, int m = 4, int j = 5);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// VALID<br/>int chico(int n, int m = 6, int j);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// INVALID<br/>int groucho(int k = 1, int m = 2, int n = 3);&#160;&#160;&#160;// VALID</p>
<p>For example, the <code>harpo()</code> prototype permits calls with one, two, or three arguments:</p>
<p class="programlisting">beeps = harpo(2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// same as harpo(2,4,5)<br/>beeps = harpo(1,8);&#160;&#160;&#160;&#160;&#160;// same as harpo(1,8,5)<br/>beeps = harpo (8,7,6);&#160;&#160;// no default arguments used</p>
<p>The actual arguments are assigned to the corresponding formal arguments from left to right; you can&#8217;t skip over arguments. Thus, the following isn&#8217;t allowed:</p>
<p class="programlisting">beeps = harpo(3, ,8);&#160;&#160;&#160;// invalid, doesn't set m to 4</p>
<p>Default arguments aren&#8217;t a major programming breakthrough; rather, they are a convenience. When you begin working with class design, you&#8217;ll find that they can reduce the number of constructors, methods, and method overloads you have to define.</p>
<p><a href="#ch08ex09">Listing 8.9</a> puts default arguments to use. Note that only the prototype indicates the default. The function definition is the same as it would be without default arguments.</p>
<p class="caption1"><a id="ch08ex09"/><strong>Listing 8.9. <code>left.cpp</code></strong></p><hr/>
<p class="programlisting1">// left.cpp -- string function with a default argument<br/>#include &lt;iostream&gt;<br/>const int ArSize = 80;<br/>char * left(const char * str, int n = 1);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char sample[ArSize];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a string:\n";<br/>&#160;&#160;&#160;&#160;cin.get(sample,ArSize);<br/>&#160;&#160;&#160;&#160;char *ps = left(sample, 4);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ps &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;delete [] ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free old string<br/>&#160;&#160;&#160;&#160;ps = left(sample);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ps &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;delete [] ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free new string<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// This function returns a pointer to a new string<br/>// consisting of the first n characters in the str string.<br/>char * left(const char * str, int n)<br/>{<br/>&#160;&#160;&#160;&#160;if(n &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;n = 0;<br/>&#160;&#160;&#160;&#160;char * p = new char[n+1];<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; n &#38;&#38; str[i]; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p[i] = str[i];&#160;&#160;// copy characters<br/>&#160;&#160;&#160;&#160;while (i &lt;= n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p[i++] = '\0';&#160;&#160;// set rest of string to '\0'<br/>&#160;&#160;&#160;&#160;return p;<br/>}</p><hr/>
<p><a id="page_411"/>Here&#8217;s a sample run of the program in <a href="#ch08ex09">Listing 8.9</a>:</p>
<p class="programlisting">Enter a string:<br/><span class="EmpStrong">forthcoming</span><br/>fort<br/>f</p>
<h4 id="ch08lev2sec8">Program Notes</h4>
<p>The program in <a href="#ch08ex09">Listing 8.9</a> uses <code>new</code> to create a new string for holding the selected characters. One awkward possibility is that an uncooperative user may request a negative number of characters. In that case, the function sets the character count to <code>0</code> and eventually returns the null string. Another awkward possibility is that an irresponsible user may request more characters than the string contains. The function protects against this by using a combined test:</p>
<p class="programlisting">i &lt; n &#38;&#38; str[i]</p>
<p>The <code>i &lt; n</code> test stops the loop after <code>n</code> characters have been copied. The second part of the test, the expression <code>str[i]</code>, is the code for the character about to be copied. If the loop reaches the null character, the code is <code>0</code>, and the loop terminates. The final <code>while</code> <a id="page_412"/>loop terminates the string with the null character and then sets the rest of the allocated space, if any, to null characters.</p>
<p>Another approach for setting the size of the new string is to set <code>n</code> to the smaller of the passed value and the string length:</p>
<p class="programlisting">int len = strlen(str);<br/>n = (n &lt; len) ? n : len;&#160;&#160;&#160;&#160;// the lesser of n and len<br/>char * p = new char[n+1];</p>
<p>This ensures that <code>new</code> doesn&#8217;t allocate more space than what&#8217;s needed to hold the string. That can be useful if you make a call such as <code>left("Hi!", 32767)</code>. The first approach copies the <code>"Hi!"</code> into an array of 32767 characters, setting all but the first 3 characters to the null character. The second approach copies <code>"Hi!"</code> into an array of 4 characters. But by adding another function call (<code>strlen()</code>), it increases the program size, slows the process, and requires that you remember to include the <code>cstring</code> (or <code>string.h</code>) header file. C programmers have tended to opt for faster running, more compact code and leave a greater burden on the programmer to use functions correctly. However, the C++ tradition places greater weight on reliability. After all, a slower program that works correctly is better than a fast program that works incorrectly. If the time taken to call <code>strlen()</code> turns out to be a problem, you can let <code>left()</code> determine the lesser of <code>n</code> and the string length directly. For example, the following loop quits when <code>m</code> reaches <code>n</code> or the end of the string, whichever comes first:</p>
<p class="programlisting">int m = 0;<br/>while (m &lt;= n &#38;&#38; str[m] != '\0')<br/>&#160;&#160;&#160;&#160;&#160;&#160;m++;<br/>char * p = new char[m+1]:<br/>// use m instead of n in rest of code</p>
<p>Remember, the expression <code>str[m] != '\0'</code> evaluates to <code>true</code> when <code>str[m]</code> is not the null character and to <code>false</code> when it is the null character. Because nonzero values are converted to <code>true</code> in an <code>&#38;&#38;</code> expression and zero is converted to <code>false</code>, the <code>while</code> test also can be written this way:</p>
<p class="programlisting">while (m&lt;=n &#38;&#38; str[m])</p>
<h3 id="ch08lev1sec4">Function Overloading</h3>
<p>Function polymorphism is a neat C++ addition to C&#8217;s capabilities. Whereas default arguments let you call the same function by using varying numbers of arguments, <em>function polymorphism</em>, also called <em>function overloading</em>, lets you use multiple functions sharing the same name. The word <em>polymorphism</em> means having many forms, so <em>function polymorphism</em> lets a function have many forms. Similarly, the expression <em>function overloading</em> means you can attach more than one function to the same name, thus overloading the name. Both expressions boil down to the same thing, but we&#8217;ll usually use the expression <em>function overloading</em>&#8212;it sounds harder working. You can use function overloading to design a family of functions that do essentially the same thing but using different argument lists.</p>
<p><a id="page_413"/>Overloaded functions are analogous to verbs having more than one meaning. For example, Miss Piggy can root at the ball park for the home team, and she can root in soil for truffles. The context (one hopes) tells you which meaning of <em>root</em> is intended in each case. Similarly, C++ uses the context to decide which version of an overloaded function is intended.</p>
<p>The key to function overloading is a function&#8217;s argument list, also called the <em>function signature</em>. If two functions use the same number and types of arguments in the same order, they have the same signature; the variable names don&#8217;t matter. C++ enables you to define two functions by the same name, provided that the functions have different signatures. The signature can differ in the number of arguments or in the type of arguments, or both. For example, you can define a set of <code>print()</code> functions with the following prototypes:</p>
<p class="programlisting">void print(const char * str, int width);&#160;&#160;// #1<br/>void print(double d, int width);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #2<br/>void print(long l, int width);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #3<br/>void print(int i, int width);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #4<br/>void print(const char *str);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #5</p>
<p>When you then use a <code>print()</code> function, the compiler matches your use to the prototype that has the same signature:</p>
<p class="programlisting">print("Pancakes", 15);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #1<br/>print("Syrup");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #5<br/>print(1999.0, 10);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #2<br/>print(1999, 12);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #4<br/>print(1999L, 15);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #3</p>
<p>For example, <code>print("Pancakes", 15)</code> uses a string and an integer as arguments, and it matches Prototype #1.</p>
<p>When you use overloaded functions, you need to be sure you use the proper argument types in the function call. For example, consider the following statements:</p>
<p class="programlisting">unsigned int year = 3210;<br/>print(year, 6);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ambiguous call</p>
<p>Which prototype does the <code>print()</code> call match here? It doesn&#8217;t match any of them! A lack of a matching prototype doesn&#8217;t automatically rule out using one of the functions because C++ will try to use standard type conversions to force a match. If, say, the <em>only</em> <code>print()</code> prototype were #2, the function call <code>print(year, 6)</code> would convert the <code>year</code> value to type <code>double</code>. But in the earlier code there are three prototypes that take a number as the first argument, providing three different choices for converting <code>year</code>. Faced with this ambiguous situation, C++ rejects the function call as an error.</p>
<p>Some signatures that appear to be different from each other nonetheless can&#8217;t coexist. For example, consider these two prototypes:</p>
<p class="programlisting">double cube(double x);<br/>double cube(double &#38; x);</p>
<p><a id="page_414"/>You might think this is a place you could use function overloading because the function signatures appear to be different. But consider things from the compiler&#8217;s standpoint. Suppose you have code like this:</p>
<p class="programlisting">cout &lt;&lt; cube(x);</p>
<p>The <code>x</code> argument matches both the <code>double x</code> prototype and the <code>double &#38;x</code> prototype. The compiler has no way of knowing which function to use. Therefore, to avoid such confusion, when it checks function signatures, the compiler considers a reference to a type and the type itself to be the same signature.</p>
<p>The function-matching process does discriminate between <code>const</code> and non-<code>const</code> variables. Consider the following prototypes:</p>
<p class="programlisting">void dribble(char * bits);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded<br/>void dribble (const char *cbits);&#160;&#160;&#160;// overloaded<br/>void dabble(char * bits);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not overloaded<br/>void drivel(const char * bits);&#160;&#160;&#160;&#160;&#160;// not overloaded</p>
<p>Here&#8217;s what various function calls would match:</p>
<p class="programlisting">const char p1[20] = "How's the weather?";<br/>char p2[20] = "How's business?";<br/>dribble(p1);&#160;&#160;&#160;&#160;&#160;&#160;// dribble(const char *);<br/>dribble(p2);&#160;&#160;&#160;&#160;&#160;&#160;// dribble(char *);<br/>dabble(p1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no match<br/>dabble(p2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// dabble(char *);<br/>drivel(p1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// drivel(const char *);<br/>drivel(p2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// drivel(const char *);</p>
<p>The <code>dribble()</code> function has two prototypes&#8212;one for <code>const</code> pointers and one for regular pointers&#8212;and the compiler selects one or the other, depending on whether the actual argument is <code>const</code>. The <code>dabble()</code> function only matches a call with a non-<code>const</code> argument, but the <code>drivel()</code> function matches calls with either <code>const</code> or non-<code>const</code> arguments. The reason for this difference in behavior between <code>drivel()</code> and <code>dabble()</code> is that it&#8217;s valid to assign a non-<code>const</code> value to a <code>const</code> variable, but not vice versa.</p>
<p>Keep in mind that the signature, not the function type, enables function overloading. For example, the following two declarations are incompatible:</p>
<p class="programlisting">long gronk(int n, float m);&#160;&#160;&#160;&#160;&#160;&#160;// same signatures,<br/>double gronk(int n, float m);&#160;&#160;&#160;&#160;// hence not allowed</p>
<p>Therefore, C++ doesn&#8217;t permit you to overload <code>gronk()</code> in this fashion. You can have different return types, but only if the signatures are also different:</p>
<p class="programlisting">long gronk(int n, float m);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// different signatures,<br/>double gronk(float n, float m);&#160;&#160;&#160;&#160;// hence allowed</p>
<p>After we discuss templates later in this chapter, we&#8217;ll further discuss function matching.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch08sb04"/><a id="page_415"/>Overloading Reference Parameters</p>
<p class="sidebarpara">Class designs and the STL often use reference parameters, and it&#8217;s useful to know how overloading works with different reference types. Consider the following three prototypes:</p>
<p class="programlistingB">void sink(double &#38; r1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// matches modifiable lvalue<br/>void sank(const double &#38; r2); // matches modifiable or const lvalue, rvalue<br/>void sunk(double &#38;&#38; r3);&#160;&#160;&#160;&#160;&#160;&#160;// matches rvalue</p>
<p class="sidebarpara">The lvalue reference parameter <code>r1</code> matches a modifiable lvalue argument, such as a <code>double</code> variable. The <code>const</code> lvalue reference parameter <code>r2</code> matches a modifiable lvalue argument, a <code>const</code> lvalue argument, and an rvalue argument, such as the sum of two <code>double</code> values. Finally, the rvalue reference <code>r3</code> matches an rvalue. Note how <code>r2</code> can match the same sort of arguments that <code>r1</code> and <code>r3</code> match. This raises the question of what happens when you overload a function on these three types of parameters. The answer is that the more exact match is made:</p>
<p class="programlistingB">void staff(double &#38; rs);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// matches modifiable lvalue<br/>voit staff(const double &#38; rcs);&#160;&#160;// matches rvalue, const lvalue<br/>void stove(double &#38; r1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// matches modifiable lvalue<br/>void stove(const double &#38; r2);&#160;&#160;&#160;// matches const lvalue<br/>void stove(double &#38;&#38; r3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// matches rvalue</p>
<p class="sidebarpara">This allows you to customize the behavior of a function based on the lvalue, <code>const</code>, or rvalue nature of the argument:</p>
<p class="programlistingB">double x = 55.5;<br/>const double y = 32.0;<br/>stove(x);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls stove(double &#38;)<br/>stove(y);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls stove(const double &#38;)<br/>stove(x+y);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls stove(double &#38;&#38;)</p>
<p class="sidebarpara">If, say, you omit the <code>stove(double &#38;&#38;)</code> function, then <code>stove(x+y)</code> will call the <code>stove(const double &#38;)</code> function instead.</p>
<hr/></div>
<h4 id="ch08lev2sec9">An Overloading Example</h4>
<p>In this chapter we&#8217;ve already developed a <code>left()</code> function that returns a pointer to the first <code>n</code> characters in a string. Let&#8217;s add a second <code>left()</code> function, one that returns the first <code>n</code> digits in an integer. You can use it, for example, to examine the first three digits of a U.S. postal zip code stored as an integer, which is useful if you want to sort for urban areas.</p>
<p>The integer function is a bit more difficult to program than the string version because you don&#8217;t have the benefit of each digit being stored in its own array element. One approach is to first compute the number of digits in the number. Dividing a number by 10 lops off one digit, so you can use division to count digits. More precisely, you can do so with a loop, like this:</p>
<p class="programlisting">unsigned digits = 1;<br/>while (n /= 10)<br/>&#160;&#160;&#160;&#160;digits++;</p>
<p><a id="page_416"/>This loop counts how many times you can remove a digit from <code>n</code> until none are left. Recall that <code>n /= 10</code> is short for <code>n = n / 10</code>. If <code>n</code> is <code>8</code>, for example, the test condition assigns to <code>n</code> the value <code>8 / 10</code>, or <code>0</code>, because it&#8217;s integer division. That terminates the loop, and <code>digits</code> remains at <code>1</code>. But if <code>n</code> is <code>238</code>, the first loop test sets <code>n</code> to <code>238 / 10</code>, or <code>23</code>. That&#8217;s nonzero, so the loop increases <code>digits</code> to <code>2</code>. The next cycle sets <code>n</code> to <code>23 / 10</code>, or <code>2</code>. Again, that&#8217;s nonzero, so <code>digits</code> grows to <code>3</code>. The next cycle sets <code>n</code> to <code>2 / 10</code>, or <code>0</code>, and the loop quits, leaving <code>digits</code> set to the correct value, <code>3</code>.</p>
<p>Now suppose you know that the number has five digits, and you want to return the first three digits. You can get that value by dividing the number by 10 and then dividing the answer by 10 again. Each division by 10 lops one more digit off the right end. To calculate the number of digits to lop, you just subtract the number of digits to be shown from the total number of digits. For example, to show four digits of a nine-digit number, you lop off the last five digits. You can code this approach as follows:</p>
<p class="programlisting">ct = digits - ct;<br/>while (ct--)<br/>&#160;&#160;&#160;&#160;num /= 10;<br/>return num;</p>
<p><a href="#ch08ex10">Listing 8.10</a> incorporates this code into a new <code>left()</code> function. The function includes some additional code to handle special cases, such as asking for zero digits or asking for more digits than the number possesses. Because the signature of the new <code>left()</code> differs from that of the old <code>left()</code>, you can use both functions in the same program.</p>
<p class="caption1"><a id="ch08ex10"/><strong>Listing 8.10. <code>leftover.cpp</code></strong></p><hr/>
<p class="programlisting1">// leftover.cpp -- overloading the left() function<br/>#include &lt;iostream&gt;<br/>unsigned long left(unsigned long num, unsigned ct);<br/>char * left(const char * str, int n = 1);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char * trip = "Hawaii!!";&#160;&#160;&#160;// test value<br/>&#160;&#160;&#160;&#160;unsigned long n = 12345678; // test value<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;char * temp;<br/><br/>&#160;&#160;&#160;&#160;for (i = 1; i &lt; 10; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; left(n, i) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp = left(trip,i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; temp &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete [] temp; // point to temporary storage<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 0;<br/><br/>}<br/><br/>// This function returns the first ct digits of the number num.<br/>unsigned long left(unsigned long num, unsigned ct)<br/>{<br/>&#160;&#160;&#160;&#160;unsigned digits = 1;<br/>&#160;&#160;&#160;&#160;unsigned long n = num;<br/><br/>&#160;&#160;&#160;&#160;if (ct == 0 || num == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// return 0 if no digits<br/>&#160;&#160;&#160;&#160;while (n /= 10)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;digits++;<br/>&#160;&#160;&#160;&#160;if (digits &gt; ct)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;ct = digits - ct;<br/>&#160;&#160;&#160;&#160;while (ct--)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;num /= 10;<br/>&#160;&#160;&#160;&#160;return num;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// return left ct digits<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// if ct &gt;= number of digits<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return num;&#160;&#160;&#160;&#160;&#160;// return the whole number<br/>}<br/><br/>// This function returns a pointer to a new string<br/>// consisting of the first n characters in the str string.<br/>char * left(const char * str, int n)<br/>{<br/>&#160;&#160;&#160;&#160;if(n &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;n = 0;<br/>&#160;&#160;&#160;&#160;char * p = new char[n+1];<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; n &#38;&#38; str[i]; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p[i] = str[i];&#160;&#160;// copy characters<br/>&#160;&#160;&#160;&#160;while (i &lt;= n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p[i++] = '\0';&#160;&#160;// set rest of string to '\0'<br/>&#160;&#160;&#160;&#160;return p;<br/>}</p><hr/>
<p><a id="page_417"/>Here&#8217;s the output of the program in <a href="#ch08ex10">Listing 8.10</a>:</p>
<p class="programlisting">1<br/>H<br/>12<br/>Ha<br/>123<br/>Haw<br/>1234<br/><a id="page_418"/>Hawa<br/>12345<br/>Hawai<br/>123456<br/>Hawaii<br/>1234567<br/>Hawaii!<br/>12345678<br/>Hawaii!!<br/>12345678<br/>Hawaii!!</p>
<h4 id="ch08lev2sec10">When to Use Function Overloading</h4>
<p>You might find function overloading fascinating, but you shouldn&#8217;t overuse it. You should reserve function overloading for functions that perform basically the same task but with different forms of data. Also you might want to check whether you can accomplish the same end by using default arguments. For example, you could replace the single, string-oriented <code>left()</code> function with two overloaded functions:</p>
<p class="programlisting">char * left(const char * str, unsigned n);&#160;&#160;&#160;// two arguments<br/>char * left(const char * str);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// one argument</p>
<p>But using the single function with a default argument is simpler. There&#8217;s just one function to write instead of two, and the program requires memory for just one function instead of two. If you decide to modify the function, you have to edit only one. However, if you require different types of arguments, default arguments are of no avail, so in that case, you should use function overloading.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch08sb05"/>What Is Name Decoration?</p>
<p class="sidebarpara">How does C++ keep track of which overloaded function is which? It assigns a secret identity to each of these functions. When you use the editor of your C++ development tool to write and compile programs, your C++ compiler performs a bit of magic on your behalf&#8212;known as <em>name decoration</em> or <em>name mangling</em>&#8212;through which each function name is encrypted, based on the formal parameter types specified in the function&#8217;s prototype. Consider the following undecorated function prototype:</p>
<p class="programlistingB">long MyFunctionFoo(int, float);</p>
<p class="sidebarpara">This format is fine for us humans; we know that the function accepts two arguments of type <code>int</code> and <code>float</code>, and it returns a value of type <code>long</code>. For its own use, the compiler documents this interface by transforming the name into an internal representation with a more unsightly appearance, perhaps something like this:</p>
<p class="programlistingB">?MyFunctionFoo@@YAXH</p>
<p class="sidebarpara">The apparent gibberish decorating the original name (or mangling it, depending on your attitude) encodes the number and types of parameters. A different function signature would result in a different set of symbols being added, and different compilers would use different conventions for their efforts at decorating.</p>
<hr/></div>
<h3 id="ch08lev1sec5">Function Templates</h3>
<p><a id="page_419"/>Contemporary C++ compilers implement one of the newer C++ additions: function templates. A <em>function template</em> is a generic function description; that is, it defines a function in terms of a generic type for which a specific type, such as <code>int</code> or <code>double</code>, can be substituted. By passing a type as a parameter to a template, you cause the compiler to generate a function for that particular type. Because templates let you program in terms of a generic type instead of a specific type, the process is sometimes termed <em>generic programming</em>. Because types are represented by parameters, the template feature is sometimes referred to as <em>parameterized types</em>. Let&#8217;s see why such a feature is useful and how it works.</p>
<p>Earlier <a href="#ch08ex04">Listing 8.4</a> defined a function that swapped two <code>int</code> values. Suppose you want to swap two <code>double</code> values instead. One approach is to duplicate the original code but replace each <code>int</code> with <code>double</code>. If you need to swap two <code>char</code> values, you can use the same technique again. Still, it&#8217;s wasteful of your valuable time to have to make these petty changes, and there&#8217;s always the possibility of making an error. If you make the changes by hand, you might overlook an <code>int</code>. If you do a global search-and-replace to substitute, say, <code>double</code> for <code>int</code>, you might do something such as converting</p>
<p class="programlisting">int x;<br/>short interval;</p>
<p>to the following:</p>
<p class="programlisting">double x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// intended change of type<br/>short doubleerval;&#160;&#160;&#160;// unintended change of variable name</p>
<p>C++&#8217;s function template capability automates the process, saving you time and providing greater reliability.</p>
<p>Function templates enable you to define a function in terms of some arbitrary type. For example, you can set up a swapping template like this:</p>
<p class="programlisting">template &lt;typename AnyType&gt;<br/>void Swap(AnyType &#38;a, AnyType &#38;b)<br/>{<br/>&#160;&#160;&#160;&#160;AnyType temp;<br/>&#160;&#160;&#160;&#160;temp = a;<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}</p>
<p>The first line specifies that you are setting up a template and that you&#8217;re naming the arbitrary type <code>AnyType</code>. The keywords <code>template</code> and <code>typename</code> are obligatory, except that you can use the keyword <code>class</code> instead of <code>typename</code>. Also you must use the angle brackets. The type name (<code>AnyType</code>, in this example) is your choice, as long as you follow the usual C++ naming rules; many programmers use simple names such as <code>T</code>, which, one must admit, is simple indeed. The rest of the code describes the algorithm for swapping two values of type <code>AnyType</code>. The template does not create any functions. Instead, it provides the compiler with directions about how to define a function. If you want a function to swap <a id="page_420"/><code>int</code>s, then the compiler creates a function following the template pattern, substituting <code>int</code> for <code>AnyType</code>. Similarly, if you need a function to swap <code>double</code>s, the compiler follows the template, substituting the <code>double</code> type for <code>AnyType</code>.</p>
<p>Before the C++98 Standard added the keyword <code>typename</code> to the language, C++ used the keyword <code>class</code> in this particular context. That is, you can write the template definition this way:</p>
<p class="programlisting">template &lt;class AnyType&gt;<br/>void Swap(AnyType &#38;a, AnyType &#38;b)<br/>{<br/>&#160;&#160;&#160;&#160;AnyType temp;<br/>&#160;&#160;&#160;&#160;temp = a;<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}</p>
<p>The <code>typename</code> keyword makes it a bit more obvious that the parameter <code>AnyType</code> represents a type; however, large libraries of code have already been developed by using the older keyword <code>class</code>. The C++ Standard treats the two keywords identically when they are used in this context. This book uses both forms so that you will be familiar with them when encountering them elsewhere.</p>
<div class="note"><hr/>
<p class="title"><a id="ch08note04"/>Tip</p>
<p class="notepara">You should use templates if you need functions that apply the same algorithm to a variety of types. If you aren&#8217;t concerned with backward compatibility and can put up with the effort of typing a longer word, you can use the keyword <code>typename</code> rather than <code>class</code> when you declare type parameters.</p>
<hr/></div>
<p>To let the compiler know that you need a particular form of swap function, you just use a function called <code>Swap()</code> in your program. The compiler checks the argument types you use and then generates the corresponding function. <a href="#ch08ex11">Listing 8.11</a> shows how this works. The program layout follows the usual pattern for ordinary functions, with a template function prototype near the top of the file and the template function definition following <code>main()</code>. The example follows the more usual practice of using <code>T</code> instead of <code>AnyType</code> as the type parameter.</p>
<p class="caption1"><a id="ch08ex11"/><strong>Listing 8.11. <code>funtemp.cpp</code></strong></p><hr/>
<p class="programlisting1">// funtemp.cpp -- using a function template<br/>#include &lt;iostream&gt;<br/>// function template prototype<br/>template &lt;typename T&gt;&#160;&#160;// or class T<br/>void Swap(T &#38;a, T &#38;b);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int i = 10;<br/>&#160;&#160;&#160;&#160;int j = 20;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "i, j = " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using compiler-generated int swapper:\n";<br/>&#160;&#160;&#160;&#160;Swap(i,j);&#160;&#160;// generates void Swap(int &#38;, int &#38;)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Now i, j = " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; ".\n";<br/><br/>&#160;&#160;&#160;&#160;double x = 24.5;<br/>&#160;&#160;&#160;&#160;double y = 81.7;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "x, y = " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using compiler-generated double swapper:\n";<br/>&#160;&#160;&#160;&#160;Swap(x,y);&#160;&#160;// generates void Swap(double &#38;, double &#38;)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Now x, y = " &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;// cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// function template definition<br/>template &lt;typename T&gt;&#160;&#160;// or class T<br/>void Swap(T &#38;a, T &#38;b)<br/>{<br/>&#160;&#160;&#160;&#160;T temp;&#160;&#160;&#160;// temp a variable of type T<br/>&#160;&#160;&#160;&#160;temp = a;<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}</p><hr/>
<p><a id="page_421"/>The first <code>Swap()</code> function in <a href="#ch08ex11">Listing 8.11</a> has two <code>int</code> arguments, so the compiler generates an <code>int</code> version of the function. That is, it replaces each use of <code>T</code> with <code>int</code>, producing a definition that looks like this:</p>
<p class="programlisting">void Swap(int &#38;a, int &#38;b)<br/>{<br/>&#160;&#160;&#160;&#160;int temp;<br/>&#160;&#160;&#160;&#160;temp = a;<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}</p>
<p>You don&#8217;t see this code, but the compiler generates and then uses it in the program. The second <code>Swap()</code> function has two <code>double</code> arguments, so the compiler generates a <code>double</code> version. That is, it replaces <code>T</code> with <code>double</code>, generating this code:</p>
<p class="programlisting">void Swap(double &#38;a, double &#38;b)<br/>{<br/>&#160;&#160;&#160;&#160;double temp;<br/>&#160;&#160;&#160;&#160;temp = a;<br/><a id="page_422"/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}</p>
<p>Here&#8217;s the output of the program in <a href="#ch08ex11">Listing 8.11</a>, which shows that the process has worked:</p>
<p class="programlisting">i, j = 10, 20.<br/>Using compiler-generated int swapper:<br/>Now i, j = 20, 10.<br/>x, y = 24.5, 81.7.<br/>Using compiler-generated double swapper:<br/>Now x, y = 81.7, 24.5.</p>
<p>Note that function templates don&#8217;t make executable programs any shorter. In <a href="#ch08ex11">Listing 8.11</a>, you still wind up with two separate function definitions, just as you would if you defined each function manually. And the final code doesn&#8217;t contain any templates; it just contains the actual functions generated for the program. The benefits of templates are that they make generating multiple function definitions simpler and more reliable.</p>
<p>More typically, templates are placed in a header file that is then included in the file using them. <a href="ch09.html#ch09">Chapter 9</a> discusses header files.</p>
<h4 id="ch08lev2sec11">Overloaded Templates</h4>
<p>You use templates when you need functions that apply the same algorithm to a variety of types, as in <a href="#ch08ex11">Listing 8.11</a>. It might be, however, that not all types would use the same algorithm. To handle this possibility, you can overload template definitions, just as you overload regular function definitions. As with ordinary overloading, overloaded templates need distinct function signatures. For example, <a href="#ch08ex12">Listing 8.12</a> adds a new swapping template&#8212;one for swapping elements of two arrays. The original template has the signature <code>(T &#38;, T &#38;)</code>, whereas the new template has the signature <code>(T [], T [], int)</code>. Note that the final parameter in this case happens to be a specific type (<code>int</code>) rather than a generic type. Not all template arguments have to be template parameter types.</p>
<p>When, in <code>twotemps.cpp</code>, the compiler encounters the first use of <code>Swap()</code>, it notices that it has two <code>int</code> arguments and matches <code>Swap()</code> to the original template. The second use, however, has two <code>int</code> arrays and an <code>int</code> value as arguments, and this matches the new template.</p>
<p class="caption1"><a id="ch08ex12"/><strong>Listing 8.12. <code>twotemps.cpp</code></strong></p><hr/>
<p class="programlisting1">// twotemps.cpp -- using overloaded template functions<br/>#include &lt;iostream&gt;<br/>template &lt;typename T&gt;&#160;&#160;&#160;&#160;&#160;// original template<br/>void Swap(T &#38;a, T &#38;b);<br/><br/>template &lt;typename T&gt;&#160;&#160;&#160;&#160;&#160;// new template<br/>void Swap(T *a, T *b, int n);<br/><a id="page_423"/>void Show(int a[]);<br/>const int Lim = 8;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int i = 10, j = 20;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "i, j = " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using compiler-generated int swapper:\n";<br/>&#160;&#160;&#160;&#160;Swap(i,j);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// matches original template<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Now i, j = " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; ".\n";<br/><br/>&#160;&#160;&#160;&#160;int d1[Lim] = {0,7,0,4,1,7,7,6};<br/>&#160;&#160;&#160;&#160;int d2[Lim] = {0,7,2,0,1,9,6,9};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Original arrays:\n";<br/>&#160;&#160;&#160;&#160;Show(d1);<br/>&#160;&#160;&#160;&#160;Show(d2);<br/>&#160;&#160;&#160;&#160;Swap(d1,d2,Lim);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// matches new template<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Swapped arrays:\n";<br/>&#160;&#160;&#160;&#160;Show(d1);<br/>&#160;&#160;&#160;&#160;Show(d2);<br/>&#160;&#160;&#160;&#160;// cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>template &lt;typename T&gt;<br/>void Swap(T &#38;a, T &#38;b)<br/>{<br/>&#160;&#160;&#160;&#160;T temp;<br/>&#160;&#160;&#160;&#160;temp = a;<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}<br/><br/>template &lt;typename T&gt;<br/>void Swap(T a[], T b[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;T temp;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp = a[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;a[i] = b[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;b[i] = temp;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>void Show(int a[])<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; "/";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; a[2] &lt;&lt; a[3] &lt;&lt; "/";<br/>&#160;&#160;&#160;&#160;for (int i = 4; i &lt; Lim; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; a[i];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}</p><hr/>
<p><a id="page_424"/>Here is the output of the program in <a href="#ch08ex12">Listing 8.12</a>:</p>
<p class="programlisting">i, j = 10, 20.<br/>Using compiler-generated int swapper:<br/>Now i, j = 20, 10.<br/>Original arrays:<br/>07/04/1776<br/>07/20/1969<br/>Swapped arrays:<br/>07/20/1969<br/>07/04/1776</p>
<h4 id="ch08lev2sec12">Template Limitations</h4>
<p>Suppose you have a template function:</p>
<p class="programlisting">template &lt;class T&gt;&#160;&#160;&#160;&#160;&#160;// or template &lt;typename T&gt;<br/>void f(T a, T b)<br/>{...}</p>
<p>Often the code makes assumptions about what operations are possible for the type. For instance, the following statement assumes that assignment is defined, and this would not be true if type <code>T</code> is a built-in array type:</p>
<p class="programlisting">a = b;</p>
<p>Similarly, the following assumes <code>&gt;</code> is defined, which is not true if <code>T</code> is an ordinary structure:</p>
<p class="programlisting">if (a &gt; b)</p>
<p>Also the <code>&gt;</code> operator is defined for array names, but because array names are addresses, it compares the addresses of the arrays, which may not be what you have in mind. And the following assumes the multiplication operator is defined for type <code>T</code>, which is not the case if <code>T</code> is an array, a pointer, or a structure:</p>
<p class="programlisting">T c = a*b;</p>
<p>In short, it&#8217;s easy to write a template function that cannot handle certain types. On the other hand, sometimes a generalization makes sense, even if ordinary C++ syntax doesn&#8217;t allow for it. For example, it could make sense to add structures containing position coordinates, even though the <code>+</code> operator isn&#8217;t defined for structures. One approach is that C++ <a id="page_425"/>allows one to overload the <code>+</code> operator so that it can be used with a particular form of structure or class. <a href="ch11.html#ch11">Chapter 11</a> discusses this facility. A template that requires using the <code>+</code> operator then could handle a structure that had an overloaded <code>+</code> operator. Another approach is to provide specialized template definitions for particular types. Let&#8217;s look at that next.</p>
<h4 id="ch08lev2sec13">Explicit Specializations</h4>
<p>Suppose you define a structure like the following:</p>
<p class="programlisting">struct job<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;char name[40];<br/>&#160;&#160;&#160;&#160;&#160;&#160;double salary;<br/>&#160;&#160;&#160;&#160;&#160;&#160;int floor;<br/>};</p>
<p>Also suppose you want to be able to swap the contents of two such structures. The original template uses the following code to effect a swap:</p>
<p class="programlisting">temp = a;<br/>a = b;<br/>b = temp;</p>
<p>Because C++ allows you to assign one structure to another, this works fine, even if type <code>T</code> is a <code>job</code> structure. But suppose you only want to swap the <code>salary</code> and <code>floor</code> members, keeping the <code>name</code> members unchanged. This requires different code, but the arguments to <code>Swap()</code> would be the same as for the first case (references to two <code>job</code> structures), so you can&#8217;t use template overloading to supply the alternative code.</p>
<p>However, you can supply a specialized function definition, called an <em>explicit specialization</em>, with the required code. If the compiler finds a specialized definition that exactly matches a function call, it uses that definition without looking for templates.</p>
<p>The specialization mechanism has changed with the evolution of C++. We&#8217;ll look at the current form as mandated by the C++ Standard.</p>
<h5 id="ch08lev3sec9">Third-Generation Specialization (ISO/ANSI C++ Standard)</h5>
<p>After some youthful experimentation with other approaches, the C++98 Standard settled on this approach:</p>
<p class="indenthandingB">&#8226; For a given function name, you can have a non template function, a template function, and an explicit specialization template function, along with overloaded versions of all of these.</p>
<p class="indenthandingB">&#8226; The prototype and definition for an explicit specialization should be preceded by <code>template &lt;&gt;</code> and should mention the specialized type by name.</p>
<p class="indenthandingB">&#8226; A specialization overrides the regular template, and a non template function overrides both.</p>
<p><a id="page_426"/>Here&#8217;s how prototypes for swapping type <code>job</code> structures would look for these three forms:</p>
<p class="programlisting">// non template function prototype<br/>void Swap(job &#38;, job &#38;);<br/><br/>// template prototype<br/>template &lt;typename T&gt;<br/>void Swap(T &#38;, T &#38;);<br/><br/>// explicit specialization for the job type<br/>template &lt;&gt; void Swap&lt;job&gt;(job &#38;, job &#38;);</p>
<p>As mentioned previously, if more than one of these prototypes is present, the compiler chooses the non template version over explicit specializations and template versions, and it chooses an explicit specialization over a version generated from a template. For example, in the following code, the first call to <code>Swap()</code> uses the general template, and the second call uses the explicit specialization, based on the <code>job</code> type:</p>
<p class="programlisting">...<br/>template &lt;class T&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template<br/>void Swap(T &#38;, T &#38;);<br/><br/>// explicit specialization for the job type<br/>template &lt;&gt; void Swap&lt;job&gt;(job &#38;, job &#38;);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double u, v;<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;Swap(u,v);&#160;&#160;// use template<br/>&#160;&#160;&#160;&#160;job a, b;<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;Swap(a,b);&#160;&#160;// use void Swap&lt;job&gt;(job &#38;, job &#38;)<br/>}</p>
<p>The <code>&lt;job&gt;</code> in <code>Swap&lt;job&gt;</code> is optional because the function argument types indicate that this is a specialization for <code>job</code>. Thus, the prototype can also be written this way:</p>
<p class="programlisting">template &lt;&gt; void Swap(job &#38;, job &#38;);&#160;&#160;&#160;// simpler form</p>
<p>In case you have to work with an older compiler, we&#8217;ll come back to pre-C++ Standard usage soon, but first, let&#8217;s see how explicit specializations are supposed to work.</p>
<h5 id="ch08lev3sec10">An Example of Explicit Specialization</h5>
<p><a href="#ch08ex13">Listing 8.13</a> illustrates how explicit specialization works.</p>
<p class="caption1"><a id="page_427"/><a id="ch08ex13"/><strong>Listing 8.13. <code>twoswap.cpp</code></strong></p><hr/>
<p class="programlisting1">// twoswap.cpp -- specialization overrides a template<br/>#include &lt;iostream&gt;<br/>template &lt;typename T&gt;<br/>void Swap(T &#38;a, T &#38;b);<br/><br/>struct job<br/>{<br/>&#160;&#160;&#160;&#160;char name[40];<br/>&#160;&#160;&#160;&#160;double salary;<br/>&#160;&#160;&#160;&#160;int floor;<br/>};<br/><br/>// explicit specialization<br/>template &lt;&gt; void Swap&lt;job&gt;(job &#38;j1, job &#38;j2);<br/>void Show(job &#38;j);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout.precision(2);<br/>&#160;&#160;&#160;&#160;cout.setf(ios::fixed, ios::floatfield);<br/>&#160;&#160;&#160;&#160;int i = 10, j = 20;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "i, j = " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using compiler-generated int swapper:\n";<br/>&#160;&#160;&#160;&#160;Swap(i,j);&#160;&#160;&#160;&#160;// generates void Swap(int &#38;, int &#38;)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Now i, j = " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; ".\n";<br/><br/>&#160;&#160;&#160;&#160;job sue = {"Susan Yaffee", 73000.60, 7};<br/>&#160;&#160;&#160;&#160;job sidney = {"Sidney Taffee", 78060.72, 9};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Before job swapping:\n";<br/>&#160;&#160;&#160;&#160;Show(sue);<br/>&#160;&#160;&#160;&#160;Show(sidney);<br/>&#160;&#160;&#160;&#160;Swap(sue, sidney); // uses void Swap(job &#38;, job &#38;)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After job swapping:\n";<br/>&#160;&#160;&#160;&#160;Show(sue);<br/>&#160;&#160;&#160;&#160;Show(sidney);<br/>&#160;&#160;&#160;&#160;// cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>template &lt;typename T&gt;<br/>void Swap(T &#38;a, T &#38;b)&#160;&#160;&#160;&#160;// general version<br/>{<br/>&#160;&#160;&#160;&#160;T temp;<br/>&#160;&#160;&#160;&#160;temp = a;<br/>&#160;&#160;&#160;&#160;a = b;<br/>&#160;&#160;&#160;&#160;b = temp;<br/>}<br/><br/>// swaps just the salary and floor fields of a job structure<br/><br/>template &lt;&gt; void Swap&lt;job&gt;(job &#38;j1, job &#38;j2)&#160;&#160;// specialization<br/>{<br/>&#160;&#160;&#160;&#160;double t1;<br/>&#160;&#160;&#160;&#160;int t2;<br/>&#160;&#160;&#160;&#160;t1 = j1.salary;<br/>&#160;&#160;&#160;&#160;j1.salary = j2.salary;<br/>&#160;&#160;&#160;&#160;j2.salary = t1;<br/>&#160;&#160;&#160;&#160;t2 = j1.floor;<br/>&#160;&#160;&#160;&#160;j1.floor = j2.floor;<br/>&#160;&#160;&#160;&#160;j2.floor = t2;<br/>}<br/><br/>void Show(job &#38;j)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; j.name &lt;&lt; ": $" &lt;&lt; j.salary<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " on floor " &lt;&lt; j.floor &lt;&lt; endl;<br/>}</p><hr/>
<p><a id="page_428"/>Here&#8217;s the output of the program in <a href="#ch08ex13">Listing 8.13</a>:</p>
<p class="programlisting">i, j = 10, 20.<br/>Using compiler-generated int swapper:<br/>Now i, j = 20, 10.<br/>Before job swapping:<br/>Susan Yaffee: $73000.60 on floor 7<br/>Sidney Taffee: $78060.72 on floor 9<br/>After job swapping:<br/>Susan Yaffee: $78060.72 on floor 9<br/>Sidney Taffee: $73000.60 on floor 7</p>
<h4 id="ch08lev2sec14">Instantiations and Specializations</h4>
<p>To extend your understanding of templates, let&#8217;s investigate the terms <em>instantiation</em> and <em>specialization</em>. Keep in mind that including a function template in your code does not in itself generate a function definition. It&#8217;s merely a plan for generating a function definition. When the compiler uses the template to generate a function definition for a particular type, the result is termed an <em>instantiation</em> of the template. For example, in <a href="#ch08ex13">Listing 8.13</a>, the function call <code>Swap(i,j)</code> causes the compiler to generate an instantiation of <code>Swap()</code>, using <code>int</code> as the type. The template <em>is not</em> a function definition, but the specific instantiation <a id="page_429"/>using <code>int</code> <em>is</em> a function definition. This type of instantiation is termed <em>implicit instantiation</em> because the compiler deduces the necessity for making the definition by noting that the program uses a <code>Swap()</code> function with <code>int</code> parameters.</p>
<p>Originally, using implicit instantiation was the only way the compiler generated function definitions from templates, but now C++ allows for <em>explicit instantiation</em>. That means you can instruct the compiler to create a particular instantiation&#8212;for example, <code>Swap&lt;int&gt;()</code>&#8212;directly. The syntax is to declare the particular variety you want, using the <code>&lt;&gt;</code> notation to indicate the type and prefixing the declaration with the keyword <code>template</code>:</p>
<p class="programlisting">template void Swap&lt;int&gt;(int, int);&#160;&#160;// explicit instantiation</p>
<p>A compiler that implements this feature will, upon seeing this declaration, use the <code>Swap()</code> template to generate an instantiation, using the <code>int</code> type. That is, this declaration means &#8220;Use the <code>Swap()</code> template to generate a function definition for the <code>int</code> type.&#8221; Contrast the explicit instantiation with the explicit specialization, which uses one or the other of these equivalent declarations:</p>
<p class="programlisting">template &lt;&gt; void Swap&lt;int&gt;(int &#38;, int &#38;);&#160;&#160;// explicit specialization<br/>template &lt;&gt; void Swap(int &#38;, int &#38;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// explicit specialization</p>
<p>The difference is that these last two declarations mean &#8220;Don&#8217;t use the <code>Swap()</code> template to generate a function definition. Instead, use a separate, specialized function definition explicitly defined for the <code>int</code> type.&#8221; These prototypes have to be coupled with their own function definitions. The explicit specialization declaration has <code>&lt;&gt;</code> after the keyword template, whereas the explicit instantiation omits the <code>&lt;&gt;</code>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch08note05"/>Caution</p>
<p class="notepara">It is an error to try to use both an explicit instantiation and an explicit specialization for the same type(s) in the same file, or, more generally, the same translation unit.</p>
<hr/></div>
<p>Explicit instantiations also can be created by using the function in a program. For instance, consider the following:</p>
<p class="programlisting">template &lt;class T&gt;<br/>T Add(T a, T b)&#160;&#160;&#160;&#160;// pass by value<br/>{<br/>&#160;&#160;&#160;&#160;return a + b;<br/>}<br/>...<br/>int m = 6;<br/>double x = 10.2;<br/>cout &lt;&lt; Add&lt;double&gt;(x, m) &lt;&lt; endl;&#160;&#160;// explicit instantiation</p>
<p>The template would fail to match the function call <code>Add(x, m)</code> because the template expects both function arguments to be of the same type. But using <code>Add&lt;double&gt;(x, m)</code> forces the type <code>double</code> instantiation, and the argument <code>m</code> is type cast to type <code>double</code> to match the second parameter of the <code>Add&lt;double&gt;(double, double)</code> function.</p>
<p><a id="page_430"/>What if you do something similar with <code>Swap()</code>?</p>
<p class="programlisting">int m = 5;<br/>double x&#160;&#160;= 14.3;<br/>Swap&lt;double&gt;(m, x);&#160;&#160;// almost works</p>
<p>This generates an explicit instantiation for type <code>double</code>. Unfortunately, in this case, the code won&#8217;t work because the first formal parameter, being type <code>double &#38;</code>, can&#8217;t refer to the type <code>int</code> variable <code>m</code>.</p>
<p>Implicit instantiations, explicit instantiations, and explicit specializations collectively are termed <em>specializations</em>. What they all have in common is that they represent a function definition that uses specific types rather than one that is a generic description.</p>
<p>The addition of the explicit instantiation led to the new syntax of using <code>template</code> and <code>template &lt;&gt;</code> prefixes in declarations to distinguish between the explicit instantiation and the explicit specialization. As in many other cases, the cost of doing more is more syntax rules. The following fragment summarizes these concepts:</p>
<p class="programlisting">...<br/>template &lt;class T&gt;<br/>void Swap (T &#38;, T &#38;);&#160;&#160;// template prototype<br/><br/>template &lt;&gt; void Swap&lt;job&gt;(job &#38;, job &#38;);&#160;&#160;&#160;// explicit specialization for job<br/>int main(void)<br/>{<br/>&#160;&#160;template void Swap&lt;char&gt;(char &#38;, char &#38;); // explicit instantiation for char<br/>&#160;&#160;short a, b;<br/>&#160;&#160;...<br/>&#160;&#160;Swap(a,b);&#160;&#160;&#160;&#160;// implicit template instantiation for short<br/>&#160;&#160;job n, m;<br/>&#160;&#160;...<br/>&#160;&#160;Swap(n, m);&#160;&#160;&#160;// use explicit specialization for job<br/>&#160;&#160;char g, h;<br/>&#160;&#160;...<br/>&#160;&#160;Swap(g, h);&#160;&#160;// use explicit template instantiation for char<br/>&#160;&#160;...<br/>}</p>
<p>When the compiler reaches the explicit instantiation for <code>char</code>, it uses the template definition to generate a <code>char</code> version of <code>Swap()</code>. For the remaining uses of <code>Swap()</code>, the compiler matches a template to the actual arguments used in the function call. For example, when the compiler reaches the function call <code>Swap(a,b)</code>, it generates a <code>short</code> version of <code>Swap()</code> because the two arguments are type <code>short</code>. When the compiler reaches <code>Swap(n,m)</code>, it uses the separate definition (the explicit specialization) provided for the <code>job</code> type. When the compiler reaches <code>Swap(g,h)</code>, it uses the template specialization it already generated when it processed the explicit instantiation.</p>
<h4 id="ch08lev2sec15">Which Function Version Does the Compiler Pick?</h4>
<p><a id="page_431"/>What with function overloading, function templates, and function template overloading, C++ needs, and has, a well-defined strategy for deciding which function definition to use for a function call, particularly when there are multiple arguments. The process is called <em>overload resolution</em>. Detailing the complete strategy would take a small chapter, so let&#8217;s take just a broad look at how the process works:</p>
<p class="indenthandingB">&#8226; <strong>Phase 1&#8212;</strong> Assemble a list of candidate functions. These are functions and template functions that have the same names as the called functions.</p>
<p class="indenthandingB">&#8226; <strong>Phase 2&#8212;</strong> From the candidate functions, assemble a list of viable functions. These are functions with the correct number of arguments and for which there is an implicit conversion sequence, which includes the case of an exact match for each type of actual argument to the type of the corresponding formal argument. For example, a function call with a type <code>float</code> argument could have that value converted to a <code>double</code> to match a type <code>double</code> formal parameter, and a template could generate an instantiation for <code>float</code>.</p>
<p class="indenthandingB">&#8226; <strong>Phase 3&#8212;</strong> Determine whether there is a best viable function. If so, you use that function. Otherwise, the function call is an error.</p>
<p>Consider a case with just one function argument&#8212;for example, the following call:</p>
<p class="programlisting">may('B');&#160;&#160;&#160;&#160;// actual argument is type char</p>
<p>First, the compiler rounds up the suspects, which are functions and function templates that have the name <code>may()</code>. Then, it finds those that can be called with one argument. For example, the following pass muster because they have the same name and can be used with one argument:</p>
<p class="programlisting">void may(int);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #1<br/>float may(float, float = 3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #2<br/>void may(char);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #3<br/>char * may(const char *);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #4<br/>char may(const char &#38;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #5<br/>template&lt;class T&gt; void may(const T &#38;);&#160;&#160;&#160;&#160;// #6<br/>template&lt;class T&gt; void may(T *);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #7</p>
<p>Note that just the signatures and not the return types are considered. Two of these candidates (#4 and #7), however, are not viable because an integral type cannot be converted implicitly (that is, without an explicit type cast) to a pointer type. The remaining template is viable because it can be used to generate a specialization, with <code>T</code> taken as type <code>char</code>. That leaves five viable functions, each of which could be used if it were the only function declared.</p>
<p>Next, the compiler has to determine which of the viable functions is best. It looks at the conversion required to make the function call argument match the viable candidate&#8217;s argument. In general, the ranking from best to worst is this:</p>
<p class="indenthandingN"><strong>1.</strong> <a id="page_432"/>Exact match, with regular functions outranking templates</p>
<p class="indenthandingN"><strong>2.</strong> Conversion by promotion (for example, the automatic conversions of <code>char</code> and <code>short</code> to <code>int</code> and of <code>float</code> to <code>double</code>)</p>
<p class="indenthandingN"><strong>3.</strong> Conversion by standard conversion (for example, converting <code>int</code> to <code>char</code> or <code>long</code> to <code>double</code>)</p>
<p class="indenthandingN"><strong>4.</strong> User-defined conversions, such as those defined in class declarations</p>
<p>For example, Function #1 is better than Function #2 because <code>char</code>-to-<code>int</code> is a promotion (refer to <a href="ch03.html#ch03">Chapter 3</a>, &#8220;<a href="ch03.html#ch03">Dealing with Data</a>&#8221;), whereas <code>char</code>-to-<code>float</code> is a standard conversion (refer to <a href="ch03.html#ch03">Chapter 3</a>). Functions #3, #5, and #6 are better than either #1 or #2 because they are exact matches. Both #3 and #5 are better than #6 because #6 is a template. This analysis raises a couple questions. What is an exact match? And what happens if you get two of them, such as #3 and #5? Usually, as is the case with this example, two exact matches are an error; but a couple special cases are exceptions to this rule. Clearly, we need to investigate the matter further!</p>
<h5 id="ch08lev3sec11">Exact Matches and Best Matches</h5>
<p>C++ allows some &#8220;trivial conversions&#8221; when making an exact match. <a href="#ch08table01">Table 8.1</a> lists them, with <em><code>Type</code></em> standing for some arbitrary type. For example, an <code>int</code> actual argument is an exact match to an <code>int &#38;</code> formal parameter. Note that <em><code>Type</code></em> can be something like <code>char &#38;</code>, so these rules include converting <code>char &#38;</code> to <code>const char &#38;</code>. The <em><code>Type (argument-list)</code></em> entry means that a function name as an actual argument matches a function pointer as a formal parameter, as long as both have the same return type and argument list. (Remember function pointers from <a href="ch07.html#ch07">Chapter 7</a>. Also recall that you can pass the name of a function as an argument to a function that expects a pointer to a function.) We&#8217;ll discuss the <code>volatile</code> keyword later in <a href="ch09.html#ch09">Chapter 9</a>.</p>
<p class="caption"><a id="ch08table01"/><strong>Table 8.1. Trivial Conversions Allowed for an Exact Match</strong></p>
<p class="image"><img src="graphics/08tab01.jpg" alt="Image"/></p>
<p><a id="page_433"/>Suppose you have the following function code:</p>
<p class="programlisting">struct blot {int a; char b[10];};<br/>blot ink = {25, "spots"};<br/>...<br/>recycle(ink);</p>
<p>In that case, all the following prototypes would be exact matches:</p>
<p class="programlisting">void recycle(blot);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #1&#160;&#160;blot-to-blot<br/>void recycle(const blot);&#160;&#160;&#160;&#160;// #2&#160;&#160;blot-to-(const blot)<br/>void recycle(blot &#38;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #3&#160;&#160;blot-to-(blot &#38;)<br/>void recycle(const blot &#38;);&#160;&#160;// #4&#160;&#160;blot-to-(const blot &#38;)</p>
<p>As you might expect, the result of having several matching prototypes is that the compiler cannot complete the overload resolution process. There is no best viable function, and the compiler generates an error message, probably using words such as <em>ambiguous</em>.</p>
<p>However, sometimes there can be overload resolution even if two functions are an exact match. First, pointers and references to non-<code>const</code> data are preferentially matched to non-<code>const</code> pointer and reference parameters. That is, if only Functions #3 and #4 were available in the <code>recycle()</code> example, #3 would be chosen because <code>ink</code> wasn&#8217;t declared as <code>const</code>. However, this discrimination between <code>const</code> and non-<code>const</code> applies just to data referred to by pointers and references. That is, if only #1 and #2 were available, you would get an ambiguity error.</p>
<p>Another case in which one exact match is better than another is when one function is a non template function and the other isn&#8217;t. In that case, the non template is considered better than a template, including explicit specializations.</p>
<p>If you wind up with two exact matches that both happen to be template functions, the template function that is the more specialized, if either, is the better function. That means, for example, that an explicit specialization is chosen over one generated implicitly from the template pattern:</p>
<p class="programlisting">struct blot {int a; char b[10];};<br/>template &lt;class Type&gt; void recycle (Type t); // template<br/>template &lt;&gt; void recycle&lt;blot&gt; (blot &#38; t);&#160;&#160;&#160;// specialization for blot<br/>...<br/>blot ink = {25, "spots"};<br/>...<br/>recycle(ink);&#160;&#160;// use specialization</p>
<p>The term <em>most specialized</em> doesn&#8217;t necessarily imply an explicit specialization; more generally, it indicates that fewer conversions take place when the compiler deduces what type to use. For example, consider the following two templates:</p>
<p class="programlisting">template &lt;class Type&gt; void recycle (Type t);&#160;&#160;&#160;&#160;// #1<br/>template &lt;class Type&gt; void recycle (Type * t);&#160;&#160;// #2</p>
<p><a id="page_434"/>Suppose the program that contains those templates also contains the following code:</p>
<p class="programlisting">struct blot {int a; char b[10];};<br/>blot ink = {25, "spots"};<br/>...<br/>recycle(&#38;ink);&#160;&#160;// address of a structure</p>
<p>The <code>recycle(&#38;ink)</code> call matches Template #1, with <code>Type</code> interpreted as <code>blot *</code>. The <code>recycle(&#38;ink)</code> function call also matches Template #2, this time with <code>Type</code> being <code>ink</code>. This combination sends two implicit instantiations, <code>recycle&lt;blot *&gt;(blot *)</code> and <code>recycle&lt;blot&gt;(blot *)</code>, to the viable function pool.</p>
<p>Of these two template functions, <code>recycle&lt;blot *&gt;(blot *)</code> is considered the more specialized because it underwent fewer conversions in being generated. That is, Template #2 already explicitly said that the function argument was pointer-to-<em><code>Type</code></em>, so <em><code>Type</code></em> could be directly identified with <code>blot</code>. However, Template #1 had <em><code>Type</code></em> as the function argument, so <em><code>Type</code></em> had to be interpreted as pointer-to-<code>blot</code>. That is, in Template #2, <em><code>Type</code></em> was already specialized as a pointer, hence it is &#8220;more specialized.&#8221;</p>
<p>The rules for finding the most specialized template are called the <em>partial ordering rules</em> for function templates. Like explicit instantiations, they are C++98 additions to the C++ language.</p>
<h5 id="ch08lev3sec12">A Partial Ordering Rules Example</h5>
<p>Let&#8217;s examine a complete program that uses the partial ordering rules for identifying which template definition to use. <a href="#ch08ex14">Listing 8.14</a> has two template definitions for displaying the contents of an array. The first definition (Template A) assumes that the array that is passed as an argument contains the data to be displayed. The second definition (Template B) assumes that the array elements are pointers to the data to be displayed.</p>
<p class="caption1"><a id="ch08ex14"/><strong>Listing 8.14. <code>tempover.cpp</code></strong></p><hr/>
<p class="programlisting1">// tempover.cpp -- template overloading<br/>#include &lt;iostream&gt;<br/><br/>template &lt;typename T&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template A<br/>void ShowArray(T arr[], int n);<br/><br/>template &lt;typename T&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template B<br/>void ShowArray(T * arr[], int n);<br/><br/>struct debts<br/>{<br/>&#160;&#160;&#160;&#160;char name[50];<br/>&#160;&#160;&#160;&#160;double amount;<br/>};<br/><br/>int main()<br/><a id="page_435"/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int things[6] = {13, 31, 103, 301, 310, 130};<br/>&#160;&#160;&#160;&#160;struct debts mr_E[3] =<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{"Ima Wolfe", 2400.0},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{"Ura Foxe", 1300.0},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{"Iby Stout", 1800.0}<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;double * pd[3];<br/><br/>// set pointers to the amount members of the structures in mr_E<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 3; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pd[i] = &#38;mr_E[i].amount;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Listing Mr. E's counts of things:\n";<br/>// things is an array of int<br/>&#160;&#160;&#160;&#160;ShowArray(things, 6);&#160;&#160;// uses template A<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Listing Mr. E's debts:\n";<br/>// pd is an array of pointers to double<br/>&#160;&#160;&#160;&#160;ShowArray(pd, 3);&#160;&#160;&#160;&#160;&#160;&#160;// uses template B (more specialized)<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>template &lt;typename T&gt;<br/>void ShowArray(T arr[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "template A\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; arr[i] &lt;&lt; ' ';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}<br/><br/>template &lt;typename T&gt;<br/>void ShowArray(T * arr[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "template B\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; *arr[i] &lt;&lt; ' ';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}</p><hr/>
<p><a id="page_436"/>Consider this function call:</p>
<p class="programlisting">ShowArray(things, 6);</p>
<p>The identifier <code>things</code> is the name of an array of <code>int</code>, so it matches the following template with <code>T</code> taken to be type <code>int</code>:</p>
<p class="programlisting">template &lt;typename T&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template A<br/>void ShowArray(T arr[], int n);</p>
<p>Next, consider this function call:</p>
<p class="programlisting">ShowArray(pd, 3);</p>
<p>Here, <code>pd</code> is the name of an array of <code>double *</code>. This could be matched by Template A:</p>
<p class="programlisting">template &lt;typename T&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template A<br/>void ShowArray(T arr[], int n);</p>
<p>Here, <code>T</code> would be taken to be type <code>double *</code>. In this case, the template function would display the contents of the <code>pd</code> array: three addresses. The function call could also be matched by Template B:</p>
<p class="programlisting">template &lt;typename T&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template B<br/>void ShowArray(T * arr[], int n);</p>
<p>In this case, <code>T</code> is type <code>double</code>, and the function displays the dereferenced elements <code>*arr[i]</code>&#8212;that is, the <code>double</code> values pointed to by the array contents. Of the two templates, Template B is the more specialized because it makes the specific assumption that the array contents are pointers, so it is the template that gets used.</p>
<p>Here&#8217;s the output of the program in <a href="#ch08ex14">Listing 8.14</a>:</p>
<p class="programlisting">Listing Mr. E's counts of things:<br/>template A<br/>13 31 103 301 310 130<br/>Listing Mr. E's debts:<br/>template B<br/>2400 1300 1800</p>
<p>If you remove Template B from the program, the compiler then uses Template A for listing the contents of <code>pd</code>, so it lists the addresses instead of the values. Try it and see.</p>
<p>In short, the overload resolution process looks for a function that&#8217;s the best match. If there&#8217;s just one, that function is chosen. If more than one are otherwise tied, but only one is a non template function, that non template function is chosen. If more than one candidate are otherwise tied and all are template functions, but one template is more specialized than the rest, that one is chosen. If there are two or more equally good non template functions, or if there are two or more equally good template functions, none of which is more specialized than the rest, the function call is ambiguous and an error. If there are no matching calls, of course, that is also an error.</p>
<h5 id="ch08lev3sec13">Making Your Own Choices</h5>
<p><a id="page_437"/>In some circumstances, you can lead the compiler to make the choice you want by suitably writing the function call. Consider <a href="#ch08ex15">Listing 8.15</a>, which, by the way, eliminates the template prototype and places the template function definition at the top of the file. As with regular functions, a template function definition can act as its own prototype if it appears before the function is used.</p>
<p class="caption1"><a id="ch08ex15"/><strong>Listing 8.15. <code>choices.cpp</code></strong></p><hr/>
<p class="programlisting1">// choices.cpp -- choosing a template<br/>#include &lt;iostream&gt;<br/><br/>template&lt;class T&gt;&#160;&#160;// or template &lt;typename T&gt;<br/>T lesser(T a, T b)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #1<br/>{<br/>&#160;&#160;&#160;&#160;return a &lt; b ? a : b;<br/>}<br/><br/>int lesser (int a, int b)&#160;&#160;// #2<br/>{<br/>&#160;&#160;&#160;&#160;a = a &lt; 0 ? -a : a;<br/>&#160;&#160;&#160;&#160;b = b &lt; 0 ? -b : b;<br/>&#160;&#160;&#160;&#160;return a &lt; b ? a : b;<br/>}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int m = 20;<br/>&#160;&#160;&#160;&#160;int n = -30;<br/>&#160;&#160;&#160;&#160;double x = 15.5;<br/>&#160;&#160;&#160;&#160;double y = 25.9;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; lesser(m, n) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #2<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; lesser(x, y) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #1 with double<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; lesser&lt;&gt;(m, n) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;// use #1 with int<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; lesser&lt;int&gt;(x, y)&#160;&#160;&lt;&lt; endl; // use #1 with int<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>(The final function call converts <code>double</code> to <code>int</code>, and some compilers will issue warnings about that.)</p>
<p><a id="page_438"/>Here is the program output:</p>
<p class="programlisting">20<br/>15.5<br/>-30<br/>15</p>
<p><a href="#ch08ex15">Listing 8.15</a> provides a template that returns the lesser of two values and a standard function that returns the smaller absolute value of two values. If a function definition appears before its first use, the definition acts as a prototype, so this example omits the prototypes. Consider the following statement:</p>
<p class="programlisting">cout &lt;&lt; lesser(m, n) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #2</p>
<p>The function call arguments match both the template function and the non template function, so the non template function is chosen, and it returns the value <code>20</code>.</p>
<p>Next, the function call in the statement matches the template, with type <code>T</code> taken to be <code>double</code>:</p>
<p class="programlisting">cout &lt;&lt; lesser(x, y) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #1 with double</p>
<p>Now consider this statement:</p>
<p class="programlisting">cout &lt;&lt; lesser&lt;&gt;(m, n) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;// use #1 with int</p>
<p>The presence of the angle brackets in <code>lesser&lt;&gt;(m, n)</code> indicates that the compiler should choose a template function rather than a non template function, and the compiler, noting that the actual arguments are type <code>int</code>, instantiates the template using <code>int</code> for <code>T</code>.</p>
<p>Finally, consider this statement:</p>
<p class="programlisting">cout &lt;&lt; lesser&lt;int&gt;(x, y)&#160;&#160;&lt;&lt; endl; // use #1 with int</p>
<p>Here we have a request for an explicit instantiation using <code>int</code> for <code>T</code>, and that&#8217;s the function that gets used. The values of <code>x</code> and <code>y</code> are type cast to type <code>int</code>, and the function returns an <code>int</code> value, which is why the program displays <code>15</code> instead of <code>15.5</code>.</p>
<h5 id="ch08lev3sec14">Functions with Multiple Type Arguments</h5>
<p>Where matters really get involved is when a function call with multiple arguments is matched to prototypes with multiple type arguments. The compiler must look at matches for all the arguments. If it can find a function that is better than all the other viable functions, it is chosen. For one function to be better than another function, it has to provide at least as good a match for all arguments and a better match for at least one argument.</p>
<p>This book does not intend to challenge the matching process with complex examples. The rules are there so that there is a well-defined result for any possible set of function prototypes and templates.</p>
<h4 id="ch08lev2sec16">Template Function Evolution</h4>
<p>In the early days of C++, most people didn&#8217;t envision how powerful and useful template functions and template classes would prove to be. (Probably they didn&#8217;t even expend their <a id="page_439"/>envisionary powers on the topic.) But clever and dedicated programmers pushed the limits of template techniques and expanded the ideas of what was possible. Feedback from those who developed familiarity with templates led to changes that were incorporated into the C++98 Standard as well as the addition of the Standard Template Library. Since then, template programmers have continued to explore the possibilities offered by the genre, and occasionally they bump up against limitations. Their feedback has led to some changes in the C++11 Standard. We&#8217;ll look at a couple of related problems now and their solutions.</p>
<h5 id="ch08lev3sec15">What&#8217;s That Type?</h5>
<p>One problem is that when you write a template function, it&#8217;s not always possible in C++98 to know what type to use in a declaration. Consider this partial example:</p>
<p class="programlisting">template&lt;class T1, class T2&gt;<br/>void ft(T1 x, T2 y)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;?type? xpy = x + y;<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>What should the type for <code>xpy</code> be? We don&#8217;t know in advance how <code>ft()</code> might be used. The proper type might be <code>T1</code> or <code>T2</code> or some other type altogether. For example, <code>T1</code> could be <code>double</code> and <code>T2</code> could be <code>int</code>, in which case the type of the sum is <code>double</code>. Or <code>T1</code> could be <code>short</code> and <code>T2</code> could be <code>int</code>, in which case the type of the sum is <code>int</code>. Or suppose <code>T1</code> is <code>short</code> and <code>T2</code> is <code>char</code>. Then addition invokes automatic integer promotions, and the resultant type is <code>int</code>. Also the <code>+</code> operator can be overloaded for structures and classes, complicating the options further. Therefore, in C++98 there is no obvious choice for the type of <code>xpy</code>.</p>
<h5 id="ch08lev3sec16">The <code>decltype</code> Keyword (C++11)</h5>
<p>The C++11 solution is a new keyword: <code>decltype</code>. It can be used in this way:</p>
<p class="programlisting">int x;<br/>decltype(x) y;&#160;&#160;&#160;// make y the same type as x</p>
<p>The argument to <code>decltype</code> can be an expression, so in the <code>ft()</code> example, we could use this code:</p>
<p class="programlisting">decltype(x + y) xpy;&#160;&#160;// make xpy the same type as x + y<br/>xpy = x + y;</p>
<p>Alternatively, we could combine these two statements into an initialization:</p>
<p class="programlisting">decltype(x + y) xpy = x + y;</p>
<p><a id="page_440"/>So we can fix the <code>ft()</code> template this way:</p>
<p class="programlisting">template&lt;class T1, class T2&gt;<br/>void ft(T1 x, T2 y)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;decltype(x + y) xpy = x + y;<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>The <code>decltype</code> facility is a bit more complex than it might appear from these examples. The compiler has to go through a checklist to decide on the type. Suppose we have the following:</p>
<p class="programlisting">decltype(<span class="EmpItalic">expression</span>) var;</p>
<p>Here&#8217;s a somewhat simplified version of the list.</p>
<p><strong>Stage 1:</strong> If <em><code>expression</code></em> is an unparenthesized identifier (that is, no additional parentheses), then <code>var</code> is of the same type as the identifier, including qualifiers such as <code>const</code>:</p>
<p class="programlisting">double x = 5.5;<br/>double y = 7.9;<br/>double &#38;rx = x;<br/>const double * pd;<br/>decltype(x) w;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// w is type double<br/>decltype(rx) u = y;&#160;&#160;// u is type double &#38;<br/>decltype(pd) v;&#160;&#160;&#160;&#160;&#160;&#160;// v is type const double *</p>
<p><strong>Stage 2:</strong> If <em><code>expression</code></em> is a function call, then <code>var</code> has the type of the function return type:</p>
<p class="programlisting">long indeed(int);<br/>decltype (indeed(3)) m; // m is type int</p>
<div class="note"><hr/>
<p class="title"><a id="ch08note06"/>Note</p>
<p class="notepara">The call <em><code>expression</code></em> isn&#8217;t evaluated. In this case, the compiler examines the prototype to get the return type; there&#8217;s no need to actually call the function.</p>
<hr/></div>
<p><strong>Stage 3:</strong> If <em><code>expression</code></em> is an lvalue, then <code>var</code> is a reference to the expression type. This might seem to imply that earlier examples such as <code>w</code> should have been reference types, given that <code>w</code> is an lvalue. However, keep in mind that case was already captured in Stage 1. For this stage to apply, <em><code>expression</code></em> can&#8217;t be an unparenthesized identifier. So what can it be? One obvious possibility is a parenthesized identifier:</p>
<p class="programlisting">double xx = 4.4;<br/>decltype ((xx)) r2 = xx;&#160;&#160;// r2 is double &#38;<br/>decltype(xx) w = xx;&#160;&#160;&#160;&#160;&#160;&#160;// w is double (Stage 1 match)</p>
<p><a id="page_441"/>Incidentally, parentheses don&#8217;t change the value or lvaluedness of an expression. For example, the following two statements have the same effect:</p>
<p class="programlisting">xx = 98.6;<br/>(xx) = 98.6;&#160;&#160;// () don't affect use of xx</p>
<p><strong>Stage 4:</strong> If none of the preceding special cases apply, <code>var</code> is of the same type as <em><code>expression</code></em>:</p>
<p class="programlisting">int j = 3;<br/>int &#38;k = j<br/>int &#38;n = j;<br/>decltype(j+6) i1;&#160;&#160;&#160;// i1 type int<br/>decltype(100L) i2;&#160;&#160;// i2 type long<br/>decltype(k+n) i3;&#160;&#160;&#160;// i3 type int;</p>
<p>Note that although <code>k</code> and <code>n</code> are references, the expression <code>k+n</code> is not a reference; it&#8217;s just the sum of two <code>int</code>s, hence an <code>int</code>.</p>
<p>If you need more than one declaration, you can use <code>typedef</code> with <code>decltype</code>:</p>
<p class="programlisting">template&lt;class T1, class T2&gt;<br/>void ft(T1 x, T2 y)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;typedef decltype(x + y) xytype;<br/>&#160;&#160;&#160;&#160;xytype xpy = x + y;<br/>&#160;&#160;&#160;&#160;xytype arr[10];<br/>&#160;&#160;&#160;&#160;xytype &#38; rxy = arr[2];&#160;&#160;&#160;// rxy a reference<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<h5 id="ch08lev3sec17">Alternative Function Syntax (C++11 Trailing Return Type)</h5>
<p>The <code>decltype</code> mechanism by itself leaves another related problem unsolved. Consider this incomplete template function:</p>
<p class="programlisting">template&lt;class T1, class T2&gt;<br/>?type? gt(T1 x, T2 y)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;return x + y;<br/>}</p>
<p>Again, we don&#8217;t know in advance what type results from adding <code>x</code> and <code>y</code>. It might seem that we could use <code>decltype(x + y)</code> for the return type. Unfortunately, at that point in the code, the parameters <code>x</code> and <code>y</code> have not yet been declared, so they are not in scope (visible and usable to the compiler). The <code>decltype</code> specifier has to come <em>after</em> the parameters are declared. To make this possible, C++11 allows a new syntax for declaring and defining functions. Here&#8217;s how it works using built-in types. The prototype</p>
<p class="programlisting"><a id="page_442"/>double h(int x, float y);</p>
<p>can be written with this alternative syntax:</p>
<p class="programlisting">auto h(int x, float y) -&gt; double;</p>
<p>This moves the return type to after the parameter declarations. The combination <code>-&gt; double</code> is called a <em>trailing return type</em>. Here, <code>auto,</code> in another new C++11 role, is a placeholder for the type provided by the trailing return type. The same form would be used with the function definition:</p>
<p class="programlisting">auto h(int x, float y) -&gt; double<br/>{/* function body */};</p>
<p>Combining this syntax with <code>decltype</code> leads to the following solution for specifying the return type for <code>gt()</code>:</p>
<p class="programlisting">template&lt;class T1, class T2&gt;<br/>auto gt(T1 x, T2 y) -&gt; decltype(x + y)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;return x + y;<br/>}</p>
<p>Now <code>decltype</code> comes after the parameter declarations, so <code>x</code> and <code>y</code> are in scope and can be used.</p>
<h3 id="ch08lev1sec6">Summary</h3>
<p>C++ has expanded C function capabilities. By using an inline keyword with a function definition and by placing that definition ahead of the first call to that function, you suggest to the C++ compiler that it make the function inline. That is, instead of having the program jump to a separate section of code to execute the function, the compiler replaces the function call with the corresponding code inline. An inline facility should be used only when the function is short.</p>
<p>A reference variable is a kind of disguised pointer that lets you create an alias (that is, a second name) for a variable. Reference variables are primarily used as arguments to functions that process structures and class objects. Normally, an identifier declared as a reference to a particular type can refer only to data of that type. However, when one class is derived from another, such as <code>ofstream</code> from <code>ostream</code>, a reference to the base type may also refer to the derived type.</p>
<p>C++ prototypes enable you to define default values for arguments. If a function call omits the corresponding argument, the program uses the default value. If the function includes an argument value, the program uses that value instead of the default. Default arguments can be provided only from right to left in the argument list. Thus, if you provide a default value for a particular argument, you must also provide default values for all arguments to the right of that argument.</p>
<p><a id="page_443"/>A function&#8217;s signature is its argument list. You can define two functions having the same name, provided that they have different signatures. This is called <em>function polymorphism</em>, or <em>function overloading</em>. Typically, you overload functions to provide essentially the same service to different data types.</p>
<p>Function templates automate the process of overloading functions. You define a function by using a generic type and a particular algorithm, and the compiler generates appropriate function definitions for the particular argument types you use in a program.</p>
<h3 id="ch08lev1sec7">Chapter Review</h3>
<p class="question"><a id="ch08qa1q1" href="app10.html#ch08qa1a1"><strong>1.</strong></a> What kinds of functions are good candidates for inline status?</p>
<p class="question"><a id="ch08qa1q2" href="app10.html#ch08qa1a2"><strong>2.</strong></a> Suppose the <code>song()</code> function has this prototype:</p>
<p class="programlistingB">void song(const char * name, int times);</p>
<p class="indenthandinga"><strong>a.</strong> How would you modify the prototype so that the default value for <code>times</code> is <code>1</code>?</p>
<p class="indenthandinga"><strong>b.</strong> What changes would you make in the function definition?</p>
<p class="indenthandinga"><strong>c.</strong> Can you provide a default value of <code>"O, My Papa"</code> for <code>name</code>?</p>
<p class="question"><a id="ch08qa1q3" href="app10.html#ch08qa1a3"><strong>3.</strong></a> Write overloaded versions of <code>iquote()</code>, a function that displays its argument enclosed in double quotation marks. Write three versions: one for an <code>int</code> argument, one for a <code>double</code> argument, and one for a <code>string</code> argument.</p>
<p class="question"><a id="ch08qa1q4" href="app10.html#ch08qa1a4"><strong>4.</strong></a> The following is a structure template:</p>
<p class="programlistingB">struct box<br/>{<br/>&#160;&#160;&#160;&#160;char maker[40];<br/>&#160;&#160;&#160;&#160;float height;<br/>&#160;&#160;&#160;&#160;float width;<br/>&#160;&#160;&#160;&#160;float length;<br/>&#160;&#160;&#160;&#160;float volume;<br/>};</p>
<p class="indenthandinga"><strong>a.</strong> Write a function that has a reference to a <code>box</code> structure as its formal argument and displays the value of each member.</p>
<p class="indenthandinga"><strong>b.</strong> Write a function that has a reference to a <code>box</code> structure as its formal argument and sets the <code>volume</code> member to the product of the other three dimensions.</p>
<p class="question"><a id="ch08qa1q5" href="app10.html#ch08qa1a5"><strong>5.</strong></a> What changes would need be made to <a href="ch07.html#ch07ex15">Listing 7.15</a> so that the functions <code>fill()</code> and <code>show()</code> use reference parameters?</p>
<p class="question"><a id="page_444"/><a id="ch08qa1q6" href="app10.html#ch08qa1a6"><strong>6.</strong></a> The following are some desired effects. Indicate whether each can be accomplished with default arguments, function overloading, both, or neither. Provide appropriate prototypes.</p>
<p class="indenthandinga"><strong>a.</strong> <code>mass(density, volume)</code> returns the mass of an object having a density of <code>density</code> and a volume of <code>volume</code>, whereas <code>mass(density)</code> returns the mass having a density of <code>density</code> and a volume of 1.0 cubic meters. All quantities are type <code>double</code>.</p>
<p class="indenthandinga"><strong>b.</strong> <code>repeat(10, "I'm OK")</code> displays the indicated string 10 times, and <code>repeat("But you're kind of stupid")</code> displays the indicated string 5 times.</p>
<p class="indenthandinga"><strong>c.</strong> <code>average(3,6)</code> returns the <code>int</code> average of two <code>int</code> arguments, and <code>average(3.0, 6.0)</code> returns the <code>double</code> average of two <code>double</code> values.</p>
<p class="indenthandinga"><strong>d.</strong> <code>mangle("I'm glad to meet you")</code> returns the character <code>I</code> or a pointer to the string <code>"I'm mad to gleet you"</code>, depending on whether you assign the return value to a <code>char</code> variable or to a <code>char*</code> variable.</p>
<p class="question"><a id="ch08qa1q7" href="app10.html#ch08qa1a7"><strong>7.</strong></a> Write a function template that returns the larger of its two arguments.</p>
<p class="question"><a id="ch08qa1q8" href="app10.html#ch08qa1a8"><strong>8.</strong></a> Given the template of Chapter Review Question 7 and the <code>box</code> structure of Chapter Review Question 4, provide a template specialization that takes two <code>box</code> arguments and returns the one with the larger volume.</p>
<p class="question"><a id="ch08qa1q9" href="app10.html#ch08qa1a9"><strong>9.</strong></a> What types are assigned to <code>v1</code>, <code>v2</code>, <code>v3</code>, <code>v4</code>, and <code>v5</code> in the following code (assuming the code is part of a complete program)?</p>
<p class="programlistingB">int g(int x);<br/>...<br/>float m = 5.5f;<br/>float &#38; rm = m;<br/>decltype(m) v1 = m;<br/>decltype(rm) v2 = m;<br/>decltype((m)) v3 = m;<br/>decltype (g(100)) v4;<br/>decltype (2.0 * m) v5;</p>
<h3 id="ch08lev1sec8">Programming Exercises</h3>
<p class="question"><a id="ch08qa2q1"/><strong>1.</strong> Write a function that normally takes one argument, the address of a string, and prints that string once. However, if a second, type <code>int</code>, argument is provided and is nonzero, the function should print the string a number of times equal to the number of times that function has been called at that point. (Note that the number of times the string is printed is not equal to the value of the second argument; it is <a id="page_445"/>equal to the number of times the function has been called.) Yes, this is a silly function, but it makes you use some of the techniques discussed in this chapter. Use the function in a simple program that demonstrates how the function works.</p>
<p class="question"><a id="ch08qa2q2"/><strong>2.</strong> The <code>CandyBar</code> structure contains three members. The first member holds the brand name of a candy bar. The second member holds the weight (which may have a fractional part) of the candy bar, and the third member holds the number of calories (an integer value) in the candy bar. Write a program that uses a function that takes as arguments a reference to <code>CandyBar</code>, a pointer-to-<code>char</code>, a <code>double</code>, and an <code>int</code> and uses the last three values to set the corresponding members of the structure. The last three arguments should have default values of &#8220;Millennium Munch,&#8221; 2.85, and 350. Also the program should use a function that takes a reference to a <code>CandyBar</code> as an argument and displays the contents of the structure. Use <code>const</code> where appropriate.</p>
<p class="question"><a id="ch08qa2q3"/><strong>3.</strong> Write a function that takes a reference to a <code>string</code> object as its parameter and that converts the contents of the <code>string</code> to uppercase. Use the <code>toupper()</code> function described in <a href="ch06.html#ch06table04">Table 6.4</a> of <a href="ch06.html#ch06">Chapter 6</a>. Write a program that uses a loop which allows you to test the function with different input. A sample run might look like this:</p>
<p class="programlistingB">Enter a string (q to quit): <span class="EmpStrong">go away</span><br/>GO AWAY<br/>Next string (q to quit): <span class="EmpStrong">good grief!</span><br/>GOOD GRIEF!<br/>Next string (q to quit): q<br/>Bye.</p>
<p class="question"><a id="ch08qa2q4"/><strong>4.</strong> The following is a program skeleton:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/>#include &lt;cstring&gt;&#160;&#160;&#160;&#160;&#160;&#160;// for strlen(), strcpy()<br/>struct stringy {<br/>&#160;&#160;&#160;&#160;char * str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// points to a string<br/>&#160;&#160;&#160;&#160;int ct;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// length of string (not counting '\0')<br/>&#160;&#160;&#160;&#160;};<br/><br/>// prototypes for set(), show(), and show() go here<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;stringy beany;<br/>&#160;&#160;&#160;&#160;char testing[] = "Reality isn't what it used to be.";<br/><br/>&#160;&#160;&#160;&#160;set(beany, testing);&#160;&#160;&#160;&#160;// first argument is a reference,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// allocates space to hold copy of testing,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// sets str member of beany to point to the<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// new block, copies testing to new block,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// and sets ct member of beany<br/><a id="page_446"/>&#160;&#160;&#160;&#160;show(beany);&#160;&#160;&#160;&#160;&#160;&#160;// prints member string once<br/>&#160;&#160;&#160;&#160;show(beany, 2);&#160;&#160;&#160;// prints member string twice<br/>&#160;&#160;&#160;&#160;testing[0] = 'D';<br/>&#160;&#160;&#160;&#160;testing[1] = 'u';<br/>&#160;&#160;&#160;&#160;show(testing);&#160;&#160;&#160;&#160;// prints testing string once<br/>&#160;&#160;&#160;&#160;show(testing, 3); // prints testing string thrice<br/>&#160;&#160;&#160;&#160;show("Done!");<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="questionp">Complete this skeleton by providing the described functions and prototypes. Note that there should be two <code>show()</code> functions, each using default arguments. Use <code>const</code> arguments when appropriate. Note that <code>set()</code> should use <code>new</code> to allocate sufficient space to hold the designated string. The techniques used here are similar to those used in designing and implementing classes. (You might have to alter the header filenames and delete the <code>using</code> directive, depending on your compiler.)</p>
<p class="question"><a id="ch08qa2q5"/><strong>5.</strong> Write a template function <code>max5()</code> that takes as its argument an array of five items of type <code>T</code> and returns the largest item in the array. (Because the size is fixed, it can be hard-coded into the loop instead of being passed as an argument.) Test it in a program that uses the function with an array of five <code>int</code> value and an array of five <code>double</code> values.</p>
<p class="question"><a id="ch08qa2q6"/><strong>6.</strong> Write a template function <code>maxn()</code> that takes as its arguments an array of items of type <code>T</code> and an integer representing the number of elements in the array and that returns the largest item in the array. Test it in a program that uses the function template with an array of six <code>int</code> value and an array of four <code>double</code> values. The program should also include a specialization that takes an array of pointers-to-<code>char</code> as an argument and the number of pointers as a second argument and that returns the address of the longest string. If multiple strings are tied for having the longest length, the function should return the address of the first one tied for longest. Test the specialization with an array of five string pointers.</p>
<p class="question"><a id="ch08qa2q7"/><strong>7.</strong> Modify <a href="#ch08ex14">Listing 8.14</a> so that it uses two template functions called <code>SumArray()</code> to return the sum of the array contents instead of displaying the contents. The program now should report the total number of things and the sum of all the debts.</p>
</body>
</html>
