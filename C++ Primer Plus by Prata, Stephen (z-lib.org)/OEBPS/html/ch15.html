<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>15. Friends, Exceptions, and More</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch15">15. Friends, Exceptions, and More</h2>
<p><a id="page_877"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Friend classes</p>
<p class="indenthandingB">&#8226; Friend class methods</p>
<p class="indenthandingB">&#8226; Nested classes</p>
<p class="indenthandingB">&#8226; Throwing exceptions, <code>try</code> blocks, and <code>catch</code> blocks</p>
<p class="indenthandingB">&#8226; Exception classes</p>
<p class="indenthandingB">&#8226; Runtime type identification (RTTI)</p>
<p class="indenthandingB">&#8226; <code>dynamic_cast</code> and <code>typeid</code></p>
<p class="indenthandingB">&#8226; <code>static_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code></p>
<p>This chapter ties up some loose ends and ventures into some of the later additions to the C++ language. The loose ends include friend classes, friend member functions, and nested classes, which are classes declared within other classes. The later additions discussed here are exceptions, runtime type identification (RTTI), and improved type cast control. C++ exception handling provides a mechanism for dealing with unusual occurrences that otherwise would bring a program to a halt. RTTI is a mechanism for identifying object types. The new type cast operators improve the safety of type casts. These last three facilities are fairly new to C++, and older compilers do not support them.</p>
<h3 id="ch15lev1sec1">Friends</h3>
<p>Several examples in this book so far use friend functions as part of the extended interface for a class. Such functions are not the only kinds of friends a class can have. A class also can be a friend. In that case, any method of the friend class can access private and protected members of the original class. Also you can be more restrictive and designate just particular member functions of a class to be friends to another class. A class defines which functions, member functions, or classes are friends; friendship cannot be imposed from the outside. Thus, although friends do grant outside access to a class&#8217;s private portion, they <a id="page_878"/>don&#8217;t really violate the spirit of object-oriented programming. Instead, they provide more flexibility to the public interface.</p>
<h4 id="ch15lev2sec1">Friend Classes</h4>
<p>When might you want to make one class a friend to another? Let&#8217;s look at an example. Suppose you must program a simple simulation of a television and a remote control. You decide to define a <code>Tv</code> class representing a television and a <code>Remote</code> class representing a remote control. Clearly, there should be some sort of relationship between these classes, but what kind? A remote control is not a television and vice versa, so the <em>is-a</em> relationship of public inheritance doesn&#8217;t apply. Nor is either a component of the other, so the <em>has-a</em> relationship of containment or of private or protected inheritance doesn&#8217;t apply. What is true is that a remote control can modify the state of a television, and this suggests making the <code>Remote</code> class a friend to the <code>Tv</code> class.</p>
<p>Let&#8217;s define the <code>Tv</code> class. You can represent a television with a set of state members&#8212;that is, variables that describe various aspects of the television. Here are some of the possible states:</p>
<p class="indenthandingB">&#8226; On/off</p>
<p class="indenthandingB">&#8226; Channel setting</p>
<p class="indenthandingB">&#8226; Volume setting</p>
<p class="indenthandingB">&#8226; Cable or antenna tuning mode</p>
<p class="indenthandingB">&#8226; TV tuner or A/V input</p>
<p>The tuning mode reflects the fact that, in the United States, the spacing between channels for channels 14 and up is different for cable reception than it is for UHF broadcast reception. The input selection chooses between TV, which could be either cable or broadcast TV, and a DVD. Some sets may offer more choices, such as multiple DVD/Bluray inputs, but this list is enough for the purposes of this example.</p>
<p>Also a television has some parameters that aren&#8217;t state variables. For example, televisions vary in the number of channels they can receive, and you can include a member to track that value.</p>
<p>Next, you must provide the class with methods for altering the settings. Many television sets these days hide their controls behind panels, but it&#8217;s still possible with most televisions to change channels, and so on, without a remote control. However, often you can go up or down one channel at a time but can&#8217;t select a channel at random. Similarly, there&#8217;s usually a button for increasing the volume and one for decreasing the volume.</p>
<p>A remote control should duplicate the controls built in to the television. Many of its methods can be implemented by using <code>Tv</code> methods. In addition, a remote control typically provides random access channel selection. That is, you can go directly from channel 2 to channel 20 without going through all the intervening channels. Also many remotes can work in two or more modes, for example, as a television controller and as a DVD controller.</p>
<p><a id="page_879"/>These considerations suggest a definition like that shown in <a href="#ch15ex01">Listing 15.1</a>. The definition includes several constants defined as enumerations. The following statement makes <code>Remote</code> a friend class:</p>
<p class="programlisting">friend class Remote;</p>
<p>A friend declaration can appear in a public, private, or protected section; the location makes no difference. Because the <code>Remote</code> class mentions the <code>Tv</code> class, the compiler has to know about the <code>Tv</code> class before it can handle the <code>Remote</code> class. The simplest way to accomplish this is to define the <code>Tv</code> class first. Alternatively, you can use a forward declaration; we&#8217;ll discuss that option soon.</p>
<p class="caption1"><a id="ch15ex01"/><strong>Listing 15.1. <code>tv.h</code></strong></p><hr/>
<p class="programlisting1">// tv.h -- Tv and Remote classes<br/>#ifndef TV_H_<br/>#define TV_H_<br/><br/>class Tv<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;friend class Remote;&#160;&#160;&#160;// Remote can access Tv private parts<br/>&#160;&#160;&#160;&#160;enum {Off, On};<br/>&#160;&#160;&#160;&#160;enum {MinVal,MaxVal = 20};<br/>&#160;&#160;&#160;&#160;enum {Antenna, Cable};<br/>&#160;&#160;&#160;&#160;enum {TV, DVD};<br/><br/>&#160;&#160;&#160;&#160;Tv(int s = Off, int mc = 125) : state(s), volume(5),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxchannel(mc), channel(2), mode(Cable), input(TV) {}<br/>&#160;&#160;&#160;&#160;void onoff() {state = (state == On)? Off : On;}<br/>&#160;&#160;&#160;&#160;bool ison() const {return state == On;}<br/>&#160;&#160;&#160;&#160;bool volup();<br/>&#160;&#160;&#160;&#160;bool voldown();<br/>&#160;&#160;&#160;&#160;void chanup();<br/>&#160;&#160;&#160;&#160;void chandown();<br/>&#160;&#160;&#160;&#160;void set_mode() {mode = (mode == Antenna)? Cable : Antenna;}<br/>&#160;&#160;&#160;&#160;void set_input() {input = (input == TV)? DVD : TV;}<br/>&#160;&#160;&#160;&#160;void settings() const; // display all settings<br/>private:<br/>&#160;&#160;&#160;&#160;int state;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// on or off<br/>&#160;&#160;&#160;&#160;int volume;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assumed to be digitized<br/>&#160;&#160;&#160;&#160;int maxchannel;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// maximum number of channels<br/>&#160;&#160;&#160;&#160;int channel;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// current channel setting<br/>&#160;&#160;&#160;&#160;int mode;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// broadcast or cable<br/>&#160;&#160;&#160;&#160;int input;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// TV or DVD<br/>};<br/><br/>class Remote<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int mode;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// controls TV or DVD<br/>public:<br/>&#160;&#160;&#160;&#160;Remote(int m = Tv::TV) : mode(m) {}<br/>&#160;&#160;&#160;&#160;bool volup(Tv &#38; t) { return t.volup();}<br/>&#160;&#160;&#160;&#160;bool voldown(Tv &#38; t) { return t.voldown();}<br/>&#160;&#160;&#160;&#160;void onoff(Tv &#38; t) { t.onoff(); }<br/>&#160;&#160;&#160;&#160;void chanup(Tv &#38; t) {t.chanup();}<br/>&#160;&#160;&#160;&#160;void chandown(Tv &#38; t) {t.chandown();}<br/>&#160;&#160;&#160;&#160;void set_chan(Tv &#38; t, int c) {t.channel = c;}<br/>&#160;&#160;&#160;&#160;void set_mode(Tv &#38; t) {t.set_mode();}<br/>&#160;&#160;&#160;&#160;void set_input(Tv &#38; t) {t.set_input();}<br/>};<br/>&#160;#endif</p><hr/>
<p><a id="page_880"/>Most of the class methods in <a href="#ch15ex01">Listing 15.1</a> are defined inline. Note that each <code>Remote</code> method other than the constructor takes a reference to a <code>Tv</code> object as an argument. This reflects that a remote has to be aimed at a particular TV. <a href="#ch15ex02">Listing 15.2</a> shows the remaining definitions. The volume-setting functions change the volume member by one unit unless the sound has reached its minimum or maximum setting. The channel selection functions use wraparound, with the lowest channel setting, taken to be 1, immediately following the highest channel setting, <code>maxchannel</code>.</p>
<p>Many of the methods use the conditional operator to toggle a state between two settings:</p>
<p class="programlisting">void onoff() {state = (state == On)? Off : On;}</p>
<p>Provided that the two state values are <code>true</code> and <code>false</code>, or, equivalently, <code>0</code> and <code>1</code>, this can be done more compactly by using the combined bitwise exclusive OR and assignment operator (<code>^=</code>), as discussed in <a href="app05.html#app05">Appendix E</a>, &#8220;<a href="app05.html#app05">Other Operators</a>&#8221;:</p>
<p class="programlisting">void onoff() {state ^= 1;}</p>
<p>In fact, you could store up to eight bivalent state settings in a single unsigned <code>char</code> variable and toggle them individually, but that&#8217;s another story, one made possible by the bitwise operators discussed in <a href="app05.html#app05">Appendix E</a>.</p>
<p class="caption1"><a id="ch15ex02"/><strong>Listing 15.2. <code>tv.cpp</code></strong></p><hr/>
<p class="programlisting1">// tv.cpp -- methods for the Tv class (Remote methods are inline)<br/>#include &lt;iostream&gt;<br/>#include "tv.h"<br/><br/>bool Tv::volup()<br/>{<br/><a id="page_881"/>&#160;&#160;&#160;&#160;if (volume &lt; MaxVal)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;volume++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/>bool Tv::voldown()<br/>{<br/>&#160;&#160;&#160;&#160;if (volume &gt; MinVal)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;volume--;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/><br/>void Tv::chanup()<br/>{<br/>&#160;&#160;&#160;&#160;if (channel &lt; maxchannel)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;channel++;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;channel = 1;<br/>}<br/><br/>void Tv::chandown()<br/>{<br/>&#160;&#160;&#160;&#160;if (channel &gt; 1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;channel--;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;channel = maxchannel;<br/>}<br/><br/>void Tv::settings() const<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "TV is " &lt;&lt; (state == Off? "Off" : "On") &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;if (state == On)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Volume setting = " &lt;&lt; volume &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Channel setting = " &lt;&lt; channel &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Mode = "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; (mode == Antenna? "antenna" : "cable") &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Input = "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; (input == TV? "TV" : "DVD") &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>}</p><hr/>
<p><a id="page_882"/><a href="#ch15ex03">Listing 15.3</a> is a short program that tests some of the features of the program so far. The same controller is used to control two separate televisions.</p>
<p class="caption1"><a id="ch15ex03"/><strong>Listing 15.3. <code>use_tv.cpp</code></strong></p><hr/>
<p class="programlisting1">//use_tv.cpp -- using the Tv and Remote classes<br/>#include &lt;iostream&gt;<br/>#include "tv.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;Tv s42;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Initial settings for 42\" TV:\n";<br/>&#160;&#160;&#160;&#160;s42.settings();<br/>&#160;&#160;&#160;&#160;s42.onoff();<br/>&#160;&#160;&#160;&#160;s42.chanup();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nAdjusted settings for 42\" TV:\n";<br/>&#160;&#160;&#160;&#160;s42.settings();<br/><br/>&#160;&#160;&#160;&#160;Remote grey;<br/><br/>&#160;&#160;&#160;&#160;grey.set_chan(s42, 10);<br/>&#160;&#160;&#160;&#160;grey.volup(s42);<br/>&#160;&#160;&#160;&#160;grey.volup(s42);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\n42\" settings after using remote:\n";<br/>&#160;&#160;&#160;&#160;s42.settings();<br/><br/>&#160;&#160;&#160;&#160;Tv s58(Tv::On);<br/>&#160;&#160;&#160;&#160;s58.set_mode();<br/>&#160;&#160;&#160;&#160;grey.set_chan(s58,28);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\n58\" settings:\n";<br/>&#160;&#160;&#160;&#160;s58.settings();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch15ex01">Listings 15.1</a>, <a href="#ch15ex02">15.2</a>, and <a href="#ch15ex03">15.3</a>:</p>
<p class="programlisting">Initial settings for 42" TV:<br/>TV is Off<br/><br/><a id="page_883"/>Adjusted settings for 42" TV:<br/>TV is On<br/>Volume setting = 5<br/>Channel setting = 3<br/>Mode = cable<br/>Input = TV<br/><br/>42" settings after using remote:<br/>TV is On<br/>Volume setting = 7<br/>Channel setting = 10<br/>Mode = cable<br/>Input = TV<br/><br/>58" settings:<br/>TV is On<br/>Volume setting = 5<br/>Channel setting = 28<br/>Mode = antenna<br/>Input = TV</p>
<p>The main point to this exercise is that class friendship is a natural idiom in which to express some relationships. Without some form of friendship, you would either have to make the private parts of the <code>Tv</code> class public or else construct some awkward, larger class that encompasses both a television and a remote control. And that solution wouldn&#8217;t reflect the fact that a single remote control can be used with several televisions.</p>
<h4 id="ch15lev2sec2">Friend Member Functions</h4>
<p>Looking at the code for the last example, you may notice that most of the <code>Remote</code> methods are implemented by using the public interface for the <code>Tv</code> class. This means that those methods don&#8217;t really need friend status. Indeed, the only <code>Remote</code> method that accesses a private <code>Tv</code> member directly is <code>Remote::set_chan()</code>, so that&#8217;s the only method that needs to be a friend. You do have the option of making just selected class members friends to another class rather than making the entire class a friend, but that&#8217;s a bit more awkward. You need to be careful about the order in which you arrange the various declarations and definitions. Let&#8217;s look at why.</p>
<p>The way to make <code>Remote::set_chan()</code> a friend to the <code>Tv</code> class is to declare it as a friend in the <code>Tv</code> class declaration:</p>
<p class="programlisting">class Tv<br/>{<br/>&#160;&#160;&#160;&#160;friend void Remote::set_chan(Tv &#38; t, int c);<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p><a id="page_884"/>However, for the compiler to process this statement, it needs to have already seen the <code>Remote</code> definition. Otherwise, it won&#8217;t know that <code>Remote</code> is a class and that <code>set_chan()</code> is a method of that class. This suggests putting the <code>Remote</code> definition above the <code>Tv</code> definition. But the fact that <code>Remote</code> methods mention <code>Tv</code> objects means that the <code>Tv</code> definition should appear above the <code>Remote</code> definition. Part of the way around the circular dependence is to use a <em>forward declaration</em>. To do so, you insert the following statement above the <code>Remote</code> definition:</p>
<p class="programlisting">class Tv;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// forward declaration</p>
<p>This provides the following arrangement:</p>
<p class="programlisting">class Tv;&#160;&#160;// forward declaration<br/>class Remote { ... };<br/>class Tv { ... };</p>
<p>Could you use the following arrangement instead?</p>
<p class="programlisting">class Remote;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// forward declaration<br/>class Tv { ... };<br/>class Remote { ... };</p>
<p>The answer is no. The reason, as mentioned earlier, is that when the compiler sees that a <code>Remote</code> method is declared as a friend in the <code>Tv</code> class declaration, the compiler needs to have already viewed the declaration of the <code>Remote</code> class in general and of the <code>set_chan()</code> method in particular.</p>
<p>Another difficulty remains. In <a href="#ch15ex01">Listing 15.1</a>, the <code>Remote</code> declaration contains inline code such as the following:</p>
<p class="programlisting">void onoff(Tv &#38; t) { t.onoff(); }</p>
<p>Because this calls a <code>Tv</code> method, the compiler needs to have seen the <code>Tv</code> class declaration at this point so that it knows what methods <code>Tv</code> has. But as you&#8217;ve seen, that declaration necessarily follows the <code>Remote</code> declaration. The solution to this problem is to restrict <code>Remote</code> to method <em>declarations</em> and to place the actual <em>definitions</em> after the <code>Tv</code> class. This leads to the following ordering:</p>
<p class="programlisting">class Tv;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// forward declaration<br/>class Remote { ... };&#160;&#160;&#160;&#160;&#160;// Tv-using methods as prototypes only<br/>class Tv { ... };<br/>// put Remote method definitions here</p>
<p>The <code>Remote</code> prototypes look like this:</p>
<p class="programlisting">void onoff(Tv &#38; t);</p>
<p>All the compiler needs to know when inspecting this prototype is that <code>Tv</code> is a class, and the forward declaration supplies that information. By the time the compiler reaches the actual method definitions, it has already read the <code>Tv</code> class declaration and has the added information needed to compile those methods. By using the <code>inline</code> keyword in the <a id="page_885"/>method definitions, you can still make the methods inline methods. <a href="#ch15ex04">Listing 15.4</a> shows the revised header file.</p>
<p class="caption1"><a id="ch15ex04"/><strong>Listing 15.4. <code>tvfm.h</code></strong></p><hr/>
<p class="programlisting1">// tvfm.h -- Tv and Remote classes using a friend member<br/>#ifndef TVFM_H_<br/>#define TVFM_H_<br/><br/>class Tv;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// forward declaration<br/><br/>class Remote<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;enum State{Off, On};<br/>&#160;&#160;&#160;&#160;enum {MinVal,MaxVal = 20};<br/>&#160;&#160;&#160;&#160;enum {Antenna, Cable};<br/>&#160;&#160;&#160;&#160;enum {TV, DVD};<br/>private:<br/>&#160;&#160;&#160;&#160;int mode;<br/>public:<br/>&#160;&#160;&#160;&#160;Remote(int m = TV) : mode(m) {}<br/>&#160;&#160;&#160;&#160;bool volup(Tv &#38; t);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prototype only<br/>&#160;&#160;&#160;&#160;bool voldown(Tv &#38; t);<br/>&#160;&#160;&#160;&#160;void onoff(Tv &#38; t) ;<br/>&#160;&#160;&#160;&#160;void chanup(Tv &#38; t) ;<br/>&#160;&#160;&#160;&#160;void chandown(Tv &#38; t) ;<br/>&#160;&#160;&#160;&#160;void set_mode(Tv &#38; t) ;<br/>&#160;&#160;&#160;&#160;void set_input(Tv &#38; t);<br/>&#160;&#160;&#160;&#160;void set_chan(Tv &#38; t, int c);<br/><br/>};<br/><br/>class Tv<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;friend void Remote::set_chan(Tv &#38; t, int c);<br/>&#160;&#160;&#160;&#160;enum State{Off, On};<br/>&#160;&#160;&#160;&#160;enum {MinVal,MaxVal = 20};<br/>&#160;&#160;&#160;&#160;enum {Antenna, Cable};<br/>&#160;&#160;&#160;&#160;enum {TV, DVD};<br/><br/>&#160;&#160;&#160;&#160;Tv(int s = Off, int mc = 125) : state(s), volume(5),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxchannel(mc), channel(2), mode(Cable), input(TV) {}<br/>&#160;&#160;&#160;&#160;void onoff() {state = (state == On)? Off : On;}<br/>&#160;&#160;&#160;&#160;bool ison() const {return state == On;}<br/>&#160;&#160;&#160;&#160;bool volup();<br/>&#160;&#160;&#160;&#160;bool voldown();<br/>&#160;&#160;&#160;&#160;void chanup();<br/>&#160;&#160;&#160;&#160;void chandown();<br/>&#160;&#160;&#160;&#160;void set_mode() {mode = (mode == Antenna)? Cable : Antenna;}<br/>&#160;&#160;&#160;&#160;void set_input() {input = (input == TV)? DVD : TV;}<br/>&#160;&#160;&#160;&#160;void settings() const;<br/>private:<br/>&#160;&#160;&#160;&#160;int state;<br/>&#160;&#160;&#160;&#160;int volume;<br/>&#160;&#160;&#160;&#160;int maxchannel;<br/>&#160;&#160;&#160;&#160;int channel;<br/>&#160;&#160;&#160;&#160;int mode;<br/>&#160;&#160;&#160;&#160;int input;<br/>};<br/><br/>// Remote methods as inline functions<br/>inline bool Remote::volup(Tv &#38; t) { return t.volup();}<br/>inline bool Remote::voldown(Tv &#38; t) { return t.voldown();}<br/>inline void Remote::onoff(Tv &#38; t) { t.onoff(); }<br/>inline void Remote::chanup(Tv &#38; t) {t.chanup();}<br/>inline void Remote::chandown(Tv &#38; t) {t.chandown();}<br/>inline void Remote::set_mode(Tv &#38; t) {t.set_mode();}<br/>inline void Remote::set_input(Tv &#38; t) {t.set_input();}<br/>inline void Remote::set_chan(Tv &#38; t, int c) {t.channel = c;}<br/>&#160;#endif</p><hr/>
<p><a id="page_886"/>If you include <code>tvfm.h</code> instead of <code>tv.h</code> in <code>tv.cpp</code> and <code>use_tv.cpp</code>, the resulting program behaves the same as the original. The difference is that just one <code>Remote</code> method&#8212;instead of all the <code>Remote</code> methods&#8212;is a friend to the <code>Tv</code> class. <a href="#ch15fig01">Figure 15.1</a> illustrates this difference.</p>
<p class="caption"><a id="ch15fig01"/><strong>Figure 15.1. Class friends versus class member friends.</strong></p>
<p class="image"><img src="graphics/15fig01.jpg" alt="Image"/></p>
<p>Recall that inline functions have internal linkage, which means the function definition must be in the file that uses the function. Here, the inline definitions are in the header file, so including the header file in the file that uses the definitions places the definition in the right place. You could place the definitions in the implementation file instead, provided that you remove the <code>inline</code> keyword, thus giving the functions external linkage.</p>
<p>By the way, making the entire <code>Remote</code> class a friend doesn&#8217;t need a forward declaration because the friend statement itself identifies <code>Remote</code> as a class:</p>
<p class="programlisting">friend class Remote;</p>
<h4 id="ch15lev2sec3">Other Friendly Relationships</h4>
<p>Other combinations of friends and classes besides the ones discussed so far in this chapter are possible. Let&#8217;s take a brief look at some of them now.</p>
<p><a id="page_887"/>Suppose the advance of technology brings interactive remote controls. For example, an interactive remote control unit might let you enter a response to some question posed on a television program, and the television might activate a buzzer in your remote control if your response is wrong. Ignoring the possibility of television using such facilities to program the viewers, let&#8217;s just look at the C++ programming aspects. The new setup would benefit from mutual friendship, with some <code>Remote</code> methods being able to affect a <code>Tv</code> <a id="page_888"/>object, as before, and with some <code>Tv</code> methods being able to affect a <code>Remote</code> object. This can be accomplished by making the classes friends to each other. That is, <code>Tv</code> will be a friend to <code>Remote</code> in addition to <code>Remote</code> being a friend to <code>Tv</code>. One point to keep in mind is that a <code>Tv</code> method that uses a <code>Remote</code> object can be prototyped <em>before</em> the <code>Remote</code> class declaration but must be defined <em>after</em> the declaration so that the compiler will have enough information to compile the method. The setup would look like this:</p>
<p class="programlistingB">class Tv<br/>{<br/>friend class Remote;<br/>public:<br/>&#160;&#160;&#160;&#160;void buzz(Remote &#38; r);<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>class Remote<br/>{<br/>friend class Tv;<br/>public:<br/>&#160;&#160;&#160;&#160;void Bool volup(Tv &#38; t) { t.volup(); }<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>inline void Tv::buzz(Remote &#38; r)<br/>{<br/>&#160;&#160;&#160;...<br/>}</p>
<p>Because the <code>Remote</code> declaration follows the <code>Tv</code> declaration, <code>Remote::volup()</code> can be defined in the class declaration. However, the <code>Tv::buzz()</code> method has to be defined outside the <code>Tv</code> declaration so that the definition can follow the <code>Remote</code> declaration. If you don&#8217;t want <code>buzz()</code> to be inline, you need to define it in a separate method definitions file.</p>
<h4 id="ch15lev2sec4">Shared Friends</h4>
<p>Another use for friends is when a function needs to access private data in two separate classes. Logically, such a function should be a member function of each class, but that&#8217;s impossible. It could be a member of one class and a friend to the other, but sometimes it&#8217;s more reasonable to make the function a friend to both. Suppose, for example, that you have a <code>Probe</code> class that represents some sort of programmable measuring device and an <code>Analyzer</code> class that represents some sort of programmable analyzing device. Each has an internal clock, and you would like to be able to synchronize the two clocks. You could use something along the following lines:</p>
<p class="programlisting">class Analyzer;&#160;&#160;// forward declaration<br/>class Probe<br/>{<br/>&#160;&#160;&#160;&#160;friend void sync(Analyzer &#38; a, const Probe &#38; p);&#160;&#160;// sync a to p<br/>&#160;&#160;&#160;&#160;friend void sync(Probe &#38; p, const Analyzer &#38; a);&#160;&#160;// sync p to a<br/>&#160;&#160;&#160;&#160;...<br/><a id="page_889"/>};<br/>class Analyzer<br/>{<br/>&#160;&#160;&#160;&#160;friend void sync(Analyzer &#38; a, const Probe &#38; p);&#160;&#160;// sync a to p<br/>&#160;&#160;&#160;&#160;friend void sync(Probe &#38; p, const Analyzer &#38; a);&#160;&#160;// sync p to a<br/>&#160;&#160;&#160;&#160;...<br/>};<br/><br/>// define the friend functions<br/>inline void sync(Analyzer &#38; a, const Probe &#38; p)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}<br/>inline void sync(Probe &#38; p, const Analyzer &#38; a)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>The forward declaration enables the compiler to know that <code>Analyzer</code> is a type when it reaches the friend declarations in the <code>Probe</code> class declaration.</p>
<h3 id="ch15lev1sec2">Nested Classes</h3>
<p>In C++, you can place a class declaration inside another class. The class declared within another is called a <em>nested class</em>, and it helps avoid name clutter by giving the new type class scope. Member functions of the class containing the declaration can create and use objects of the nested class. The outside world can use the nested class only if the declaration is in the public section and if you use the scope-resolution operator. (Older versions of C++ either don&#8217;t allow nested classes or implement the concept incompletely.)</p>
<p>Nesting classes is not the same as containment. Recall that containment means having a class object as a member of another class. Nesting a class, on the other hand, does not create a class member. Instead, it defines a type that is known just locally to the class that contains the nested class declaration.</p>
<p>The usual reasons for nesting a class are to assist in the implementation of another class and to avoid name conflicts. The <code>Queue</code> class example in <a href="ch12.html#ch12ex10">Listing 12.10</a> in <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; provides a disguised case of nested classes by nesting a structure definition:</p>
<p class="programlisting">class Queue<br/>{<br/>private:<br/>// class scope definitions<br/>&#160;&#160;&#160;&#160;// Node is a nested structure definition local to this class<br/>&#160;&#160;&#160;&#160;struct Node {Item item; struct Node * next;};<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p><a id="page_890"/>Because a structure is a class whose members are public by default, <code>Node</code> really is a nested class. However, this definition doesn&#8217;t take advantage of class abilities. In particular, it lacks an explicit constructor. Let&#8217;s remedy that now.</p>
<p>First, you need to find where <code>Node</code> objects are created in the <code>Queue</code> example. Examining the class declaration (see <a href="ch12.html#ch12ex10">Listing 12.10</a>) and the methods definitions (see <a href="ch12.html#ch12ex11">Listing 12.11</a>) reveals that the only place in which <code>Node</code> objects are created is in the <code>enqueue()</code> method:</p>
<p class="programlisting">bool Queue::enqueue(const Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;Node * add = new Node;&#160;&#160;// create node<br/>// on failure, new throws std::bad_alloc exception<br/>&#160;&#160;&#160;&#160;add-&gt;item = item;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set node pointers<br/>&#160;&#160;&#160;&#160;add-&gt;next = NULL;<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>This code explicitly assigns values to the <code>Node</code> members after creating a <code>Node</code>. This is the sort of work that is more properly done by a constructor.</p>
<p>Knowing now where and how a constructor should be used, you can provide an appropriate constructor definition:</p>
<p class="programlisting">class Queue<br/>{<br/>// class scope definitions<br/>&#160;&#160;&#160;&#160;// Node is a nested class definition local to this class<br/>&#160;&#160;&#160;&#160;class Node<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Item item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node * next;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node(const Item &#38; i) : item(i), next(0) { }<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>This constructor initializes the node&#8217;s <code>item</code> member to <code>i</code> and sets the <code>next</code> pointer to <code>0</code>, which is one way of writing the null pointer in C++. (Using <code>NULL</code> would require including a header file that defines <code>NULL</code>. Users of a C++11-compliant compiler can use <code>nullptr</code>.) Because all nodes created by the <code>Queue</code> class have <code>next</code> initially set to the null pointer, this is the only constructor the class needs.</p>
<p>Next, you need to rewrite <code>enqueue()</code> by using the constructor</p>
<p class="programlisting">bool Queue::enqueue(const Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/><a id="page_891"/>&#160;&#160;&#160;&#160;Node * add = new Node(item);&#160;&#160;// create, initialize node<br/>// on failure, new throws std::bad_alloc exception<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>This makes the code for <code>enqueue()</code> a bit shorter and a bit safer because it automates initialization rather than requiring the programmer to correctly remember what should be done.</p>
<p>This example defines the constructor in the class declaration. Suppose you wanted to define it in a methods file, instead. In that case, the definition must reflect that the <code>Node</code> class is defined within the <code>Queue</code> class. This is accomplished by using the scope-resolution operator twice:</p>
<p class="programlisting">Queue::Node::Node(const Item &#38; i) : item(i), next(0) { }</p>
<h4 id="ch15lev2sec5">Nested Classes and Access</h4>
<p>Two kinds of access pertain to nested classes. First, where a nested class is declared controls the scope of the nested class; that is, it establishes which parts of a program can create objects of that class. Second, as with any class, the public, protected, and private sections of a nested class provide access control to class members. Where and how a nested class can be used depends on both scope and access control. Let&#8217;s examine these points further.</p>
<h5 id="ch15lev3sec1">Scope</h5>
<p>If a nested class is declared in a private section of a second class, it is known only to that second class. This applies, for example, to the <code>Node</code> class nested in the <code>Queue</code> declaration in the preceding example. Hence, <code>Queue</code> members can use <code>Node</code> objects and pointers to <code>Node</code> objects, but other parts of a program don&#8217;t even know that the <code>Node</code> class exists. If you were to derive a class from <code>Queue</code>, <code>Node</code> would be invisible to that class, too, because a derived class can&#8217;t directly access the private parts of a base class.</p>
<p>If the nested class is declared in a protected section of a second class, it is visible to that class but invisible to the outside world. However, in this case, a derived class would know about the nested class and could directly create objects of that type.</p>
<p>If a nested class is declared in a public section of a second class, it is available to the second class, to classes derived from the second class, and, because it&#8217;s public, to the outside world. However, because the nested class has class scope, it has to be used with a class qualifier in the outside world. For example, suppose you have this declaration:</p>
<p class="programlisting">class Team<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;class Coach { ... };<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};</p>
<p><a id="page_892"/>Now suppose you have an unemployed coach, one who belongs to no team. To create a <code>Coach</code> object outside the <code>Team</code> class, you can use this:</p>
<p class="programlisting">Team::Coach forhire;&#160;&#160;// create a Coach object outside the Team class</p>
<p>These same scope considerations apply to nested structures and enumerations, too. Indeed, many programmers use public enumerations to provide class constants that can be used by client programmers. For example, the many implementations of classes defined to support the <code>iostream</code> facility use this technique to provide various formatting options, as you&#8217;ve already seen (and will explore more fully in <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>&#8221;). <a href="#ch15table01">Table 15.1</a> summarizes scope properties for nested classes, structures, and enumerations.</p>
<p class="caption"><a id="ch15table01"/><strong>Table 15.1. Scope Properties for Nested Classes, Structures, and Enumerations</strong></p>
<p class="image"><img src="graphics/15tab01.jpg" alt="Image"/></p>
<h5 id="ch15lev3sec2">Access Control</h5>
<p>After a class is in scope, access control comes into play. The same rules govern access to a nested class that govern access to a regular class. Declaring the <code>Node</code> class in the <code>Queue</code> class declaration does not grant the <code>Queue</code> class any special access privileges to the <code>Node</code> class, nor does it grant the <code>Node</code> class any special access privileges to the <code>Queue</code> class. Thus, a <code>Queue</code> class object can access only the public members of a <code>Node</code> object explicitly. For that reason, the <code>Queue</code> example makes all the members of the <code>Node</code> class public. This violates the usual practice of making data members private, but the <code>Node</code> class is an internal implementation feature of the <code>Queue</code> class and is not visible to the outside world. That&#8217;s because the <code>Node</code> class is declared in the private section of the <code>Queue</code> class. Thus, although <code>Queue</code> methods can access <code>Node</code> members directly, a client using the <code>Queue</code> class cannot do so.</p>
<p>In short, the location of a class declaration determines the scope or visibility of a class. Given that a particular class is in scope, the usual access control rules (public, protected, private, friend) determine the access a program has to members of the nested class.</p>
<h4 id="ch15lev2sec6">Nesting in a Template</h4>
<p>You&#8217;ve seen that templates are a good choice for implementing container classes such as the <code>Queue</code> class. You may be wondering whether having a nested class poses any problems to converting the <code>Queue</code> class definition to a template. The answer is no. <a href="#ch15ex05">Listing 15.5</a> <a id="page_893"/>shows how this conversion can be made. As is common for class templates, the header file includes the class template, along with method function templates.</p>
<p class="caption1"><a id="ch15ex05"/><strong>Listing 15.5. <code>queuetp.h</code></strong></p><hr/>
<p class="programlisting1">// queuetp.h -- queue template with a nested class<br/>#ifndef QUEUETP_H_<br/>#define QUEUETP_H_<br/><br/>template &lt;class Item&gt;<br/>class QueueTP<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {Q_SIZE = 10};<br/>&#160;&#160;&#160;&#160;// Node is a nested class definition<br/>&#160;&#160;&#160;&#160;class Node<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Item item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node * next;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node(const Item &#38; i):item(i), next(0){ }<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;Node * front;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to front of Queue<br/>&#160;&#160;&#160;&#160;Node * rear;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to rear of Queue<br/>&#160;&#160;&#160;&#160;int items;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// current number of items in Queue<br/>&#160;&#160;&#160;&#160;const int qsize;&#160;&#160;&#160;&#160;// maximum number of items in Queue<br/>&#160;&#160;&#160;&#160;QueueTP(const QueueTP &#38; q) : qsize(0) {}<br/>&#160;&#160;&#160;&#160;QueueTP &#38; operator=(const QueueTP &#38; q) { return *this; }<br/>public:<br/>&#160;&#160;&#160;&#160;QueueTP(int qs = Q_SIZE);<br/>&#160;&#160;&#160;&#160;~QueueTP();<br/>&#160;&#160;&#160;&#160;bool isempty() const<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return items == 0;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;bool isfull() const<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return items == qsize;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;int queuecount() const<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return items;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;bool enqueue(const Item &#38;item); // add item to end<br/>&#160;&#160;&#160;&#160;bool dequeue(Item &#38;item);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// remove item from front<br/>};<br/><br/><a id="page_894"/>// QueueTP methods<br/>template &lt;class Item&gt;<br/>QueueTP&lt;Item&gt;::QueueTP(int qs) : qsize(qs)<br/>{<br/>&#160;&#160;&#160;&#160;front = rear = 0;<br/>&#160;&#160;&#160;&#160;items = 0;<br/>}<br/><br/>template &lt;class Item&gt;<br/>QueueTP&lt;Item&gt;::~QueueTP()<br/>{<br/>&#160;&#160;&#160;&#160;Node * temp;<br/>&#160;&#160;&#160;&#160;while (front != 0)&#160;&#160;&#160;&#160;&#160;&#160;// while queue is not yet empty<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp = front;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// save address of front item<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;front = front-&gt;next;// reset pointer to next item<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// delete former front<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>// Add item to queue<br/>template &lt;class Item&gt;<br/>bool QueueTP&lt;Item&gt;::enqueue(const Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;Node * add = new Node(item);&#160;&#160;&#160;&#160;// create node<br/>// on failure, new throws std::bad_alloc exception<br/>&#160;&#160;&#160;&#160;items++;<br/>&#160;&#160;&#160;&#160;if (front == 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// if queue is empty,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;front = add;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// place item at front<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rear-&gt;next = add;&#160;&#160;&#160;// else place at rear<br/>&#160;&#160;&#160;&#160;rear = add;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// have rear point to new node<br/>&#160;&#160;&#160;&#160;return true;<br/>}<br/><br/>// Place front item into item variable and remove from queue<br/>template &lt;class Item&gt;<br/>bool QueueTP&lt;Item&gt;::dequeue(Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (front == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;item = front-&gt;item;&#160;&#160;&#160;&#160;&#160;// set item to first item in queue<br/>&#160;&#160;&#160;&#160;items--;<br/>&#160;&#160;&#160;&#160;Node * temp = front;&#160;&#160;&#160;&#160;// save location of first item<br/>&#160;&#160;&#160;&#160;front = front-&gt;next;&#160;&#160;&#160;&#160;// reset front to next item<br/>&#160;&#160;&#160;&#160;delete temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// delete former first item<br/>&#160;&#160;&#160;&#160;if (items == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rear = 0;<br/>&#160;&#160;&#160;&#160;return true;<br/>}<br/><br/>&#160;#endif</p><hr/>
<p><a id="page_895"/>One interesting thing about the template in <a href="#ch15ex05">Listing 15.5</a> is that <code>Node</code> is defined in terms of the generic type <code>Item</code>. Thus, a declaration like the following leads to a <code>Node</code> defined to hold type <code>double</code> values:</p>
<p class="programlisting">QueueTp&lt;double&gt; dq;</p>
<p>And the following declaration leads to a <code>Node</code> defined to hold type <code>char</code> values:</p>
<p class="programlisting">QueueTp&lt;char&gt; cq;</p>
<p>These two <code>Node</code> classes are defined in two separate <code>QueueTP</code> classes, so there is no name conflict between the two. That is, one node is type <code>QueueTP&lt;double&gt;::Node</code>, and the other is type <code>QueueTP&lt;char&gt;::Node</code>.</p>
<p><a href="#ch15ex06">Listing 15.6</a> offers a short program for testing the new class.</p>
<p class="caption1"><a id="ch15ex06"/><strong>Listing 15.6. <code>nested.cpp</code></strong></p><hr/>
<p class="programlisting1">// nested.cpp -- using a queue that has a nested class<br/>#include &lt;iostream&gt;<br/><br/>#include &lt;string&gt;<br/>#include "queuetp.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::string;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/><br/>&#160;&#160;&#160;&#160;QueueTP&lt;string&gt; cs(5);<br/>&#160;&#160;&#160;&#160;string temp;<br/><br/>&#160;&#160;&#160;&#160;while(!cs.isfull())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter your name. You will be "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"served in the order of arrival.\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"name: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getline(cin, temp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cs.enqueue(temp);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The queue is full. Processing begins!\n";<br/><br/>&#160;&#160;&#160;&#160;while (!cs.isempty())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cs.dequeue(temp);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Now processing " &lt;&lt; temp &lt;&lt; "...\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_896"/>Here is a sample run of the program in <a href="#ch15ex05">Listings 15.5</a> and <a href="#ch15ex06">15.6</a>:</p>
<p class="programlisting">Please enter your name. You will be served in the order of arrival.<br/>name: <span class="EmpStrong">Kinsey Millhone</span><br/>Please enter your name. You will be served in the order of arrival.<br/>name: <span class="EmpStrong">Adam Dalgliesh</span><br/>Please enter your name. You will be served in the order of arrival.<br/>name: <span class="EmpStrong">Andrew Dalziel</span><br/>Please enter your name. You will be served in the order of arrival.<br/>name: <span class="EmpStrong">Kay Scarpetta</span><br/>Please enter your name. You will be served in the order of arrival.<br/>name: <span class="EmpStrong">Richard Jury</span><br/>The queue is full. Processing begins!<br/>Now processing Kinsey Millhone...<br/>Now processing Adam Dalgliesh...<br/>Now processing Andrew Dalziel...<br/>Now processing Kay Scarpetta...<br/>Now processing Richard Jury...</p>
<h3 id="ch15lev1sec3">Exceptions</h3>
<p>Programs sometimes encounter runtime problems that prevent them from continuing normally. For example, a program may try to open an unavailable file, or it may request more memory than is available, or it may encounter values it cannot abide. Usually, programmers try to anticipate such calamities. C++ exceptions provide a powerful and flexible tool for dealing with these situations. Exceptions are a relatively recent addition to C++, so some older compilers haven&#8217;t implemented them. Also some compilers turn this feature off by default, so you may have to use the compiler options to turn it on.</p>
<p>Before examining exceptions, let&#8217;s look at some of the more rudimentary options available to programmers. As a test case, let&#8217;s look at a function that calculates the harmonic mean of two numbers. The <em>harmonic mean</em> of two numbers is defined as the inverse of the average of the inverses. This can be reduced to the following expression:</p>
<p class="programlisting">2.0 &#215; x &#215; y / (x + y)</p>
<p><a id="page_897"/>Note that if y is the negative of x, this formula results in division by zero, a rather undesirable operation. Many newer compilers handle division by zero by generating a special floating-point value that represents infinity; <code>cout</code> displays this value as <code>Inf</code>, <code>inf</code>, <code>INF</code>, or something similar. Other compilers may produce programs that crash when division by zero occurs. It is best to write code that behaves in the same controlled fashion on all systems.</p>
<h4 id="ch15lev2sec7">Calling <code>abort()</code></h4>
<p>One way to handle this is to have the function call the <code>abort()</code> function if one argument is the negative of the other. The <code>abort()</code> function has its prototype in the <code>cstdlib</code> (or <code>stdlib.h</code>) header file. A typical implementation, if called, sends a message such as &#8220;abnormal program termination&#8221; to the standard error stream (the same as the one used by <code>cerr</code>) and terminates the program. It also returns an implementation-dependent value that indicates failure to the operating system or, if the program was initiated by another program, to the parent process. Whether <code>abort()</code> flushes file buffers (that is, memory areas used to store material for transfers to and from files) depends on the implementation. If you prefer, you can use <code>exit()</code>, which does flush file buffers, but without displaying a message. <a href="#ch15ex07">Listing 15.7</a> shows a short program that uses <code>abort()</code>.</p>
<p class="caption1"><a id="ch15ex07"/><strong>Listing 15.7. <code>error1.cpp</code></strong></p><hr/>
<p class="programlisting1">//error1.cpp -- using the abort() function<br/>#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt;<br/>double hmean(double a, double b);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double x, y, z;<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter two numbers: ";<br/>&#160;&#160;&#160;&#160;while (std::cin &gt;&gt; x &gt;&gt; y)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;z = hmean(x,y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Harmonic mean of " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " is " &lt;&lt; z &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter next set of numbers &lt;q to quit&gt;: ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Bye!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>double hmean(double a, double b)<br/>{<br/>&#160;&#160;&#160;&#160;if (a == -b)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "untenable arguments to hmean()\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::abort();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 2.0 * a * b / (a + b);<br/>}</p><hr/>
<p><a id="page_898"/>Here&#8217;s a sample run of the program in <a href="#ch15ex07">Listing 15.7</a>:</p>
<p class="programlisting">Enter two numbers: <span class="EmpStrong">3 6</span><br/>Harmonic mean of 3 and 6 is 4<br/>Enter next set of numbers &lt;q to quit&gt;: <span class="EmpStrong">10 -10</span><br/>untenable arguments to hmean()<br/>abnormal program termination</p>
<p>Note that calling the <code>abort()</code> function from <code>hmean()</code> terminates the program directly, without returning first to <code>main()</code>. In general, different compilers issue different abort messages. Here is another such message:</p>
<p class="programlisting">This application has requested the Runtime to terminate it<br/>in an unusual way. Please contact the application's support<br/>team for more information.</p>
<p>(You may, perhaps, enjoy the conceit that our little program has a support team.) The program could avoid aborting by checking the values of <code>x</code> and <code>y</code> before calling the <code>hmean()</code> function. However, it&#8217;s not safe to rely on a programmer to know (or care) enough to perform such a check.</p>
<h4 id="ch15lev2sec8">Returning an Error Code</h4>
<p>A more flexible approach than aborting is to use a function&#8217;s return value to indicate a problem. For example, the <code>get(void)</code> member of the <code>ostream</code> class ordinarily returns the ASCII code for the next input character, but it returns the special value <code>EOF</code> if it encounters the end-of-file. This approach doesn&#8217;t work for <code>hmean()</code>. Any numeric value could be a valid return value, so there&#8217;s no special value available to indicate a problem. In this kind of situation, you can use a pointer argument or a reference argument to get a value back to the calling program and use the function return value to indicate success or failure. The <code>istream</code> family of overloaded <code>&gt;&gt;</code> operators uses a variant of this technique. By informing the calling program of the success or failure, you give the program the option of taking actions other than aborting. <a href="#ch15ex08">Listing 15.8</a> shows an example of this approach. It redefines <code>hmean()</code> as a <code>bool</code> function whose return value indicates success or failure. It adds a third argument for obtaining the answer.</p>
<p class="caption1"><a id="page_899"/><a id="ch15ex08"/><strong>Listing 15.8. <code>error2.cpp</code></strong></p><hr/>
<p class="programlisting1">//error2.cpp -- returning an error code<br/>#include &lt;iostream&gt;<br/>#include &lt;cfloat&gt;&#160;&#160;// (or float.h) for DBL_MAX<br/><br/>bool hmean(double a, double b, double * ans);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double x, y, z;<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter two numbers: ";<br/>&#160;&#160;&#160;&#160;while (std::cin &gt;&gt; x &gt;&gt; y)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (hmean(x,y,&#38;z))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Harmonic mean of " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " is " &lt;&lt; z &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "One value should not be the negative "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "of the other - try again.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter next set of numbers &lt;q to quit&gt;: ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Bye!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>bool hmean(double a, double b, double * ans)<br/>{<br/>&#160;&#160;&#160;&#160;if (a == -b)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*ans = DBL_MAX;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*ans = 2.0 * a * b / (a + b);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>}</p><hr/>
<p>Here&#8217;s a sample run of the program in <a href="#ch15ex08">Listing 15.8</a>:</p>
<p class="programlisting">Enter two numbers: <span class="EmpStrong">3 6</span><br/>Harmonic mean of 3 and 6 is 4<br/>Enter next set of numbers &lt;q to quit&gt;: <span class="EmpStrong">10 -10</span><br/>One value should not be the negative of the other - try again.<br/><a id="page_900"/>Enter next set of numbers &lt;q to quit&gt;: <span class="EmpStrong">1 19</span><br/>Harmonic mean of 1 and 19 is 1.9<br/>Enter next set of numbers &lt;q to quit&gt;: <span class="EmpStrong">q</span><br/>Bye!</p>
<h5 id="ch15lev3sec3">Program Notes</h5>
<p>In <a href="#ch15ex08">Listing 15.8</a>, the program design allows the user to continue, bypassing the effects of bad input. Of course, the design does rely on the user to check the function return value, something that programmers don&#8217;t always do. For example, to keep the sample programs short, the listings in this book don&#8217;t check to see if <code>cout</code> was successful in handling output.</p>
<p>You could use either a pointer or a reference for the third arguments. Many programmers prefer using pointers for arguments of the built-in types because that makes it obvious which argument is being used for the answer.</p>
<p>Another variation on the idea of storing a return condition somewhere is to use a global variable. The function with the potential problem could set the global variable to a particular value if things go wrong, and the calling program could check the variable. This is the method used by the traditional C math library, which uses the global variable <code>errno</code> for this purpose. You have to make sure, of course, that some other function doesn&#8217;t try to use a global variable of the same name for some other purpose.</p>
<h4 id="ch15lev2sec9">The Exception Mechanism</h4>
<p>Now let&#8217;s see how you can handle problems by using the exception mechanism. A C++ <em>exception</em> is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero. Exceptions provide a way to transfer control from one part of a program to another. Handling an exception has three components:</p>
<p class="indenthandingB">&#8226; Throwing an exception</p>
<p class="indenthandingB">&#8226; Catching an exception with a handler</p>
<p class="indenthandingB">&#8226; Using a <code>try</code> block</p>
<p>A program throws an exception when a problem shows up. For example, you can modify <code>hmean()</code> in <a href="#ch15ex07">Listing 15.7</a> to throw an exception instead of call the <code>abort()</code> function. A throw statement, in essence, is a jump; that is, it tells a program to jump to statements at another location. The <code>throw</code> keyword indicates the throwing of an exception. It&#8217;s followed by a value, such as a character string or an object, that indicates the nature of the exception.</p>
<p>A program catches an exception with an <em>exception handler</em> at the place in the program where you want to handle the problem. The <code>catch</code> keyword indicates the catching of an exception. A handler begins with the keyword <code>catch</code>, followed by a type declaration (in parentheses) that indicates the type of exception to which it responds. That, in turn, is followed by a brace-enclosed block of code that indicates the actions to take. The <code>catch</code> keyword, along with the exception type, serves as a label that identifies the point in a <a id="page_901"/>program to which execution should jump when an exception is thrown. An exception handler is also called a <code>catch</code> <em>block</em>.</p>
<p>A <code>try</code> <em>block</em> identifies a block of code for which particular exceptions will be activated. It&#8217;s followed by one or more <code>catch</code> blocks. The <code>try</code> block itself is indicated by the keyword <code>try</code>, followed by a brace-enclosed block of code indicating the code for which exceptions will be noticed.</p>
<p>The easiest way to see how these three elements fit together is to look at a short example, such as the one in <a href="#ch15ex09">Listing 15.9</a>.</p>
<p class="caption1"><a id="ch15ex09"/><strong>Listing 15.9. <code>error3.cpp</code></strong></p><hr/>
<p class="programlisting1">// error3.cpp -- using an exception<br/>#include &lt;iostream&gt;<br/>double hmean(double a, double b);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double x, y, z;<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter two numbers: ";<br/>&#160;&#160;&#160;&#160;while (std::cin &gt;&gt; x &gt;&gt; y)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start of try block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;z = hmean(x,y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// end of try block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;catch (const char * s)&#160;&#160;// start of exception handler<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; s &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter a new pair of numbers: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// end of handler<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Harmonic mean of " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " is " &lt;&lt; z &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter next set of numbers &lt;q to quit&gt;: ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Bye!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>double hmean(double a, double b)<br/>{<br/>&#160;&#160;&#160;&#160;if (a == -b)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw "bad hmean() arguments: a = -b not allowed";<br/>&#160;&#160;&#160;&#160;return 2.0 * a * b / (a + b);<br/>}</p><hr/>
<p><a id="page_902"/>Here&#8217;s a sample run of the program in <a href="#ch15ex09">Listing 15.9</a>:</p>
<p class="programlisting">Enter two numbers: <span class="EmpStrong">3 6</span><br/>Harmonic mean of 3 and 6 is 4<br/>Enter next set of numbers &lt;q to quit&gt;: <span class="EmpStrong">10 -10</span><br/>bad hmean() arguments: a = -b not allowed<br/>Enter a new pair of numbers: <span class="EmpStrong">1 19</span><br/>Harmonic mean of 1 and 19 is 1.9<br/>Enter next set of numbers &lt;q to quit&gt;: <span class="EmpStrong">q</span><br/>Bye!</p>
<h5 id="ch15lev3sec4">Program Notes</h5>
<p>The <code>try</code> block in <a href="#ch15ex09">Listing 15.9</a> looks like this:</p>
<p class="programlisting">try {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start of try block<br/>&#160;&#160;&#160;&#160;z = hmean(x,y);<br/>}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// end of try block</p>
<p>If any statement in this block leads to an exception being thrown, the <code>catch</code> blocks after this block will handle the exception. If the program calls <code>hmean()</code> somewhere else outside this (and any other) <code>try</code> block, it won&#8217;t have the opportunity to handle an exception.</p>
<p>Throwing an exception looks like this:</p>
<p class="programlisting">if (a == -b)<br/>&#160;&#160;&#160;&#160;throw "bad hmean() arguments: a = -b not allowed";</p>
<p>In this case, the thrown exception is the string <code>"bad hmean() arguments: a = -b not allowed"</code>. The exception type can be a string, as in this case, or other C++ types. A class type is the usual choice, as later examples in this chapter illustrate.</p>
<p>Executing the <code>throw</code> is a bit like executing a return statement in that it terminates function execution. However, instead of returning control to the calling program, a <code>throw</code> causes a program to back up through the sequence of current function calls until it finds the function that contains the <code>try</code> block. In <a href="#ch15ex09">Listing 15.9</a>, that function is the same as the calling function. Soon you&#8217;ll see an example involving backing up more than one function. Meanwhile, in this case, the <code>throw</code> passes program control back to <code>main()</code>. There, the program looks for an exception handler (following the <code>try</code> block) that matches the type of exception thrown.</p>
<p>The handler, or <code>catch</code> block, looks like this:</p>
<p class="programlisting">catch (char * s)&#160;&#160;// start of exception handler<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; s &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;sdt::cout &lt;&lt; "Enter a new pair of numbers: ";<br/>&#160;&#160;&#160;&#160;continue;<br/>}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// end of handler</p>
<p><a id="page_903"/>The <code>catch</code> block looks a bit like a function definition, but it&#8217;s not. The keyword <code>catch</code> identifies this as a handler, and <code>char * s</code> means that this handler matches a thrown exception that is a string. This declaration of <code>s</code> acts much like a function argument definition in that a matching thrown exception is assigned to <code>s</code>. Also, if an exception does match this handler, the program executes the code within the braces.</p>
<p>If a program completes executing statements in a <code>try</code> block without any exceptions being thrown, it skips the <code>catch</code> block or blocks after the <code>try</code> block and goes to the first statement following the handlers. So when the sample run of the program in <a href="#ch15ex09">Listing 15.9</a> processes the values <code>3</code> and <code>6</code>, program execution goes directly to the output statement and reports the result.</p>
<p>Let&#8217;s trace through the events in the sample run that occur after the values <code>10</code> and <code>-10</code> are passed to the <code>hmean()</code> function. The <code>if</code> test causes <code>hmean()</code> to throw an exception. This terminates execution of <code>hmean()</code>. Searching back, the program determines that <code>hmean()</code> was called from within a <code>try</code> block in <code>main()</code>. It then looks for a <code>catch</code> block with a type that matches the exception type. The single <code>catch</code> block present has a <code>char *</code> parameter, so it does match. Detecting the match, the program assigns the string <code>"bad hmean() arguments: a = -b not allowed"</code> to the variable <code>s</code>. Next, the program executes the code in the handler. First, it prints <code>s</code>, which is the caught exception. Then it prints instructions to the user to enter new data. Finally, it executes a <code>continue</code> statement, which causes the program to skip the rest of the <code>while</code> loop and jump to its beginning again. The fact that the <code>continue</code> statement takes the program to the beginning of the loop illustrates the fact that handler statements are part of the loop and that the <code>catch</code> line acts like a label directing program flow (see <a href="#ch15fig02">Figure 15.2</a>).</p>
<p class="caption"><a id="ch15fig02"/><strong>Figure 15.2. Program flow with exceptions.</strong></p>
<p class="image"><img src="graphics/15fig02.jpg" alt="Image"/></p>
<p>You might wonder what happens if a function throws an exception and there&#8217;s no <code>try</code> block or else no matching handler. By default, the program eventually calls the <code>abort()</code> function, but you can modify that behavior. We&#8217;ll return to this topic later in this chapter.</p>
<h4 id="ch15lev2sec10">Using Objects as Exceptions</h4>
<p>Typically, functions that throw exceptions throw objects. One important advantage of this is that you can use different exception types to distinguish among different functions and situations that produce exceptions. Also an object can carry information with it, and you can use this information to help identify the conditions that caused the exception to be thrown. Also in principle a <code>catch</code> block could use that information to decide which course of action to pursue. Here, for example, is one possible design for an exception to be thrown by the <code>hmean()</code> function:</p>
<p class="programlisting">class bad_hmean<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double v1;<br/>&#160;&#160;&#160;&#160;double v2;<br/>public:<br/>&#160;&#160;&#160;&#160;bad_hmean(int a = 0, int b = 0) : v1(a), v2(b){}<br/><a id="page_904"/>&#160;&#160;&#160;&#160;void mesg();<br/>};<br/><br/>inline void bad_hmean::mesg()<br/>{<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "hmean(" &lt;&lt; v1 &lt;&lt; ", " &lt;&lt; v2 &lt;&lt;"): "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "invalid arguments: a = -b\n";<br/>}</p>
<p>A <code>bad_hmean</code> object can be initialized to the values passed to <code>hmean()</code>, and the <code>mesg()</code> method can be used to report the problem, including the values. The <code>hmean()</code> function can use code like this:</p>
<p class="programlisting">if (a == -b)<br/>&#160;&#160;&#160;&#160;throw bad_hmean(a,b);</p>
<p><a id="page_905"/>This calls the <code>bad_hmean()</code> constructor, initializing the object to hold the argument values.</p>
<p><a href="#ch15ex10">Listings 15.10</a> and <a href="#ch15ex11">15.11</a> add a second exception class, <code>bad_gmean</code>, and a second function, called <code>gmean()</code>, that throws a <code>bad_gmean</code> exception. The <code>gmean()</code> function calculates the geometric mean of two numbers, which is the square root of their product. This function is defined if both arguments are non-negative, so it throws an exception if it detects negative arguments. <a href="#ch15ex10">Listing 15.10</a> is a header file that holds the exception class definitions, and <a href="#ch15ex11">Listing 15.11</a> is a sample program that uses that header file. Note that the <code>try</code> block is followed by two consecutive <code>catch</code> blocks:</p>
<p class="programlisting">try {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start of try block<br/>&#160;&#160;&#160;&#160;...<br/>}// end of try block<br/>catch (bad_hmean &#38; bg)&#160;&#160;&#160;&#160;// start of catch block<br/>{<br/>&#160;&#160;&#160;...<br/>}<br/>catch (bad_gmean &#38; hg)<br/>{<br/>&#160;&#160;&#160;...<br/>} // end of catch block</p>
<p>If, say, <code>hmean()</code> throws a <code>bad_hmean</code> exception, the first <code>catch</code> block catches it. If <code>gmean()</code> throws a <code>bad_gmean</code> exception, the exception falls through the first <code>catch</code> block and gets caught by the second.</p>
<p class="caption1"><a id="ch15ex10"/><strong>Listing 15.10. <code>exc_mean.h</code></strong></p><hr/>
<p class="programlisting1">// exc_mean.h&#160;&#160;-- exception classes for hmean(), gmean()<br/>#include &lt;iostream&gt;<br/><br/>class bad_hmean<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double v1;<br/>&#160;&#160;&#160;&#160;double v2;<br/>public:<br/>&#160;&#160;&#160;&#160;bad_hmean(double a = 0, double b = 0) : v1(a), v2(b){}<br/>&#160;&#160;&#160;&#160;void mesg();<br/>};<br/><br/>inline void bad_hmean::mesg()<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "hmean(" &lt;&lt; v1 &lt;&lt; ", " &lt;&lt; v2 &lt;&lt;"): "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "invalid arguments: a = -b\n";<br/>}<br/><br/>class bad_gmean<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;double v1;<br/>&#160;&#160;&#160;&#160;double v2;<br/>&#160;&#160;&#160;&#160;bad_gmean(double a = 0, double b = 0) : v1(a), v2(b){}<br/>&#160;&#160;&#160;&#160;const char * mesg();<br/>};<br/><br/>inline const char * bad_gmean::mesg()<br/>{<br/>&#160;&#160;&#160;&#160;return "gmean() arguments should be &gt;= 0\n";<br/>}</p><hr/>
<p class="caption1"><a id="page_906"/><a id="ch15ex11"/><strong>Listing 15.11. <code>error4.cpp</code></strong></p><hr/>
<p class="programlisting1">//error4.cpp &#8211; using exception classes<br/>#include &lt;iostream&gt;<br/>#include &lt;cmath&gt; // or math.h, unix users may need -lm flag<br/>#include "exc_mean.h"<br/>// function prototypes<br/>double hmean(double a, double b);<br/>double gmean(double a, double b);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;double x, y, z;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter two numbers: ";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; x &gt;&gt; y)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start of try block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;z = hmean(x,y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Harmonic mean of " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " is " &lt;&lt; z &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Geometric mean of " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " is " &lt;&lt; gmean(x,y) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter next set of numbers &lt;q to quit&gt;: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}// end of try block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;catch (bad_hmean &#38; bg)&#160;&#160;&#160;&#160;// start of catch block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bg.mesg();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Try again.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;catch (bad_gmean &#38; hg)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; hg.mesg();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Values used: " &lt;&lt; hg.v1 &lt;&lt; ", "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; hg.v2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Sorry, you don't get to play any more.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} // end of catch block<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>double hmean(double a, double b)<br/>{<br/>&#160;&#160;&#160;&#160;if (a == -b)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_hmean(a,b);<br/>&#160;&#160;&#160;&#160;return 2.0 * a * b / (a + b);<br/>}<br/><br/>double gmean(double a, double b)<br/>{<br/>&#160;&#160;&#160;&#160;if (a &lt; 0 || b &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_gmean(a,b);<br/>&#160;&#160;&#160;&#160;return std::sqrt(a * b);<br/>}</p><hr/>
<p><a id="page_907"/>Here&#8217;s a sample run of the program, one that gets terminated by bad input for the <code>gmean()</code> function:</p>
<p class="programlisting">Enter two numbers: 4 12<br/>Harmonic mean of 4 and 12 is 6<br/>Geometric mean of 4 and 12 is 6.9282<br/>Enter next set of numbers &lt;q to quit&gt;: 5 -5<br/>hmean(5, -5): invalid arguments: a = -b<br/>Try again.<br/>5 -2<br/>Harmonic mean of 5 and -2 is -6.66667<br/>gmean() arguments should be &gt;= 0<br/>Values used: 5, -2<br/>Sorry, you don't get to play any more.<br/>Bye!</p>
<p>One point to notice is that the <code>bad_hmean</code> handler uses a <code>continue</code> statement, whereas the <code>bad_gmean</code> handler uses a <code>break</code> statement. Thus, bad input to <code>hmean()</code> leads the <a id="page_908"/>program to skip the rest of the loop and start the next loop cycle. But bad input for <code>gmean()</code> terminates the loop. This illustrates how a program can determine which exception is thrown (by the exception type) and tailor the response to the exception.</p>
<p>A second point to notice is that the <code>bad_gmean</code> design illustrates techniques that are different from what <code>bad_hmean</code> uses. In particular, <code>bad_gmean</code> uses public data and a method that returns a C-style string.</p>
<h4 id="ch15lev2sec11">Exception Specifications Meet C++11</h4>
<p>Sometimes an idea that seems promising in principle doesn&#8217;t work out so well in practice. Such is the story of <em>exception specifications</em>, a feature added by C++98 and then deprecated by C++11. That means the feature still is in the standard, but it may not be in the future, so you are encouraged not to use it.</p>
<p>However, before you ignore exception specifications, you at least should know what they look like. They look like this:</p>
<p class="programlisting">double harm(double a) throw(bad_thing);&#160;&#160;// may throw bad_thing exception<br/>double marm(double) throw();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// doesn't throw an exception</p>
<p>The <code>throw()</code> part, with or without a list of types, is the exception specification, and it would appear in both the prototype and the function definition.</p>
<p>One reason for exception specifications was to alert the user to the possible need of a <code>try</code> block. However, that can be accomplished just as easily with a comment. A second reason was to allow the compiler to add code to do runtime checks to see if the exception specification was violated. This can happen fairly easily. For instance, <code>marm()</code> might not throw an exception, but it might call a function that calls a function that throws an exception. And maybe that function didn&#8217;t throw an exception when you wrote the code, but after a library update, it now does. Anyway, the consensus that developed in the programming community, particularly among those who worked most diligently in writing exception-safe code, was that this feature is best ignored. And now you, too, can ignore exception specifications with the blessings of C++11.</p>
<p>However, C++11 does allow for one special specification&#8212;the new keyword <code>noexcept</code> can be used to indicate a function that does not throw an exception:</p>
<p class="programlisting">double marm() noexcept;&#160;&#160;// marm() doesn't throw an exception</p>
<p>There is some debate about the necessity and usefulness of this specification, with some feeling it&#8217;s better to avoid using it (at least, in most cases). But others felt strongly enough about the need to introduce a new keyword. It&#8217;s thought that knowing that a function shouldn&#8217;t throw an exception can help the compiler optimize code. This usage should be thought of as a promise made by the programmer of the function.</p>
<p>There also is a <code>noexcept()</code> operator (see <a href="app05.html#app05">Appendix E</a>) that reports on whether or not its operand could throw an exception.</p>
<h4 id="ch15lev2sec12">Unwinding the Stack</h4>
<p><a id="page_909"/>Suppose a <code>try</code> block doesn&#8217;t contain a direct call to a function that throws an exception but that it calls a function that calls a function that throws an exception. Execution still jumps from the function in which the exception is thrown to the function that contains the <code>try</code> block and handlers. Doing so involves <em>unwinding the stack</em>, which we&#8217;ll discuss now.</p>
<p>First, let&#8217;s look at how C++ normally handles function calls and returns. C++ typically handles function calls by placing information on a stack (see <a href="ch09.html#ch09">Chapter 9</a>, &#8220;<a href="ch09.html#ch09">Memory Models and Namespaces</a>&#8221;). In particular, a program places the address of a calling function instruction (a <em>return address</em>) on the stack. When the called function completes, the program uses that address to determine where to continue with program execution. Also the function call places any function arguments on the stack, where they are treated as automatic variables. If the called function creates any new automatic variables, they, too, are added to the stack. If a called function calls another function, its information is added to the stack, and so on. When a function terminates, program execution passes to the address stored when the function was called, and the top of the stack is freed. Thus a function normally returns to the function that called it, with each function liberating its automatic variables as it terminates. If an automatic variable is a class object, then the class destructor, if any, is called.</p>
<p>Now suppose a function terminates via a thrown exception instead of via a return call. Again, the program frees memory from the stack. But instead of stopping at the first return address on the stack, the program continues freeing the stack until it reaches a return address that resides in a <code>try</code> block (see <a href="#ch15fig03">Figure 15.3</a>). Control then passes to the exception handlers at the end of the block rather than to the first statement following the function call. This process is called <em>unwinding the stack</em>. One very important feature of the <code>throw</code> mechanism is that, just as with function returns, the class destructors are called for any automatic class objects on the stack. However, a function return just processes objects put on the stack by that function, whereas the <code>throw</code> statement processes objects put on the stack by the entire sequence of function calls between the <code>try</code> block and the <code>throw</code>. Without the unwinding-the-stack feature, a <code>throw</code> would leave destructors uncalled for automatic class objects placed on the stack by intermediate function calls.</p>
<p class="caption"><a id="ch15fig03"/><strong>Figure 15.3. <code>throw</code> versus <code>return</code>.</strong></p>
<p class="image"><img src="graphics/15fig03.jpg" alt="Image"/></p>
<p><a href="#ch15ex12">Listing 15.12</a> provides an example of unwinding the stack. In it, <code>main()</code> calls <code>means()</code>, which in turn calls <code>hmean()</code> and <code>gmean()</code>. The <code>means()</code> function, for the lack of anything better to do, calculates the mean of the arithmetic, harmonic, and geometric means. Both <code>main()</code> and <code>means()</code> create objects of the <code>demo</code> type (a babbling class that announces when its constructor and destructor are used) so that you can see what happens to those objects when exceptions are thrown. The <code>try</code> block in <code>main()</code> catches both <code>bad_hmean</code> and <code>bad_gmean</code> exceptions, and the <code>try</code> block in <code>means()</code> catches just the <code>bad_hmean</code> exception. This <code>catch</code> block has the following code:</p>
<p class="programlisting">catch (bad_hmean &#38; bg) // start of catch block<br/>{<br/>&#160;&#160;&#160;&#160;bg.mesg();<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Caught in means()\n";<br/>&#160;&#160;&#160;&#160;throw;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// rethrows the exception<br/>}</p>
<p><a id="page_910"/>After the code responds by displaying messages, it rethrows the exception, which means, in this case, sending the exception on up to <code>main()</code>. (In general, a rethrown exception rises to the next <code>try</code>-<code>catch</code> combination that catches that particular type of exception. If no handler is found, the program, by default, aborts.) <a href="#ch15ex12">Listing 15.12</a> uses the same header file (<code>exc_mean.h</code> in <a href="#ch15ex10">listing 15.10</a>) as <a href="#ch15ex11">Listing 15.11</a>.</p>
<p class="caption1"><a id="ch15ex12"/><strong>Listing 15.12. <code>error5.cpp</code></strong></p><hr/>
<p class="programlisting1">//error5.cpp -- unwinding the stack<br/>#include &lt;iostream&gt;<br/>#include &lt;cmath&gt; // or math.h, unix users may need -lm flag<br/>#include &lt;string&gt;<br/>#include "exc_mean.h"<br/><br/>class demo<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string word;<br/>public:<br/>&#160;&#160;&#160;&#160;demo (const std::string &#38; str)<br/><a id="page_911"/>&#160;&#160;&#160;&#160;{<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;word = str;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "demo " &lt;&lt; word &lt;&lt; " created\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;~demo()<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "demo " &lt;&lt; word &lt;&lt; " destroyed\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;void show() const<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "demo " &lt;&lt; word &lt;&lt; " lives!\n";<br/>&#160;&#160;&#160;&#160;}<br/>};<br/><br/>// function prototypes<br/>double hmean(double a, double b);<br/>double gmean(double a, double b);<br/>double means(double a, double b);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;double x, y, z;<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;demo d1("found in block in main()");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter two numbers: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin &gt;&gt; x &gt;&gt; y)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start of try block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;z = means(x,y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "The mean mean of " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " is " &lt;&lt; z &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter next pair: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} // end of try block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;catch (bad_hmean &#38; bg)&#160;&#160;&#160;&#160;// start of catch block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bg.mesg();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Try again.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;catch (bad_gmean &#38; hg)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; hg.mesg();<br/><a id="page_912"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Values used: " &lt;&lt; hg.v1 &lt;&lt; ", "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; hg.v2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Sorry, you don't get to play any more.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} // end of catch block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d1.show();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye!\n";<br/>&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>double hmean(double a, double b)<br/>{<br/>&#160;&#160;&#160;&#160;if (a == -b)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_hmean(a,b);<br/>&#160;&#160;&#160;&#160;return 2.0 * a * b / (a + b);<br/>}<br/><br/>double gmean(double a, double b)<br/>{<br/>&#160;&#160;&#160;&#160;if (a &lt; 0 || b &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_gmean(a,b);<br/>&#160;&#160;&#160;&#160;return std::sqrt(a * b);<br/>}<br/><br/>double means(double a, double b)<br/>{<br/>&#160;&#160;&#160;&#160;double am, hm, gm;<br/>&#160;&#160;&#160;&#160;demo d2("found in means()");<br/>&#160;&#160;&#160;&#160;am = (a + b) / 2.0;&#160;&#160;&#160;&#160;// arithmetic mean<br/>&#160;&#160;&#160;&#160;try<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hm = hmean(a,b);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gm = gmean(a,b);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;catch (bad_hmean &#38; bg) // start of catch block<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bg.mesg();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Caught in means()\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// rethrows the exception<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;d2.show();<br/>&#160;&#160;&#160;&#160;return (am + hm + gm) / 3.0;<br/>}</p><hr/>
<p><a id="page_913"/>Here&#8217;s a sample run of the program:</p>
<p class="programlisting">demo found in block in main() created<br/>Enter two numbers: <span class="EmpStrong">6 12</span><br/>demo found in means() created<br/>demo found in means() lives!<br/>demo found in means() destroyed<br/>The mean mean of 6 and 12 is 8.49509<br/><span class="EmpStrong">6 -6</span><br/>demo found in means() created<br/>hmean(6, -6): invalid arguments: a = -b<br/>Caught in means()<br/>demo found in means() destroyed<br/>hmean(6, -6): invalid arguments: a = -b<br/>Try again.<br/><span class="EmpStrong">6 -8</span><br/>demo found in means() created<br/>demo found in means() destroyed<br/>gmean() arguments should be &gt;= 0<br/>Values used: 6, -8<br/>Sorry, you don't get to play any more.<br/>demo found in block in main() lives!<br/>demo found in block in main() destroyed<br/>Bye!</p>
<h5 id="ch15lev3sec5">Program Notes</h5>
<p>Let&#8217;s trace through the course of the sample run shown in the preceding section. First, as the <code>demo</code> constructor announces, an object is created in the block in <code>main()</code>. Next, <code>means()</code> is called, and another <code>demo</code> object is created. The <code>means()</code> function passes the values <code>6</code> and <code>12</code> on to <code>hmean()</code> and <code>gmean()</code>, and those functions return values to <code>means()</code>, which calculates a result and returns it. Before returning the result, <code>means()</code> invokes <code>d2.show()</code>. After returning the result, <code>means()</code> terminates, and the destructor for <code>d2</code> is called automatically:</p>
<p class="programlisting">demo found in means() lives!<br/>demo found in means() destroyed</p>
<p>The next input cycle sends the values <code>6</code> and <code>-6</code> to <code>means()</code>, and then <code>means()</code> creates a new <code>demo</code> object and relays the values to <code>hmean()</code>. The <code>hmean()</code> function then throws a <code>bad_hmean</code> exception, which is caught by the <code>catch</code> block in <code>means()</code>, as is shown by the following output:</p>
<p class="programlisting">hmean(6, -6): invalid arguments: a = -b<br/>Caught in means()</p>
<p><a id="page_914"/>The <code>throw</code> statement in this block then terminates <code>means()</code> and sends the exception up to <code>main()</code>. The fact that <code>d2.show()</code> isn&#8217;t called demonstrates that the execution of <code>means()</code> is terminated. But note that the destructor for <code>d2</code> is called:</p>
<p class="programlisting">demo found in means() destroyed</p>
<p>This illustrates an extremely important aspect of exceptions: As the program unwinds the stack to reach where an exception is caught, it frees automatic storage class variables on the stack. If a variable happens to be a class object, then the destructor for that object is called.</p>
<p>Meanwhile, the rethrown exception reaches <code>main()</code>, where the appropriate <code>catch</code> block catches and handles it:</p>
<p class="programlisting">hmean(6, -6): invalid arguments: a = -b<br/>Try again.</p>
<p>Now the third input cycle begins, with <code>6</code> and <code>-8</code> sent on to <code>means()</code>. Once again, <code>means()</code> creates a new <code>demo</code> object. It passes <code>6</code> and <code>-8</code> to <code>hmean()</code>, which processes them without a problem. Then <code>means()</code> passes <code>6</code> and <code>-8</code> to <code>gmean()</code>, which throws a <code>bad_gmean</code> exception. Because <code>means())</code> doesn&#8217;t catch <code>bad_gmean</code> exceptions, the exception is passed on up to <code>main()</code>, and no further code in <code>means()</code> is executed. However, once again, as the program unwinds the stack, it frees local automatic variables, so the destructor for <code>d2</code> is called:</p>
<p class="programlisting">demo found in means() destroyed</p>
<p>Finally, the <code>bad_gmean</code> handler in <code>main()</code> catches the exception and terminates the loop:</p>
<p class="programlisting">gmean() arguments should be &gt;= 0<br/>Values used: 6, -8<br/>Sorry, you don't get to play any more.</p>
<p>Then the program terminates normally, displaying a few messages and automatically calling the destructor for <code>d1</code>. If the <code>catch</code> block used, say, <code>exit(EXIT_FAILURE)</code> instead of <code>break</code>, the program would terminate immediately, so you wouldn&#8217;t see these messages:</p>
<p class="programlisting">demo found in main() lives!<br/>Bye!</p>
<p>However, you would still see this message:</p>
<p class="programlisting">demo found in main() destroyed</p>
<p>Again, the exception mechanism would attend to freeing automatic variables on the stack.</p>
<h4 id="ch15lev2sec13">More Exception Features</h4>
<p>Although the <code>throw</code>-<code>catch</code> mechanism is similar to function arguments and the function return mechanism, there are a few differences. One, which you&#8217;ve already encountered, is that a return statement in a function <code>fun()</code> transfers execution to the function that called <a id="page_915"/><code>fun()</code>, but a <code>throw</code> transfers execution all the way up to the first function having a <code>try</code>-<code>catch</code> combination that catches the exception. For example, in <a href="#ch15ex12">Listing 15.12</a>, when <code>hmean()</code> throws an exception, control passes up to <code>means()</code>, but when <code>gmean()</code> throws an exception, control passes up to <code>main()</code>.</p>
<p>Another difference is that the compiler always creates a temporary copy when throwing an exception, even if the exception specifier and <code>catch</code> blocks specify a reference. For instance, consider this code:</p>
<p class="programlisting">class problem {...};<br/>...<br/>void super() throw (problem)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;if (oh_no)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;problem oops;&#160;&#160;&#160;// construct object<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw oops;&#160;&#160;&#160;&#160;&#160;// throw it<br/>&#160;&#160;&#160;&#160;...<br/>}<br/>...<br/>try {<br/>&#160;&#160;&#160;&#160;super();<br/>}<br/>catch(problem &#38; p)<br/>{<br/>// statements<br/>}</p>
<p>Here, <code>p</code> would refer to a copy of <code>oops</code> rather than to <code>oops</code>. That&#8217;s a good thing because <code>oops</code> no longer exists after <code>super()</code> terminates. By the way, it is simpler to combine construction with the <code>throw</code>:</p>
<p class="programlisting">throw problem();&#160;&#160;&#160;&#160;&#160;// construct and throw default problem object</p>
<p>At this point you might wonder why the code uses a reference if the <code>throw</code> generates a copy. After all, the usual reason for using a reference return value is the efficiency of not having to make a copy. The answer is that references have another important property: A base-class reference can also refer to derived-class objects. Suppose you have a collection of exception types that are related by inheritance. In that case, the exception specification need only list a reference to the base type, and that would also match any derived objects thrown.</p>
<p>Suppose you have a class hierarchy of exceptions and you want to handle the different types separately. A base-class reference can catch all objects of a family, but a derived-class object can only catch that object and objects of classes derived from that class. A thrown object is caught by the first <code>catch</code> block that matches it. This suggests arranging the <code>catch</code> blocks in inverse order of derivation:</p>
<p class="programlisting"><a id="page_916"/>class bad_1 {...};<br/>class bad_2 : public bad_1 {...};<br/>class bad_3 : public bad 2 {...};<br/>...<br/>void duper()<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;if (oh_no)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_1();<br/>&#160;&#160;&#160;&#160;if (rats)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_2();<br/>&#160;&#160;&#160;&#160;if (drat)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_3();<br/>}<br/>...<br/>try {<br/>&#160;&#160;&#160;&#160;duper();<br/>}<br/>catch(bad_3 &#38;be)<br/>{ // statements }<br/>catch(bad_2 &#38;be)<br/>{ // statements }<br/>catch(bad_1 &#38;be)<br/>{ // statements }</p>
<p>If the <code>bad_1 &#38;</code> handler were first, it would catch the <code>bad_1</code>, <code>bad_2</code>, and <code>bad_3</code> exceptions. With the inverse order, a <code>bad_3</code> exception would be caught by the <code>bad_3 &#38;</code> handler.</p>
<div class="note"><hr/>
<p class="title"><a id="ch15note01"/>Tip</p>
<p class="notepara">If you have an inheritance hierarchy of exception classes, you should arrange the order of the <code>catch</code> blocks so that the exception of the most-derived class (that is, the class furthest down the class hierarchy sequence) is caught first and the base-class exception is caught last.</p>
<hr/></div>
<p>Arranging <code>catch</code> blocks in the proper sequence allows you to be selective about how each type of exception is handled. But sometimes you might not know what type of exception to expect. For instance, say you write a function that calls another function, and you don&#8217;t know whether that other function throws exceptions. You can still catch the exception even if you don&#8217;t know the type. The trick to catching any exception is to use an ellipsis for the exception type:</p>
<p class="programlisting">catch (...) { // statements }&#160;&#160;// catches any type exception</p>
<p><a id="page_917"/>If you do know some exceptions that are thrown, you can place this catchall form at the end of the <code>catch</code> block sequence, a bit like the <code>default</code> case for a <code>switch</code>:</p>
<p class="programlisting">try {<br/>&#160;&#160;&#160;&#160;duper();<br/>}<br/>catch(bad_3 &#38;be)<br/>{ // statements }<br/>catch(bad_2 &#38;be)<br/>{ // statements }<br/>catch(bad_1 &#38;be)<br/>{ // statements }<br/>catch(bad_hmean &#38; h)<br/>{ // statements }<br/>catch (...)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// catch whatever is left<br/>{ // statements }</p>
<p>You can set up a handler to catch an object instead of a reference. A base-class object will catch a derived class object, but the derived aspects will be stripped off. Thus, base-class versions of virtual methods will be used.</p>
<h4 id="ch15lev2sec14">The <code>exception</code> Class</h4>
<p>The main intent for C++ exceptions is to provide language-level support for designing fault-tolerant programs. That is, exceptions make it easier to incorporate error handling into a program design so you don&#8217;t have to tack on some more rigid form of error handling as an afterthought. The flexibility and relative convenience of exceptions should encourage programmers to integrate fault handling into the program design process, if appropriate. In short, exceptions are the kind of feature that, like classes, can modify your approach to programming.</p>
<p>Newer C++ compilers are incorporating exceptions into the language. For example, the <code>exception</code> header file (formerly <code>exception.h</code> or <code>except.h</code>) defines an <code>exception</code> class that C++ uses as a base class for other exception classes used to support the language. Your code, too, can throw an <code>exception</code> object or use the <code>exception</code> class as a base class. One virtual member function is named <code>what()</code>, and it returns a string, the nature of which is implementation dependent. However, because this method is virtual, you can redefine it in a class derived from <code>exception</code>:</p>
<p class="programlisting">#include &lt;exception&gt;<br/>class bad_hmean : public std::exception<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;const char * what() { return "bad arguments to hmean()"; }<br/>...<br/>};<br/>class bad_gmean : public std::exception<br/>{<br/><a id="page_918"/>public:<br/>&#160;&#160;&#160;&#160;const char * what() { return "bad arguments to gmean()"; }<br/>...<br/>};</p>
<p>If you don&#8217;t want to handle these derived exceptions differently from one another, you can catch them with the same base-class handler:</p>
<p class="programlisting">try {<br/>...<br/>}<br/>catch(std::exception &#38; e)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; e.what() &lt;&lt; endl;<br/>...<br/>}</p>
<p>Or you could catch the different types separately.</p>
<p>The C++ library defines many exception types based on <code>exception</code>.</p>
<h5 id="ch15lev3sec6">The <code>stdexcept</code> Exception Classes</h5>
<p>The <code>stdexcept</code> header file defines several more exception classes. First, the file defines the <code>logic_error</code> and <code>runtime_error</code> classes, both of which derive publicly from <code>exception</code>:</p>
<p class="programlisting">class logic_error : public exception {<br/>public:<br/>explicit logic_error(const string&#38; what_arg);<br/>...<br/>};<br/><br/>class domain_error : public logic_error {<br/>public:<br/>explicit domain_error(const string&#38; what_arg);<br/>...<br/>};</p>
<p>Note that the constructors take a <code>string</code> object as an argument; this argument provides the character data returned as a C-style string by the <code>what()</code> method.</p>
<p>These two new classes serve, in turn, as bases for two families of derived classes. The <code>logic_error</code> family describes, as you might expect, typical logic errors. In principle, sound programming could avoid such errors, but in practice, such errors might show up. The name of each class indicates the sort of error it is intended to report:</p>
<p class="programlisting">domain_error<br/>invalid_argument<br/>length_error<br/>out_of_bounds</p>
<p><a id="page_919"/>Each class has a constructor like that of <code>logic_error</code> that allows you to provide the string to be returned by the <code>what()</code> method.</p>
<p>Perhaps a little amplification might be helpful. A mathematical function has a domain and a range. The domain consists of the values for which the function is defined, and the range consists of the values that a function returns. For example, the domain of the sine function is from negative infinity to positive infinity because the sine is defined for all real numbers. But the range of the sine function is from -1 to +1 because those are the extreme possible values of the sine of an angle. On the other hand, the domain of the inverse function arcsine is -1 to +1, while its range is -[pi] to +[pi]. If you wrote a function that passed an argument to the <code>std::sin()</code> function, you could have your function throw a <code>domain_error</code> object if the argument were outside the -1 to +1 domain.</p>
<p>The <code>invalid_argument</code> exception alerts you that an unexpected value has been passed to a function. For example, if a function expects to receive a string for which each character is either a <code>'0'</code> or <code>'1'</code>, it could throw the <code>invalid_argument</code> exception if some other character appeared in the string.</p>
<p>The <code>length_error</code> exception is used to indicate that not enough space is available for the desired action. For example, the <code>string</code> class has an <code>append()</code> method that throws a <code>length_error</code> exception if the resulting string would be larger than the maximum possible string length.</p>
<p>The <code>out_of_bounds</code> exception is typically used to indicate indexing errors. For example, you could define an array-like class for which <code>operator()[]</code> throws the <code>out_of_bounds</code> exception if the index used is invalid for that array.</p>
<p>Next, the <code>runtime_error</code> family describes errors that might show up during runtime but that could not easily be predicted and prevented. The name of each class indicates the sort of error it is intended to report:</p>
<p class="programlisting">range_error<br/>overflow_error<br/>underflow_error</p>
<p>Each class has a constructor like that of <code>runtime_error</code> that allows you to provide the string to be returned by the <code>what()</code> method.</p>
<p>An underflow error can occur in floating-point calculations. In general, there is a smallest nonzero magnitude that a floating-point type can represent. A calculation that would produce a smaller value would cause an underflow error. An overflow error can occur with either integer or floating-point types when the magnitude of the result of a calculation would exceed the largest representable value for that type. A computational result can lie outside the valid range of a function without being an underflow or overflow, and you can use the <code>range_error</code> exception for such situations.</p>
<p>In general, an exception of the <code>logic_error</code> family indicates a problem that is susceptible to a programming fix, whereas a <code>runtime_error</code> family exception is just a bit of unavoidable trouble. All these error classes have the same general characteristics. The main distinction is that the different class names allow you to handle each type of exception <a id="page_920"/>individually. On the other hand, the inheritance relationships allow you to lump them together if you prefer. For example, the following code catches the <code>out_of_bounds</code> exception individually, treats the remaining <code>logic_error</code> family of exceptions as a group and treats <code>exception</code> objects, the <code>runtime_error</code> family of objects and any remaining exception types derived from <code>exception</code> collectively:</p>
<p class="programlisting">try {<br/>...<br/>}<br/>catch(out_of_bounds &#38; oe) // catch out_of_bounds error<br/>{...}<br/>catch(logic_error &#38; oe)&#160;&#160;&#160;// catch remaining logic_error family<br/>{...}<br/>catch(exception &#38; oe)&#160;&#160;&#160;&#160;&#160;// catch runtime_error, exception objects<br/>{...}</p>
<p>If one of these library classes doesn&#8217;t meet your needs, it makes sense to derive an exception class from <code>logic_error</code> or <code>runtime_error</code> so that you can fit your exceptions into the same general hierarchy.</p>
<h5 id="ch15lev3sec7">The <code>bad_alloc</code> Exception and <code>new</code></h5>
<p>The current C++ way to handle memory allocation problems with <code>new</code> is to have <code>new</code> throw a <code>bad_alloc</code> exception. The <code>new</code> header includes a declaration for the <code>bad_alloc</code> class, which is publicly derived from the <code>exception</code> class. In the days of yore, however, <code>new</code> returned a null pointer when it couldn&#8217;t allocate the requested amount of memory.</p>
<p><a href="#ch15ex13">Listing 15.13</a> demonstrates the current approach. If the exception is caught, the program displays the implementation-dependent message returned by the inherited <code>what()</code> method and terminates early.</p>
<p class="caption1"><a id="ch15ex13"/><strong>Listing 15.13. <code>newexcp.cpp</code></strong></p><hr/>
<p class="programlisting1">// newexcp.cpp -- the bad_alloc exception<br/>#include &lt;iostream&gt;<br/>#include &lt;new&gt;<br/>#include &lt;cstdlib&gt;&#160;&#160;// for exit(), EXIT_FAILURE<br/>using namespace std;<br/><br/>struct Big<br/>{<br/>&#160;&#160;&#160;&#160;double stuff[20000];<br/>};<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Big * pb;<br/>&#160;&#160;&#160;&#160;try {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Trying to get a big block of memory:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pb = new Big[10000]; // 1,600,000,000 bytes<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Got past the new request:\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;catch (bad_alloc &#38; ba)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Caught the exception!\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ba.what() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Memory successfully allocated\n";<br/>&#160;&#160;&#160;&#160;pb[0].stuff[0] = 4;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pb[0].stuff[0] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;delete [] pb;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_921"/>Here&#8217;s the output for one system:</p>
<p class="programlisting">Trying to get a big block of memory:<br/>Caught the exception!<br/>std::bad_alloc</p>
<p>In this case, the <code>what()</code> method returns the string <code>"std::bad_alloc"</code>.</p>
<p>If the program runs without allocation problems on your system, you can try increasing the amount of memory requested.</p>
<h5 id="ch15lev3sec8">The Null Pointer and <code>new</code></h5>
<p>Much code was written when <code>new</code> (the old <code>new</code>) returned a null pointer upon failure. Some compilers handled the transition to the new <code>new</code> by letting the user set a flag or switch to choose which behavior she wanted. Currently, the standard provides for an alternative form of <code>new</code> that still returns a null pointer. Its use looks like this:</p>
<p class="programlisting">int * pi = new (std::nothrow) int;<br/>int * pa = new (std::nowthrow) int[500];</p>
<p>Using this form, you could rewrite the core of <a href="#ch15ex13">Listing 15.13</a> this way:</p>
<p class="programlisting">Big * pb;<br/><br/><br/>pb = new (std::nothrow) Big[10000]; // 1,600,000,000 bytes<br/>if (pb == 0)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Could not allocate memory. Bye.\n";<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}</p>
<h4 id="ch15lev2sec15">Exceptions, Classes, and Inheritance</h4>
<p><a id="page_922"/>Exceptions, classes, and inheritance interact in a couple ways. First, you can derive one exception class from another, as the standard C++ library does. Second, you can incorporate exceptions into classes by nesting exception class declarations inside a class definition. Third, such nested declarations can be inherited and can serve as base classes themselves.</p>
<p><a href="#ch15ex14">Listing 15.14</a> starts us on the way to exploring some of these possibilities. This header file declares a rudimentary <code>Sales</code> class that holds a year value and an array of 12 monthly sales figures. The <code>LabeledSales</code> class derives from <code>Sales</code> and adds a member to hold a label for the data.</p>
<p class="caption1"><a id="ch15ex14"/><strong>Listing 15.14. <code>sales.h</code></strong></p><hr/>
<p class="programlisting1">// sales.h&#160;&#160;-- exceptions and inheritance<br/>#include &lt;stdexcept&gt;<br/>#include &lt;string&gt;<br/><br/>class Sales<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;enum {MONTHS = 12};&#160;&#160;&#160;// could be a static const<br/>&#160;&#160;&#160;&#160;class bad_index : public std::logic_error<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bi;&#160;&#160;// bad index value<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;explicit bad_index(int ix,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38; s = "Index error in Sales object\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bi_val() const {return bi;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;virtual ~bad_index() throw() {}<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;explicit Sales(int yy = 0);<br/>&#160;&#160;&#160;&#160;Sales(int yy, const double * gr, int n);<br/>&#160;&#160;&#160;&#160;virtual ~Sales() { }<br/>&#160;&#160;&#160;&#160;int Year() const { return year; }<br/>&#160;&#160;&#160;&#160;virtual double operator[](int i) const;<br/>&#160;&#160;&#160;&#160;virtual double &#38; operator[](int i);<br/>private:<br/>&#160;&#160;&#160;&#160;double gross[MONTHS];<br/>&#160;&#160;&#160;&#160;int year;<br/>};<br/><br/>class LabeledSales : public Sales<br/>{<br/>&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;class nbad_index : public Sales::bad_index<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::string lbl;<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nbad_index(const std::string &#38; lb, int ix,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38; s = "Index error in LabeledSales object\n");<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38; label_val() const {return lbl;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;virtual ~nbad_index() throw() {}<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;explicit LabeledSales(const std::string &#38; lb = "none", int yy = 0);<br/>&#160;&#160;&#160;&#160;LabeledSales(const std::string &#38; lb, int yy, const double * gr, int n);<br/>&#160;&#160;&#160;&#160;virtual ~LabeledSales() { }<br/>&#160;&#160;&#160;&#160;const std::string &#38; Label() const {return label;}<br/>&#160;&#160;&#160;&#160;virtual double operator[](int i) const;<br/>&#160;&#160;&#160;&#160;virtual double &#38; operator[](int i);<br/>private:<br/>&#160;&#160;&#160;&#160;std::string label;<br/>};</p><hr/>
<p><a id="page_923"/>Let&#8217;s examine a few details of <a href="#ch15ex14">Listing 15.14</a>. First, the symbolic constant <code>MONTHS</code> is in the protected section of <code>Sales</code>; this makes the value available to derived classes, such as <code>LabeledSales</code>.</p>
<p>Next, the <code>bad_index</code> class is nested in the public section of <code>Sales</code>; this makes the class available as a type to client <code>catch</code> blocks. Note that the outside world requires the type to be identified as <code>Sales::bad_index</code>. This class derives from the standard <code>logic_error</code> class. The <code>bad_index</code> class has the ability to store and report an out-of-bounds value for an array index.</p>
<p>The <code>nbad_index</code> class is nested in the public section of <code>LabeledSales</code>, making it available to client code as <code>LabeledSales::nbad_index</code>. It derives from <code>bad_index</code>, adding the ability to store and report the label of a <code>LabeledSales</code> object. Because <code>bad_index</code> derives from <code>logic_error</code>, <code>nbad_index</code> also ultimately derives from <code>logic_error</code>.</p>
<p>Both classes have overloaded <code>operator[]()</code> methods that are designed to access the individual array elements stored in an object and to throw an exception if an index is out of bounds.</p>
<p>Both the <code>bad_index</code> and <code>nbad_index</code> classes use the <code>throw()</code> exception specification. The reason is that both eventually inherit from the <code>exception</code> base class, and its virtual destructor uses the <code>throw()</code> exception specification. This is a C++98 feature; under C++11, the <code>exception</code> destructor doesn&#8217;t have an exception specification.</p>
<p><a href="#ch15ex15">Listing 15.15</a> shows the implementation of the methods that weren&#8217;t already defined inline in <a href="#ch15ex14">Listing 15.14</a>. Note that nested classes require using the scope-resolution operator more than once. Also note that the <code>operator[]()</code> functions throw exceptions if the array index is out of bounds.</p>
<p class="caption1"><a id="page_924"/><a id="ch15ex15"/><strong>Listing 15.15. <code>sales.cpp</code></strong></p><hr/>
<p class="programlisting1">// sales.cpp -- Sales implementation<br/>#include "sales.h"<br/>using std::string;<br/><br/>Sales::bad_index::bad_index(int ix, const string &#38; s )<br/>&#160;&#160;&#160;&#160;: std::logic_error(s), bi(ix)<br/>{<br/>}<br/><br/>Sales::Sales(int yy)<br/>{<br/>&#160;&#160;&#160;&#160;year = yy;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; MONTHS; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gross[i] = 0;<br/>}<br/><br/>Sales::Sales(int yy, const double * gr, int n)<br/>{<br/>&#160;&#160;&#160;&#160;year = yy;<br/>&#160;&#160;&#160;&#160;int lim = (n &lt; MONTHS)? n : MONTHS;<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; lim; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gross[i] = gr[i];<br/>&#160;&#160;&#160;&#160;// for i &gt; n and i &lt; MONTHS<br/>&#160;&#160;&#160;&#160;for ( ; i &lt; MONTHS; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;gross[i] = 0;<br/>}<br/><br/>double Sales::operator[](int i) const<br/>{<br/>&#160;&#160;&#160;&#160;if(i &lt; 0 || i &gt;= MONTHS)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_index(i);<br/>&#160;&#160;&#160;&#160;return gross[i];<br/>}<br/><br/>double &#38; Sales::operator[](int i)<br/>{<br/>&#160;&#160;&#160;&#160;if(i &lt; 0 || i &gt;= MONTHS)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_index(i);<br/>&#160;&#160;&#160;&#160;return gross[i];<br/>}<br/><br/>LabeledSales::nbad_index::nbad_index(const string &#38; lb, int ix,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const string &#38; s ) : Sales::bad_index(ix, s)<br/>{<br/>&#160;&#160;&#160;&#160;lbl = lb;<br/>}<br/><br/>LabeledSales::LabeledSales(const string &#38; lb, int yy)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Sales(yy)<br/>{<br/>&#160;&#160;&#160;&#160;label = lb;<br/>}<br/><br/>LabeledSales::LabeledSales(const string &#38; lb, int yy,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const double * gr, int n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Sales(yy, gr, n)<br/>{<br/>&#160;&#160;&#160;&#160;label = lb;<br/>}<br/><br/>double LabeledSales::operator[](int i) const<br/>{&#160;&#160;&#160;&#160;if(i &lt; 0 || i &gt;= MONTHS)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw nbad_index(Label(), i);<br/>&#160;&#160;&#160;&#160;return Sales::operator[](i);<br/>}<br/><br/>double &#38; LabeledSales::operator[](int i)<br/>{<br/>&#160;&#160;&#160;&#160;if(i &lt; 0 || i &gt;= MONTHS)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw nbad_index(Label(), i);<br/>&#160;&#160;&#160;&#160;return Sales::operator[](i);<br/>}</p><hr/>
<p><a id="page_925"/><a href="#ch15ex16">Listing 15.16</a> uses the classes in a program that first tries to go beyond the end of the array in the <code>LabeledSales</code> object <code>sales2</code> and then beyond the end of the array in the <code>Sales</code> object <code>sales1</code>. These attempts are made in two separate <code>try</code> blocks that test for each kind of exception.</p>
<p class="caption1"><a id="ch15ex16"/><strong>Listing 15.16. <code>use_sales.cpp</code></strong></p><hr/>
<p class="programlisting1">// use_sales.cpp&#160;&#160;-- nested exceptions<br/>#include &lt;iostream&gt;<br/>#include "sales.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/><a id="page_926"/>&#160;&#160;&#160;&#160;double vals1[12] =<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1220, 1100, 1122, 2212, 1232, 2334,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2884, 2393, 3302, 2922, 3002, 3544<br/>&#160;&#160;&#160;&#160;};<br/><br/>&#160;&#160;&#160;&#160;double vals2[12] =<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12, 11, 22, 21, 32, 34,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;28, 29, 33, 29, 32, 35<br/>&#160;&#160;&#160;&#160;};<br/><br/>&#160;&#160;&#160;&#160;Sales sales1(2011, vals1, 12);<br/>&#160;&#160;&#160;&#160;LabeledSales sales2("Blogstar",2012, vals2, 12 );<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "First try block:\n";<br/>&#160;&#160;&#160;&#160;try<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Year = " &lt;&lt; sales1.Year() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 0; i &lt; 12; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; sales1[i] &lt;&lt; ' ';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % 6 == 5)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Year = " &lt;&lt; sales2.Year() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Label = " &lt;&lt; sales2.Label() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 0; i &lt;= 12; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; sales2[i] &lt;&lt; ' ';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % 6 == 5)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "End of try block 1.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;catch(LabeledSales::nbad_index &#38; bad)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; bad.what();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Company: " &lt;&lt; bad.label_val() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "bad index: " &lt;&lt; bad.bi_val() &lt;&lt; endl;<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;catch(Sales::bad_index &#38; bad)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; bad.what();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "bad index: " &lt;&lt; bad.bi_val() &lt;&lt; endl;<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;cout &lt;&lt; "\nNext try block:\n";<br/>&#160;&#160;&#160;try<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sales2[2] = 37.5;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sales1[20] = 23345;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "End of try block 2.\n";<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;catch(LabeledSales::nbad_index &#38; bad)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; bad.what();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Company: " &lt;&lt; bad.label_val() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "bad index: " &lt;&lt; bad.bi_val() &lt;&lt; endl;<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;catch(Sales::bad_index &#38; bad)<br/>&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; bad.what();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "bad index: " &lt;&lt; bad.bi_val() &lt;&lt; endl;<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;cout &lt;&lt; "done\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_927"/>Here is the output of the program in <a href="#ch15ex14">Listings 15.14</a>, <a href="#ch15ex15">15.15</a>, and <a href="#ch15ex16">15.16</a>:</p>
<p class="programlisting">First try block:<br/>Year = 2011<br/>1220 1100 1122 2212 1232 2334<br/>2884 2393 3302 2922 3002 3544<br/>Year = 2012<br/>Label = Blogstar<br/>12 11 22 21 32 34<br/>28 29 33 29 32 35<br/>Index error in LabeledSales object<br/>Company: Blogstar<br/>bad index: 12<br/><br/>Next try block:<br/>Index error in Sales object<br/>bad index: 20<br/>done</p>
<h4 id="ch15lev2sec16">When Exceptions Go Astray</h4>
<p><a id="page_928"/>After an exception is thrown, it has two opportunities to cause problems. First, if it is thrown in a function that has an exception specification, it has to match one of the types in the specification list. (Remember that in an inheritance hierarchy, a class type matches objects of that type and of types descended from it.) If the exception doesn&#8217;t match the specification, the unmatched exception is branded an <em>unexpected exception</em>, and, by default, it causes the program to abort. (Although C++11 deprecates exception specifications, they still remain in the language and in some existing code.) If the exception passes this first hurdle (or avoids it because the function lacks an exception specification), it then has to be caught. If it isn&#8217;t, which can happen if there is no containing <code>try</code> block or no matching <code>catch</code> block, the exception is branded an <em>uncaught exception</em>, and by default, it causes the program to abort. However, you can alter a program&#8217;s response to unexpected and uncaught exceptions. Let&#8217;s see how, beginning with uncaught exceptions.</p>
<p>An uncaught exception doesn&#8217;t initiate an immediate abort. Instead, the program first calls a function called <code>terminate()</code>. By default, <code>terminate()</code> calls the <code>abort()</code> function. You can modify the behavior of <code>terminate()</code> by <em>registering</em> a function that <code>terminate()</code> should call instead of <code>abort()</code>. To do this, you call the <code>set_terminate()</code> function. Both <code>set_terminate()</code> and <code>terminate()</code> are declared in the <code>exception</code> header file:</p>
<p class="programlisting">typedef void (*terminate_handler)();<br/>terminate_handler set_terminate(terminate_handler f) throw();&#160;&#160;// C++98<br/>terminate_handler set_terminate(terminate_handler f) noexcept; // C++11<br/>void terminate();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C++98<br/>void terminate() noexcept;&#160;&#160;&#160;// C++11</p>
<p>Here the <code>typedef</code> makes <code>terminate_handler</code> the type name for a pointer to a function that has no arguments and no return value. The <code>set_terminate()</code> function takes, as its argument, the name of a function (that is, its address) that has no arguments and the <code>void</code> return type. It returns the address of the previously registered function. If you call the <code>set_terminate()</code> function more than once, <code>terminate()</code> calls the function set by the most recent call to <code>set_terminate()</code>.</p>
<p>Let&#8217;s look at an example. Suppose you want an uncaught exception to cause a program to print a message to that effect and then call the <code>exit()</code> function, providing an exit status value of <code>5</code>. First, you include the <code>exception</code> header file. You can make its declarations available with a <code>using</code> directive or appropriate <code>using</code> declarations, or you can use the <code>std::</code> qualifier:</p>
<p class="programlisting">#include &lt;exception&gt;<br/>using namespace std;</p>
<p>Next, you design a function that does the two required actions and has the proper prototype:</p>
<p class="programlisting">void myQuit()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Terminating due to uncaught exception\n";<br/><a id="page_929"/>&#160;&#160;&#160;&#160;exit(5);<br/>}</p>
<p>Finally, at the start of the program, you designate this function as your chosen termination action:</p>
<p class="programlisting">set_terminate(myQuit);</p>
<p>Now, if an exception is thrown and not caught, the program calls <code>terminate()</code>, and <code>terminate()</code> calls <code>MyQuit()</code>.</p>
<p>Next, let&#8217;s look at unexpected exceptions. By using exception specifications for a function, you provide the means for users of the functions to know which exceptions to catch. That is, suppose you have the following prototype:</p>
<p class="programlisting">double Argh(double, double) throw(out_of_bounds);</p>
<p>Then you might use the function this way:</p>
<p class="programlisting">try {<br/>&#160;&#160;&#160;&#160;x = Argh(a, b);<br/>}<br/>catch(out_of_bounds &#38; ex)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>It&#8217;s good to know which exceptions to catch; recall that an uncaught exception, by default, aborts the program.</p>
<p>However, there&#8217;s a bit more to the story. In principle, the exception specification should include exceptions thrown by functions called by the function in question. For example, if <code>Argh()</code> calls a <code>Duh()</code> function that can throw a <code>retort</code> object exception, then <code>retort</code> should appear in the <code>Argh()</code> exception specification as well as in the <code>Duh()</code> exception specification. Unless you write all the functions yourself and are careful, there&#8217;s no guarantee that this will get done correctly. You might, for example, use an older commercial library whose functions don&#8217;t have exception specifications. This suggests that you should look more closely at what happens if a function throws an exception that is not in its exception specification. (It also suggests that the whole exception specification mechanism might be unwieldy, which is part of the reason C++11 deprecates it.)</p>
<p>The behavior is much like that for uncaught exceptions. If there is an unexpected exception, the program calls the <code>unexpected()</code> function. (You didn&#8217;t expect the <code>unexpected()</code> function? No one expects the <code>unexpected()</code> function!) This function, in turn, calls <code>terminate()</code>, which, by default, calls <code>abort()</code>. Just as there is a <code>set_terminate()</code> function that modifies the behavior of <code>terminate()</code>, there is a <code>set_unexpected()</code> function that modifies the behavior of <code>unexpected()</code>. These new functions are also declared in the exception header file:</p>
<p class="programlisting">typedef void (*unexpected_handler)();<br/>unexpected_handler set_unexpected(unexpected_handler f) throw();&#160;&#160;&#160;// C++98<br/>unexpected_handler set_unexpected(unexpected_handler f) noexcept;&#160;&#160;// C++11<br/><a id="page_930"/>void unexpected();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C++98<br/>void unexpected() noexcept;&#160;&#160;// C+0x</p>
<p>However, the behavior of the function you supply for <code>set_unexpected()</code> is more regulated than that of a function for <code>set_terminate()</code>. In particular, the <code>unexpected_handler</code> function has the following choices:</p>
<p class="indenthandingB">&#8226; It can end the program by calling <code>terminate()</code> (the default behavior), <code>abort()</code>, or <code>exit()</code>.</p>
<p class="indenthandingB">&#8226; It can throw an exception.</p>
<p>The result of throwing an exception (the second choice here) depends on the exception thrown by the replacement <code>unexpected_handler</code> function and the original exception specification for the function that threw the unexpected type:</p>
<p class="indenthandingB">&#8226; If the newly thrown exception matches the original exception specification, then the program proceeds normally from there; that is, it will look for a <code>catch</code> block that matches the newly thrown exception. Basically, this approach replaces an exception of an unexpected type to an exception of an expected type.</p>
<p class="indenthandingB">&#8226; If the newly thrown exception does not match the original exception specification and if the exception specification <em>does not</em> include the <code>std::bad_exception</code> type, the program calls <code>terminate()</code>. The <code>bad_exception</code> type derives from the <code>exception</code> type and is declared in the <code>exception</code> header file.</p>
<p class="indenthandingB">&#8226; If the newly thrown exception does not match the original exception specification and if the original exception specification <em>does</em> include the <code>std::bad_exception</code> type, the unmatched exception is replaced with an exception of the <code>std::bad_exception</code> type.</p>
<p>In short, if you&#8217;d like to catch all exceptions, expected or otherwise, you can do something like the following. First, you make sure the exception header file declarations are available:</p>
<p class="programlisting">#include &lt;exception&gt;<br/>using namespace std;</p>
<p>Next, you design a replacement function that converts unexpected exceptions to the <code>bad_exception</code> type and that has the proper prototype:</p>
<p class="programlisting">void myUnexpected()<br/>{<br/>&#160;&#160;&#160;&#160;throw std::bad_exception();&#160;&#160;//or just throw;<br/>}</p>
<p>Just using <code>throw</code> without an exception causes the original exception to be rethrown. However, the exception will be replaced with a <code>bad_exception</code> object if the exception specification includes that type.</p>
<p><a id="page_931"/>Next, at the start of the program, you designate this function as your chosen unexpected exception action:</p>
<p class="programlisting">set_unexpected(myUnexpected);</p>
<p>Finally, you include the <code>bad_exception</code> type in exception specifications and <code>catch</code> block sequences:</p>
<p class="programlisting">double Argh(double, double) throw(out_of_bounds, bad_exception);<br/>...<br/>try {<br/>&#160;&#160;&#160;&#160;x = Argh(a, b);<br/>}<br/>catch(out_of_bounds &#38; ex)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}<br/>catch(bad_exception &#38; ex)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<h4 id="ch15lev2sec17">Exception Cautions</h4>
<p>From the preceding discussion of using exceptions, you might gather (and gather correctly) that exception handling should be designed into a program rather than tacked on. Doing this has some disadvantages, though. For example, using exceptions adds to the size and subtracts from the speed of a program. Exception specifications don&#8217;t work well with templates because template functions might throw different kinds of exceptions, depending on the particular specialization used. Exceptions and dynamic memory allocation don&#8217;t always work that well together.</p>
<p>Let&#8217;s look a little further at dynamic memory allocation and exceptions. First, consider the following function:</p>
<p class="programlisting">void test1(int n)<br/>{<br/>&#160;&#160;&#160;&#160;string mesg("I'm trapped in an endless loop");<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;if (oh_no)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw exception();<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;return;<br/>}</p>
<p>The <code>string</code> class uses dynamic memory allocation. Normally, the <code>string</code> destructor for <code>mesg</code> would be called when the function reached <code>return</code> and terminated. Thanks to stack unwinding, the <code>throw</code> statement, even though it terminates the function prematurely, still allows the destructor to be called. So in this case, memory is managed properly.</p>
<p><a id="page_932"/>Now consider this function:</p>
<p class="programlisting">void test2(int n)<br/>{<br/>&#160;&#160;&#160;&#160;double * ar = new double[n];<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;if (oh_no)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw exception();<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;delete [] ar;<br/>&#160;&#160;&#160;&#160;return;<br/>}</p>
<p>Here there is a problem. Unwinding the stack removes the variable <code>ar</code> from the stack. But the premature termination of the function means that the <code>delete []</code> statement at the end of the function is skipped. The pointer is gone, but the memory block it pointed to is still intact and inaccessible. In short, there is a memory leak.</p>
<p>The leak can be avoided. For example, you can catch the exception in the same function that throws it, put some cleanup code into the <code>catch</code> block, and rethrow the exception:</p>
<p class="programlisting">void test3(int n)<br/>{<br/>&#160;&#160;&#160;&#160;double * ar = new double[n];<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;try {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (oh_no)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw exception();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;catch(exception &#38; ex)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete [] ar;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;delete [] ar;<br/>&#160;&#160;&#160;&#160;return;<br/>}</p>
<p>However, this clearly enhances the opportunities for oversights and other errors. Another solution is to use one of the smart pointer templates discussed in <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library.&#8221;</p>
<p>In short, although exception handling is extremely important for some projects, it does have costs in terms of programming effort, program size, and program speed. On the other hand, the cost of no error checking can be much worse.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch15sb01"/><a id="page_933"/>Exception Handling</p>
<p class="sidebarpara">In modern libraries, exception handling can appear to reach new levels of complexity&#8212;much of it due to undocumented or poorly documented exception-handling routines. Anyone familiar with the use of a modern operating system has surely seen the errors and problems caused by unhandled exceptions. The programmers behind these errors often face an uphill battle, learning the complexity that lies within the libraries: what exceptions are thrown, why and when they occur, and how to handle them.</p>
<p class="sidebarpara">A novice programmer quickly finds that the research battle to understand exception handling in a library is as difficult as the struggle to learn the language itself; modern libraries can contain routines and paradigms as alien and difficult as any C++ syntax detail. Exposure to and understanding of the intricacies of libraries and classes is, for good software, as necessary as the time you spend learning C++ itself. The exception and error-handling details you decipher from your libraries&#8217; documentation and source code will always serve you and your software in good stead.</p>
<hr/></div>
<h3 id="ch15lev1sec4">Runtime Type Identification</h3>
<p><em>Runtime type identification (RTTI)</em> is one of the more recent additions to C++, and it isn&#8217;t supported by many older implementations. Other implementations may have compiler settings for turning RTTI on and off. The intent of RTTI is to provide a standard way for a program to determine the type of object during runtime. Many class libraries have already provided ways to do so for their own class objects, but in the absence of built-in support in C++, each vendor&#8217;s mechanism is typically incompatible with those of other vendors. Creating a language standard for RTTI should allow future libraries to be compatible with each other.</p>
<h4 id="ch15lev2sec18">What Is RTTI For?</h4>
<p>Suppose you have a hierarchy of classes descended from a common base class. You can set a base-class pointer to point to an object of any of the classes in this hierarchy. Next, you call a function that, after processing some information, selects one of these classes, creates an object of that type, and returns its address, which gets assigned to a base-class pointer. How can you tell what kind of object it points to?</p>
<p>Before answering this question, you need to think about why you would want to know the type. Perhaps you want to invoke the correct version of a class method. If that&#8217;s the case, you don&#8217;t really need to know the object type, as long as that function is a virtual function possessed by all members of the class hierarchy. But it could be that a derived object has an uninherited method. In that case, only some objects could use the method. Or maybe, for debugging purposes, you would like to keep track of which kinds of objects were generated. For these last two cases, RTTI provides an answer.</p>
<h4 id="ch15lev2sec19">How Does RTTI Work?</h4>
<p><a id="page_934"/>C++ has three components supporting RTTI:</p>
<p class="indenthandingB">&#8226; The <code>dynamic_cast</code> operator generates a pointer to a derived type from a pointer to a base type, if possible. Otherwise, the operator returns <code>0</code>, the null pointer.</p>
<p class="indenthandingB">&#8226; The <code>typeid</code> operator returns a value identifying the exact type of an object.</p>
<p class="indenthandingB">&#8226; A <code>type_info</code> structure holds information about a particular type.</p>
<p>You can use RTTI only with a class hierarchy that has virtual functions. The reason for this is that these are the only class hierarchies for which you should be assigning the addresses of derived objects to base-class pointers.</p>
<div class="note"><hr/>
<p class="title"><a id="ch15note02"/>Caution</p>
<p class="notepara">RTTI works only for classes that have virtual functions.</p>
<hr/></div>
<p>Let&#8217;s examine the three components of RTTI.</p>
<h5 id="ch15lev3sec9">The <code>dynamic_cast</code> Operator</h5>
<p>The <code>dynamic_cast</code> operator is intended to be the most heavily used RTTI component. It doesn&#8217;t answer the question of what type of object a pointer points to. Instead, it answers the question of whether you can safely assign the address of an object to a pointer of a particular type. Let&#8217;s look at what that means. Suppose you have the following hierarchy:</p>
<p class="programlistingB">class Grand { // has virtual methods};<br/>class Superb : public Grand { ... };<br/>class Magnificent : public Superb { ... };</p>
<p>Next, suppose you have the following pointers:</p>
<p class="programlisting">Grand * pg = new Grand;<br/>Grand * ps = new Superb;<br/>Grand * pm = new Magnificent;</p>
<p>Finally, consider the following type casts:</p>
<p class="programlisting">Magnificent * p1 = (Magnificent *) pm;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #1<br/>Magnificent * p2 = (Magnificent *) pg;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #2<br/>Superb * p3 = (Magnificent *) pm;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #3</p>
<p>Which of these type casts are safe? Depending on the class declarations, all of them could be safe, but the only ones guaranteed to be safe are the ones in which the pointer is the same type as the object or else a direct or indirect base type for the object. For example, Type Cast #1 is safe because it sets a type <code>Magnificent</code> pointer to point to a type <code>Magnificent</code> object. Type Cast #2 is not safe because it assigns the address of a base-class object (<code>Grand</code>) to a derived-class (<code>Magnificent</code>) pointer. Thus, the program would expect the base-class object to have derived-class properties, and that, in general, is false. A <code>Magnificent</code> object, for example, might have data members that a <code>Grand</code> object would <a id="page_935"/>lack. Type Cast #3, however, is safe because it assigns the address of a derived-class object to a base-class pointer. That is, public derivation promises that a <code>Magnificent</code> object also is a <code>Superb</code> object (direct base) and a <code>Grand</code> object (indirect base). Thus, it&#8217;s safe to assign its address to pointers of all three types. Virtual functions ensure that using pointers of any of the three types to a <code>Magnificent</code> object will invoke <code>Magnificent</code> methods.</p>
<p>Note that the question of whether a type conversion is safe is both more general and more useful than the question of what kind of object is pointed to. The usual reason for wanting to know the type is so that you can know if it&#8217;s safe to invoke a particular method. You don&#8217;t necessarily need an exact type match to invoke a method. The type can be a base type for which a virtual version of the method is defined. The next example illustrates this point.</p>
<p>First, however, let&#8217;s look at the <code>dynamic_cast</code> syntax. The operator is used like this, where <code>pg</code> points to an object:</p>
<p class="programlisting">Superb * pm = dynamic_cast&lt;Superb *&gt;(pg);</p>
<p>This code asks whether the pointer <code>pg</code> can be type cast safely (as described previously) to the type <code>Superb *</code>. If it can, the operator returns the address of the object. Otherwise it returns <code>0</code>, the null pointer.</p>
<div class="note"><hr/>
<p class="title"><a id="ch15note03"/>Note</p>
<p class="notepara">In general, the following expression converts the pointer <code>pt</code> to a pointer of type <code>Type *</code> if the pointed-to object (<code>*pt</code>) is of type <code>Type</code> or else derived directly or indirectly from type <code>Type</code>:</p>
<p class="programlistingB">dynamic_cast&lt;Type *&gt;(pt)</p>
<p class="notepara">Otherwise, the expression evaluates to <code>0</code>, the null pointer.</p>
<hr/></div>
<p><a href="#ch15ex17">Listing 15.17</a> illustrates the process. First it defines three classes, coincidentally named <code>Grand</code>, <code>Superb</code>, and <code>Magnificent</code>. The <code>Grand</code> class defines a virtual <code>Speak()</code> function, which each of the other classes redefines. The <code>Superb</code> class defines a virtual <code>Say()</code> function, which <code>Magnificent</code> redefines (see <a href="#ch15fig04">Figure 15.4</a>). The program defines a <code>GetOne()</code> function that randomly creates and initializes an object of one of these three types and then returns the address as a type <code>Grand *</code> pointer. (The <code>GetOne()</code> function simulates an interactive user making decisions.) A loop assigns this pointer to a type <code>Grand *</code> variable called <code>pg</code> and then uses <code>pg</code> to invoke the <code>Speak()</code> function. Because this function is virtual, the code correctly invokes the <code>Speak()</code> version that is appropriate to the pointed-to object:</p>
<p class="programlisting">for (int i = 0; i &lt; 5; i++)<br/>{<br/>&#160;&#160;&#160;&#160;pg = GetOne();<br/>&#160;&#160;&#160;&#160;pg-&gt;Speak();<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p class="caption"><a id="page_936"/><a id="ch15fig04"/><strong>Figure 15.4. The <code>Grand</code> family of classes.</strong></p>
<p class="image"><img src="graphics/15fig04.jpg" alt="Image"/></p>
<p>You can&#8217;t use this exact approach (using a pointer-to-<code>Grand</code>) to invoke the <code>Say()</code> function; it&#8217;s not defined for the <code>Grand</code> class. However, you can use the <code>dynamic_cast</code> operator to see if <code>pg</code> can be type cast to a pointer to <code>Superb</code>. This will be true if the object is either type <code>Superb</code> or <code>Magnificent</code>. In either case, you can invoke the <code>Say()</code> function safely:</p>
<p class="programlisting">if (ps = dynamic_cast&lt;Superb *&gt;(pg))<br/>&#160;&#160;&#160;&#160;ps-&gt;Say();</p>
<p>Recall that the value of an assignment expression is the value of its left-hand side. Thus, the value of the <code>if</code> condition is <code>ps</code>. If the type cast succeeds, <code>ps</code> is nonzero, or true. If the type cast fails, which it will if <code>pg</code> points to a <code>Grand</code> object, <code>ps</code> is zero, or false. <a href="#ch15ex17">Listing 15.17</a> shows the full code. (By the way, some compilers, noting that programmers usually use the <code>==</code> operator in an <code>if</code> statement condition, may issue a warning about unintended assignment.)</p>
<p class="caption1"><a id="ch15ex17"/><strong>Listing 15.17. <code>rtti1.cpp</code></strong></p><hr/>
<p class="programlisting1">// rtti1.cpp -- using the RTTI dynamic_cast operator<br/>#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/><br/>using std::cout;<br/><br/><a id="page_937"/>class Grand<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int hold;<br/>public:<br/>&#160;&#160;&#160;&#160;Grand(int h = 0) : hold(h) {}<br/>&#160;&#160;&#160;&#160;virtual void Speak() const { cout &lt;&lt; "I am a grand class!\n";}<br/>&#160;&#160;&#160;&#160;virtual int Value() const { return hold; }<br/>};<br/><br/>class Superb : public Grand<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;Superb(int h = 0) : Grand(h) {}<br/>&#160;&#160;&#160;&#160;void Speak() const {cout &lt;&lt; "I am a superb class!!\n"; }<br/>&#160;&#160;&#160;&#160;virtual void Say() const<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ cout &lt;&lt; "I hold the superb value of " &lt;&lt; Value() &lt;&lt; "!\n";}<br/>};<br/><br/>class Magnificent : public Superb<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char ch;<br/>public:<br/>&#160;&#160;&#160;&#160;Magnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}<br/>&#160;&#160;&#160;&#160;void Speak() const {cout &lt;&lt; "I am a magnificent class!!!\n";}<br/>&#160;&#160;&#160;&#160;void Say() const {cout &lt;&lt; "I hold the character " &lt;&lt; ch &lt;&lt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" and the integer "&#160;&#160;&lt;&lt; Value() &lt;&lt; "!\n"; }<br/>};<br/><br/>Grand * GetOne();<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;std::srand(std::time(0));<br/>&#160;&#160;&#160;&#160;Grand * pg;<br/>&#160;&#160;&#160;&#160;Superb * ps;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 5; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pg = GetOne();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pg-&gt;Speak();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if( ps = dynamic_cast&lt;Superb *&gt;(pg))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;Say();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>Grand * GetOne()&#160;&#160;&#160;&#160;// generate one of three kinds of objects randomly<br/>{<br/>&#160;&#160;&#160;&#160;Grand * p;<br/>&#160;&#160;&#160;&#160;switch( std::rand() % 3)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0: p = new Grand(std::rand() % 100);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 1: p = new Superb(std::rand() % 100);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 2: p = new Magnificent(std::rand() % 100,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'A' + std::rand() % 26);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return p;<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch15note04"/><a id="page_938"/>Note</p>
<p class="notepara">Even if your compiler supports RTTI, it might have that feature turned off by default. If the feature is inactive, the program may still compile but produce runtime errors. If you find this to be the case, you should check your documentation or explore the menu options.</p>
<hr/></div>
<p>The program in <a href="#ch15ex17">Listing 15.17</a> illustrates an important point. You should use virtual functions when possible and RTTI only when necessary. Here is some sample output:</p>
<p class="programlisting">I am a superb class!!<br/>I hold the superb value of 68!<br/>I am a magnificent class!!!<br/>I hold the character R and the integer 68!<br/>I am a magnificent class!!!<br/>I hold the character D and the integer 12!<br/>I am a magnificent class!!!<br/>I hold the character V and the integer 59!<br/>I am a grand class!</p>
<p>As you can see, the <code>Say()</code> methods were invoked just for the <code>Superb</code> and <code>Magnificent</code> classes. (The output will vary from run to run because the program uses <code>rand()</code> to select the object type.)</p>
<p>You can use <code>dynamic_cast</code> with references, too. The usage is slightly different; there is no reference value corresponding to the null-pointer type, so there&#8217;s no special reference value that can be used to indicate failure. Instead, when goaded by an improper request, <code>dynamic_cast</code> throws a type <code>bad_cast</code> exception, which is derived from the <code>exception</code> class and defined in the <code>typeinfo</code> header file. Thus, the operator can be used as follows, where <code>rg</code> is a reference to a <code>Grand</code> object:</p>
<p class="programlisting">#include &lt;typeinfo&gt; // for bad_cast<br/>...<br/>try {<br/><a id="page_939"/>&#160;&#160;&#160;&#160;Superb &#38; rs = dynamic_cast&lt;Superb &#38;&gt;(rg);<br/>&#160;&#160;&#160;&#160;...<br/>}<br/>catch(bad_cast &#38;){<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<h5 id="ch15lev3sec10">The <code>typeid</code> Operator and <code>type_info</code> Class</h5>
<p>The <code>typeid</code> operator lets you determine whether two objects are the same type. Somewhat like <code>sizeof</code>, it accepts two kinds of arguments:</p>
<p class="indenthandingB">&#8226; The name of a class</p>
<p class="indenthandingB">&#8226; An expression that evaluates to an object</p>
<p>The <code>typeid</code> operator returns a reference to a <code>type_info</code> object, where <code>type_info</code> is a class defined in the <code>typeinfo</code> header file (formerly <code>typeinfo.h</code>). The <code>type_info</code> class overloads the <code>==</code> and <code>!=</code> operators so that you can use these operators to compare types. For example, the following expression evaluates to the <code>bool</code> value <code>true</code> if <code>pg</code> points to a <code>Magnificent</code> object and to <code>false</code> otherwise:</p>
<p class="programlisting">typeid(Magnificent) == typeid(*pg)</p>
<p>If <code>pg</code> happens to be a null pointer, the program throws a <code>bad_typeid</code> exception. This exception type is derived from the <code>exception</code> class and is declared in the <code>typeinfo</code> header file.</p>
<p>The implementation of the <code>type_info</code> class varies among vendors, but it includes a <code>name()</code> member that returns an implementation-dependent string that is typically (but not necessarily) the name of the class. For example, the following statement displays the string defined for the class of the object to which the pointer <code>pg</code> points:</p>
<p class="programlisting">cout &lt;&lt; "Now processing type " &lt;&lt; typeid(*pg).name() &lt;&lt; ".\n";</p>
<p><a href="#ch15ex18">Listing 15.18</a> modifies <a href="#ch15ex17">Listing 15.17</a> so that it uses the <code>typeid</code> operator and the <code>name()</code> member function. Note that they are used for situations that <code>dynamic_cast</code> and <code>virtual</code> functions don&#8217;t handle. The <code>typeid</code> test is used to select an action that isn&#8217;t even a class method, so it can&#8217;t be invoked by a class pointer. The <code>name()</code> method statement shows how the method can be used in debugging. Note that the program includes the <code>typeinfo</code> header file.</p>
<p class="caption1"><a id="ch15ex18"/><strong>Listing 15.18. <code>rtti2.cpp</code></strong></p><hr/>
<p class="programlisting1">// rtti2.cpp&#160;&#160;-- using dynamic_cast, typeid, and type_info<br/>#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>#include &lt;typeinfo&gt;<br/>using namespace std;<br/><br/><a id="page_940"/>class Grand<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int hold;<br/>public:<br/>&#160;&#160;&#160;&#160;Grand(int h = 0) : hold(h) {}<br/>&#160;&#160;&#160;&#160;virtual void Speak() const { cout &lt;&lt; "I am a grand class!\n";}<br/>&#160;&#160;&#160;&#160;virtual int Value() const { return hold; }<br/>};<br/><br/>class Superb : public Grand<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;Superb(int h = 0) : Grand(h) {}<br/>&#160;&#160;&#160;&#160;void Speak() const {cout &lt;&lt; "I am a superb class!!\n"; }<br/>&#160;&#160;&#160;&#160;virtual void Say() const<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ cout &lt;&lt; "I hold the superb value of " &lt;&lt; Value() &lt;&lt; "!\n";}<br/>};<br/><br/>class Magnificent : public Superb<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char ch;<br/>public:<br/>&#160;&#160;&#160;&#160;Magnificent(int h = 0, char cv = 'A') : Superb(h), ch(cv) {}<br/>&#160;&#160;&#160;&#160;void Speak() const {cout &lt;&lt; "I am a magnificent class!!!\n";}<br/>&#160;&#160;&#160;&#160;void Say() const {cout &lt;&lt; "I hold the character " &lt;&lt; ch &lt;&lt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" and the integer "&#160;&#160;&lt;&lt; Value() &lt;&lt; "!\n"; }<br/>};<br/><br/>Grand * GetOne();<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;srand(time(0));<br/>&#160;&#160;&#160;&#160;Grand * pg;<br/>&#160;&#160;&#160;&#160;Superb * ps;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 5; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pg = GetOne();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Now processing type " &lt;&lt; typeid(*pg).name() &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pg-&gt;Speak();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if( ps = dynamic_cast&lt;Superb *&gt;(pg))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;Say();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (typeid(Magnificent) == typeid(*pg))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Yes, you're really magnificent.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>Grand * GetOne()<br/>{<br/>&#160;&#160;&#160;&#160;Grand * p;<br/><br/>&#160;&#160;&#160;&#160;switch( rand() % 3)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 0: p = new Grand(rand() % 100);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 1: p = new Superb(rand() % 100);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 2: p = new Magnificent(rand() % 100, 'A' + rand() % 26);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return p;<br/>}</p><hr/>
<p><a id="page_941"/>Here&#8217;s a sample run of the program in <a href="#ch15ex18">Listing 15.18</a>:</p>
<p class="programlisting">Now processing type Magnificent.<br/>I am a magnificent class!!!<br/>I hold the character P and the integer 52!<br/>Yes, you're really magnificent.<br/>Now processing type Superb.<br/>I am a superb class!!<br/>I hold the superb value of 37!<br/>Now processing type Grand.<br/>I am a grand class!<br/>Now processing type Superb.<br/>I am a superb class!!<br/>I hold the superb value of 18!<br/>Now processing type Grand.<br/>I am a grand class!</p>
<p>As with the preceding example, the exact output will vary from run to run because the program uses <code>rand()</code> to select types. Also some compilers may provide different output when <code>name()</code> is called, for example, <code>5Grand</code> instead of <code>Grand</code>.</p>
<h4 id="ch15lev2sec20">Misusing RTTI</h4>
<p>RTTI has many vocal critics within the C++ community. They view RTTI as unnecessary, a potential source of program inefficiency, and a possible contributor to bad programming practices. Without delving into the debate over RTTI, let&#8217;s look at the sort of programming that you should avoid.</p>
<p><a id="page_942"/>Consider the core of <a href="#ch15ex17">Listing 15.17</a>:</p>
<p class="programlisting">Grand * pg;<br/>Superb * ps;<br/>for (int i = 0; i &lt; 5; i++)<br/>{<br/>&#160;&#160;&#160;&#160;pg = GetOne();<br/>&#160;&#160;&#160;&#160;pg-&gt;Speak();<br/>&#160;&#160;&#160;&#160;if( ps = dynamic_cast&lt;Superb *&gt;(pg))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;Say();<br/>}</p>
<p>By using <code>typeid</code> and ignoring <code>dynamic_cast</code> and virtual functions, you can rewrite this code as follows:</p>
<p class="programlisting">Grand * pg;<br/>Superb * ps;<br/>Magnificent * pm;<br/>for (int i = 0; i &lt; 5; i++)<br/>{<br/>&#160;&#160;&#160;&#160;pg = GetOne();<br/>&#160;&#160;&#160;&#160;if (typeid(Magnificent) == typeid(*pg))<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pm = (Magnificent *) pg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pm-&gt;Speak();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pm-&gt;Say();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else if (typeid(Superb) == typeid(*pg))<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps = (Superb *) pg;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;Speak();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;Say();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pg-&gt;Speak();<br/>}</p>
<p>Not only is this uglier and longer than the original, it has the serious flaw of naming each class explicitly. Suppose, for example, that you find it necessary to derive an <code>Insufferable</code> class from the <code>Magnificent</code> class. And suppose the new class redefines <code>Speak()</code> and <code>Say()</code>. With the version that uses <code>typeid</code> to test explicitly for each type, you would have to modify the <code>for</code> loop code, adding a new <code>else if</code> section. The original version, however, requires no changes at all. The following statement works for all classes derived from <code>Grand</code>:</p>
<p class="programlisting">pg-&gt;Speak();</p>
<p>And this statement works for all classes derived from <code>Superb</code>:</p>
<p class="programlisting">if( ps = dynamic_cast&lt;Superb *&gt;(pg))<br/>&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;Say();</p>
<div class="note"><hr/>
<p class="title"><a id="ch15note05"/><a id="page_943"/>Tip</p>
<p class="notepara">If you find yourself using <code>typeid</code> in an extended series of <code>if else</code> statements, you should check whether you should instead use virtual functions and <code>dynamic_cast</code>.</p>
<hr/></div>
<h3 id="ch15lev1sec5">Type Cast Operators</h3>
<p>The C type cast operator, in Bjarne Stroustrup&#8217;s view, is too lax. For example, consider the following:</p>
<p class="programlisting">struct Data<br/>{<br/>&#160;&#160;&#160;&#160;double data[200];<br/>};<br/><br/>struct Junk<br/>{<br/>&#160;&#160;&#160;&#160;int junk[100];<br/>};<br/>Data d = {2.5e33, 3.5e-19, 20.2e32};<br/>char * pch = (char *) (&#38;d);&#160;&#160;&#160;// type cast #1 &#8211; convert to string<br/>char ch = char (&#38;d);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// type cast #2 - convert address to a char<br/>Junk * pj = (Junk *) (&#38;d);&#160;&#160;&#160;&#160;// type cast #3 - convert to Junk pointer</p>
<p>First, which of these three type casts makes any sense? Unless you resort to the implausible, none of them make much sense. Second, which of these three type casts are allowed? In C, all of them are. Stroustrup&#8217;s response to this laxity was to tighten up what is allowable for a general type cast and to add four type cast operators that provide more discipline for the casting process:</p>
<p class="programlisting">dynamic_cast<br/>const_cast<br/>static_cast<br/>reinterpret_cast</p>
<p>Instead of using a general type cast, you can select an operator that is suited to a particular purpose. This documents the intended reason for the type cast and gives the compiler a chance to check that you did what you thought you did.</p>
<p>You&#8217;ve already seen the <code>dynamic_cast</code> operator. To summarize, suppose <code>High</code> and <code>Low</code> are two classes, that <code>ph</code> is type <code>High *</code>, and that <code>pl</code> is type <code>Low *</code>. Then the following statement assigns a <code>Low *</code> pointer to <code>pl</code> only if <code>Low</code> is an accessible base class (direct or indirect) to <code>High</code>:</p>
<p class="programlisting">pl = dynamic_cast&lt;Low *&gt; ph;</p>
<p>Otherwise, the statement assigns the null pointer to <code>pl</code>. In general, the operator has this syntax:</p>
<p class="programlisting">dynamic_cast &lt; <span class="EmpItalic">type-name</span> &gt; (<span class="EmpItalic">expression</span>)</p>
<p><a id="page_944"/>The purpose of this operator is to allow upcasts within a class hierarchy (such type casts being safe because of the <em>is-a</em> relationship) and to disallow other casts.</p>
<p>The <code>const_cast</code> operator is for making a type cast with the sole purpose of changing whether a value is <code>const</code> or <code>volatile</code>. It has the same syntax as the <code>dynamic_cast</code> operator:</p>
<p class="programlisting">const_cast &lt; <span class="EmpItalic">type-name</span> &gt; (<span class="EmpItalic">expression</span>)</p>
<p>The result of making such a type cast is an error if any other aspect of the type is altered. That is, <em><code>type_name</code></em> and <em><code>expression</code></em> must be of the same type, except that they can differ in the presence or absence of <code>const</code> or <code>volatile</code>. Again, suppose <code>High</code> and <code>Low</code> are two classes:</p>
<p class="programlisting">High bar;<br/>const High * pbar = &#38;bar;<br/>&#160;&#160;&#160;&#160;...<br/>High * pb = const_cast&lt;High *&gt; (pbar);&#160;&#160;&#160;&#160;// valid<br/>const Low * pl = const_cast&lt;const Low *&gt; (pbar);&#160;&#160;&#160;&#160;&#160;&#160;// invalid</p>
<p>The first type cast makes <code>*pb</code> a pointer that can be used to alter the value of the <code>bar</code> object; it removes the <code>const</code> label. The second type cast is invalid because it attempts to change the type from <code>const High *</code> to <code>const Low *</code>.</p>
<p>The reason for this operator is that occasionally you may have a need for a value that is constant most of the time but that can be changed occasionally. In such a case, you can declare the value as <code>const</code> and use <code>const_cast</code> when you need to alter the value. This could be done using the general type cast, but the general type cast can also simultaneously change the type:</p>
<p class="programlisting">High bar;<br/>const High * pbar = &#38;bar;<br/>...<br/>High * pb = (High *) (pbar);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid<br/>Low * pl = (Low *) (pbar);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// also valid</p>
<p>Because the simultaneous change of type and constantness may be an unintentional programming slip, using the <code>const_cast</code> operator is safer.</p>
<p>The <code>const_cast</code> is not all powerful. It can change the pointer access to a quantity, but the effect of attempting to change a quantity that is declared <code>const</code> is undefined. Let&#8217;s clarify this statement with the short example shown in <a href="#ch15ex19">Listing 15.19</a>.</p>
<p class="caption1"><a id="ch15ex19"/><strong>Listing 15.19. <code>constcast.cpp</code></strong></p><hr/>
<p class="programlisting1">// constcast.cpp -- using const_cast&lt;&gt;<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>using std::endl;<br/><br/>void change(const int * pt, int n);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;int pop1 = 38383;<br/>&#160;&#160;&#160;&#160;const int pop2 = 2000;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "pop1, pop2: " &lt;&lt; pop1 &lt;&lt; ", " &lt;&lt; pop2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;change(&#38;pop1, -103);<br/>&#160;&#160;&#160;&#160;change(&#38;pop2, -103);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "pop1, pop2: " &lt;&lt; pop1 &lt;&lt; ", " &lt;&lt; pop2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void change(const int * pt, int n)<br/>{<br/>&#160;&#160;&#160;&#160;int * pc;<br/><br/>&#160;&#160;&#160;&#160;pc = const_cast&lt;int *&gt;(pt);<br/>&#160;&#160;&#160;&#160;*pc += n;<br/>}</p><hr/>
<p><a id="page_945"/>The <code>const_cast</code> operator can remove the <code>const</code> from <code>const int * pt</code>, thus allowing the compiler to accept the following statement in <code>change()</code>:</p>
<p class="programlisting">*pc += n;</p>
<p>However, because <code>pop2</code> is declared as <code>const</code>, the compiler may protect it from any change, as is shown by the following sample output:</p>
<p class="programlisting">pop1, pop2: 38383, 2000<br/>pop1, pop2: 38280, 2000</p>
<p>As you can see, the calls to <code>change()</code> alter <code>pop1</code> but not <code>pop2</code>. The pointer in <code>change()</code> is declared as <code>const int *</code>, so it can&#8217;t be used to change the value of the pointed-to <code>int</code>. The pointer <code>pc</code> has the <code>const</code> cast away, so it can be used to change the pointed-to value, but only if that value wasn&#8217;t itself <code>const</code>. Therefore, <code>pc</code> can be used to alter <code>pop1</code> but not <code>pop2</code>.</p>
<p>The <code>static_cast</code> operator has the same syntax as the other operators:</p>
<p class="programlisting">static_cast &lt; <span class="EmpItalic">type-name</span> &gt; (<span class="EmpItalic">expression</span>)</p>
<p>It&#8217;s valid only if <em><code>type_name</code></em> can be converted implicitly to the same type that <em><code>expression</code></em> has, or vice versa. Otherwise, the type cast is an error. Suppose that <code>High</code> is a base class to <code>Low</code> and that <code>Pond</code> is an unrelated class. Then conversions from <code>High</code> to <code>Low</code> and <code>Low</code> to <code>High</code> are valid, but a conversion from <code>Low</code> to <code>Pond</code> is disallowed:</p>
<p class="programlisting">High bar;<br/>Low blow;<br/>...<br/><a id="page_946"/>High * pb = static_cast&lt;High *&gt; (&#38;blow);&#160;&#160;&#160;&#160;&#160;// valid upcast<br/>Low * pl = static_cast&lt;Low *&gt; (&#38;bar);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid downcast<br/>Pond * pmer = static_cast&lt;Pond *&gt; (&#38;blow);&#160;&#160;&#160;// invalid, Pond unrelated</p>
<p>The first conversion here is valid because an upcast can be done explicitly. The second conversion, from a base-class pointer to a derived-class pointer, can&#8217;t be done without an explicit type conversion. But because the type cast in the other direction can be made without a type cast, it&#8217;s valid to use <code>static_cast</code> for a downcast.</p>
<p>Similarly, because an enumeration value can be converted to an integral type without a type cast, an integral type can be converted to an enumeration value with <code>static_cast</code>. Also you can use <code>static_cast</code> to convert <code>double</code> to <code>int</code>, to convert <code>float</code> to <code>long</code>, and to perform the various other numeric conversions.</p>
<p>The <code>reinterpret_cast</code> operator is for inherently risky type casts. It doesn&#8217;t let you cast away <code>const</code>, but it does allow other unsavory things. Sometimes a programmer has to do implementation-dependent, unsavory things, and using the <code>reinterpret_cast</code> operator makes it simpler to keep track of such acts. It has the same syntax as the other three operators:</p>
<p class="programlisting">reinterpret_cast &lt; <span class="EmpItalic">type-name</span> &gt; (<span class="EmpItalic">expression</span>)</p>
<p>Here is a sample use:</p>
<p class="programlisting">struct dat {short a; short b;};<br/>long value = 0xA224B118;<br/>dat * pd = reinterpret_cast&lt; dat *&gt; (&#38;value);<br/>cout &lt;&lt; hex &lt;&lt; pd-&gt;a;&#160;&#160;&#160;// display first 2 bytes of value</p>
<p>Typically, such type casts would be used for low-level, implementation-dependent programming and would not be portable. For example, one system may store the bytes in a multibyte value in a different order than does a second system.</p>
<p>The <code>reinterpret_cast</code> operator doesn&#8217;t allow just anything, however. For example, you can cast a pointer type to an integer type that&#8217;s large enough to hold the pointer representation, but you can&#8217;t cast a pointer to a smaller integer type or to a floating-point type. Another restriction is that you can&#8217;t cast a function pointer to a data pointer or vice versa.</p>
<p>The plain type cast in C++ is also restricted. Basically, it can do anything the other type casts can do, plus some combinations, such as a <code>static_cast</code> or <code>reinterpret_cast</code> followed by a <code>const_cast</code>, but it can&#8217;t do anything else. Thus, the following type cast is allowed in C but, typically, not in C++ because for most C++ implementations the <code>char</code> type is too small to hold a pointer implementation:</p>
<p class="programlisting">char ch = char (&#38;d);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// type cast #2 - convert address to a char</p>
<p>These restrictions make sense, but if you find such enforced good judgment oppressive, you still have C available.</p>
<h3 id="ch15lev1sec6">Summary</h3>
<p><a id="page_947"/>Friends allow you to develop a more flexible interface for classes. A class can have other functions, other classes, and member functions of other classes as friends. In some cases, you may need to use forward declarations and to exert care in the ordering of class declarations and methods in order to get friends to mesh properly.</p>
<p>Nested classes are classes that are declared within other classes. Nested classes facilitate the design of helper classes that implement other classes but needn&#8217;t be part of a public interface.</p>
<p>The C++ exception mechanism provides a flexible way to deal with awkward programming events such as inappropriate values, failed I/O attempts, and the like. Throwing an exception terminates the function currently executing and transfers control to a matching <code>catch</code> block. <code>catch</code> blocks immediately follow a <code>try</code> block, and for an exception to be caught, the function call that directly or indirectly led to the exception must be in the <code>try</code> block. The program then executes the code in the <code>catch</code> block. This code may attempt to fix the problem, or it can terminate the program. A class can be designed with nested exception classes that can be thrown when problems specific to the class are detected. A function can include an exception specification that identifies the exceptions that can be thrown in that function, although C++11 deprecates that feature. Uncaught exceptions (those with no matching <code>catch</code> block) by default terminate a program. So do unexpected exceptions (those not matching an exception specification.)</p>
<p>The RTTI features allow a program to detect the type of an object. The <code>dynamic_cast</code> operator is used to cast a derived-class pointer to a base-class pointer; its main purpose is to ensure that it&#8217;s okay to invoke a virtual function call. The <code>typeid</code> operator returns a <code>type_info</code> object. Two <code>typeid</code> return values can be compared to determine whether an object is of a specific type, and the returned <code>type_info</code> object can be used to obtain information about an object.</p>
<p>The <code>dynamic_cast</code>, <code>static_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code> operators provide safer, better-documented type casts than the general type cast mechanism.</p>
<h3 id="ch15lev1sec7">Chapter Review</h3>
<p class="question"><a id="ch15qa1q1" href="app10.html#ch15qa1a1"><strong>1.</strong></a> What&#8217;s wrong with the following attempts at establishing friends?</p>
<p class="indenthandinga"><strong>a.</strong></p>
<p class="programlistingB">class snap {<br/>&#160;&#160;&#160;&#160;friend clasp;<br/>&#160;&#160;&#160;&#160;&#160;...<br/>};<br/>class clasp { ... };</p>
<p class="indenthandinga"><strong>b.</strong></p>
<p class="programlistingB">class cuff {<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;void snip(muff &#38;) { ... }<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/><a id="page_948"/>};<br/>class muff {<br/>&#160;&#160;&#160;&#160;&#160;friend void cuff::snip(muff &#38;);<br/>&#160;&#160;&#160;&#160;&#160;...<br/>};</p>
<p class="indenthandinga"><strong>c.</strong> class muff {</p>
<p class="programlistingB">&#160;&#160;&#160;&#160;&#160;&#160;friend void cuff::snip(muff &#38;);<br/>&#160;&#160;&#160;&#160;&#160;...<br/>};<br/>class cuff {<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;void snip(muff &#38;) { ... }<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};</p>
<p class="question"><a id="ch15qa1q2" href="app10.html#ch15qa1a2"><strong>2.</strong></a> You&#8217;ve seen how to create mutual class friends. Can you create a more restricted form of friendship in which only some members of Class B are friends to Class A and some members of A are friends to B? Explain.</p>
<p class="question"><a id="ch15qa1q3" href="app10.html#ch15qa1a3"><strong>3.</strong></a> What problems might the following nested class declaration have?</p>
<p class="programlistingB">class Ribs<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;class Sauce<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int soy;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int sugar;<br/>&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Sauce(int s1, int s2) : soy(s1), sugar(s2) { }<br/>&#160;&#160;&#160;};<br/>&#160;&#160;&#160;...<br/>};</p>
<p class="question"><a id="ch15qa1q4" href="app10.html#ch15qa1a4"><strong>4.</strong></a> How does <code>throw</code> differ from <code>return</code>?</p>
<p class="question"><a id="ch15qa1q5" href="app10.html#ch15qa1a5"><strong>5.</strong></a> Suppose you have a hierarchy of exception classes that are derived from a base exception class. In what order should you place <code>catch</code> blocks?</p>
<p class="question"><a id="ch15qa1q6" href="app10.html#ch15qa1a6"><strong>6.</strong></a> Consider the <code>Grand</code>, <code>Superb</code>, and <code>Magnificent</code> classes defined in this chapter. Suppose <code>pg</code> is a type <code>Grand *</code> pointer that is assigned the address of an object of one of these three classes and that <code>ps</code> is a type <code>Superb *</code> pointer. What is the difference in how the following two code samples behave?</p>
<p class="programlistingB">if (ps = dynamic_cast&lt;Superb *&gt;(pg))<br/>&#160;&#160;&#160;&#160;ps-&gt;say();&#160;&#160;// sample #1<br/><br/><a id="page_949"/>if (typeid(*pg) == typeid(Superb))<br/>&#160;&#160;&#160;&#160;(Superb *) pg)-&gt;say();&#160;&#160;// sample #2</p>
<p class="question"><a id="ch15qa1q7" href="app10.html#ch15qa1a7"><strong>7.</strong></a> How is the <code>static_cast</code> operator different from the <code>dynamic_cast</code> operator?</p>
<h3 id="ch15lev1sec8">Programming Exercises</h3>
<p class="question"><a id="ch15qa2q1"/><strong>1.</strong> Modify the <code>Tv</code> and <code>Remote</code> classes as follows:</p>
<p class="indenthandinga"><strong>a.</strong> Make them mutual friends.</p>
<p class="indenthandinga"><strong>b.</strong> Add a state variable member to the <code>Remote</code> class that describes whether the remote control is in normal or interactive mode.</p>
<p class="indenthandinga"><strong>c.</strong> Add a <code>Remote</code> method that displays the mode.</p>
<p class="indenthandinga"><strong>d.</strong> Provide the <code>Tv</code> class with a method for toggling the new <code>Remote</code> member. This method should work only if the TV is in the on state.</p>
<p class="questionp">Write a short program that tests these new features.</p>
<p class="question"><a id="ch15qa2q2"/><strong>2.</strong> Modify <a href="#ch15ex11">Listing 15.11</a> so that the two exception types are classes derived from the <code>logic_error</code> class provided by the <code>&lt;stdexcept&gt;</code> header file. Have each <code>what()</code> method report the function name and the nature of the problem. The exception objects need not hold the bad values; they should just support the <code>what()</code> method.</p>
<p class="question"><a id="ch15qa2q3"/><strong>3.</strong> This exercise is the same as Programming Exercise 2, except that the exceptions should be derived from a base class (itself derived from <code>logic_error</code>) that stores the two argument values, the exceptions should have a method that reports these values as well as the function name, and a single <code>catch</code> block that catches the base-class exemption should be used for both exceptions, with either exception causing the loop to terminate.</p>
<p class="question"><a id="ch15qa2q4"/><strong>4.</strong> <a href="#ch15ex16">Listing 15.16</a> uses two <code>catch</code> blocks after each <code>try</code> block so that the <code>nbad_index</code> exception leads to the <code>label_val()</code> method being invoked. Modify the program so that it uses a single <code>catch</code> block after each <code>try</code> block and uses RTTI to handle invoking <code>label_val()</code> only when appropriate.</p>
</body>
</html>
