<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>16. The string Class and the Standard Template Library</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch16">16. The <code>string</code> Class and the Standard Template Library</h2>
<p><a id="page_951"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; The standard C++ <code>string</code> class</p>
<p class="indenthandingB">&#8226; The <code>auto_ptr</code>, <code>unique_ptr</code>, and <code>shared_ptr</code> templates</p>
<p class="indenthandingB">&#8226; The Standard Template Library (STL)</p>
<p class="indenthandingB">&#8226; Container classes</p>
<p class="indenthandingB">&#8226; Iterators</p>
<p class="indenthandingB">&#8226; Function objects (functors)</p>
<p class="indenthandingB">&#8226; STL algorithms</p>
<p class="indenthandingB">&#8226; The <code>initializer_list</code> template</p>
<p>By now you are familiar with the C++ goal of reusable code. One of the big payoffs is when you can reuse code written by others. That&#8217;s where class libraries come in. There are many commercially available C++ class libraries, and there are also libraries that come as part of the C++ package. For example, you&#8217;ve been using the input/output classes supported by the <code>ostream</code> header file. This chapter looks at other reusable code available for your programming pleasure.</p>
<p>You&#8217;ve already encountered the <code>string</code> class, and this chapter examines it more extensively. Then the chapter looks at &#8220;smart pointer&#8221; template classes that make managing dynamic memory a bit easier. Next, the chapter looks at the Standard Template Library (STL), a collection of useful templates for handling various kinds of container objects. The STL exemplifies the programming paradigm called <em>generic programming</em>. Finally, the chapter looks at the <code>initializer_list</code> template class, the C++11 addition that enables using initializer-list syntax with STL objects.</p>
<h3 id="ch16lev1sec1">The <code>string</code> Class</h3>
<p><a id="page_952"/>Many programming applications need to process strings. C provides some support with its <code>string.h</code> (<code>cstring</code> in C++) family of string functions, and many early C++ implementations provide home-grown classes to handle strings. <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; introduced the ANSI/ISO C++ string class. <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; with its modest String class, illustrates some aspects of designing a class to represent strings.</p>
<p>Recall that the <code>string</code> class is supported by the <code>string</code> header file. (Note that the <code>string.h</code> and <code>cstring</code> header files support the C library string functions for C-style strings, not the <code>string</code> class.) The key to using a class is knowing its public interface, and the <code>string</code> class has an extensive set of methods, including several constructors, overloaded operators for assigning strings, concatenating strings, comparing strings, and accessing individual elements, as well as utilities for finding characters and substrings in a string, and more. In short, the <code>string</code> class has lots to offer.</p>
<h4 id="ch16lev2sec1">Constructing a String</h4>
<p>Let&#8217;s look at the <code>string</code> constructors. After all, one of the most important things to know about a class is what your options are when creating objects of that class. <a href="#ch16ex01">Listing 16.1</a> uses seven of the <code>string</code> constructors (labeled <code>ctor</code>, the traditional C++ abbreviation for <em>constructor</em>). <a href="#ch16table01">Table 16.1</a> briefly describes the constructors. The table begins with the seven constructors used in <a href="#ch16ex01">Listing 16.1</a>, in that order. It also lists a couple of C++11 additions. The constructor representations are simplified in that they conceal the fact that <code>string</code> really is a <code>typedef</code> for a template specialization <code>basic_string&lt;char&gt;</code> and that they omit an optional argument relating to memory management. (This aspect is discussed later this chapter and in <a href="app06.html#app06">Appendix F</a>, &#8220;The <code>string</code> Template Class.&#8221;) The type <code>size_type</code> is an implementation-dependent integral type defined in the <code>string</code> header file. The class defines <code>string::npos</code> as the maximum possible length of the string. Typically, this would equal the maximum value of an <code>unsigned int</code>. Also the table uses the common abbreviation NBTS for null-byte-terminated string&#8212;that is, the traditional C string, which is terminated with a null character.</p>
<p class="caption"><a id="ch16table01"/><strong>Table 16.1. <code>string</code> Class Constructors</strong></p>
<p class="image"><img src="graphics/16tab01.jpg" alt="Image"/></p>
<p class="caption1"><a id="page_953"/><a id="ch16ex01"/><strong>Listing 16.1. <code>str1.cpp</code></strong></p><hr/>
<p class="programlisting1">// str1.cpp -- introducing the string class<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>// using string constructors<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;string one("Lottery Winner!");&#160;&#160;&#160;&#160;&#160;// ctor #1<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; one &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded &lt;&lt;<br/>&#160;&#160;&#160;&#160;string two(20, '$');&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #2<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; two &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;string three(one);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #3<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; three &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;one += " Oops!";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded +=<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; one &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;two = "Sorry! That was ";<br/>&#160;&#160;&#160;&#160;three[0] = 'P';<br/>&#160;&#160;&#160;&#160;string four;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #4<br/>&#160;&#160;&#160;&#160;four = two + three;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded +, =<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; four &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;char alls[] = "All's well that ends well";<br/>&#160;&#160;&#160;&#160;string five(alls,20);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #5<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; five &lt;&lt; "!\n";<br/>&#160;&#160;&#160;&#160;string six(alls+6, alls + 10);&#160;&#160;&#160;&#160;&#160;// ctor #6<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; six&#160;&#160;&lt;&lt; ", ";<br/>&#160;&#160;&#160;&#160;string seven(&#38;five[6], &#38;five[10]); // ctor #6 again<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; seven &lt;&lt; "...\n";<br/>&#160;&#160;&#160;&#160;string eight(four, 7, 16);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #7<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; eight &lt;&lt; " in motion!" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_954"/>The program in <a href="#ch16ex01">Listing 16.1</a> also uses the overloaded <code>+=</code> operator, which appends one string to another, the overloaded <code>=</code> operator for assigning one string to another, the overloaded <code>&lt;&lt;</code> operator for displaying a <code>string</code> object, and the overloaded <code>[]</code> operator for accessing an individual character in a string.</p>
<p>Here is the output of the program in <a href="#ch16ex01">Listing 16.1</a>:</p>
<p class="programlisting">Lottery Winner!<br/>$$$$$$$$$$$$$$$$$$$$<br/>Lottery Winner!<br/>Lottery Winner! Oops!<br/>Sorry! That was Pottery Winner!<br/>All's well that ends!<br/>well, well...<br/>That was Pottery in motion!</p>
<h5 id="ch16lev3sec1">Program Notes</h5>
<p>The start of the program in <a href="#ch16ex01">Listing 16.1</a> illustrates that you can initialize a <code>string</code> object to a regular C-style string and display it by using the overloaded <code>&lt;&lt;</code> operator:</p>
<p class="programlisting">string one("Lottery Winner!");&#160;&#160;&#160;&#160;// ctor #1<br/>cout &lt;&lt; one &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded &lt;&lt;</p>
<p>The next constructor initializes the <code>string</code> object <code>two</code> to a string consisting of 20 <code>$</code> characters:</p>
<p class="programlisting">string two(20, '$');&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #2</p>
<p>The copy constructor initializes the <code>string</code> object <code>three</code> to the <code>string</code> object <code>one</code>:</p>
<p class="programlisting">string three(one);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #3</p>
<p>The overloaded <code>+=</code> operator appends the string <code>" Oops!"</code> to the string <code>one</code>:</p>
<p class="programlisting">one += " Oops!";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded +=</p>
<p><a id="page_955"/>This particular example appends a C-style string to a <code>string</code> object. However, the <code>+=</code> operator is multiply overloaded so that you can also append <code>string</code> objects and single characters:</p>
<p class="programlisting">one += two;&#160;&#160;&#160;// append a string object (not in program)<br/>one += '!';&#160;&#160;&#160;// append a type char value (not in program)</p>
<p>Similarly, the <code>=</code> operator is overloaded so that you can assign a <code>string</code> object to a <code>string</code> object, a C-style string to a <code>string</code> object, or a simple <code>char</code> value to a <code>string</code> object:</p>
<p class="programlisting">two = "Sorry! That was "; // assign a C-style string<br/>two = one;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assign a string object (not in program)<br/>two = '?';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assign a char value (not in program)</p>
<p>Overloading the <code>[]</code> operator, as the <code>String</code> example in <a href="ch12.html#ch12">Chapter 12</a> does, permits access to individual characters in a <code>string</code> object by using array notation:</p>
<p class="programlisting">three[0] = 'P';</p>
<p>A default constructor creates an empty string that can later be given a value:</p>
<p class="programlisting">string four;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #4<br/>four = two + three;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// overloaded +, =</p>
<p>The second line here uses the overloaded <code>+</code> operator to create a temporary <code>string</code> object, which is then assigned, using the overloaded <code>=</code> operator, to the <code>four</code> object. As you might expect, the <code>+</code> operator concatenates its two operands into a single <code>string</code> object. The operator is multiply overloaded, so the second operand can be a <code>string</code> object or a C-style string or a <code>char</code> value.</p>
<p>The fifth constructor takes a C-style string and an integer as arguments, with the integer indicating how many characters to copy:</p>
<p class="programlisting">char alls[] = "All's well that ends well";<br/>string five(alls,20);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #5</p>
<p>Here, as the output shows, just the first 20 characters (<code>"All's well that ends"</code>) are used to initialize the <code>five</code> object. As <a href="#ch16table01">Table 16.1</a> notes, if the character count exceeds the length of the C-style string, the requested number of characters is still copied. So replacing 20 with 40 in the preceding example would result in 15 junk characters being copied at the end of <code>five</code>. (That is, the constructor would interpret the contents in memory following the string <code>"All's well that ends well"</code> as character codes.)</p>
<p>The sixth constructor has a template argument:</p>
<p class="programlisting">template&lt;class Iter&gt; string(Iter <span class="EmpItalic">begin</span>, Iter <span class="EmpItalic">end</span>);</p>
<p>The intent is that <em><code>begin</code></em> and <em><code>end</code></em> act like pointers pointing to two locations in memory. (In general, <em><code>begin</code></em> and <em><code>end</code></em> can be iterators, generalizations of pointers extensively used in the STL.) The constructor then uses the values between the locations pointed to by <em><code>begin</code></em> and <em><code>end</code></em> to initialize the <code>string</code> object it constructs. The notation [<em><code>begin</code></em>, <em><code>end</code></em>), borrowed from mathematics, means the range includes <em><code>begin</code></em> but doesn&#8217;t include <em><code>end</code></em>. <a id="page_956"/>That is, <em><code>end</code></em> points to a location one past the last value to be used. Consider the following statement:</p>
<p class="programlisting">string six(alls+6, alls + 10);&#160;&#160;&#160;&#160;// ctor #6</p>
<p>Because the name of an array is a pointer, both <code>alls + 6</code> and <code>alls + 10</code> are type <code>char *</code>, so the template is used with <code>Iter</code> replaced by type <code>char *</code>. The first argument points to the first <code>w</code> in the <code>alls</code> array, and the second argument points to the space following the first <code>well</code>. Thus, <code>six</code> is initialized to the string <code>"well"</code>. <a href="#ch16fig01">Figure 16.1</a> shows how the constructor works.</p>
<p class="caption"><a id="ch16fig01"/><strong>Figure 16.1. A <code>string</code> constructor using a range.</strong></p>
<p class="image"><img src="graphics/16fig01.jpg" alt="Image"/></p>
<p>Now suppose you want to use this constructor to initialize an object to part of another <code>string</code> object&#8212;say, the object <code>five</code>. The following does not work:</p>
<p class="programlisting">string seven(five + 6, five + 10);</p>
<p>The reason is that the name of an object, unlike the name of an array, is not treated as the address of an object, hence <code>five</code> is not a pointer and <code>five + 6</code> is meaningless. However, <code>five[6]</code> is a <code>char</code> value, so <code>&#38;five[6]</code> is an address and can be used as an argument to the constructor:</p>
<p class="programlisting">string seven(&#38;five[6], &#38;five[10]);// ctor #6 again</p>
<p>The seventh constructor copies a portion of one <code>string</code> object to the constructed object:</p>
<p class="programlisting">string eight(four, 7, 16);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ctor #7</p>
<p>This statement copies 16 characters from <code>four</code> to <code>eight</code>, starting at position 7 (the eighth character) in <code>four</code>.</p>
<h5 id="ch16lev3sec2">C++11 Constructors</h5>
<p>The <code>string(string &#38;&#38; str) noexcept</code> constructor is similar to the copy constructor in that the new <code>string</code> is a copy of <code>str</code>. However, unlike the copy constructor, it doesn&#8217;t guarantee that <code>str</code> will be treated as <code>const</code>. This form of constructor is termed a <em>move constructor</em>. The compiler can use it in some situations instead of the copy constructor to <a id="page_957"/>optimize performance. <a href="ch18.html#ch18">Chapter 18</a>, &#8220;<a href="ch18.html#ch18">Visiting with the New C++ Standard</a>,&#8221; discusses this topic in the section &#8220;<a href="ch18.html#ch18lev1sec2">Move Semantics and the rvalue Reference</a>.&#8221;</p>
<p>The <code>string(initializer_list&lt;char&gt; il)</code> constructor enables list-initialization for the <code>string</code> class. That is, it makes declarations like the following possible:</p>
<p class="programlisting">string piano_man = {'L', 'i', 's','z','t'};<br/>string comp_lang {'L', 'i', 's', 'p'};</p>
<p>This may not be that useful for the <code>string</code> class because using C-style strings is easier, but it does satisfy the intent to make the list-initialization syntax universal. This chapter will discuss the <code>initializer_list</code> template further later on.</p>
<h4 id="ch16lev2sec2">The <code>string</code> Class Input</h4>
<p>Another useful thing to know about a class is what input options are available. For C-style strings, recall, you have three options:</p>
<p class="programlisting">char info[100];<br/>cin &gt;&gt; info;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a word<br/>cin.getline(info, 100);&#160;&#160;// read a line, discard \n<br/>cin.get(info, 100);&#160;&#160;&#160;&#160;&#160;&#160;// read a line, leave \n in queue</p>
<p>For <code>string</code> objects, recall, you have two options:</p>
<p class="programlisting">string stuff;<br/>cin &gt;&gt; stuff;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a word<br/>getline(cin, stuff);&#160;&#160;&#160;&#160;&#160;// read a line, discard \n</p>
<p>Both versions of <code>getline()</code> allow for an optional argument that specifies which character to use to delimit input:</p>
<p class="programlisting">cin.getline(info,100,':');&#160;&#160;&#160;&#160;// read up to :, discard :<br/>getline(stuff, ':');&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read up to :, discard :</p>
<p>The main operational difference is that the <code>string</code> versions automatically size the target <code>string</code> object to hold the input characters:</p>
<p class="programlisting">char fname[10];<br/>string lname;<br/>cin &gt;&gt; fname;&#160;&#160;&#160;&#160;&#160;&#160;// could be a problem if input size &gt; 9 characters<br/>cin &gt;&gt; lname;&#160;&#160;&#160;&#160;&#160;&#160;// can read a very, very long word<br/>cin.getline(fname, 10);&#160;&#160;// may truncate input<br/>getline(cin, fname);&#160;&#160;&#160;&#160;&#160;// no truncation</p>
<p>The automatic sizing feature allows the <code>string</code> version of <code>getline()</code> to dispense with the numeric parameter that limits the number of input characters to be read.</p>
<p>A design difference is that the C-style string input facilities are methods of the <code>istream</code> class, whereas the <code>string</code> versions are standalone functions. That&#8217;s why <code>cin</code> is an invoking object for C-style string input and a function argument for <code>string</code> object input. This applies to the <code>&gt;&gt;</code> form, too, which is evident if the code is written in function form:</p>
<p class="programlisting"><a id="page_958"/>cin.operator&gt;&gt;(fname);&#160;&#160;&#160;&#160;&#160;// ostream class method<br/>operator&gt;&gt;(cin, lname);&#160;&#160;&#160;&#160;// regular function</p>
<p>Let&#8217;s examine the <code>string</code> input functions a bit more closely. Both, as mentioned, size the target string to fit the input. There are limits. The first limiting factor is the maximum allowable size for a string, represented by the constant <code>string::npos</code>. This, typically, is the maximum value of an <code>unsigned int</code>, so it doesn&#8217;t pose a practical limit for ordinary, interactive input. It could be a factor, however, if you attempt to read the contents of an entire file into a single <code>string</code> object. The second limiting factor is the amount of memory available to a program.</p>
<p>The <code>getline()</code> function for the <code>string</code> class reads characters from the input and stores them in a <code>string</code> object until one of three things occurs:</p>
<p class="indenthandingB">&#8226; The end-of-file is encountered, in which case <code>eofbit</code> of the input stream is set, implying that both the <code>fail()</code> and <code>eof()</code> methods will return <code>true</code>.</p>
<p class="indenthandingB">&#8226; The delimiting character (<code>\n</code>, by default) is reached, in which case it is removed from the input stream but not stored.</p>
<p class="indenthandingB">&#8226; The maximum possible number of characters (the lesser of <code>string::npos</code> and the number of bytes in memory available for allocation) is read, in which case <code>failbit</code> of the input stream is set, implying that the <code>fail()</code> method will return <code>true</code>.</p>
<p>(An input stream object has an accounting system to keep track of the error state of the stream. In this system, setting <code>eofbit</code> registers detecting the end-of-file; setting <code>failbit</code> registers detecting an input error; setting <code>badbit</code> registers some unrecognized failure, such as a hardware failure; and setting <code>goodbit</code> indicates that all is well. <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>,&#8221; discusses this further.)</p>
<p>The <code>operator&gt;&gt;()</code> function for the <code>string</code> class behaves similarly, except that instead of reading to and discarding a delimiting character, it reads up to a white space character and leaves that character in the input queue. A white space character is a space, newline, or tab character or more generally, any character for which <code>isspace()</code> returns <code>true</code>.</p>
<p>So far in this book, you&#8217;ve seen several examples of console <code>string</code> input. Because the input functions for <code>string</code> objects work with streams and recognize the end-of-file, you can also use them for file input. <a href="#ch16ex02">Listing 16.2</a> shows a short example that reads strings from the file. It assumes that the file contains strings separated by the colon character and uses the <code>getline()</code> method of specifying a delimiter. It then numbers and displays the strings, one string to an output line.</p>
<p class="caption1"><a id="ch16ex02"/><strong>Listing 16.2. <code>strfile.cpp</code></strong></p><hr/>
<p class="programlisting1">// strfile.cpp -- read strings from a file<br/>#include &lt;iostream&gt;<br/>#include &lt;fstream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;cstdlib&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;&#160;ifstream fin;<br/>&#160;&#160;&#160;&#160;&#160;fin.open("tobuy.txt");<br/>&#160;&#160;&#160;&#160;&#160;if (fin.is_open() == false)<br/>&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Can't open file. Bye.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;string item;<br/>&#160;&#160;&#160;&#160;&#160;int count = 0;<br/>&#160;&#160;&#160;&#160;&#160;getline(fin, item, ':');<br/>&#160;&#160;&#160;&#160;&#160;while (fin)&#160;&#160;// while input is good<br/>&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++count;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; count &lt;&lt;": " &lt;&lt; item &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getline(fin, item,':');<br/>&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Done\n";<br/>&#160;&#160;&#160;&#160;&#160;fin.close();<br/>&#160;&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_959"/>Here is a sample <code>tobuy.txt</code> file:</p>
<p class="programlisting">sardines:chocolate ice cream:pop corn:leeks:<br/>cottage cheese:olive oil:butter:tofu:</p>
<p>Typically, for the program to find the text file, the text file should be in the same directory as the executable program or sometimes in the same directory as the project file. Or you can provide the full path name. On a Windows system, keep in mind that in a C-style string the escape sequence <code>\\</code> represents a single backslash:</p>
<p class="programlisting">fin.open("C:\\CPP\\Progs\\tobuy.txt"); // file = C:\CPP\Progs\tobuy.txt</p>
<p>Here is the output of the program in <a href="#ch16ex02">Listing 16.2</a>:</p>
<p class="programlisting">1: sardines<br/>2: chocolate ice cream<br/>3: pop corn<br/>4: leeks<br/>5:<br/>cottage cheese<br/>6: olive oil<br/>7: butter<br/>8: tofu<br/>9:<br/><br/>Done</p>
<p><a id="page_960"/>Note that with <code>:</code> specified as the delimiting character, the newline character becomes just another regular character. Thus, the newline character at the end of the first line of the file becomes the first character of the string that continues as <code>"cottage cheese"</code>. Similarly, the newline character at the end of the second input line, if present, becomes the sole content of the ninth input string.</p>
<h4 id="ch16lev2sec3">Working with Strings</h4>
<p>So far, you&#8217;ve learned that you can create <code>string</code> objects in a variety of ways, display the contents of a <code>string</code> object, read data into a <code>string</code> object, append to a <code>string</code> object, assign to a <code>string</code> object, and concatenate two <code>string</code> objects. What else can you do?</p>
<p>You can compare strings. All six relational operators are overloaded for <code>string</code> objects, with one object being considered less than another if it occurs earlier in the machine collating sequence. If the machine collating sequence is the ASCII code, that implies that digits are less than uppercase characters and uppercase characters are less than lowercase characters. Each relational operator is overloaded three ways so that you can compare a <code>string</code> object with another <code>string</code> object, compare a <code>string</code> object with a C-style string, and compare a C-style string with a <code>string</code> object:</p>
<p class="programlisting">string snake1("cobra");<br/>string snake2("coral");<br/>char snake3[20] = "anaconda";<br/>if (snake1 &lt; snake 2)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// operator&lt;(const string &#38;, const string &#38;)<br/>&#160;&#160;&#160;&#160;...<br/>if (snake1 == snake3)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// operator==(const string &#38;, const char *)<br/>&#160;&#160;&#160;&#160;...<br/>if (snake3 != snake2)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// operator!=(const char *, const string &#38;)<br/>&#160;&#160;&#160;&#160;...</p>
<p>You can determine the size of a string. Both the <code>size()</code> and <code>length()</code> member functions return the number of characters in a string:</p>
<p class="programlisting">if (snake1.length() == snake2.size())<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Both strings have the same length.\n"</p>
<p>Why two functions that do the same thing? The <code>length()</code> member comes from earlier versions of the <code>string</code> class, and <code>size()</code> was added for STL compatibility.</p>
<p>You can search a string for a given substring or character in a variety of ways. <a href="#ch16table02">Table 16.2</a> provides a short description of four variations of a <code>find()</code> method. Recall that <code>string::npos</code> is the maximum possible number of characters in a string, typically the largest <code>unsigned int</code> or <code>unsigned long</code> value.</p>
<p class="caption"><a id="page_961"/><a id="ch16table02"/><strong>Table 16.2. The Overloaded <code>find()</code> Method</strong></p>
<p class="image"><img src="graphics/16tab02.jpg" alt="Image"/></p>
<p>The <code>string</code> library also provides the related methods <code>rfind()</code>, <code>find_first_of()</code>, <code>find_last_of()</code>, <code>find_first_not_of()</code>, and <code>find_last_not_of()</code>, each with the same set of overloaded function signatures as the <code>find()</code> method. The <code>rfind()</code> method finds the last occurrence of a substring or character. The <code>find_first_of()</code> method finds the first occurrence in the invoking string of any of the characters in the argument. For example, the following statement would return the location of the <code>r</code> in <code>"cobra"</code> (that is, the index 3) because that&#8217;s the first occurrence of any of the letters in <code>"hark"</code> in <code>"cobra"</code>:</p>
<p class="programlisting">int where = snake1.find_first_of("hark");</p>
<p>The <code>find_last_of()</code> method works the same, except it finds the last occurrence. Thus, the following statement would return the location of the <code>a</code> in <code>"cobra"</code>:</p>
<p class="programlisting">int where = snake1.last_first_of("hark");</p>
<p>The <code>find_first_not_of()</code> method finds the first character in the invoking string that is not a character in the argument. So the following would return the location of the <code>c</code> in <code>cobra</code> because <code>c</code> is not found in <code>hark</code>:</p>
<p class="programlisting">int where = snake1.find_first_not_of("hark");</p>
<p>(You&#8217;ll learn about <code>find_last_not_of()</code> in an exercise at the end of this chapter.)</p>
<p><a id="page_962"/>There are many more methods, but these are enough to put together a sample program that&#8217;s a graphically impaired version of the word game Hangman. The game stores a list of words in an array of <code>string</code> objects, picks a word at random, and lets you guess letters in the word. Six wrong guesses, and you lose. The program uses the <code>find()</code> function to check your guesses and the <code>+=</code> operator to build a <code>string</code> object to keep track of your wrong guesses. To keep track of your good guesses, the program creates a word the same length as the mystery word but consisting of hyphens. The hyphens are then replaced by correct guesses. <a href="#ch16ex03">Listing 16.3</a> shows the program.</p>
<p class="caption1"><a id="ch16ex03"/><strong>Listing 16.3. <code>hangman.cpp</code></strong></p><hr/>
<p class="programlisting1">// hangman.cpp -- some string methods<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>#include &lt;cctype&gt;<br/>using std::string;<br/>const int NUM = 26;<br/>const string wordlist[NUM] = {"apiary", "beetle", "cereal",<br/>&#160;&#160;&#160;&#160;"danger", "ensign", "florid", "garage", "health", "insult",<br/>&#160;&#160;&#160;&#160;"jackal", "keeper", "loaner", "manage", "nonce", "onset",<br/>&#160;&#160;&#160;&#160;"plaid", "quilt", "remote", "stolid", "train", "useful",<br/>&#160;&#160;&#160;&#160;"valid", "whence", "xenon", "yearn", "zippy"};<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::tolower;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;std::srand(std::time(0));<br/>&#160;&#160;&#160;&#160;char play;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Will you play a word game? &lt;y/n&gt; ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; play;<br/>&#160;&#160;&#160;&#160;play = tolower(play);<br/>&#160;&#160;&#160;&#160;while (play == 'y')<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string target = wordlist[std::rand() % NUM];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int length = target.length();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string attempt(length, '-');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string badchars;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int guesses = 6;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Guess my secret word. It has " &lt;&lt; length<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " letters, and you guess\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "one letter at a time. You get " &lt;&lt; guesses<br/><a id="page_963"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " wrong guesses.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Your word: " &lt;&lt; attempt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (guesses &gt; 0 &#38;&#38; attempt != target)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char letter;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Guess a letter: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; letter;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (badchars.find(letter) != string::npos<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|| attempt.find(letter) != string::npos)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "You already guessed that. Try again.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int loc = target.find(letter);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (loc == string::npos)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Oh, bad guess!\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--guesses;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;badchars += letter; // add to string<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Good guess!\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;attempt[loc]=letter;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// check if letter appears again<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc = target.find(letter, loc + 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (loc != string::npos)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;attempt[loc]=letter;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loc = target.find(letter, loc + 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Your word: " &lt;&lt; attempt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (attempt != target)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (badchars.length() &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bad choices: " &lt;&lt; badchars &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; guesses &lt;&lt; " bad guesses left\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (guesses &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "That's right!\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Sorry, the word is " &lt;&lt; target &lt;&lt; ".\n";<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Will you play another? &lt;y/n&gt; ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; play;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;play = tolower(play);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_964"/>Here&#8217;s a sample run of the program in <a href="#ch16ex03">Listing 16.3</a>:</p>
<p class="programlisting">Will you play a word game? &lt;y/n&gt; <span class="EmpStrong">y</span><br/>Guess my secret word. It has 6 letters, and you guess<br/>one letter at a time. You get 6 wrong guesses.<br/>Your word: ------<br/>Guess a letter: <span class="EmpStrong">e</span><br/>Oh, bad guess!<br/>Your word: ------<br/>Bad choices: e<br/>5 bad guesses left<br/>Guess a letter: <span class="EmpStrong">a</span><br/>Good guess!<br/>Your word: a--a--<br/>Bad choices: e<br/>5 bad guesses left<br/>Guess a letter: <span class="EmpStrong">t</span><br/>Oh, bad guess!<br/>Your word: a--a--<br/>Bad choices: et<br/>4 bad guesses left<br/>Guess a letter: <span class="EmpStrong">r</span><br/>Good guess!<br/>Your word: a--ar-<br/>Bad choices: et<br/>4 bad guesses left<br/>Guess a letter: <span class="EmpStrong">y</span><br/>Good guess!<br/>Your word: a--ary<br/>Bad choices: et<br/>4 bad guesses left<br/>Guess a letter: <span class="EmpStrong">i</span><br/>Good guess!<br/>Your word: a-iary<br/>Bad choices: et<br/>4 bad guesses left<br/>Guess a letter: <span class="EmpStrong">p</span><br/><a id="page_965"/>Good guess!<br/>Your word: apiary<br/>That's right!<br/>Will you play another? &lt;y/n&gt; <span class="EmpStrong">n</span><br/>Bye</p>
<h5 id="ch16lev3sec3">Program Notes</h5>
<p>In <a href="#ch16ex03">Listing 16.3</a>, the fact that the relational operators are overloaded lets you treat strings in the same fashion you would treat numeric variables:</p>
<p class="programlisting">while (guesses &gt; 0 &#38;&#38; attempt != target)</p>
<p>This is easier to follow than, say, using <code>strcmp()</code> with C-style strings.</p>
<p>The program uses <code>find()</code> to check whether a character was selected earlier; if it was already selected, it will be found in either the <code>badchars</code> string (bad guesses) or in the <code>attempt</code> string (good guesses):</p>
<p class="programlisting">if (badchars.find(letter) != string::npos<br/>&#160;&#160;&#160;&#160;|| attempt.find(letter) != string::npos)</p>
<p>The <code>npos</code> variable is a static member of the <code>string</code> class. Its value, recall, is the maximum allowable number of characters for a <code>string</code> object. Therefore, because indexing begins at zero, it is one greater than the largest possible index and can be used to indicate failure to find a character or a string.</p>
<p>The program makes use of the fact that one of the overloaded versions of the <code>+=</code> operator lets you append individual characters to a string:</p>
<p class="programlisting">badchars += letter;&#160;&#160;// append a char to a string object</p>
<p>The heart of the program begins by checking whether the chosen letter is in the mystery word:</p>
<p class="programlisting">int loc = target.find(letter);</p>
<p>If <code>loc</code> is a valid value, the letter can be placed in the corresponding location in the answer string:</p>
<p class="programlisting">attempt[loc]=letter;</p>
<p>However, a given letter might occur more than once in the mystery word, so the program has to keep checking. The program uses the optional second argument to <code>find()</code>, which specifies a starting place in the string from which to begin the search. Because the letter was found at location <code>loc</code>, the next search should begin at <code>loc + 1</code>. A <code>while</code> loop keeps the search going until no more occurrences of that character are found. Note that <code>find()</code> indicates failure if <code>loc</code> is after the end of the string:</p>
<p class="programlisting">// check if letter appears again<br/>loc = target.find(letter, loc + 1);<br/>while (loc != string::npos)<br/>{<br/><a id="page_966"/>&#160;&#160;&#160;&#160;attempt[loc]=letter;<br/>&#160;&#160;&#160;&#160;loc = target.find(letter, loc + 1);<br/>}</p>
<h4 id="ch16lev2sec4">What Else Does the <code>string</code> Class Offer?</h4>
<p>The <code>string</code> library supplies many other facilities. There are functions for erasing part or all of a string, for replacing part or all of one string with part or all of another string, for inserting material into a string or removing material from a string, for comparing part or all of one string with part or all of another string, and for extracting a substring from a string. There&#8217;s a function for copying part of one string to another string, and there&#8217;s a function for swapping the contents of two strings. Most of these functions are overloaded so that they can work with C-style strings as well as with <code>string</code> objects. <a href="app06.html#app06">Appendix F</a> describes the string library function briefly, but let&#8217;s talk about a few more features here.</p>
<p>First, think about the automatic sizing feature. In <a href="#ch16ex03">Listing 16.3</a>, what happens each time the program appends a letter to a string? It can&#8217;t necessarily just grow the string in place because it might run into neighboring memory that is already in use. So it may have to allocate a new block and then copy the old contents to a new location. It would be inefficient to do this a lot, so many C++ implementations allocate a block of memory larger than the actual string, giving the string room to grow. Then if the string eventually exceeds that size, the program allocates a new block twice the size to afford more room to grow without continuous resizing. The <code>capacity()</code> method returns the size of the current block, and the <code>reserve()</code> method allows you to request a minimum size for the block. <a href="#ch16ex04">Listing 16.4</a> shows an example that uses these methods.</p>
<p class="caption1"><a id="ch16ex04"/><strong>Listing 16.4. <code>str2.cpp</code></strong></p><hr/>
<p class="programlisting1">// str2.cpp -- capacity() and reserve()<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;string empty;<br/>&#160;&#160;&#160;&#160;string small = "bit";<br/>&#160;&#160;&#160;&#160;string larger = "Elephants are a girl's best friend";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sizes:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\tempty: " &lt;&lt; empty.size() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\tsmall: " &lt;&lt; small.size() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\tlarger: " &lt;&lt; larger.size() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Capacities:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\tempty: " &lt;&lt; empty.capacity() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\tsmall: " &lt;&lt; small.capacity() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\tlarger: " &lt;&lt; larger.capacity() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;empty.reserve(50);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Capacity after empty.reserve(50): "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; empty.capacity() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_967"/>Here is the output of the program in <a href="#ch16ex04">Listing 16.4</a> for one C++ implementation:</p>
<p class="programlisting">Sizes:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;empty: 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;small: 3<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;larger: 34<br/>Capacities:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;empty: 15<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;small: 15<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;larger: 47<br/>Capacity after empty.reserve(50): 63</p>
<p>Note that this implementation uses a minimum capacity of 15 characters and seems to use 1 less than multiples of 16 as standard choices for capacities. Other implementations may make different choices.</p>
<p>What if you have a <code>string</code> object but need a C-style string? For example, you might want to open a file whose name is in a <code>string</code> object:</p>
<p class="programlisting">string filename;<br/>cout &lt;&lt; "Enter file name: ";<br/>cin &gt;&gt; filename;<br/>ofstream fout;</p>
<p>The bad news is that the <code>open()</code> method requires a C-style string argument. The good news is that the <code>c_str()</code> method returns a pointer to a C-style string that has the same contents as the invoking <code>string</code> object. So you can use this:</p>
<p class="programlisting">fout.open(filename.c_str());</p>
<h4 id="ch16lev2sec5">String Varieties</h4>
<p>This section treats the <code>string</code> class as if it were based on the <code>char</code> type. In fact, as mentioned earlier, the string library really is based on a template class:</p>
<p class="programlisting">template&lt;class charT, class traits = char _traits&lt;charT&gt;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class Allocator = allocator&lt;charT&gt; &gt;<br/>basic_string {...};</p>
<p>The <code>basic_string</code> template comes with four specializations, each of which has a <code>typedef</code> name:</p>
<p class="programlisting">typedef basic_string&lt;char&gt; string;<br/>typedef basic_string&lt;wchar_t&gt; wstring;<br/>typedef basic_string&lt;char16_t&gt; u16string;&#160;&#160;&#160;// C++11<br/>typedef basic_string&lt;char32_t&gt; u32string ;&#160;&#160;// C++11</p>
<p><a id="page_968"/>This allows you to use strings based on the <code>wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code> types as well as the <code>char</code> type. You could even develop some sort of character-like class and use the <code>basic_string</code> class template with it, provided that your class met certain requirements. The <code>traits</code> class describes specific facts about the chosen character type, such as how to compare values. There are predefined specializations of the <code>char_traits</code> template for the <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code> types, and these are the default values for <code>traits</code>. The <code>Allocator</code> class represents a class to manage memory allocation. There are predefined specializations of the <code>allocator</code> template for the various character types, and these are the defaults. They use <code>new</code> and <code>delete</code>.</p>
<h3 id="ch16lev1sec2">Smart Pointer Template Classes</h3>
<p>A <em>smart pointer</em> is a class object that acts like a pointer but has additional features. Here we&#8217;ll look at three smart pointer templates that can help with managing the use of dynamic memory allocation. Let&#8217;s begin by taking a look at what might be needed and how it can be accomplished. Consider the following function:</p>
<p class="programlisting">void remodel(std::string &#38; str)<br/>{<br/>&#160;&#160;&#160;&#160;std::string * ps = new std::string(str);<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;str = ps;<br/>&#160;&#160;&#160;&#160;return;<br/>}</p>
<p>You probably see its flaw. Each time the function is called, it allocates memory from the heap but never frees the memory, thus creating a memory leak. You also know the solution&#8212;just remember to free the allocated memory by adding the following statement just before the <code>return</code> statement:</p>
<p class="programlisting">delete ps;</p>
<p>However, a solution involving the phrase &#8220;just remember to&#8221; is seldom the best solution. Sometimes you won&#8217;t remember. Or you will remember but accidentally remove or comment out the code. And even if you do remember, there can still be problems. Consider the following variation:</p>
<p class="programlisting">void remodel(std::string &#38; str)<br/>{<br/>&#160;&#160;&#160;&#160;std::string * ps = new std::string(str);<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;if (weird_thing())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw exception();<br/>&#160;&#160;&#160;&#160;str = *ps;<br/>&#160;&#160;&#160;&#160;delete ps;<br/>&#160;&#160;&#160;&#160;return;<br/>}</p>
<p><a id="page_969"/>If the exception is thrown, the <code>delete</code> statement isn&#8217;t reached, and again there is a memory leak.</p>
<p>You can fix that oversight, as illustrated in <a href="ch14.html#ch14">Chapter 14</a>, &#8220;<a href="ch14.html#ch14">Reusing Code in C++</a>,&#8221; but it would be nice if there were a neater solution. Let&#8217;s think about what is needed. When a function such as <code>remodel()</code> terminates, either normally or by throwing an exception, local variables are removed from the stack memory&#8212;so the memory occupied by the pointer <code>ps</code> is freed. It would be nice if, in addition, the memory pointed to by <code>ps</code> was freed. If <code>ps</code> had a destructor, that destructor could free the pointed-to memory when <code>ps</code> expires. Thus, the problem with <code>ps</code> is that it is just an ordinary pointer and not a class object having a destructor. If it were an object, you could have its destructor delete the pointed-to memory when the object expires. And that is the idea behind <code>auto_ptr</code>, <code>unique_ptr</code>, and <code>shared_ptr</code>. The <code>auto_ptr</code> template is the C++98 solution. C++11 deprecates <code>auto_ptr</code> and provides the other two as alternatives. However, although deprecated, <code>auto_ptr</code> has been used for years and may be your only choice if your compiler doesn&#8217;t support the other two.</p>
<h4 id="ch16lev2sec6">Using Smart Pointers</h4>
<p>These three smart pointer templates (<code>auto_ptr</code>, <code>unique_ptr</code>, and <code>shared_ptr</code> ) each defines a pointer-like object intended to be assigned an address obtained (directly or indirectly) by <code>new</code>. When the smart pointer expires, its destructor uses <code>delete</code> to free the memory. Thus, if you assign an address returned by <code>new</code> to one of these objects, you don&#8217;t have to remember to free the memory later; it will be freed automatically when the smart pointer object expires. <a href="#ch16fig02">Figure 16.2</a> illustrates the behavioral difference between <code>auto_ptr</code> and a regular pointer. The <code>shared_ptr</code> and <code>unique_ptr</code> share the same behavior in this situation.</p>
<p class="caption"><a id="ch16fig02"/><strong>Figure 16.2. A regular pointer versus <code>auto_ptr</code>.</strong></p>
<p class="image"><img src="graphics/16fig02.jpg" alt="Image"/></p>
<p>To create one of these smart pointer objects, you include the <code>memory</code> header file, which includes the template definitions. Then you use the usual template syntax to instantiate the kind of pointer you require. The <code>auto_ptr</code> template, for instance, includes the following constructor:</p>
<p class="programlisting">template&lt;class X&gt; class auto_ptr {<br/>public:<br/>&#160;&#160;&#160;&#160;explicit auto_ptr(X* p =0) throw();<br/>...};</p>
<p>(The <code>throw()</code> notation, recall, means this constructor doesn&#8217;t throw an exception. Like <code>auto_ptr</code>, it is deprecated.) Thus, asking for an <code>auto_ptr</code> object of type <code>X</code> gives you an <code>auto_ptr</code> object that points to type <code>X</code>:</p>
<p class="programlisting">auto_ptr&lt;double&gt; pd(new double);&#160;&#160;// pd an auto_ptr to double<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// (use in place of double * pd)<br/>auto_ptr&lt;string&gt; ps(new string);&#160;&#160;// ps an auto_ptr to string<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// (use in place of string * ps)</p>
<p><a id="page_970"/>Here <code>new double</code> is a pointer returned by <code>new</code> to a newly allocated chunk of memory. It is the argument to the <code>auto_ptr&lt;double&gt;</code> constructor; that is, it is the actual argument corresponding to the formal parameter <code>p</code> in the prototype. Similarly, <code>new string</code> is also an actual argument for a constructor. The other two smart pointers use the same syntax:</p>
<p class="programlisting">unique_ptr&lt;double&gt; pdu(new double);&#160;&#160;// pdu an unique_ptr to double<br/>shared_ptr&lt;string&gt; pss(new string);&#160;&#160;// pss a shared_ptr to string</p>
<p><a id="page_971"/>Thus, to convert the <code>remodel()</code> function, you would follow these three steps:</p>
<p class="indenthandingN"><strong>1.</strong> Include the <code>memory</code> header file.</p>
<p class="indenthandingN"><strong>2.</strong> Replace the pointer-to-<code>string</code> with a smart pointer object that points to <code>string</code>.</p>
<p class="indenthandingN"><strong>3.</strong> Remove the <code>delete</code> statement.</p>
<p>Here&#8217;s the function with those changes made using <code>auto_ptr</code>:</p>
<p class="programlisting">#include &lt;memory&gt;<br/>void remodel(std::string &#38; str)<br/>{<br/>&#160;&#160;&#160;&#160;std::auto_ptr&lt;std::string&gt; ps (new std::string(str));<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;if (weird_thing())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw exception();<br/>&#160;&#160;&#160;&#160;str = *ps;<br/>&#160;&#160;&#160;&#160;// delete ps;&#160;&#160;NO LONGER NEEDED<br/>&#160;&#160;&#160;&#160;return;<br/>}</p>
<p>Note that smart pointers belong to the <code>std</code> namespace. <a href="#ch16ex05">Listing 16.5</a> presents a simple program using all three of these smart pointers. (Your compiler will need to support the C++11 <code>shared_ptr</code> and <code>unique_ptr</code> classes.) Each use is placed inside a block so that the pointer expires when execution leaves the block. The <code>Report</code> class uses verbose methods to report when an object is created or destroyed.</p>
<p class="caption1"><a id="ch16ex05"/><strong>Listing 16.5. <code>smrtptrs.cpp</code></strong></p><hr/>
<p class="programlisting1">// smrtptrs.cpp -- using three kinds of smart pointers<br/>// requires support of C++11 shared_ptr and unique_ptr<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;memory&gt;<br/><br/>class Report<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string str;<br/>public:<br/>&#160;&#160;&#160;&#160;Report(const std::string s) : str(s)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ std::cout &lt;&lt; "Object created!\n"; }<br/>&#160;&#160;&#160;&#160;~Report() { std::cout &lt;&lt; "Object deleted!\n"; }<br/>&#160;&#160;&#160;&#160;void comment() const { std::cout &lt;&lt; str &lt;&lt; "\n"; }<br/>};<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::auto_ptr&lt;Report&gt; ps (new Report("using auto_ptr"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;comment();&#160;&#160;&#160;// use -&gt; to invoke a member function<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::shared_ptr&lt;Report&gt; ps (new Report("using shared_ptr"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;comment();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::unique_ptr&lt;Report&gt; ps (new Report("using unique_ptr"));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps-&gt;comment();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_972"/>Here is the output:</p>
<p class="programlisting">Object created!<br/>using auto_ptr<br/>Object deleted!<br/>Object created!<br/>using shared_ptr<br/>Object deleted!<br/>Object created!<br/>using unique_ptr<br/>Object deleted!</p>
<p>Each of these classes has an <code>explicit</code> constructor taking a pointer as an argument. Thus, there is no automatic type cast from a pointer to a smart pointer object:</p>
<p class="programlisting">shared_ptr&lt;double&gt; pd;<br/>double *p_reg = new double;<br/>pd = p_reg;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed (implicit conversion)<br/>pd = shared_ptr&lt;double&gt;(p_reg);&#160;&#160;&#160;&#160;&#160;// allowed (explicit conversion<br/>shared_ptr&lt;double&gt; pshared = p_reg; // not allowed (implicit conversion)<br/>shared_ptr&lt;double&gt; pshared(p_reg);&#160;&#160;// allowed (explicit conversion)</p>
<p>The smart pointer template classes are defined so that in most respects a smart pointer object acts like a regular pointer. For example, given that <code>ps</code> is a smart pointer object, you can dereference it (<code>*ps</code>), use it to access structure members (<code>ps-&gt;puffIndex</code>), and assign it to a regular pointer that points to the same type. You can also assign one smart pointer object to another of the same type, but that raises an issue that the next section faces.</p>
<p>But first, here&#8217;s something you should avoid with all three of these smart pointers:</p>
<p class="programlisting">string vacation("I wandered lonely as a cloud.");<br/>shared_ptr&lt;string&gt; pvac(&#38;vacation);&#160;&#160;// NO!</p>
<p>When <code>pvac</code> expires, the program would apply the <code>delete</code> operator to non-heap memory, which is wrong.</p>
<p><a id="page_973"/>If <a href="#ch16ex05">Listing 16.5</a> represents the pinnacle of your programming aspirations, any of these three smart pointers will serve your purposes. But there is more to the story.</p>
<h4 id="ch16lev2sec7">Smart Pointer Considerations</h4>
<p>Why three smart pointers? (Actually, there are four, but we won&#8217;t discuss <code>weak_ptr</code>.) And why is <code>auto_ptr</code> being deprecated?</p>
<p>Begin by considering assignment:</p>
<p class="programlisting">auto_ptr&lt;string&gt; ps (new string("I reigned lonely as a cloud."));<br/>auto_ptr&lt;string&gt; vocation;<br/>vocation = ps;</p>
<p>What should the assignment statement accomplish? If <code>ps</code> and <code>vocation</code> were ordinary pointers, the result would be two pointers pointing to the same <code>string</code> object. That is not acceptable here because the program would wind up attempting to delete the same object twice&#8212;once when <code>ps</code> expires, and once when <code>vocation</code> expires. There are ways to avoid this problem:</p>
<p class="indenthandingB">&#8226; Define the assignment operator so that it makes a deep copy. This results in two pointers pointing to two distinct objects, one of which is a copy of the other.</p>
<p class="indenthandingB">&#8226; Institute the concept of <em>ownership</em>, with only one smart pointer allowed to own a particular object. Only if the smart pointer owns the object will its destructor delete the object. Then have assignment transfer ownership. This is the strategy used for <code>auto_ptr</code> and for <code>unique_ptr</code>, although <code>unique_ptr</code> is somewhat more restrictive.</p>
<p class="indenthandingB">&#8226; Create an even smarter pointer that keeps track of how many smart pointers refer to a particular object. This is called <em>reference counting</em>. Assignment, for example, would increase the count by one, and the expiration of a pointer would decrease the count by one. Only when the final pointer expires would <code>delete</code> be invoked. This is the <code>shared_ptr</code> strategy.</p>
<p>The same strategies we&#8217;ve discussed for assignment, of course, would also apply to the copy constructors.</p>
<p>Each approach has its uses. <a href="#ch16ex06">Listing 16.6</a> shows an example for which <code>auto_ptr</code> is poorly suited.</p>
<p class="caption1"><a id="ch16ex06"/><strong>Listing 16.6. <code>fowl.cpp</code></strong></p><hr/>
<p class="programlisting1">// fowl.cpp&#160;&#160;-- auto_ptr a poor choice<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;memory&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;auto_ptr&lt;string&gt; films[5] =<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;auto_ptr&lt;string&gt; (new string("Fowl Balls")),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;auto_ptr&lt;string&gt; (new string("Duck Walks")),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;auto_ptr&lt;string&gt; (new string("Chicken Runs")),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;auto_ptr&lt;string&gt; (new string("Turkey Errors")),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;auto_ptr&lt;string&gt; (new string("Goose Eggs"))<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;auto_ptr&lt;string&gt; pwin;<br/>&#160;&#160;&#160;&#160;pwin = films[2];&#160;&#160;&#160;// films[2] loses ownership<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The nominees for best avian baseball film are\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 5; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; *films[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The winner is " &lt;&lt; *pwin &lt;&lt; "!\n";<br/>&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_974"/>Here is some sample output:</p>
<p class="programlisting">The nominees for best avian baseball film are<br/>Fowl Balls<br/>Duck Walks<br/>Segmentation fault (core dumped)</p>
<p>The &#8220;core dumped&#8221; message should help fix in your memory that a misused <code>auto_ptr</code> can be a problem. (The behavior for this sort of code is undefined, so you might encounter different behavior, depending on your system.) Here the problem is that the following statement transfers ownership from <code>films[2]</code> to <code>pwin</code>:</p>
<p class="programlisting">pwin = films[2];&#160;&#160;&#160;// films[2] loses ownership</p>
<p>That causes <code>films[2]</code> to no longer refer to the string. After an <code>auto_ptr</code> gives up ownership of an object, it no longer provides access to the object. When the program goes to print the string pointed to by <code>films[2]</code>, it finds the null pointer, which apparently is an unpleasant surprise.</p>
<p>Suppose you go back to <a href="#ch16ex06">Listing 16.6</a> but use <code>shared_ptr</code> instead of <code>auto_ptr</code>. (You&#8217;ll need a compiler that supports the C++11 <code>shared_ptr</code> class.) Then the program runs fine and gives this output:</p>
<p class="programlisting">The nominees for best avian baseball film are<br/>Fowl Balls<br/>Duck Walks<br/>Chicken Runs<br/>Turkey Errors<br/>Goose Eggs<br/>The winner is Chicken Runs!</p>
<p><a id="page_975"/>The difference occurs in this part of the program:</p>
<p class="programlisting">shared_ptr&lt;string&gt; pwin;<br/>pwin = films[2];</p>
<p>This time both <code>pwin</code> and <code>films[2]</code> point to the same object, and the reference count is upped from 1 to 2. At the end of the program, <code>pwin</code>, which was declared last, is the first object to have its destructor called. The destructor decreases the reference count to 1. Then the members of the array of <code>shared_ptr</code>s are freed. The destructor for <code>films[2]</code> decrements the count to 0 and frees the previously allocated space.</p>
<p>So with <code>shared_ptr</code>, <a href="#ch16ex06">Listing 16.6</a> runs fine. With <code>auto_ptr</code> it experienced a runtime crash. What happens if you use <code>unique_ptr</code>? Like <code>auto-ptr</code>, <code>unique_ptr</code> incorporates the ownership model. Yet instead of crashing, the <code>unique_ptr</code> version yields a compile-time error objecting to this line:</p>
<p class="programlisting">pwin = films[2];</p>
<p>Clearly, it is time to look further into the differences between these last two types.</p>
<h4 id="ch16lev2sec8">Why <code>unique_ptr</code> Is Better than <code>auto_ptr</code></h4>
<p>Consider the following statements:</p>
<p class="programlisting">auto_ptr&lt;string&gt; p1(new string("auto");&#160;&#160;//#1<br/>auto_ptr&lt;string&gt; p2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//#2<br/>p2 = p1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//#3</p>
<p>When, in statement #3, <code>p2</code> takes over ownership of the <code>string</code> object, <code>p1</code> is stripped of ownership. This, recall, is good because it prevents the destructors for both <code>p1</code> and <code>p2</code> from trying to delete the same object. But it also is bad if the program subsequently tries to use <code>p1</code> because <code>p1</code> no longer points to valid data.</p>
<p>Now consider the <code>unique_ptr</code> equivalent:</p>
<p class="programlisting">unique_ptr&lt;string&gt; p3(new string("auto");&#160;&#160;//#4<br/>unique_ptr&lt;string&gt; p4;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//#5<br/>p4 = p3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//#6</p>
<p>In this case, the compiler does not allow statement #6, so we avoid the problem of <code>p3</code> not pointing to valid data. Hence, <code>unique_ptr</code> is safer (compile-time error versus potential program crash) than <code>auto_ptr</code>.</p>
<p>But there are times when assigning one smart pointer to another doesn&#8217;t leave a dangerous orphan behind. Suppose we have this function definition:</p>
<p class="programlisting">unique_ptr&lt;string&gt; demo(const char * s)<br/>{<br/>&#160;&#160;&#160;&#160;unique_ptr&lt;string&gt; temp(new string(s));<br/>&#160;&#160;&#160;&#160;return temp;<br/>}</p>
<p><a id="page_976"/>And suppose we then have this code:</p>
<p class="programlisting">unique_ptr&lt;string&gt; ps;<br/>ps = demo("Uniquely special");</p>
<p>Here, <code>demo()</code> returns a temporary <code>unique_ptr</code>, and then <code>ps</code> takes over ownership of the object originally owned by the returned <code>unique_ptr</code>. Then the returned <code>unique_ptr</code> is destroyed. That&#8217;s okay because <code>ps</code> now has ownership of the <code>string</code> object. But another good thing has happened. Because the temporary <code>unique_ptr</code> returned by <code>demo()</code> is soon destroyed, there&#8217;s no possibility of it being misused in an attempt to access invalid data. In other words, there is no reason to forbid assignment in this case. And, miraculously enough, the compiler does allow it!</p>
<p>In short, if a program attempts to assign one <code>unique_ptr</code> to another, the compiler allows it if the source object is a temporary rvalue and disallows it if the source object has some duration:</p>
<p class="programlisting">using namespace std;<br/>unique_ptr&lt; string&gt; pu1(new string "Hi ho!");<br/>unique_ptr&lt; string&gt; pu2;<br/>pu2 = pu1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//#1 not allowed<br/>unique_ptr&lt;string&gt; pu3;<br/>pu3 = unique_ptr&lt;string&gt;(new string "Yo!");&#160;&#160;//#2 allowed</p>
<p>Assignment #1 would leave a dangling <code>unique_ptr</code> behind (that is, <code>pu1</code>), a possible source of mischief. Assignment #2 leaves no <code>unique_ptr</code> behind because it invokes the <code>unique_ptr</code> constructor, which constructs a temporary object that is destroyed when ownership is transferred to <code>pu3</code>. This selective behavior is one indication that <code>unique_ptr</code> is superior to <code>auto_ptr</code>, which would allow both forms of assignment. It&#8217;s also the reason that <code>auto_ptr</code>s are banned (by recommendation, not by the compiler) from being used in container objects, whereas <code>unique_ptr</code>s are allowed. If a container algorithm tries to do something along the lines of assignment #1 to the contents of a container of <code>unique_ptr</code>s, you get a compile-time error. If the algorithm tries to do something like assignment #2, that&#8217;s okay, and the program proceeds. With <code>auto_ptr</code>s, cases like assignment #1 could lead to undefined behavior and mysterious crashes.</p>
<p>Of course, it could be possible that you really want to do something like statement #1. The assignment is unsafe only if you use the abandoned smart pointer in an unsmart manner, such as dereferencing it. But you could safely reuse the pointer by assigning a new value to it. C++ has a standard library function called <code>std::move()</code> that lets you assign one <code>unique_ptr</code> to another. Here is an example using the previously defined <code>demo()</code> function, which returns a <code>unique_ptr&lt;string&gt;</code> object:</p>
<p class="programlisting">using namespace std;<br/>unique_ptr&lt;string&gt; ps1, ps2;<br/>ps1 = demo("Uniquely special");<br/>ps2 = move(ps1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// enable assignment<br/>ps1 = demo(" and more");<br/>cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;</p>
<p><a id="page_977"/>You may be wondering how <code>unique_ptr</code>, unlike <code>auto_ptr</code>, is able to discriminate between safe and possibly unsafe uses. The answer is that it uses the C++11 additions of move constructors and rvalue references, as discussed in <a href="ch18.html#ch18">Chapter 18</a>.</p>
<p>Also <code>unique_ptr</code> has another advantage over <code>auto_ptr</code>. It has a variant that can be used with arrays. Remember, you must pair <code>delete</code> with <code>new</code> and <code>delete []</code> with <code>new []</code>. The <code>auto_ptr</code> template uses <code>delete</code>, not <code>delete []</code>, so it can only be used with <code>new</code>, not with <code>new []</code>. But <code>unique_ptr</code> has a <code>new[]</code>, <code>delete[]</code> version:</p>
<p class="programlisting">std::unique_ptr&lt; double[]&gt;pda(new double(5));&#160;&#160;// will use delete []</p>
<div class="note"><hr/>
<p class="title"><a id="ch16note01"/>Caution</p>
<p class="notepara">You should use an <code>auto_prt</code> or <code>shared_ptr</code> object only for memory allocated by <code>new</code>, not for memory allocated by <code>new []</code>. You should not use <code>auto_ptr</code>, <code>shared_ptr</code>, or <code>unique_ptr</code> for memory not allocated via <code>new</code> or, in the case of <code>unique_ptr</code>, via <code>new</code> or <code>new[]</code>.</p>
<hr/></div>
<h4 id="ch16lev2sec9">Selecting a Smart Pointer</h4>
<p>Which pointer type should you use? If the program uses more than one pointer to an object, <code>shared_ptr</code> is your choice. For instance, you may have an array of pointers and use some auxiliary pointers to identify particular elements, such as the largest and the smallest. Or you could have two kinds of objects that contain pointers to the same third object. Or you might have an STL container of pointers. Many of the STL algorithms include copy or assignment operations that will work with <code>shared_ptr</code> but not with <code>unique_ptr</code> (you&#8217;ll get a compiler warning) or <code>auto_ptr</code> (you&#8217;ll get undefined behavior). If your compiler doesn&#8217;t offer <code>shared_ptr</code>, you can get a version from the Boost library.</p>
<p>If the program doesn&#8217;t need multiple pointers to the same object, <code>unique_ptr</code> works. It&#8217;s a good choice for the return type for a function that returns a pointer to memory allocated by <code>new</code>. That way, ownership is transferred to the <code>unique_ptr</code> assigned the return value, and that smart pointer takes on the responsibility of calling <code>delete</code>. You can store <code>unique_ptr</code> objects in an STL container providing you don&#8217;t invoke methods or algorithms, such as <code>sort()</code>, that copy or assign one <code>unique_ptr</code> to another. For example, assuming the proper <code>include</code>s and <code>using</code> statements, code fragments like the following could be used in a program:</p>
<p class="programlisting">unique_ptr&lt;int&gt; make_int(int n)<br/>{<br/>&#160;&#160;&#160;&#160;return unique_ptr&lt;int&gt;(new int(n));<br/>}<br/>void show(unique_ptr&lt;int&gt; &#38; pi)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pass by reference<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; *a &lt;&lt; ' ';<br/>}<br/>int main()<br/>{<br/>...<br/><a id="page_978"/>&#160;&#160;&#160;&#160;vector&lt;unique_ptr&lt;int&gt; &gt; vp(size);<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; vp.size(); i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vp[i] = make_int(rand() % 1000);&#160;&#160;&#160;&#160;// copy temporary unique_ptr<br/>&#160;&#160;&#160;&#160;vp.push_back(make_int(rand() % 1000))&#160;&#160;&#160;// ok because arg is temporary<br/>&#160;&#160;&#160;&#160;for_each(vp.begin(), vp.end(), show);&#160;&#160;&#160;// use for_each()<br/>...<br/>}</p>
<p>The call to <code>push_back()</code> works because it passes a temporary <code>unique_ptr</code> to be assigned to a <code>unique_ptr</code> in <code>vp</code>. Also note the <code>for_each()</code> statement would fail if <code>show()</code> were passed an object by value instead of by reference because then it would be necessary to initialize <code>pi</code> to a nontemporary <code>unique_ptr</code> from <code>vp</code>, which isn&#8217;t allowed. As mentioned before, the compiler will catch attempts to use <code>unique_ptr</code> inappropriately.</p>
<p>You can assign a <code>unique_ptr</code> to <code>shared_ptr</code> under the same conditions that you can assign one <code>unique_ptr</code> to another&#8212;the source has to be an rvalue. As previously, in the following code <code>make_int()</code> is a function with a <code>unique_ptr&lt;int&gt;</code> return type:</p>
<p class="programlisting">unique_ptr&lt;int&gt; pup(make_int(rand() % 1000);&#160;&#160;// ok<br/>shared_ptr&lt;int&gt; spp(pup);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed, pup an lvalue<br/>shared_ptr&lt;int&gt; spr(make_int(rand() % 1000);&#160;&#160;// ok</p>
<p>The <code>shared_ptr</code> template includes an explicit constructor for converting an rvalue <code>unique_ptr</code> to a <code>shared_ptr</code>. The <code>shared_ptr</code> takes over ownership of the object previously owned by the <code>unique_ptr</code>.</p>
<p>You would use a<code>uto_ptr</code> in the same situation as <code>unique_ptr</code>, but the latter is preferred. If your compiler doesn&#8217;t provide <code>unique_ptr</code>, you might consider the BOOST library <code>scoped_ptr</code>, which is similar.</p>
<h3 id="ch16lev1sec3">The Standard Template Library</h3>
<p>The STL provides a collection of templates representing containers, iterators, function objects, and algorithms. A container is a unit, like an array, that can hold several values. STL containers are homogeneous; that is, they hold values all of the same kind. Algorithms are recipes for accomplishing particular tasks, such as sorting an array or finding a particular value in a list. Iterators are objects that let you move through a container much as pointers let you move through an array; they are generalizations of pointers. Function objects are objects that act like functions; they can be class objects or function pointers (including function names because a function name acts as a pointer). The STL lets you construct a variety of containers, including arrays, queues, and lists, and it lets you perform a variety of operations, including searching, sorting, and randomizing.</p>
<p>Alex Stepanov and Meng Lee developed STL at Hewlett-Packard Laboratories, releasing the implementation in 1994. The ISO/ANSI C++ committee voted to incorporate it as a part of the C++ Standard. The STL is not an example of object-oriented programming. Instead, it represents a different programming paradigm called <em>generic programming</em>. This makes STL interesting both in terms of what it does and in terms of its approach. <a id="page_979"/>There&#8217;s too much information about the STL to present in a single chapter, so we&#8217;ll look at some representative examples and examine the spirit of the generic programming approach. We&#8217;ll begin by looking at a few specific examples. Then, when you have a hands-on appreciation for containers, iterators, and algorithms, we&#8217;ll look at the underlying design philosophy and then take an overview of the whole STL. <a href="app07.html#app07">Appendix G</a>, &#8220;The STL Methods and Functions,&#8221; summarizes the various STL methods and functions.</p>
<h4 id="ch16lev2sec10">The <code>vector</code> Template Class</h4>
<p><a href="ch04.html#ch04">Chapter 4</a> touched briefly on the <code>vector</code> class. We&#8217;ll look more closely at it now. In computing, the term <em>vector</em> corresponds to an array rather than to the mathematical vector discussed in <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>.&#8221; (Mathematically, an N-dimensional mathematical vector can be represented by a set of N components, so in that aspect, a mathematical vector is like an N-dimensional array. However, a mathematical vector has additional properties, such as inner and outer products, that a computer vector doesn&#8217;t necessarily have.) A computing-style vector holds a set of like values that can be accessed randomly. That is, you can use, say, an index to directly access the 10th element of a vector without having to access the preceding 9 elements first. So a <code>vector</code> class would provide operations similar to those of the <code>valarray</code> and <code>ArrayTP</code> classes introduced in <a href="ch14.html#ch14">Chapter 14</a> and to those of the <code>array</code> class introduced in <a href="ch04.html#ch04">Chapter 4</a>. That is, you could create a <code>vector</code> object, assign one <code>vector</code> object to another, and use the <code>[]</code> operator to access <code>vector</code> elements. To make the class generic, you make it a template class. That&#8217;s what the STL does, defining a <code>vector</code> template in the <code>vector</code> (formerly <code>vector.h</code>) header file.</p>
<p>To create a <code>vector</code> template object, you use the usual <code>&lt;</code><em><code>type</code></em><code>&gt;</code> notation to indicate the type to be used. Also the <code>vector</code> template uses dynamic memory allocation, and you can use an initialization argument to indicate how many vector elements you want:</p>
<p class="programlisting">#include vector<br/>using namespace std;<br/>vector&lt;int&gt; ratings(5);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a vector of 5 ints<br/>int n;<br/>cin &gt;&gt; n;<br/>vector&lt;double&gt; scores(n);&#160;&#160;&#160;&#160;&#160;// a vector of n doubles</p>
<p>After you create a <code>vector</code> object, operator overloading for <code>[]</code> makes it possible to use the usual array notation for accessing individual elements:</p>
<p class="programlisting">ratings[0] = 9;<br/>for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; scores[i] &lt;&lt; endl;</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch16sb01"/>Allocators Again</p>
<p class="sidebarpara">Like the string class, the various STL container templates take an optional template argument that specifies what allocator object to use to manage memory. For example, the vector template begins like this:</p>
<p class="programlistingB">template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;<br/>&#160;&#160;&#160;&#160;class vector {...</p>
<p class="sidebarpara">If you omit a value for this template argument, the container template uses the <code>allocator&lt;T&gt;</code> class by default. This class uses <code>new</code> and <code>delete</code>.</p>
<hr/></div>
<p><a id="page_980"/><a href="#ch16ex07">Listing 16.7</a> uses this class in an undemanding application. This particular program creates two <code>vector</code> objects, one an <code>int</code> specialization and one a <code>string</code> specialization; each has five elements.</p>
<p class="caption1"><a id="ch16ex07"/><strong>Listing 16.7. <code>vect1.cpp</code></strong></p><hr/>
<p class="programlisting1">// vect1.cpp -- introducing the vector template<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;vector&gt;<br/><br/>const int NUM = 5;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::vector;<br/>&#160;&#160;&#160;&#160;using std::string;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;vector&lt;int&gt; ratings(NUM);<br/>&#160;&#160;&#160;&#160;vector&lt;string&gt; titles(NUM);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You will do exactly as told. You will enter\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; NUM &lt;&lt; " book titles and your ratings (0-10).\n";<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; NUM; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter title #" &lt;&lt; i + 1 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getline(cin,titles[i]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your rating (0-10): ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; ratings[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Thank you. You entered the following:\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Rating\tBook\n";<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; NUM; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ratings[i] &lt;&lt; "\t" &lt;&lt; titles[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_981"/>Here&#8217;s a sample run of the program in <a href="#ch16ex07">Listing 16.7</a>:</p>
<p class="programlisting">You will do exactly as told. You will enter<br/>5 book titles and your ratings (0-10).<br/>Enter title #1: <span class="EmpStrong">The Cat Who Knew C++</span><br/>Enter your rating (0-10): <span class="EmpStrong">6</span><br/>Enter title #2: <span class="EmpStrong">Felonious Felines</span><br/>Enter your rating (0-10): <span class="EmpStrong">4</span><br/>Enter title #3: <span class="EmpStrong">Warlords of Wonk</span><br/>Enter your rating (0-10): <span class="EmpStrong">3</span><br/>Enter title #4: <span class="EmpStrong">Don't Touch That Metaphor</span><br/>Enter your rating (0-10): <span class="EmpStrong">5</span><br/>Enter title #5: <span class="EmpStrong">Panic Oriented Programming</span><br/>Enter your rating (0-10): <span class="EmpStrong">8</span><br/>Thank you. You entered the following:<br/>Rating&#160;&#160;Book<br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Knew C++<br/>4&#160;&#160;&#160;&#160;&#160;&#160;&#160;Felonious Felines<br/>3&#160;&#160;&#160;&#160;&#160;&#160;&#160;Warlords of Wonk<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;Don't Touch That Metaphor<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;Panic Oriented Programming</p>
<p>All this program does is use the <code>vector</code> template as a convenient way to create a dynamically allocated array. The next section shows an example that uses more of the class methods.</p>
<h4 id="ch16lev2sec11">Things to Do to Vectors</h4>
<p>Besides allocating storage, what else can the <code>vector</code> template do for you? All the STL containers provide certain basic methods, including <code>size()</code>, which returns the number of elements in a container, <code>swap()</code>, which exchanges the contents of two containers, <code>begin()</code>, which returns an iterator that refers to the first element in a container, and <code>end()</code>, which returns an iterator that represents past-the-end for the container.</p>
<p>What&#8217;s an iterator? It&#8217;s a generalization of a pointer. In fact, it can be a pointer. Or it can be an object for which pointer-like operations such as dereferencing (for example, <code>operator*()</code>) and incrementing (for example, <code>operator++()</code>) have been defined. As you&#8217;ll see later, generalizing pointers to iterators allows the STL to provide a uniform interface for a variety of container classes, including ones for which simple pointers wouldn&#8217;t work. Each container class defines a suitable iterator. The type name for this iterator is a class scope <code>typedef</code> called <code>iterator</code>. For example, to declare an iterator for a type <code>double</code> specialization of <code>vector</code>, you would use this:</p>
<p class="programlisting">vector&lt;double&gt;::iterator pd;&#160;&#160;// pd an iterator</p>
<p>Suppose <code>scores</code> is a <code>vector&lt;double&gt;</code> object:</p>
<p class="programlisting">vector&lt;double&gt; scores;</p>
<p><a id="page_982"/>Then you can use the iterator <code>pd</code> in code like the following:</p>
<p class="programlisting">pd = scores.begin();&#160;&#160;// have pd point to the first element<br/>*pd = 22.3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// dereference pd and assign value to first element<br/>++pd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// make pd point to the next element</p>
<p>As you can see, an iterator behaves like a pointer. By the way, here&#8217;s another place the C++11 automatic type deduction can be useful. Instead of, say,</p>
<p class="programlisting">vector&lt;double&gt;::iterator pd = scores.begin();</p>
<p>you can use this:</p>
<p class="programlisting">auto pd = scores.begin();&#160;&#160;&#160;// C++11 automatic type deduction</p>
<p>Returning to the example, what&#8217;s <em>past-the-end</em>? It is an iterator that refers to an element one past the last element in a container. The idea is similar to the idea of the null character being one element past the last actual character in a C-style string, except that the null character is the value in the element, and past-the-end is a pointer (or iterator) to the element. The <code>end()</code> member function identifies the past-the-end location. If you set an iterator to the first element in a container and keep incrementing it, eventually it will reach past-the-end, and you will have traversed the entire contents of the container. Thus, if <code>scores</code> and <code>pd</code> are defined as in the preceding example, you can display the contents with this code:</p>
<p class="programlisting">for (pd = scores.begin(); pd != scores.end(); pd++)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; *pd &lt;&lt; endl;;</p>
<p>All containers have the methods just discussed. The <code>vector</code> template class also has some methods that only some STL containers have. One handy method, called <code>push_back()</code>, adds an element to the end of a <code>vector</code>. While doing so, it attends to memory management so that the <code>vector</code> size increases to accommodate added members. This means you can write code like the following:</p>
<p class="programlisting">vector&lt;double&gt; scores;&#160;&#160;// create an empty vector<br/>double temp;<br/>while (cin &gt;&gt; temp &#38;&#38; temp &gt;= 0)<br/>&#160;&#160;&#160;&#160;scores.push_back(temp);<br/>cout &lt;&lt; "You entered " &lt;&lt; scores.size() &lt;&lt; " scores.\n";</p>
<p>Each loop cycle adds one more element to the <code>scores</code> object. You don&#8217;t have to pick the number of element when you write the program or when you run the program. As long as the program has access to sufficient memory, it will expand the size of <code>scores</code> as necessary.</p>
<p>The <code>erase()</code> method removes a given range of a vector. It takes two iterator arguments that define the range to be removed. It&#8217;s important that you understand how the STL defines ranges using two iterators. The first iterator refers to the beginning of the range, and the second iterator is one beyond the end of the range. For example, the <a id="page_983"/>following erases the first and second elements&#8212;that is, those referred to by <code>begin()</code> and <code>begin() + 1</code>:</p>
<p class="programlisting">scores.erase(scores.begin(), scores.begin() + 2);</p>
<p>(Because <code>vector</code> provides random access, operations such as <code>begin() + 2</code> are defined for the <code>vector</code> class iterators.) If <code>it1</code> and <code>it2</code> are two iterators, the STL literature uses the notation [<code>p1</code>, <code>p2</code>) to indicate a range starting with <code>p1</code> and going up to, but not including, <code>p2</code>. Thus, the range [<code>begin()</code>, <code>end()</code>) encompasses the entire contents of a collection (see <a href="#ch16fig03">Figure 16.3</a>). Also the range [<code>p1</code>, <code>p1</code>) is empty. (The [ ) notation is not part of C++, so it doesn&#8217;t appear in code; it just appears in documentation.)</p>
<p class="caption"><a id="ch16fig03"/><strong>Figure 16.3. The STL range concept.</strong></p>
<p class="image"><img src="graphics/16fig03.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch16note02"/>Note</p>
<p class="notepara">A range [<code>it1</code>, <code>it2</code>) is specified by two iterators <code>it1</code> and <code>it2</code>, and it runs from <code>it1</code> up to, but not including, <code>it2</code>.</p>
<hr/></div>
<p>An <code>insert()</code> method complements <code>erase()</code>. It takes three iterator arguments. The first gives the position ahead of which new elements are to be inserted. The second and third iterator parameters define the range to be inserted. This range typically is part of another container object. For example, the following code inserts all but the first element of the <code>new_v</code> vector ahead of the first element of the <code>old_v</code> vector:</p>
<p class="programlisting">vector&lt;int&gt; old_v;<br/>vector&lt;int&gt; new_v;<br/>...<br/>old_v.insert(old_v.begin(), new_v.begin() + 1, new_v.end());</p>
<p>Incidentally, this is a case where having a past-the-end element is handy because it makes it simple to append something to the end of a vector. In this code the new material is inserted ahead of <code>old.end()</code>, meaning it&#8217;s placed <em>after</em> the last element in the vector:</p>
<p class="programlisting">old_v.insert(old_v.end(), new_v.begin() + 1, new_v.end());</p>
<p><a id="page_984"/><a href="#ch16ex08">Listing 16.8</a> illustrates the use of <code>size()</code>, <code>begin()</code>, <code>end()</code>, <code>push_back()</code>, <code>erase()</code>, and <code>insert()</code>. To simplify data handling, the <code>rating</code> and <code>title</code> components of <a href="#ch16ex07">Listing 16.7</a> are incorporated into a single <code>Review</code> structure, and <code>FillReview()</code> and <code>ShowReview()</code> functions provide input and output facilities for <code>Review</code> objects.</p>
<p class="caption1"><a id="ch16ex08"/><strong>Listing 16.8. <code>vect2.cpp</code></strong></p><hr/>
<p class="programlisting1">// vect2.cpp -- methods and iterators<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;vector&gt;<br/><br/>struct Review {<br/>&#160;&#160;&#160;&#160;std::string title;<br/>&#160;&#160;&#160;&#160;int rating;<br/>};<br/>bool FillReview(Review &#38; rr);<br/>void ShowReview(const Review &#38; rr);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::vector;<br/>&#160;&#160;&#160;&#160;vector&lt;Review&gt; books;<br/>&#160;&#160;&#160;&#160;Review temp;<br/>&#160;&#160;&#160;&#160;while (FillReview(temp))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;books.push_back(temp);<br/>&#160;&#160;&#160;&#160;int num = books.size();<br/>&#160;&#160;&#160;&#160;if (num &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Thank you. You entered the following:\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Rating\tBook\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i &lt; num; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShowReview(books[i]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Reprising:\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Rating\tBook\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector&lt;Review&gt;::iterator pr;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (pr = books.begin(); pr != books.end(); pr++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShowReview(*pr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector &lt;Review&gt; oldlist(books);&#160;&#160;&#160;&#160;&#160;// copy constructor used<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (num &gt; 3)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// remove 2 items<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;books.erase(books.begin() + 1, books.begin() + 3);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "After erasure:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (pr = books.begin(); pr != books.end(); pr++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShowReview(*pr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// insert 1 item<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;books.insert(books.begin(), oldlist.begin() + 1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oldlist.begin() + 2);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "After insertion:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (pr = books.begin(); pr != books.end(); pr++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShowReview(*pr);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;books.swap(oldlist);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Swapping oldlist with books:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (pr = books.begin(); pr != books.end(); pr++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShowReview(*pr);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Nothing entered, nothing gained.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>bool FillReview(Review &#38; rr)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter book title (quit to quit): ";<br/>&#160;&#160;&#160;&#160;std::getline(std::cin,rr.title);<br/>&#160;&#160;&#160;&#160;if (rr.title == "quit")<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter book rating: ";<br/>&#160;&#160;&#160;&#160;std::cin &gt;&gt; rr.rating;<br/>&#160;&#160;&#160;&#160;if (!std::cin)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;// get rid of rest of input line<br/>&#160;&#160;&#160;&#160;while (std::cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;return true;<br/>}<br/><br/>void ShowReview(const Review &#38; rr)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; rr.rating &lt;&lt; "\t" &lt;&lt; rr.title &lt;&lt; std::endl;<br/>}</p><hr/>
<p><a id="page_985"/>Here is a sample run of the program in <a href="#ch16ex08">Listing 16.8</a>:</p>
<p class="programlisting">Enter book title (quit to quit): <span class="EmpStrong">The Cat Who Knew Vectors</span><br/>Enter book rating: <span class="EmpStrong">5</span><br/>Enter book title (quit to quit): <span class="EmpStrong">Candid Canines</span><br/>Enter book rating: <span class="EmpStrong">7</span><br/>Enter book title (quit to quit): <span class="EmpStrong">Warriors of Wonk</span><br/>Enter book rating: <span class="EmpStrong">4</span><br/>Enter book title (quit to quit): <span class="EmpStrong">Quantum Manners</span><br/><a id="page_986"/>Enter book rating: <span class="EmpStrong">8</span><br/>Enter book title (quit to quit): <span class="EmpStrong">quit</span><br/>Thank you. You entered the following:<br/>Rating&#160;&#160;Book<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Knew Vectors<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;Candid Canines<br/>4&#160;&#160;&#160;&#160;&#160;&#160;&#160;Warriors of Wonk<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;Quantum Manners<br/>Reprising:<br/>Rating&#160;&#160;Book<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Knew Vectors<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;Candid Canines<br/>4&#160;&#160;&#160;&#160;&#160;&#160;&#160;Warriors of Wonk<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;Quantum Manners<br/>After erasure:<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Knew Vectors<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;Quantum Manners<br/>After insertion:<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;Candid Canines<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Knew Vectors<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;Quantum Manners<br/>Swapping oldlist with books:<br/>5&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Knew Vectors<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;Candid Canines<br/>4&#160;&#160;&#160;&#160;&#160;&#160;&#160;Warriors of Wonk<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;Quantum Manners</p>
<h4 id="ch16lev2sec12">More Things to Do to Vectors</h4>
<p>There are many things programmers commonly do with arrays, such as search them, sort them, randomize the order, and so on. Does the vector template class have methods for these common operations? No! The STL takes a broader view, defining <em>nonmember</em> functions for these operations. Thus, instead of defining a separate <code>find()</code> member function for each container class, it defines a single <code>find()</code> nonmember function that can be used for all container classes. This design philosophy saves a lot of duplicate work. For example, suppose you had 8 container classes and 10 operations to support. If each class had its own member function, you&#8217;d need 8&#215;10, or 80, separate member function definitions. But with the STL approach, you&#8217;d need just 10 separate nonmember function definitions. And if you defined a new container class, provided that you followed the proper guidelines, it too could use the existing 10 nonmember functions to find, sort, and so on.</p>
<p>On the other hand, the STL sometimes defines a member function even if it also defines a nonmember function for the same task. The reason is that for some actions, there is a class-specific algorithm that is more efficient than the more general algorithm. Therefore, the vector <code>swap()</code> will be more efficient than the nonmember <code>swap()</code>. On the other <a id="page_987"/>hand, the nonmember version will allow you swap contents between two different kinds of containers.</p>
<p>Let&#8217;s examine three representative STL functions: <code>for_each()</code>, <code>random_shuffle()</code>, and <code>sort()</code>. The <code>for_each()</code> function can be used with any container class. It takes three arguments. The first two are iterators that define a range in the container, and the last is a pointer to a function. (More generally, the last argument is a function object; you&#8217;ll learn about function objects shortly.) The <code>for_each()</code> function then applies the pointed-to function to each container element in the range. The pointed-to function must not alter the value of the container elements. You can use the <code>for_each()</code> function instead of a <code>for</code> loop. For example, you can replace the code</p>
<p class="programlisting">vector&lt;Review&gt;::iterator pr;<br/>for (pr = books.begin(); pr != books.end(); pr++)<br/>&#160;&#160;&#160;&#160;ShowReview(*pr);</p>
<p>with the following:</p>
<p class="programlisting">for_each(books.begin(), books.end(), ShowReview);</p>
<p>This enables you to avoid dirtying your hands (and code) with explicit use of iterator variables.</p>
<p>The <code>random_shuffle()</code> function takes two iterators that specify a range and rearranges the elements in that range in random order. For example, the following statement randomly rearranges the order of all the elements in the <code>books</code> vector:</p>
<p class="programlisting">random_shuffle(books.begin(), books.end());</p>
<p>Unlike <code>for_each</code>, which works with any container class, this function requires that the container class allow random access, which the <code>vector</code> class does.</p>
<p>The <code>sort()</code> function, too, requires that the container support random access. It comes in two versions. The first version takes two iterators that define a range, and it sorts that range by using the <code>&lt;</code> operator defined for the type element stored in the container. For example, the following sorts the contents of <code>coolstuff</code> in ascending order, using the built-in <code>&lt;</code> operator to compare values:</p>
<p class="programlisting">vector&lt;int&gt; coolstuff;<br/>...<br/>sort(coolstuff.begin(), coolstuff.end());</p>
<p>If the container elements are user-defined objects, then there has to be an <code>operator&lt;()</code> function defined that works with that type of object in order to use <code>sort()</code>. For example, you could sort a vector containing <code>Review</code> objects if you provided either a <code>Review</code> member function or a nonmember function for <code>operator&lt;()</code>. Because <code>Review</code> is a structure, its members are public, and a nonmember function like this would serve:</p>
<p class="programlisting">bool operator&lt;(const Review &#38; r1, const Review &#38; r2)<br/>{<br/>&#160;&#160;&#160;&#160;if (r1.title &lt; r2.title)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/><a id="page_988"/>&#160;&#160;&#160;&#160;else if (r1.title == r2.title &#38;&#38; r1.rating &lt; r2.rating)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}</p>
<p>With a function like this in place, you could then sort a vector of <code>Review</code> objects (such as <code>books</code>):</p>
<p class="programlisting">sort(books.begin(), books.end());</p>
<p>This version of the <code>operator&lt;()</code> function sorts in lexicographic order of the title members. If two objects have the same title members, they are then sorted in ratings order. But suppose you want to sort in decreasing order or in order of ratings instead of titles. In such a case, you can use the second form of <code>sort()</code>. It takes three arguments. The first two, again, are iterators that indicate the range. The final argument is a pointer to a function (more generally, a function object) to be used instead of <code>operator&lt;()</code> for making the comparison. The return value should be convertible to <code>bool</code>, with <code>false</code> meaning the two arguments are in the wrong order. Here&#8217;s an example of such a function:</p>
<p class="programlisting">bool WorseThan(const Review &#38; r1, const Review &#38; r2)<br/>{<br/>&#160;&#160;&#160;&#160;if (r1.rating &lt; r2.rating)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}</p>
<p>With this function in place, you can use the following statement to sort the <code>books</code> vector of <code>Review</code> objects in order of increasing rating values:</p>
<p class="programlisting">sort(books.begin(), books.end(), WorseThan);</p>
<p>Note that the <code>WorseThan()</code> function does a less complete job than <code>operator&lt;()</code> of ordering <code>Review</code> objects. If two objects have the same title member, the <code>operator&lt;()</code> function sorts by using the rating member. But if two objects have the same rating member, <code>WorseThan()</code> treats them as equivalent. The first kind of ordering is called <em>total ordering</em>, and the second kind is called <em>strict weak ordering</em>. With total ordering, if both <em>a</em> &lt; <em>b</em> and <em>b</em> &lt; <em>a</em> are false, then <em>a</em> and <em>b</em> must be identical. With strict weak ordering, that&#8217;s not so. They might be identical, or they might just have one aspect that is the same, such as the <code>rating</code> member in the <code>WorseThan()</code> example. So instead of saying the two objects are identical, the best you can say for strict weak ordering is that they are <em>equivalent</em>.</p>
<p><a href="#ch16ex09">Listing 16.9</a> illustrates the use of these STL functions.</p>
<p class="caption1"><a id="ch16ex09"/><strong>Listing 16.9. <code>vect3.cpp</code></strong></p><hr/>
<p class="programlisting1">// vect3.cpp -- using STL functions<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/><a id="page_989"/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/><br/>struct Review {<br/>&#160;&#160;&#160;&#160;std::string title;<br/>&#160;&#160;&#160;&#160;int rating;<br/>};<br/><br/>bool operator&lt;(const Review &#38; r1, const Review &#38; r2);<br/>bool worseThan(const Review &#38; r1, const Review &#38; r2);<br/>bool FillReview(Review &#38; rr);<br/>void ShowReview(const Review &#38; rr);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/><br/>&#160;&#160;&#160;&#160;vector&lt;Review&gt; books;<br/>&#160;&#160;&#160;&#160;Review temp;<br/>&#160;&#160;&#160;&#160;while (FillReview(temp))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;books.push_back(temp);<br/>&#160;&#160;&#160;&#160;if (books.size() &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Thank you. You entered the following "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; books.size() &lt;&lt; " ratings:\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Rating\tBook\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for_each(books.begin(), books.end(), ShowReview);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sort(books.begin(), books.end());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Sorted by title:\nRating\tBook\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for_each(books.begin(), books.end(), ShowReview);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sort(books.begin(), books.end(), worseThan);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Sorted by rating:\nRating\tBook\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for_each(books.begin(), books.end(), ShowReview);<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;random_shuffle(books.begin(), books.end());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "After shuffling:\nRating\tBook\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for_each(books.begin(), books.end(), ShowReview);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "No entries. ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>bool operator&lt;(const Review &#38; r1, const Review &#38; r2)<br/>{<br/>&#160;&#160;&#160;&#160;if (r1.title &lt; r2.title)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;else if (r1.title == r2.title &#38;&#38; r1.rating &lt; r2.rating)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/><br/>bool worseThan(const Review &#38; r1, const Review &#38; r2)<br/>{<br/>&#160;&#160;&#160;&#160;if (r1.rating &lt; r2.rating)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/><br/>bool FillReview(Review &#38; rr)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter book title (quit to quit): ";<br/>&#160;&#160;&#160;&#160;std::getline(std::cin,rr.title);<br/>&#160;&#160;&#160;&#160;if (rr.title == "quit")<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter book rating: ";<br/>&#160;&#160;&#160;&#160;std::cin &gt;&gt; rr.rating;<br/>&#160;&#160;&#160;&#160;if (!std::cin)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>&#160;&#160;&#160;&#160;// get rid of rest of input line<br/>&#160;&#160;&#160;&#160;while (std::cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;return true;<br/>}<br/><br/>void ShowReview(const Review &#38; rr)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; rr.rating &lt;&lt; "\t" &lt;&lt; rr.title &lt;&lt; std::endl;<br/>}</p><hr/>
<p><a id="page_990"/>Here&#8217;s a sample run of the program in <a href="#ch16ex09">Listing 16.9</a>:</p>
<p class="programlisting">Enter book title (quit to quit): <span class="EmpStrong">The Cat Who Can Teach You Weight Loss</span><br/>Enter book rating: <span class="EmpStrong">8</span><br/>Enter book title (quit to quit): <span class="EmpStrong">The Dogs of Dharma</span><br/>Enter book rating: <span class="EmpStrong">6</span><br/>Enter book title (quit to quit): <span class="EmpStrong">The Wimps of Wonk</span><br/>Enter book rating: <span class="EmpStrong">3</span><br/>Enter book title (quit to quit): <span class="EmpStrong">Farewell and Delete</span><br/>Enter book rating: <span class="EmpStrong">7</span><br/><a id="page_991"/>Enter book title (quit to quit): <span class="EmpStrong">quit</span><br/>Thank you. You entered the following 4 ratings:<br/>Rating&#160;&#160;Book<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Can Teach You Weight Loss<br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Dogs of Dharma<br/>3&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Wimps of Wonk<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;Farewell and Delete<br/>Sorted by title:<br/>Rating&#160;&#160;Book<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;Farewell and Delete<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Can Teach You Weight Loss<br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Dogs of Dharma<br/>3&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Wimps of Wonk<br/>Sorted by rating:<br/>Rating&#160;&#160;Book<br/>3&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Wimps of Wonk<br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Dogs of Dharma<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;Farewell and Delete<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Can Teach You Weight Loss<br/>After shuffling:<br/>Rating&#160;&#160;Book<br/>7&#160;&#160;&#160;&#160;&#160;&#160;&#160;Farewell and Delete<br/>3&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Wimps of Wonk<br/>6&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Dogs of Dharma<br/>8&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Cat Who Can Teach You Weight Loss<br/>Bye.</p>
<h4 id="ch16lev2sec13">The Range-Based <code>for</code> Loop (C++11)</h4>
<p>The range-based <code>for</code> loop, mentioned in <a href="ch05.html#ch05">Chapter 5</a>, &#8220;<a href="ch05.html#ch05">Loops and Relational Expressions</a>,&#8221; is designed to work with the STL. To review, here&#8217;s the first example from <a href="ch05.html#ch05">Chapter 5</a>:</p>
<p class="programlisting">double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};<br/>for (double x : prices)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; std::endl;</p>
<p>The contents of the parentheses for the <code>for</code> loop declare a variable of the type stored in a container and then the name of the container. Next, the body of the loop uses the named variable to access each container element in turn. Consider, for instance, this statement from <a href="#ch16ex09">Listing 16.9</a>:</p>
<p class="programlisting">for_each(books.begin(), books.end(), ShowReview);</p>
<p>It can be replaced with the following range-based <code>for</code> loop:</p>
<p class="programlisting">for (auto x : books) ShowReview(x);</p>
<p>The compiler will use the type of <code>books</code>, which is <code>vector&lt;Review&gt;</code>, to deduce that <code>x</code> is type <code>Review</code>, and the loop will pass each <code>Review</code> object in <code>books</code> to <code>ShowReview()</code> in turn.</p>
<p><a id="page_992"/>Unlike <code>for_each()</code>, the range-based <code>for</code> can alter the contents of a container. The trick is to specify a reference parameter. For example, suppose we have this function:</p>
<p class="programlisting">void InflateReview(Review &#38;r){r.rating++;}</p>
<p>You could apply this function to each element in <code>books</code> with the following loop:</p>
<p class="programlisting">for (auto &#38; x : books) InflateReview(x);</p>
</body>
</html>
