<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>3. Dealing with Data</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch03">3. Dealing with Data</h2>
<p><a id="page_65"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Rules for naming C++ variables</p>
<p class="indenthandingB">&#8226; C++&#8217;s built-in integer types: <code>unsigned long</code>, <code>long</code>, <code>unsigned int</code>, <code>int</code>, <code>unsigned short</code>, <code>short</code>, <code>char</code>, <code>unsigned char</code>, <code>signed char</code>, <code>bool</code></p>
<p class="indenthandingB">&#8226; C++11&#8217;s additions: <code>unsigned long long</code> and <code>long long</code></p>
<p class="indenthandingB">&#8226; The <code>climits</code> file, which represents system limits for various integer types</p>
<p class="indenthandingB">&#8226; Numeric literals (constants) of various integer types</p>
<p class="indenthandingB">&#8226; Using the <code>const</code> qualifier to create symbolic constants</p>
<p class="indenthandingB">&#8226; C++&#8217;s built-in floating-point types: <code>float</code>, <code>double</code>, and <code>long double</code></p>
<p class="indenthandingB">&#8226; The <code>cfloat</code> file, which represents system limits for various floating-point types</p>
<p class="indenthandingB">&#8226; Numeric literals of various floating-point types</p>
<p class="indenthandingB">&#8226; C++&#8217;s arithmetic operators</p>
<p class="indenthandingB">&#8226; Automatic type conversions</p>
<p class="indenthandingB">&#8226; Forced type conversions (type casts)</p>
<p>The essence of object-oriented programming (OOP) is designing and extending your own data types. Designing your own data types represents an effort to make a type match the data. If you do this properly, you&#8217;ll find it much simpler to work with the data later. But before you can create your own types, you must know and understand the types that are built in to C++ because those types will be your building blocks.</p>
<p>The built-in C++ types come in two groups: fundamental types and compound types. In this chapter you&#8217;ll meet the fundamental types, which represent integers and floating-point numbers. That might sound like just two types; however, C++ recognizes that no one integer type and no one floating-point type match all programming requirements, so it offers several variants on these two data themes. <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; follows up by covering several types that are built on the basic types; these additional compound types include arrays, strings, pointers, and structures.</p>
<p><a id="page_66"/>Of course, a program also needs a means to identify stored data. In this chapter you&#8217;ll examine one method for doing so&#8212;using variables. Then you&#8217;ll look at how to do arithmetic in C++. Finally, you&#8217;ll see how C++ converts values from one type to another.</p>
<h3 id="ch03lev1sec1">Simple Variables</h3>
<p>Programs typically need to store information&#8212;perhaps the current price of Google stock, the average humidity in New York City in August, the most common letter in the U.S. Constitution and its relative frequency, or the number of available Elvis impersonators. To store an item of information in a computer, the program must keep track of three fundamental properties:</p>
<p class="indenthandingB">&#8226; Where the information is stored</p>
<p class="indenthandingB">&#8226; What value is kept there</p>
<p class="indenthandingB">&#8226; What kind of information is stored</p>
<p>The strategy the examples in this book have used so far is to declare a variable. The type used in the declaration describes the kind of information, and the variable name represents the value symbolically. For example, suppose Chief Lab Assistant Igor uses the following statements:</p>
<p class="programlisting">int braincount;<br/>braincount = 5;</p>
<p>These statements tell the program that it is storing an integer and that the name <code>braincount</code> represents the integer&#8217;s value, 5 in this case. In essence, the program locates a chunk of memory large enough to hold an integer, notes the location, and copies the value 5 into the location. You then can use <code>braincount</code> later in your program to access that memory location. These statements don&#8217;t tell you (or Igor) where in memory the value is stored, but the program does keep track of that information, too. Indeed, you can use the <code>&#38;</code> operator to retrieve <code>braincount</code>&#8217;s address in memory. You&#8217;ll learn about that operator in the next chapter, when you investigate a second strategy for identifying data&#8212;using pointers.</p>
<h4 id="ch03lev2sec1">Names for Variables</h4>
<p>C++ encourages you to use meaningful names for variables. If a variable represents the cost of a trip, you should call it <code>cost_of_trip</code> or <code>costOfTrip</code>, not just <code>x</code> or <code>cot</code>. You do have to follow a few simple C++ naming rules:</p>
<p class="indenthandingB">&#8226; The only characters you can use in names are alphabetic characters, numeric digits, and the underscore (_) character.</p>
<p class="indenthandingB">&#8226; The first character in a name cannot be a numeric digit.</p>
<p class="indenthandingB">&#8226; Uppercase characters are considered distinct from lowercase characters.</p>
<p class="indenthandingB">&#8226; <a id="page_67"/>You can&#8217;t use a C++ keyword for a name.</p>
<p class="indenthandingB">&#8226; Names beginning with two underscore characters or with an underscore character followed by an uppercase letter are reserved for use by the implementation&#8212;that is, the compiler and the resources it uses. Names beginning with a single underscore character are reserved for use as global identifiers by the implementation.</p>
<p class="indenthandingB">&#8226; C++ places no limits on the length of a name, and all characters in a name are significant. However, some platforms might have their own length limits.</p>
<p>The next-to-last point is a bit different from the preceding points because using a name such as __<code>time_stop</code> or _<code>Donut</code> doesn&#8217;t produce a compiler error; instead, it leads to undefined behavior. In other words, there&#8217;s no telling what the result will be. The reason there is no compiler error is that the names are not illegal but rather are reserved for the implementation to use. The bit about global names refers to where the names are declared; <a href="ch04.html#ch04">Chapter 4</a> touches on that topic.</p>
<p>The final point differentiates C++ from ANSI C (C99), which guarantees only that the first 63 characters in a name are significant. (In ANSI C, two names that have the same first 63 characters are considered identical, even if the 64th characters differ.)</p>
<p>Here are some valid and invalid C++ names:</p>
<p class="programlisting">int poodle;&#160;&#160;&#160;&#160;// valid<br/>int Poodle;&#160;&#160;&#160;&#160;// valid and distinct from poodle<br/>int POODLE;&#160;&#160;&#160;&#160;// valid and even more distinct<br/>Int terrier;&#160;&#160;&#160;// invalid -- has to be int, not Int<br/>int my_stars3&#160;&#160;// valid<br/>int _Mystars3; // valid but reserved -- starts with underscore<br/>int 4ever;&#160;&#160;&#160;&#160;&#160;// invalid because starts with a digit<br/>int double;&#160;&#160;&#160;&#160;// invalid -- double is a C++ keyword<br/>int begin;&#160;&#160;&#160;&#160;&#160;// valid -- begin is a Pascal keyword<br/>int __fools;&#160;&#160;&#160;// valid but reserved -- starts with two underscores<br/>int the_very_best_variable_i_can_be_version_112;&#160;&#160;// valid<br/>int honky-tonk;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invalid -- no hyphens allowed</p>
<p>If you want to form a name from two or more words, the usual practice is to separate the words with an underscore character, as in <code>my_onions</code>, or to capitalize the initial character of each word after the first, as in <code>myEyeTooth</code>. (C veterans tend to use the underscore method in the C tradition, whereas those raised in the Pascal tradition prefer the capitalization approach.) Either form makes it easier to see the individual words and to distinguish between, say, <code>carDrip</code> and <code>cardRip</code>, or <code>boat_sport</code> and <code>boats_port</code>.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch03sb01"/>Naming Schemes</p>
<p class="sidebarpara">Schemes for naming variables, like schemes for naming functions, provide fertile ground for fervid discussion. Indeed, this topic produces some of the most strident disagreements in programming. Again, as with function names, the C++ compiler doesn&#8217;t care about your variable names as long as they satisfy the rules, but a consistent, precise personal naming convention will serve you well.</p>
<p class="sidebarpara">As in function naming, capitalization is a key issue in variable naming (see the sidebar &#8220;<a href="ch02.html#ch02sb11">Naming Conventions</a>&#8221; in <a href="ch02.html#ch02">Chapter 2</a>, &#8220;<a href="ch02.html#ch02">Setting Out to C++</a>&#8221;), but many programmers may insert an additional level of information in a variable name&#8212;a prefix that describes the variable&#8217;s type or contents. For instance, the integer <code>myWeight</code> might be named <code>nMyWeight</code>; here, the <code>n</code> prefix is used to represent an integer value, which is useful when you are reading code and the definition of the variable isn&#8217;t immediately at hand. Alternatively, this variable might be named <code>intMyWeight</code>, which is more precise and legible, although it does include a couple extra letters (anathema to many programmers). Other prefixes are commonly used in like fashion: <code>str</code> or <code>sz</code> might be used to represent a null-terminated string of characters, <code>b</code> might represent a Boolean value, <code>p</code> a pointer, <code>c</code> a single character.</p>
<p class="sidebarpara">As you progress into the world of C++, you will find many examples of the prefix naming style (including the handsome <code>m_lpctstr</code> prefix&#8212;a class member value that contains a long pointer to a constant, null-terminated string of characters), as well as other, more bizarre and possibly counterintuitive styles that you may or may not adopt as your own. As in all the stylistic, subjective parts of C++, consistency and precision are best. You should use variable names to fit your own needs, preferences, and personal style. (Or, if required, choose names that fit the needs, preferences, and personal style of your employer.)</p>
<hr/></div>
<h4 id="ch03lev2sec2">Integer Types</h4>
<p><a id="page_68"/><em>Integers</em> are numbers with no fractional part, such as 2, 98, &#8211;5286, and 0. There are lots of integers, assuming that you consider an infinite number to be a lot, so no finite amount of computer memory can represent all possible integers. Thus, a language can represent only a subset of all integers. Some languages offer just one integer type (one type fits all!), but C++ provides several choices. This gives you the option of choosing the integer type that best meets a program&#8217;s particular requirements. This concern with matching type to data presages the designed data types of OOP.</p>
<p>The various C++ integer types differ in the amount of memory they use to hold an integer. A larger block of memory can represent a larger range in integer values. Also some types (signed types) can represent both positive and negative values, whereas others (unsigned types) can&#8217;t represent negative values. The usual term for describing the amount of memory used for an integer is <em>width</em>. The more memory a value uses, the wider it is. C++&#8217;s basic integer types, in order of increasing width, are <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, and, with C++11, <code>long long</code>. Each comes in both signed and unsigned versions. That gives you a choice of ten different integer types! Let&#8217;s look at these integer types in more detail. Because the <code>char</code> type has some special properties (it&#8217;s most often used to represent characters instead of numbers), this chapter covers the other types first.</p>
<h4 id="ch03lev2sec3">The <code>short</code>, <code>int</code>, <code>long</code>, and <code>long long</code> Integer Types</h4>
<p>Computer memory consists of units called <em>bits</em>. (See the &#8220;<a href="#ch03sb02">Bits and Bytes</a>&#8221; sidebar later in this chapter.) By using different numbers of bits to store values, the C++ types <code>short</code>, <code>int</code>, <code>long</code>, and <code>long long</code> can represent up to four different integer widths. It would be convenient if each type were always some particular width for all systems&#8212;for example, if <code>short</code> were always 16 bits, <code>int</code> were always 32 bits, and so on. But life is not that simple. <a id="page_69"/>No one choice is suitable for all computer designs. C++ offers a flexible standard with some guaranteed minimum sizes, which it takes from C. Here&#8217;s what you get:</p>
<p class="indenthandingB">&#8226; A <code>short</code> integer is at least 16 bits wide.</p>
<p class="indenthandingB">&#8226; An <code>int</code> integer is at least as big as <code>short</code>.</p>
<p class="indenthandingB">&#8226; A <code>long</code> integer is at least 32 bits wide and at least as big as <code>int</code>.</p>
<p class="indenthandingB">&#8226; A <code>long long</code> integer is at least 64 bits wide and at least as big as <code>long</code>.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch03sb02"/>Bits and Bytes</p>
<p class="sidebarpara">The fundamental unit of computer memory is the <em>bit</em>. Think of a bit as an electronic switch that you can set to either off or on. Off represents the value 0, and on represents the value 1. An 8-bit chunk of memory can be set to 256 different combinations. The number 256 comes from the fact that each bit has two possible settings, making the total number of combinations for 8 bits 2 &#215; 2 &#215; 2 &#215; 2 &#215; 2 &#215; 2 &#215; 2 &#215; 2, or 256. Thus, an 8-bit unit can represent, say, the values 0 through 255 or the values &#8211;128 through 127. Each additional bit doubles the number of combinations. This means you can set a 16-bit unit to 65,536 different values, a 32-bit unit to 4,294,672,296 different values, and a 64-bit unit to 18,446,744,073,709,551,616 different values. As a point of comparison, <code>unsigned long</code> can&#8217;t hold the Earth&#8217;s current population or the number of stars in our galaxy, but <code>long long</code> can.</p>
<p class="sidebarpara">A <em>byte</em> usually means an 8-bit unit of memory. <em>Byte</em> in this sense is the unit of measurement that describes the amount of memory in a computer, with a kilobyte equal to 1,024 bytes and a megabyte equal to 1,024 kilobytes. However, C++ defines <em>byte</em> differently. The <em>C++ byte</em> consists of at least enough adjacent bits to accommodate the basic character set for the implementation. That is, the number of possible values must equal or exceed the number of distinct characters. In the United States, the basic character sets are usually the ASCII and EBCDIC sets, each of which can be accommodated by 8 bits, so the C++ byte is typically 8 bits on systems using those character sets. However, international programming can require much larger character sets, such as Unicode, so some implementations may use a 16-bit byte or even a 32-bit byte. Some use the term <em>octet</em> to denote an 8-bit byte.</p>
<hr/></div>
<p>Many systems currently use the minimum guarantee, making <code>short</code> 16 bits and <code>long</code> 32 bits. This still leaves several choices open for <code>int</code>. It could be 16, 24, or 32 bits in width and meet the standard. It could even be 64 bits, providing that <code>long</code> and <code>long long</code> are at least that wide. Typically, <code>int</code> is 16 bits (the same as <code>short</code>) for older IBM PC implementations and 32 bits (the same as <code>long</code>) for Windows XP, Windows Vista, Windows 7, Macintosh OS X, VAX, and many other minicomputer implementations. Some implementations give you a choice of how to handle <code>int</code>. (What does your implementation use? The next example shows you how to determine the limits for your system without your having to open a manual.) The differences between implementations for type widths can cause problems when you move a C++ program from one environment to another, including using a different compiler on the same system. But a little care, as discussed later in this chapter, can minimize those problems.</p>
<p><a id="page_70"/>You use these type names to declare variables just as you would use <code>int</code>:</p>
<p class="programlisting">short score;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// creates a type short integer variable<br/>int temperature;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// creates a type int integer variable<br/>long position;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// creates a type long integer variable</p>
<p>Actually, <code>short</code> is short for <code>short int</code> and <code>long</code> is short for <code>long int</code>, but hardly anyone uses the longer forms.</p>
<p>The four types&#8212;<code>int</code>, <code>short</code>, <code>long</code>, and <code>long long</code>&#8212;are signed types, meaning each splits its range approximately equally between positive and negative values. For example, a 16-bit <code>int</code> might run from &#8211;32,768 to +32,767.</p>
<p>If you want to know how your system&#8217;s integers size up, you can use C++ tools to investigate type sizes with a program. First, the <code>sizeof</code> operator returns the size, in bytes, of a type or a variable. (An <em>operator</em> is a built-in language element that operates on one or more items to produce a value. For example, the addition operator, represented by <code>+</code>, adds two values.) Recall that the meaning of <em>byte</em> is implementation dependent, so a 2-byte <code>int</code> could be 16 bits on one system and 32 bits on another. Second, the <code>climits</code> header file (or, for older implementations, the <code>limits.h</code> header file) contains information about integer type limits. In particular, it defines symbolic names to represent different limits. For example, it defines <code>INT_MAX</code> as the largest possible <code>int</code> value and <code>CHAR_BIT</code> as the number of bits in a byte. <a href="#ch03ex01">Listing 3.1</a> demonstrates how to use these facilities. The program also illustrates <em>initialization</em>, which is the use of a declaration statement to assign a value to a variable.</p>
<p class="caption1"><a id="ch03ex01"/><strong>Listing 3.1. <code>limits.cpp</code></strong></p><hr/>
<p class="programlisting1">// limits.cpp -- some integer limits<br/>#include &lt;iostream&gt;<br/>#include &lt;climits&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use limits.h for older systems<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int n_int = INT_MAX;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initialize n_int to max int value<br/>&#160;&#160;&#160;&#160;short n_short = SHRT_MAX;&#160;&#160;&#160;// symbols defined in climits file<br/>&#160;&#160;&#160;&#160;long n_long = LONG_MAX;<br/>&#160;&#160;&#160;&#160;long long n_llong = LLONG_MAX;<br/><br/>&#160;&#160;&#160;&#160;// sizeof operator yields size of type or of variable<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "int is " &lt;&lt; sizeof (int) &lt;&lt; " bytes." &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "short is " &lt;&lt; sizeof n_short &lt;&lt; " bytes." &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "long is " &lt;&lt; sizeof n_long &lt;&lt; " bytes." &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "long long is " &lt;&lt; sizeof n_llong &lt;&lt; " bytes." &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Maximum values:" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "int: " &lt;&lt; n_int &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "short: " &lt;&lt; n_short &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "long: " &lt;&lt; n_long &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "long long: " &lt;&lt; n_llong &lt;&lt; endl &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Minimum int value = " &lt;&lt; INT_MIN &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bits per byte = " &lt;&lt; CHAR_BIT &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch03note01"/><a id="page_71"/>Note</p>
<p class="notepara">If your system doesn&#8217;t support the <code>long_long</code> type, you should remove the lines using that type.</p>
<hr/></div>
<p>Here is sample output from the program in <a href="#ch03ex01">Listing 3.1</a>:</p>
<p class="programlisting">int is 4 bytes.<br/>short is 2 bytes.<br/>long is 4 bytes.<br/>long long is 8 bytes.<br/><br/>Maximum values:<br/>int: 2147483647<br/>short: 32767<br/>long: 2147483647<br/>long long: 9223372036854775807<br/><br/>Minimum int value = -2147483648<br/>Bits per byte = 8</p>
<p>These particular values came from a system running 64-bit Windows 7.</p>
<p>The following sections look at the chief programming features for this program.</p>
<h5 id="ch03lev3sec1">The <code>sizeof</code> Operator and the <code>climits</code> Header File</h5>
<p>The <code>sizeof</code> operator reports that <code>int</code> is 4 bytes on the base system, which uses an 8-bit byte. You can apply the <code>sizeof</code> operator to a type name or to a variable name. When you use the <code>sizeof</code> operator with a type name, such as <code>int</code>, you enclose the name in parentheses. But when you use the operator with the name of the variable, such as <code>n_short</code>, parentheses are optional:</p>
<p class="programlisting">cout &lt;&lt; "int is " &lt;&lt; sizeof (int) &lt;&lt; " bytes.\n";<br/>cout &lt;&lt; "short is " &lt;&lt; sizeof n_short &lt;&lt; " bytes.\n";</p>
<p>The <code>climits</code> header file defines symbolic constants (see the sidebar, &#8220;<a href="#ch03sb03">Symbolic Constants the Preprocessor Way</a>,&#8221; later in this chapter) to represent type limits. As mentioned previously, <code>INT_MAX</code> represents the largest value type <code>int</code> can hold; this turned out to be 2,147,483,647 for our Windows 7 system. The compiler manufacturer provides a <code>climits</code> file that reflects the values appropriate to that compiler. For example, the <code>climits</code> file for some older systems that used a 16-bit <code>int</code>, defines <code>INT_MAX</code> to represent 32,767. <a href="#ch03table01">Table 3.1</a> <a id="page_72"/>summarizes the symbolic constants defined in the <code>climits</code> file; some pertain to types you have not yet learned.</p>
<p class="caption"><a id="ch03table01"/><strong>Table 3.1. Symbolic Constants from <code>climits</code></strong></p>
<p class="image"><img src="graphics/03tab01.jpg" alt="Image"/></p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch03sb03"/>Symbolic Constants the Preprocessor Way</p>
<p class="sidebarpara">The <code>climits</code> file contains lines similar to the following:</p>
<p class="programlistingB">#define INT_MAX 32767</p>
<p class="sidebarpara">Recall that the C++ compilation process first passes the source code through a preprocessor. Here <code>#define</code>, like <code>#include</code>, is a preprocessor directive. What this particular directive tells the preprocessor is this: Look through the program for instances of <code>INT_MAX</code> and replace each occurrence with <code>32767</code>. So the <code>#define</code> directive works like a global search-and-replace command in a text editor or word processor. The altered program is compiled after these replacements occur. The preprocessor looks for independent tokens (separate words) and skips embedded words. That is, the preprocessor doesn&#8217;t replace <code>PINT_MAXIM</code> with <code>P32767IM</code>. You can use <code>#define</code> to define your own symbolic constants, too (see <a href="#ch03ex02">Listing 3.2</a>). However, the <code>#define</code> directive is a C relic. C++ has a better way of creating symbolic constants (using the <code>const</code> keyword, discussed in a later section), so you won&#8217;t be using <code>#define</code> much. But some header files, particularly those designed to be used with both C and C++, do use it.</p>
<hr/></div>
<h5 id="ch03lev3sec2">Initialization</h5>
<p><a id="page_73"/><em>Initialization</em> combines assignment with declaration. For example, the following statement declares the <code>n_int</code> variable and sets it to the largest possible type <code>int</code> value:</p>
<p class="programlisting">int n_int = INT_MAX;</p>
<p>You can also use literal constants, such as <code>255</code>, to initialize values. You can initialize a variable to another variable, provided that the other variable has been defined first. You can even initialize a variable to an expression, provided that all the values in the expression are known when program execution reaches the declaration:</p>
<p class="programlisting">int uncles = 5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initialize uncles to 5<br/>int aunts = uncles;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initialize aunts to 5<br/>int chairs = aunts + uncles + 4;&#160;&#160;&#160;&#160;&#160;&#160;// initialize chairs to 14</p>
<p>Moving the <code>uncles</code> declaration to the end of this list of statements would invalidate the other two initializations because then the value of <code>uncles</code> wouldn&#8217;t be known at the time the program tries to initialize the other variables.</p>
<p>The initialization syntax shown previously comes from C; C++ has an initialization syntax that is not shared with C:</p>
<p class="programlisting">int owls = 101;&#160;&#160;&#160;// traditional C initialization, sets owls to 101<br/>int wrens(432);&#160;&#160;&#160;// alternative C++ syntax, set wrens to 432</p>
<div class="note"><hr/>
<p class="title"><a id="ch03note02"/>Caution</p>
<p class="notepara">If you don&#8217;t initialize a variable that is defined inside a function, the variable&#8217;s value is <em>indeterminate</em>. That means the value is whatever happened to be sitting at that memory location prior to the creation of the variable.</p>
<hr/></div>
<p>If you know what the initial value of a variable should be, initialize it. True, separating the declaring of a variable from assigning it a value can create momentary suspense:</p>
<p class="programlisting">short year;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// what could it be?<br/>year = 1492;&#160;&#160;&#160;&#160;&#160;&#160;// oh</p>
<p>But initializing the variable when you declare it protects you from forgetting to assign the value later.</p>
<h5 id="ch03lev3sec3">Initialization with C++11</h5>
<p><a id="page_74"/>There&#8217;s another format for initialization that&#8217;s used with arrays and structures but in C++98 can also be used with single-valued variables:</p>
<p class="programlisting">int hamburgers = {24};&#160;&#160;// set hamburgers to 24</p>
<p>Using a braced initializer for a single-valued variable hasn&#8217;t been particularly common, but the C++11 standard is extending it some ways. First, it can be used with or without the <code>=</code> sign:</p>
<p class="programlisting">int emus{7};&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set emus to 5<br/>int rheas = {12};&#160;&#160;// set rheas to 12</p>
<p>Second, the braces can be left empty, in which case the variable is initialized to 0:</p>
<p class="programlisting">int rocs = {};&#160;&#160;&#160;&#160;&#160;// set rocs to 0<br/>int psychics{};&#160;&#160;&#160;&#160;// set psychics to 0</p>
<p>Third, it provides better protection against type conversion errors, a topic we&#8217;ll return to near the end of this chapter.</p>
<p>Why, you may ask with good reason, does the language need more alternatives? As odd as it may seem, the reason is to make using C++ easier for the novice. In the past, C++ has used different forms of initialization for different types, and the form used to initialize class variables was different from the form used for ordinary structures&#8212;and that, in turn, was different from the form usually used for simple variables such as we have been using. C++ added the parentheses form of initialization to make initializing ordinary variables more like initializing class variables. C++11 makes it possible to use the braces syntax (with or without the <code>=</code>) with all types&#8212;a universal initialization syntax. In the future, texts may introduce you to initialization using the brace forms and mention the other forms as historical oddities retained for backward compatibility.</p>
<h4 id="ch03lev2sec4">Unsigned Types</h4>
<p>Each of the four integer types you just learned about comes in an unsigned variety that can&#8217;t hold negative values. This has the advantage of increasing the largest value the variable can hold. For example, if <code>short</code> represents the range &#8211;32,768 to +32,767, the unsigned version can represent the range 0 to 65,535. Of course, you should use unsigned types only for quantities that are never negative, such as populations, bean counts, and happy face manifestations. To create unsigned versions of the basic integer types, you just use the keyword <code>unsigned</code> to modify the declarations:</p>
<p class="programlisting">unsigned short change;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// unsigned short type<br/>unsigned int rovert;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// unsigned int type<br/>unsigned quarterback;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// also unsigned int<br/>unsigned long gone;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// unsigned long type<br/>unsigned long long lang_lang;&#160;&#160;&#160;// unsigned long long type</p>
<p>Note that <code>unsigned</code> by itself is short for <code>unsigned int</code>.</p>
<p><a id="page_75"/><a href="#ch03ex02">Listing 3.2</a> illustrates the use of unsigned types. It also shows what might happen if your program tries to go beyond the limits for integer types. Finally, it gives you one last look at the preprocessor <code>#define</code> statement.</p>
<p class="caption1"><a id="ch03ex02"/><strong>Listing 3.2. <code>exceed.cpp</code></strong></p><hr/>
<p class="programlisting1">// exceed.cpp -- exceeding some integer limits<br/>#include &lt;iostream&gt;<br/>#define ZERO 0&#160;&#160;&#160;&#160;&#160;&#160;// makes ZERO symbol for 0 value<br/>#include &lt;climits&gt;&#160;&#160;// defines INT_MAX as largest int value<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;short sam = SHRT_MAX;&#160;&#160;&#160;&#160;&#160;// initialize a variable to max value<br/>&#160;&#160;&#160;&#160;unsigned short sue = sam;// okay if variable sam already defined<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sam has " &lt;&lt; sam &lt;&lt; " dollars and Sue has " &lt;&lt; sue;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " dollars deposited." &lt;&lt; endl<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Add $1 to each account." &lt;&lt; endl &lt;&lt; "Now ";<br/>&#160;&#160;&#160;&#160;sam = sam + 1;<br/>&#160;&#160;&#160;&#160;sue = sue + 1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sam has " &lt;&lt; sam &lt;&lt; " dollars and Sue has " &lt;&lt; sue;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " dollars deposited.\nPoor Sam!" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;sam = ZERO;<br/>&#160;&#160;&#160;&#160;sue = ZERO;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sam has " &lt;&lt; sam &lt;&lt; " dollars and Sue has " &lt;&lt; sue;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " dollars deposited." &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Take $1 from each account." &lt;&lt; endl &lt;&lt; "Now ";<br/>&#160;&#160;&#160;&#160;sam = sam - 1;<br/>&#160;&#160;&#160;&#160;sue = sue - 1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sam has " &lt;&lt; sam &lt;&lt; " dollars and Sue has " &lt;&lt; sue;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " dollars deposited." &lt;&lt; endl &lt;&lt; "Lucky Sue!" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s the output from the program in <a href="#ch03ex02">Listing 3.2</a>:</p>
<p class="programlisting">Sam has 32767 dollars and Sue has 32767 dollars deposited.<br/>Add $1 to each account.<br/>Now Sam has -32768 dollars and Sue has 32768 dollars deposited.<br/>Poor Sam!<br/>Sam has 0 dollars and Sue has 0 dollars deposited.<br/>Take $1 from each account.<br/>Now Sam has -1 dollars and Sue has 65535 dollars deposited.<br/>Lucky Sue!</p>
<p><a id="page_76"/>The program sets a <code>short</code> variable (<code>sam</code>) and an <code>unsigned short</code> variable (<code>sue</code>) to the largest <code>short</code> value, which is 32,767 on our system. Then it adds 1 to each value. This causes no problems for <code>sue</code> because the new value is still much less than the maximum value for an unsigned integer. But <code>sam</code> goes from 32,767 to &#8211;32,768! Similarly, subtracting 1 from 0 creates no problems for <code>sam</code>, but it makes the unsigned variable <code>sue</code> go from 0 to 65,535. As you can see, these integers behave much like an odometer. If you go past the limit, the values just start over at the other end of the range (see <a href="#ch03fig01">Figure 3.1</a>). C++ guarantees that unsigned types behave in this fashion. However, C++ doesn&#8217;t guarantee that signed integer types can exceed their limits (overflow and underflow) without complaint, but that is the most common behavior on current implementations.</p>
<p class="caption"><a id="ch03fig01"/><strong>Figure 3.1. Typical overflow behavior for integers.</strong></p>
<p class="image"><img src="graphics/03fig01.jpg" alt="Image"/></p>
<h4 id="ch03lev2sec5">Choosing an Integer Type</h4>
<p>With the richness of C++ integer types, which should you use? Generally, <code>int</code> is set to the most &#8220;natural&#8221; integer size for the target computer. <em>Natural size</em> refers to the integer form that the computer handles most efficiently. If there is no compelling reason to choose another type, you should use <code>int</code>.</p>
<p>Now look at reasons why you might use another type. If a variable represents something that is never negative, such as the number of words in a document, you can use an unsigned type; that way the variable can represent higher values.</p>
<p><a id="page_77"/>If you know that the variable might have to represent integer values too great for a 16-bit integer, you should use <code>long</code>. This is true even if <code>int</code> is 32 bits on your system. That way, if you transfer your program to a system with a 16-bit <code>int</code>, your program won&#8217;t embarrass you by suddenly failing to work properly (see <a href="#ch03fig02">Figure 3.2</a>). And if a mere two billion is inadequate for your needs, you can move up to <code>long long</code>.</p>
<p class="caption"><a id="ch03fig02"/><strong>Figure 3.2. For portability, use <code>long</code> for big integers.</strong></p>
<p class="image"><img src="graphics/03fig02.jpg" alt="Image"/></p>
<p>Using <code>short</code> can conserve memory if <code>short</code> is smaller than <code>int</code>. Most typically, this is important only if you have a large array of integers. (An <em>array</em> is a data structure that stores several values of the same type sequentially in memory.) If it is important to conserve space, you should use <code>short</code> instead of <code>int</code>, even if the two are the same size. Suppose, for example, that you move your program from a 16-bit <code>int</code> system to a 32-bit <code>int</code> system. That doubles the amount of memory needed to hold an <code>int</code> array, but it doesn&#8217;t affect the requirements for a <code>short</code> array. Remember, a bit saved is a bit earned.</p>
<p>If you need only a single byte, you can use <code>char</code>. We&#8217;ll examine that possibility soon.</p>
<h4 id="ch03lev2sec6">Integer Literals</h4>
<p><a id="page_78"/>An integer literal, or constant, is one you write out explicitly, such as 212 or 1776. C++, like C, lets you write integers in three different number bases: base 10 (the public favorite), base 8 (the old Unix favorite), and base 16 (the hardware hacker&#8217;s favorite). <a href="app01.html#app01">Appendix A</a>, &#8220;<a href="app01.html#app01">Number Bases</a>,&#8221; describes these bases; here we&#8217;ll look at the C++ representations. C++ uses the first digit or two to identify the base of a number constant. If the first digit is in the range 1&#8211;9, the number is base 10 (decimal); thus 93 is base 10. If the first digit is 0 and the second digit is in the range 1&#8211;7, the number is base 8 (octal); thus 042 is octal and equal to 34 decimal. If the first two characters are 0x or 0X, the number is base 16 (hexadecimal); thus 0x42 is hex and equal to 66 decimal. For hexadecimal values, the characters a&#8211;f and A&#8211;F represent the hexadecimal digits corresponding to the values 10&#8211;15. 0xF is 15 and 0xA5 is 165 (10 sixteens plus 5 ones). <a href="#ch03ex03">Listing 3.3</a> is tailor-made to show the three bases.</p>
<p class="caption1"><a id="ch03ex03"/><strong>Listing 3.3. <code>hexoct1.cpp</code></strong></p><hr/>
<p class="programlisting1">// hexoct1.cpp -- shows hex and octal literals<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int chest = 42;&#160;&#160;&#160;&#160;&#160;// decimal integer literal<br/>&#160;&#160;&#160;&#160;int waist = 0x42;&#160;&#160;&#160;// hexadecimal integer literal<br/>&#160;&#160;&#160;&#160;int inseam = 042;&#160;&#160;&#160;// octal integer literal<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Monsieur cuts a striking figure!\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "chest = " &lt;&lt; chest &lt;&lt; " (42 in decimal)\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "waist = " &lt;&lt; waist &lt;&lt; " (0x42 in hex)\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "inseam = " &lt;&lt; inseam &lt;&lt; " (042 in octal)\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>By default, <code>cout</code> displays integers in decimal form, regardless of how they are written in a program, as the following output shows:</p>
<p class="programlisting">Monsieur cuts a striking figure!<br/>chest = 42 (42 in decimal)<br/>waist = 66 (0x42 in hex)<br/>inseam = 34 (042 in octal)</p>
<p>Keep in mind that these notations are merely notational conveniences. For example, if you belong to a vintage PC club and read that the CGA video memory segment is B000 in hexadecimal, you don&#8217;t have to convert the value to base 10 45,056 before using it in your program. Instead, you can simply use 0xB000. But whether you write the value ten as 10, 012, or 0xA, it&#8217;s stored the same way in the computer&#8212;as a binary (base 2) value.</p>
<p><a id="page_79"/>By the way, if you want to display a value in hexadecimal or octal form, you can use some special features of <code>cout</code>. Recall that the <code>iostream</code> header file provides the <code>endl</code> manipulator to give <code>cout</code> the message to start a new line. Similarly, it provides the <code>dec</code>, <code>hex</code>, and <code>oct</code> manipulators to give <code>cout</code> the messages to display integers in decimal, hexadecimal, and octal formats, respectively. <a href="#ch03ex04">Listing 3.4</a> uses <code>hex</code> and <code>oct</code> to display the decimal value 42 in three formats. (Decimal is the default format, and each format stays in effect until you change it.)</p>
<p class="caption1"><a id="ch03ex04"/><strong>Listing 3.4. <code>hexoct2.cpp</code></strong></p><hr/>
<p class="programlisting1">// hexoct2.cpp -- display values in hex and octal<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int chest = 42;<br/>&#160;&#160;&#160;&#160;int waist = 42;<br/>&#160;&#160;&#160;&#160;int inseam = 42;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Monsieur cuts a striking figure!"&#160;&#160;&lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "chest = " &lt;&lt; chest &lt;&lt; " (decimal for 42)" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; hex;&#160;&#160;&#160;&#160;&#160;&#160;// manipulator for changing number base<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "waist = " &lt;&lt; waist &lt;&lt; " (hexadecimal for 42)" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; oct;&#160;&#160;&#160;&#160;&#160;&#160;// manipulator for changing number base<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "inseam = " &lt;&lt; inseam &lt;&lt; " (octal for 42)" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s the program output for <a href="#ch03ex04">Listing 3.4</a>:</p>
<p class="programlisting">Monsieur cuts a striking figure!<br/>chest = 42 (decimal for 42)<br/>waist = 2a (hexadecimal for 42)<br/>inseam = 52 (octal for 42)</p>
<p>Note that code like the following doesn&#8217;t display anything onscreen:</p>
<p class="programlisting">cout &lt;&lt; hex;</p>
<p>Instead, it changes the way <code>cout</code> displays integers. Thus, the manipulator <code>hex</code> is really a message to <code>cout</code> that tells it how to behave. Also note that because the identifier <code>hex</code> is part of the <code>std</code> namespace and the program uses that namespace, this program can&#8217;t use <code>hex</code> as the name of a variable. However, if you omitted the <code>using</code> directive and instead used <code>std::cout</code>, <code>std::endl</code>, <code>std::hex</code>, and <code>std::oct</code>, you could still use plain <code>hex</code> as the name for a variable.</p>
<h4 id="ch03lev2sec7">How C++ Decides What Type a Constant Is</h4>
<p><a id="page_80"/>A program&#8217;s declarations tell the C++ compiler the type of a particular integer variable. But what about constants? That is, suppose you represent a number with a constant in a program:</p>
<p class="programlisting">cout &lt;&lt; "Year = " &lt;&lt; 1492 &lt;&lt; "\n";</p>
<p>Does the program store <code>1492</code> as an <code>int</code>, a <code>long</code>, or some other integer type? The answer is that C++ stores integer constants as type <code>int</code> unless there is a reason to do otherwise. Two such reasons are if you use a special suffix to indicate a particular type or if a value is too large to be an <code>int</code>.</p>
<p>First, look at the suffixes. These are letters placed at the end of a numeric constant to indicate the type. An <code>l</code> or <code>L</code> suffix on an integer means the integer is a type <code>long</code> constant, a <code>u</code> or <code>U</code> suffix indicates an <code>unsigned int</code> constant, and <code>ul</code> (in any combination of orders and uppercase and lowercase) indicates a type <code>unsigned long</code> constant. (Because a lowercase <code>l</code> can look much like the digit <code>1</code>, you should use the uppercase <code>L</code> for suffixes.) For example, on a system using a 16-bit <code>int</code> and a 32-bit <code>long</code>, the number <code>22022</code> is stored in 16 bits as an <code>int</code>, and the number <code>22022L</code> is stored in 32 bits as a <code>long</code>. Similarly, <code>22022LU</code> and <code>22022UL</code> are <code>unsigned long</code>. C++11 provides the <code>ll</code> and <code>LL</code> suffixes for type <code>long long</code>, and <code>ull</code>, <code>Ull</code>, <code>uLL</code>, and <code>ULL</code> for <code>unsigned long long</code>.</p>
<p>Next, look at size. C++ has slightly different rules for decimal integers than it has for hexadecimal and octal integers. (Here decimal means base 10, just as hexadecimal means base 16; the term <em>decimal</em> does not necessarily imply a decimal point.) A decimal integer without a suffix is represented by the smallest of the following types that can hold it: <code>int</code>, <code>long</code>, or <code>long long</code>. On a computer system using a 16-bit <code>int</code> and a 32-bit <code>long</code>, <code>20000</code> is represented as type <code>int</code>, <code>40000</code> is represented as <code>long</code>, and <code>3000000000</code> is represented as <code>long long</code>. A hexadecimal or octal integer without a suffix is represented by the smallest of the following types that can hold it: <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long,</code> or <code>unsigned long long</code>. The same computer system that represents <code>40000</code> as <code>long</code> represents the hexadecimal equivalent 0x9C40 as an <code>unsigned int</code>. That&#8217;s because hexadecimal is frequently used to express memory addresses, which intrinsically are unsigned. So <code>unsigned int</code> is more appropriate than <code>long</code> for a 16-bit address.</p>
<h4 id="ch03lev2sec8">The <code>char</code> Type: Characters and Small Integers</h4>
<p>It&#8217;s time to turn to the final integer type: <code>char</code>. As you probably suspect from its name, the <code>char</code> type is designed to store characters, such as letters and numeric digits. Now, whereas storing numbers is no big deal for computers, storing letters is another matter. Programming languages take the easy way out by using number codes for letters. Thus, the <code>char</code> type is another integer type. It&#8217;s guaranteed to be large enough to represent the entire range of basic symbols&#8212;all the letters, digits, punctuation, and the like&#8212;for the target computer system. In practice, many systems support fewer than 128 kinds of characters, so a single byte can represent the whole range. Therefore, although <code>char</code> is most often used to handle characters, you can also use it as an integer type that is typically smaller than <code>short</code>.</p>
<p><a id="page_81"/>The most common symbol set in the United States is the ASCII character set, described in <a href="app03.html#app03">Appendix C</a>, &#8220;<a href="app03.html#app03">The ASCII Character Set</a>.&#8221; A numeric code (the ASCII code) represents each character in the set. For example, 65 is the code for the character A, and 77 is the code for the character M. For convenience, this book assumes ASCII code in its examples. However, a C++ implementation uses whatever code is native to its host system&#8212;for example, EBCDIC (pronounced &#8220;eb-se-dik&#8221;) on an IBM mainframe. Neither ASCII nor EBCDIC serve international needs that well, and C++ supports a wide-character type that can hold a larger range of values, such as are used by the international Unicode character set. You&#8217;ll learn about this <code>wchar_t</code> type later in this chapter.</p>
<p>Try the <code>char</code> type in <a href="#ch03ex05">Listing 3.5</a>.</p>
<p class="caption1"><a id="ch03ex05"/><strong>Listing 3.5. <code>chartype.cpp</code></strong></p><hr/>
<p class="programlisting1">// chartype.cpp -- the char type<br/>#include &lt;iostream&gt;<br/>int main( )<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char ch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// declare a char variable<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a character: " &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ch;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Hola! ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Thank you for the " &lt;&lt; ch &lt;&lt; " character." &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s the output from the program in <a href="#ch03ex05">Listing 3.5</a>:</p>
<p class="programlisting">Enter a character:<br/><span class="EmpStrong">M</span><br/>Hola! Thank you for the M character.</p>
<p>The interesting thing is that you type an <code>M</code>, not the corresponding character code, <code>77</code>. Also the program prints an <code>M</code>, not <code>77</code>. Yet if you peer into memory, you find that <code>77</code> is the value stored in the <code>ch</code> variable. The magic, such as it is, lies not in the <code>char</code> type but in <code>cin</code> and <code>cout</code>. These worthy facilities make conversions on your behalf. On input, <code>cin</code> converts the keystroke input <code>M</code> to the value <code>77</code>. On output, <code>cout</code> converts the value <code>77</code> to the displayed character <code>M</code>; <code>cin</code> and <code>cout</code> are guided by the type of variable. If you place the same value <code>77</code> into an <code>int</code> variable, <code>cout</code> displays it as <code>77</code>. (That is, <code>cout</code> displays two 7 characters.) <a href="#ch03ex06">Listing 3.6</a> illustrates this point. It also shows how to write a character literal in C++: Enclose the character within two single quotation marks, as in <code>'M'</code>. (Note that the example doesn&#8217;t use double quotation marks. C++ uses single quotation marks for a character and double quotation marks for a string. The <code>cout</code> object can handle either, but, as <a href="ch04.html#ch04">Chapter 4</a> discusses, the two are quite different from one another.) Finally, the program introduces a <code>cout</code> feature, the <code>cout.put()</code> function, which displays a single character.</p>
<p class="caption1"><a id="page_82"/><a id="ch03ex06"/><strong>Listing 3.6. <code>morechar.cpp</code></strong></p><hr/>
<p class="programlisting1">// morechar.cpp -- the char type and int type contrasted<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char ch = 'M';&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assign ASCII code for M to ch<br/>&#160;&#160;&#160;&#160;int i = ch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// store same code in an int<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The ASCII code for " &lt;&lt; ch &lt;&lt; " is " &lt;&lt; i &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Add one to the character code:" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;ch = ch + 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// change character code in ch<br/>&#160;&#160;&#160;&#160;i = ch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// save new character code in i<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The ASCII code for " &lt;&lt; ch &lt;&lt; " is " &lt;&lt; i &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;// using the cout.put() member function to display a char<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Displaying char ch using cout.put(ch): ";<br/>&#160;&#160;&#160;&#160;cout.put(ch);<br/><br/>&#160;&#160;&#160;&#160;// using cout.put() to display a char constant<br/>&#160;&#160;&#160;&#160;cout.put('!');<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; "Done" &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output from the program in <a href="#ch03ex06">Listing 3.6</a>:</p>
<p class="programlisting">The ASCII code for M is 77<br/>Add one to the character code:<br/>The ASCII code for N is 78<br/>Displaying char ch using cout.put(ch): N!<br/>Done</p>
<h5 id="ch03lev3sec4">Program Notes</h5>
<p>In the program in <a href="#ch03ex06">Listing 3.6</a>, the notation <code>'M'</code> represents the numeric code for the M character, so initializing the <code>char</code> variable <code>ch</code> to <code>'M'</code> sets <code>ch</code> to the value <code>77</code>. The program then assigns the identical value to the <code>int</code> variable <code>i</code>, so both <code>ch</code> and <code>i</code> have the value <code>77</code>. Next, <code>cout</code> displays <code>ch</code> as <code>M</code> and <code>i</code> as <code>77</code>. As previously stated, a value&#8217;s type guides <code>cout</code> as it chooses how to display that value&#8212;just another example of smart objects.</p>
<p>Because <code>ch</code> is really an integer, you can apply integer operations to it, such as adding 1. This changes the value of <code>ch</code> to 78. The program then resets <code>i</code> to the new value. (Equivalently, you can simply add 1 to <code>i</code>.) Again, <code>cout</code> displays the <code>char</code> version of that value as a character and the <code>int</code> version as a number.</p>
<p><a id="page_83"/>The fact that C++ represents characters as integers is a genuine convenience that makes it easy to manipulate character values. You don&#8217;t have to use awkward conversion functions to convert characters to ASCII and back.</p>
<p>Even digits entered via the keyboard are read as characters. Consider the following sequence:</p>
<p class="programlisting">char ch;<br/>cin &gt;&gt; ch;</p>
<p>If you type <code>5</code> and Enter, this code reads the <code>5</code> character and stores the character code for the <code>5</code> character (53 in ASCII) in <code>ch</code>. Now consider this code:</p>
<p class="programlisting">int n;<br/>cin &gt;&gt; n;</p>
<p>The same input results in the program reading the <code>5</code> character and running a routine converting the character to the corresponding numeric value of <code>5</code>, which gets stored in <code>n</code>.</p>
<p>Finally, the program uses the <code>cout.put()</code> function to display both <code>c</code> and a character constant.</p>
<h5 id="ch03lev3sec5">A Member Function: <code>cout.put()</code></h5>
<p>Just what is <code>cout.put()</code>, and why does it have a period in its name? The <code>cout.put()</code> function is your first example of an important C++ OOP concept, the <em>member function</em>. Remember that a class defines how to represent data and how to manipulate it. A member function belongs to a class and describes a method for manipulating class data. The <code>ostream</code> class, for example, has a <code>put()</code> member function that is designed to output characters. You can use a member function only with a particular object of that class, such as the <code>cout</code> object, in this case. To use a class member function with an object such as <code>cout</code>, you use a period to combine the object name (<code>cout</code>) with the function name (<code>put()</code>). The period is called the <em>membership operator</em>. The notation <code>cout.put()</code> means to use the class member function <code>put()</code> with the class object <code>cout</code>. You&#8217;ll learn about this in greater detail when you reach classes in <a href="ch10.html#ch10">Chapter 10</a>, &#8220;<a href="ch10.html#ch10">Objects and Classes</a>.&#8221; Now the only classes you have are the <code>istream</code> and <code>ostream</code> classes, and you can experiment with their member functions to get more comfortable with the concept.</p>
<p>The <code>cout.put()</code> member function provides an alternative to using the <code>&lt;&lt;</code> operator to display a character. At this point you might wonder why there is any need for <code>cout.put()</code>. Much of the answer is historical. Before Release 2.0 of C++, <code>cout</code> would display character <em>variables</em> as characters but display character <em>constants</em>, such as <code>'M'</code> and <code>'N'</code>, as numbers. The problem was that earlier versions of C++, like C, stored character constants as type <code>int</code>. That is, the code <code>77</code> for <code>'M'</code> would be stored in a 16-bit or 32-bit unit. Meanwhile, <code>char</code> variables typically occupied 8 bits. A statement like the following copied 8 bits (the important 8 bits) from the constant <code>'M'</code> to the variable <code>ch</code>:</p>
<p class="programlisting">char ch = 'M';</p>
<p><a id="page_84"/>Unfortunately, this meant that, to <code>cout</code>, <code>'M'</code> and <code>ch</code> looked quite different from one another, even though both held the same value. So a statement like the following would print the ASCII code for the <code>$</code> character rather than simply display <code>$</code>:</p>
<p class="programlisting">cout &lt;&lt; '$';</p>
<p>But the following would print the character, as desired:</p>
<p class="programlisting">cout.put('$');</p>
<p>Now, after Release 2.0, C++ stores single-character constants as type <code>char</code>, not type <code>int</code>. Therefore, <code>cout</code> now correctly handles character constants.</p>
<p>The <code>cin</code> object has a couple different ways of reading characters from input. You can explore these by using a program that uses a loop to read several characters, so we&#8217;ll return to this topic when we cover loops in <a href="ch05.html#ch05">Chapter 5</a>, &#8220;<a href="ch05.html#ch05">Loops and Relational Expressions</a>.&#8221;</p>
<h5 id="ch03lev3sec6"><code>char</code> Literals</h5>
<p>You have several options for writing character literals in C++. The simplest choice for ordinary characters, such as letters, punctuation, and digits, is to enclose the character in single quotation marks. This notation stands for the numeric code for the character. For example, an ASCII system has the following correspondences:</p>
<p class="indenthandingB">&#8226; <code>'A'</code> is <code>65</code>, the ASCII code for <code>A</code>.</p>
<p class="indenthandingB">&#8226; <code>'a'</code> is <code>97</code>, the ASCII code for <code>a</code>.</p>
<p class="indenthandingB">&#8226; <code>'5'</code> is <code>53</code>, the ASCII code for the digit <code>5</code>.</p>
<p class="indenthandingB">&#8226; <code>' '</code> is <code>32</code>, the ASCII code for the space character.</p>
<p class="indenthandingB">&#8226; <code>'!'</code> is <code>33</code>, the ASCII code for the exclamation point.</p>
<p>Using this notation is better than using the numeric codes explicitly. It&#8217;s clearer, and it doesn&#8217;t assume a particular code. If a system uses EBCDIC, then <code>65</code> is not the code for <code>A</code>, but <code>'A'</code> still represents the character.</p>
<p>There are some characters that you can&#8217;t enter into a program directly from the keyboard. For example, you can&#8217;t make the newline character part of a string by pressing the Enter key; instead, the program editor interprets that keystroke as a request for it to start a new line in your source code file. Other characters have difficulties because the C++ language imbues them with special significance. For example, the double quotation mark character delimits string literals, so you can&#8217;t just stick one in the middle of a string literal. C++ has special notations, called <em>escape sequences</em>, for several of these characters, as shown in <a href="#ch03table02">Table 3.2</a>. For example, <code>\a</code> represents the alert character, which beeps your terminal&#8217;s speaker or rings its bell. The escape sequence <code>\n</code> represents a newline. And <code>\"</code> represents the double quotation mark as an ordinary character instead of a string delimiter. You can use these notations in strings or in character constants, as in the following examples:</p>
<p class="caption"><a id="page_85"/><a id="ch03table02"/><strong>Table 3.2. C++ Escape Sequence Codes</strong></p>
<p class="image"><img src="graphics/03tab02.jpg" alt="Image"/></p>
<p class="programlisting">char alarm = '\a';<br/>cout &lt;&lt; alarm &lt;&lt; "Don't do that again!\a\n";<br/>cout &lt;&lt; "Ben \"Buggsie\" Hacker\nwas here!\n";</p>
<p>The last line produces the following output:</p>
<p class="programlisting">Ben "Buggsie" Hacker<br/>was here!</p>
<p>Note that you treat an escape sequence, such as <code>\n</code>, just as a regular character, such as <code>Q</code>. That is, you enclose it in single quotes to create a character constant and don&#8217;t use single quotes when including it as part of a string.</p>
<p>The escape sequence concept dates back to when people communicated with computers using the teletype, an electromechanical typewriter-printer, and modern systems don&#8217;t always honor the complete set of escape sequences. For example, some systems remain silent for the alarm character.</p>
<p>The newline character provides an alternative to <code>endl</code> for inserting new lines into output. You can use the newline character in character constant notation (<code>'\n'</code>) or as character in a string (<code>"\n"</code>). All three of the following move the screen cursor to the beginning of the next line:</p>
<p class="programlisting">cout &lt;&lt; endl;&#160;&#160;&#160;&#160;// using the endl manipulator<br/>cout &lt;&lt; '\n';&#160;&#160;&#160;&#160;// using a character constant<br/>cout &lt;&lt; "\n";&#160;&#160;&#160;&#160;// using a string</p>
<p>You can embed the newline character in a longer string; this is often more convenient than using <code>endl</code>. For example, the following two <code>cout</code> statements produce the same output:</p>
<p class="programlisting">cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "What next?" &lt;&lt; endl &lt;&lt; "Enter a number:" &lt;&lt; endl;<br/>cout &lt;&lt; "\n\nWhat next?\nEnter a number:\n";</p>
<p><a id="page_86"/>When you&#8217;re displaying a number, <code>endl</code> is a bit easier to type than <code>"\n"</code> or <code>'\n'</code>, but when you&#8217;re displaying a string, ending the string with a newline character requires less typing:</p>
<p class="programlisting">cout &lt;&lt; x &lt;&lt; endl;&#160;&#160;&#160;&#160;// easier than cout &lt;&lt; x &lt;&lt; "\n";<br/>cout &lt;&lt; "Dr. X.\n";&#160;&#160;&#160;// easier than cout &lt;&lt; "The Dr. X."&#160;&#160;&lt;&lt; endl;</p>
<p>Finally, you can use escape sequences based on the octal or hexadecimal codes for a character. For example, Ctrl+Z has an ASCII code of 26, which is 032 in octal and 0x1a in hexadecimal. You can represent this character with either of the following escape sequences: <code>\032</code> or <code>\x1a</code>. You can make character constants out of these by enclosing them in single quotes, as in <code>'\032'</code>, and you can use them as parts of a string, as in <code>"hi\x1a there"</code>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch03note03"/>Tip</p>
<p class="notepara">When you have a choice between using a numeric escape sequence or a symbolic escape sequence, as in <code>\0x8</code> versus <code>\b</code>, use the symbolic code. The numeric representation is tied to a particular code, such as ASCII, but the symbolic representation works with all codes and is more readable.</p>
<hr/></div>
<p><a href="#ch03ex07">Listing 3.7</a> demonstrates a few escape sequences. It uses the alert character to get your attention, the newline character to advance the cursor (one small step for a cursor, one giant step for cursorkind), and the backspace character to back the cursor one space to the left. (Houdini once painted a picture of the Hudson River using only escape sequences; he was, of course, a great escape artist.)</p>
<p class="caption1"><a id="ch03ex07"/><strong>Listing 3.7. <code>bondini.cpp</code></strong></p><hr/>
<p class="programlisting1">// bondini.cpp -- using escape sequences<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\aOperation \"HyperHype\" is now activated!\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your agent code:________\b\b\b\b\b\b\b\b";<br/>&#160;&#160;&#160;&#160;long code;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; code;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\aYou entered " &lt;&lt; code &lt;&lt; "...\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\aCode verified! Proceed with Plan Z3!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch03note04"/>Note</p>
<p class="notepara">Some systems might behave differently, displaying the <code>\b</code> as a small rectangle rather than backspacing, for example, or perhaps erasing while backspacing, perhaps ignoring <code>\a</code>.</p>
<hr/></div>
<p><a id="page_87"/>When you start the program in <a href="#ch03ex07">Listing 3.7</a>, it puts the following text onscreen:</p>
<p class="programlisting">Operation "HyperHype" is now activated!<br/>Enter your agent code:________</p>
<p>After printing the underscore characters, the program uses the backspace character to back up the cursor to the first underscore. You can then enter your secret code and continue. Here&#8217;s a complete run:</p>
<p class="programlisting">Operation "HyperHype" is now activated!<br/>Enter your agent code:<span class="EmpStrong">42007007</span><br/>You entered 42007007...<br/>Code verified! Proceed with Plan Z3!</p>
<h5 id="ch03lev3sec7">Universal Character Names</h5>
<p>C++ implementations support a basic source character set&#8212;that is, the set of characters you can use to write source code. It consists of the letters (uppercase and lowercase) and digits found on a standard U.S. keyboard, the symbols, such as <code>{</code> and <code>=</code>, used in the C language, and a scattering of other characters, such as the space character. Then there is a basic execution character set, which includes characters that can be processed during the execution of a program (for example, characters read from a file or displayed on screen). This adds a few more characters, such as backspace and alert. The C++ Standard also allows an implementation to offer extended source character sets and extended execution character sets. Furthermore, those additional characters that qualify as letters can be used as part of the name of an identifier. Thus, a German implementation might allow you to use umlauted vowels, and a French implementation might allow accented vowels. C++ has a mechanism for representing such international characters that is independent of any particular keyboard: the use of <em>universal character names</em>.</p>
<p>Using universal character names is similar to using escape sequences. A universal character name begins either with <code>\u</code> or <code>\U</code>. The <code>\u</code> form is followed by 8 hexadecimal digits, and the <code>\U</code> form by 16 hexadecimal digits. These digits represent the ISO 10646 code point for the character. (ISO 10646 is an international standard under development that provides numeric codes for a wide range of characters. See &#8220;<a href="#ch03sb04">Unicode and ISO 10646</a>,&#8221; later in this chapter.)</p>
<p>If your implementation supports extended characters, you can use universal character names in identifiers, as character constants, and in strings. For example, consider the following code:</p>
<p class="programlisting">int k\u00F6rper;<br/>cout &lt;&lt; "Let them eat g\u00E2teau.\n";</p>
<p>The ISO 10646 code point for &#246; is 00F6, and the code point for &#226; is 00E2. Thus, this C++ code would set the variable name to <code>k&#246;rper</code> and display the following output:</p>
<p class="programlisting">Let them eat g&#226;teau.</p>
<p><a id="page_88"/>If your system doesn&#8217;t support ISO 10646, it might display some other character for &#226; or perhaps simply display the word <code>gu00E2teau</code>.</p>
<p>Actually, from the standpoint of readability, there&#8217;s not much point to using <code>\u00F6</code> as part of a variable name, but an implementation that included the <code>&#246;</code> character as part of an extended source character set probably would also allow you to type that character from the keyboard.</p>
<p>Note that C++ uses the term &#8220;universal code name,&#8221; not, say, &#8220;universal code.&#8221; That&#8217;s because a construction such as <code>\u00F6</code> should be considered a label meaning &#8220;the character whose Unicode code point is U-00F6.&#8221; A compliant C++ compiler will recognize this as representing the <code>'&#246;'</code> character, but there is no requirement that internal coding be 00F6. Just as, in principle, the character <code>'T'</code> can be represented internally by ASCII on one computer and by a different coding system on another computer, the <code>'\u00F6'</code> character can have different encodings on different systems. Your source code can use the same universal code name on all systems, and the compiler will then represent it by the appropriate internal code used on the particular system.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch03sb04"/>Unicode and ISO 10646</p>
<p class="sidebarpara">Unicode provides a solution to the representation of various character sets by providing a standard numbering system for a great number of characters and symbols, grouping them by type. For example, the ASCII code is incorporated as a subset of Unicode, so U.S. Latin characters such as A and Z have the same representation under both systems. But Unicode also incorporates other Latin characters, such as those used in European languages; characters from other alphabets, including Greek, Cyrillic, Hebrew, Cherokee, Arabic, Thai, and Bengali; and ideographs, such as those used for Chinese and Japanese. So far Unicode represents more than 109,000 symbols and more than 90 scripts, and it is still under development. If you want to know more, you can check the Unicode Consortium&#8217;s website, at <a href="http://www.unicode.org">www.unicode.org</a>.</p>
<p class="sidebarpara">Unicode assigns a number, called a <code>code point</code>, for each of its characters. The typical notation for Unicode code points looks like this: U-222B. The U identifies this as a Unicode character, and the 222B is the hexadecimal number for the character&#8212;an integral sign, in this case.</p>
<p class="sidebarpara">The International Organization for Standardization (ISO) established a working group to develop ISO 10646, also a standard for coding multilingual text. The ISO 10646 group and the Unicode group have worked together since 1991 to keep their standards synchronized with one another.</p>
<hr/></div>
<h5 id="ch03lev3sec8"><code>signed char</code> and <code>unsigned char</code></h5>
<p>Unlike <code>int</code>, <code>char</code> is not signed by default. Nor is it unsigned by default. The choice is left to the C++ implementation in order to allow the compiler developer to best fit the type to the hardware properties. If it is vital to you that <code>char</code> has a particular behavior, you can use <code>signed char</code> or <code>unsigned char</code> explicitly as types:</p>
<p class="programlisting">char fodo;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// may be signed, may be unsigned<br/>unsigned char bar;&#160;&#160;&#160;&#160;&#160;&#160;// definitely unsigned<br/>signed char snark;&#160;&#160;&#160;&#160;&#160;&#160;// definitely signed</p>
<p><a id="page_89"/>These distinctions are particularly important if you use <code>char</code> as a numeric type. The <code>unsigned char</code> type typically represents the range 0 to 255, and <code>signed char</code> typically represents the range &#8211;128 to 127. For example, suppose you want to use a <code>char</code> variable to hold values as large as 200. That works on some systems but fails on others. You can, however, successfully use <code>unsigned char</code> for that purpose on any system. On the other hand, if you use a <code>char</code> variable to hold a standard ASCII character, it doesn&#8217;t really matter whether <code>char</code> is signed or unsigned, so you can simply use <code>char</code>.</p>
<h5 id="ch03lev3sec9">For When You Need More: <code>wchar_t</code></h5>
<p>Programs might have to handle character sets that don&#8217;t fit within the confines of a single 8-bit byte (for example, the Japanese kanji system). C++ handles this in a couple ways. First, if a large set of characters is the basic character set for an implementation, a compiler vendor can define <code>char</code> as a 16-bit byte or larger. Second, an implementation can support both a small basic character set and a larger extended character set. The usual 8-bit <code>char</code> can represent the basic character set, and another type, called <code>wchar_t</code> (for <em>w</em>ide <em>char</em>acter <em>t</em>ype), can represent the extended character set. The <code>wchar_t</code> type is an integer type with sufficient space to represent the largest extended character set used on the system. This type has the same size and sign properties as one of the other integer types, which is called the <em>underlying</em> type. The choice of underlying type depends on the implementation, so it could be <code>unsigned short</code> on one system and <code>int</code> on another.</p>
<p>The <code>cin</code> and <code>cout</code> family consider input and output as consisting of streams of <code>char</code>s, so they are not suitable for handling the <code>wchar_t</code> type. The <code>iostream</code> header file provides parallel facilities in the form of <code>wcin</code> and <code>wcout</code> for handling <code>wchar_t</code> streams. Also you can indicate a wide-character constant or string by preceding it with an <code>L</code>. The following code stores a <code>wchar_t</code> version of the letter <code>P</code> in the variable <code>bob</code> and displays a <code>wchar_t</code> version of the word <code>tall</code>:</p>
<p class="programlisting">wchar_t bob = L'P';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a wide-character constant<br/>wcout &lt;&lt; L"tall" &lt;&lt; endl;&#160;&#160;&#160;// outputting a wide-character string</p>
<p>On a system with a 2-byte <code>wchar_t</code>, this code stores each character in a 2-byte unit of memory. This book doesn&#8217;t use the wide-character type, but you should be aware of it, particularly if you become involved in international programming or in using Unicode or ISO 10646.</p>
<h5 id="ch03lev3sec10">New C++11 Types: <code>char16_t</code> and <code>char32_t</code></h5>
<p>As the programming community gained more experience with Unicode, it became clear that the <code>wchar_t</code> type wasn&#8217;t enough. It turns out that encoding characters and strings of characters on a computer system is more complex than just using the Unicode numeric values (called code points). In particular, it&#8217;s useful, when encoding strings of characters, to have a type of definite size and signedness. But the sign and size of <code>wchar_t</code> can vary from one implementation to another. So C++11 introduces the types <code>char16_t</code>, which is unsigned and 16 bits, and <code>char32_t</code>, which is unsigned and 32 bits. C++11 uses the <code>u</code> prefix for char16_t character and string constants, as in <code>u'C'</code> and <code>u"be good"</code>. Similarly, it <a id="page_90"/>uses the <code>U</code> prefix for <code>char32_t</code> constants, as in <code>U'R'</code> and <code>U"dirty rat"</code>. The <code>char16_t</code> type is a natural match for universal character names of the form <code>/u00F6</code>, and the <code>char32_t</code> type is a natural match for universal character names of the form <code>/U0000222B</code>. The prefixes <code>u</code> and <code>U</code> are used to indicate character literals of types <code>char16_t</code> and <code>char32_t</code>, respectively:</p>
<p class="programlisting">char16_t ch1 = u'q';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// basic character in 16-bit form<br/>char32_t ch2 = U'/U0000222B';&#160;&#160;// universal character name in 32-bit form</p>
<p>Like <code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code> each have an underlying type, which is one of the built-in integer types. But the underlying type can be different on one system from what it is on another.</p>
<h4 id="ch03lev2sec9">The <code>bool</code> Type</h4>
<p>The ANSI/ISO C++ Standard has added a new type (new to C++, that is), called <code>bool</code>. It&#8217;s named in honor of the English mathematician George Boole, who developed a mathematical representation of the laws of logic. In computing, a <em>Boolean variable</em> is one whose value can be either <code>true</code> or <code>false</code>. In the past, C++, like C, has not had a Boolean type. Instead, as you&#8217;ll see in greater detail in <a href="ch05.html#ch05">Chapters 5</a> and <a href="ch06.html#ch06">6</a>, C++ interprets nonzero values as true and zero values as false. Now, however, you can use the <code>bool</code> type to represent true and false, and the predefined literals <code>true</code> and <code>false</code> represent those values. That is, you can make statements like the following:</p>
<p class="programlisting">bool is_ready = true;</p>
<p>The literals <code>true</code> and <code>false</code> can be converted to type <code>int</code> by promotion, with <code>true</code> converting to 1 and <code>false</code> to 0:</p>
<p class="programlisting">int ans = true;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ans assigned 1<br/>int promise = false;&#160;&#160;&#160;&#160;&#160;&#160;// promise assigned 0</p>
<p>Also any numeric or pointer value can be converted implicitly (that is, without an explicit type cast) to a <code>bool</code> value. Any nonzero value converts to <code>true</code>, whereas a zero value converts to <code>false</code>:</p>
<p class="programlisting">bool start = -100;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start assigned true<br/>bool stop = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// stop assigned false</p>
<p>After the book introduces <code>if</code> statements (in <a href="ch06.html#ch06">Chapter 6</a>, &#8220;<a href="ch06.html#ch06">Branching Statements and Logical Operators</a>&#8221;), the <code>bool</code> type will become a common feature in the examples.</p>
<h3 id="ch03lev1sec2">The <code>const</code> Qualifier</h3>
<p>Now let&#8217;s return to the topic of symbolic names for constants. A symbolic name can suggest what the constant represents. Also if the program uses the constant in several places and you need to change the value, you can just change the single symbol definition. The <a id="page_91"/>note about <code>#define</code> statements earlier in this chapter (see the sidebar &#8220;<a href="#ch03sb03">Symbolic Constants the Preprocessor Way</a>&#8221;) promises that C++ has a better way to handle symbolic constants. That way is to use the <code>const</code> keyword to modify a variable declaration and initialization. Suppose, for example, that you want a symbolic constant for the number of months in a year. Just enter this line in a program:</p>
<p class="programlisting">const int Months = 12;&#160;&#160;// Months is symbolic constant for 12</p>
<p>Now you can use <code>Months</code> in a program instead of <code>12</code>. (A bare <code>12</code> in a program might represent the number of inches in a foot or the number of donuts in a dozen, but the name <code>Months</code> tells you what the value <code>12</code> represents.) After you initialize a constant such as <code>Months</code>, its value is set. The compiler does not let you subsequently change the value <code>Months</code>. If you try to, for example, g++ gives an error message that the program used an assignment of a read-only variable. The keyword <code>const</code> is termed a <em>qualifier</em> because it qualifies the meaning of a declaration.</p>
<p>A common practice is to capitalize the first character in a name to help remind yourself that <code>Months</code> is a constant. This is by no means a universal convention, but it helps separate the constants from the variables when you read a program. Another convention is to make all the characters uppercase; this is the usual convention for constants created using <code>#define</code>. Yet another convention is to begin constant names with the letter k, as in <code>kmonths</code>. And there are yet other conventions. Many organizations have particular coding conventions they expect their programmers to follow.</p>
<p>The general form for creating a constant is this:</p>
<p class="programlisting">const <span class="EmpItalic">type name</span> = <span class="EmpItalic">value</span>;</p>
<p>Note that you initialize a <code>const</code> in the declaration. The following sequence is no good:</p>
<p class="programlisting">const int toes;&#160;&#160;&#160;&#160;// value of toes undefined at this point<br/>toes = 10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// too late!</p>
<p>If you don&#8217;t provide a value when you declare the constant, it ends up with an unspecified value that you cannot modify.</p>
<p>If your background is in C, you might feel that the <code>#define</code> statement, which is discussed earlier, already does the job adequately. But <code>const</code> is better. For one thing, it lets you specify the type explicitly. Second, you can use C++&#8217;s scoping rules to limit the definition to particular functions or files. (Scoping rules describe how widely known a name is to different modules; you&#8217;ll learn about this in more detail in <a href="ch09.html#ch09">Chapter 9</a>, &#8220;<a href="ch09.html#ch09">Memory Models and Namespaces</a>.&#8221;) Third, you can use <code>const</code> with more elaborate types, such as arrays and structures, as discussed in <a href="ch04.html#ch04">Chapter 4</a>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch03note05"/>Tip</p>
<p class="notepara">If you are coming to C++ from C and you are about to use <code>#define</code> to define a symbolic constant, use <code>const</code> instead.</p>
<hr/></div>
<p>ANSI C also uses the <code>const</code> qualifier, which it borrows from C++. If you&#8217;re familiar with the ANSI C version, you should be aware that the C++ version is slightly different. <a id="page_92"/>One difference relates to the scope rules, and <a href="ch09.html#ch09">Chapter 9</a> covers that point. The other main difference is that in C++ (but not in C), you can use a <code>const</code> value to declare the size of an array. You&#8217;ll see examples in <a href="ch04.html#ch04">Chapter 4</a>.</p>
<h3 id="ch03lev1sec3">Floating-Point Numbers</h3>
<p>Now that you have seen the complete line of C++ integer types, let&#8217;s look at the floating-point types, which compose the second major group of fundamental C++ types. These numbers let you represent numbers with fractional parts, such as the gas mileage of an M1 tank (0.56 MPG). They also provide a much greater range in values. If a number is too large to be represented as type <code>long</code>&#8212;for example, the number of bacterial cells in a human body (estimated to be greater than 100,000,000,000)&#8212;you can use one of the floating-point types.</p>
<p>With floating-point types, you can represent numbers such as 2.5 and 3.14159 and 122442.32&#8212;that is, numbers with fractional parts. A computer stores such values in two parts. One part represents a value, and the other part scales that value up or down. Here&#8217;s an analogy. Consider the two numbers 34.1245 and 34124.5. They&#8217;re identical except for scale. You can represent the first one as 0.341245 (the base value) and 100 (the scaling factor). You can represent the second as 0.341245 (the same base value) and 100,000 (a bigger scaling factor). The scaling factor serves to move the decimal point, hence the term <em>floating-point</em>. C++ uses a similar method to represent floating-point numbers internally, except it&#8217;s based on binary numbers, so the scaling is by factors of 2 instead of by factors of 10. Fortunately, you don&#8217;t have to know much about the internal representation. The main points are that floating-point numbers let you represent fractional, very large, and very small values, and they have internal representations much different from those of integers.</p>
<h4 id="ch03lev2sec10">Writing Floating-Point Numbers</h4>
<p>C++ has two ways of writing floating-point numbers. The first is to use the standard decimal-point notation you&#8217;ve been using much of your life:</p>
<p class="programlisting">12.34&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// floating-point<br/>939001.32&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// floating-point<br/>0.00023&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// floating-point<br/>8.0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// still floating-point</p>
<p>Even if the fractional part is 0, as in 8.0, the decimal point ensures that the number is represented in floating-point format and not as an integer. (The C++ Standard does allow for implementations to represent different locales&#8212;for example, providing a mechanism for using the European method of using a comma instead of a period for the decimal point. However, these choices govern how the numbers can appear in input and output, not in code.)</p>
<p>The second method for representing floating-point values is called E notation, and it looks like this: <code>3.45E6</code>. This means that the value 3.45 is multiplied by 1,000,000; the E6 means 10 to the 6th power, which is 1 followed by 6 zeros. Thus <code>3.45E6</code> means <a id="page_93"/>3,450,000. The 6 is called an <em>exponent</em>, and the 3.45 is termed the <em>mantissa</em>. Here are more examples:</p>
<p class="programlisting">2.52e+8&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// can use E or e, + is optional<br/>8.33E-4&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// exponent can be negative<br/>7E5&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// same as 7.0E+05<br/>-18.32e13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// can have + or - sign in front<br/>1.69e12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// 2010 Brazilian public debt in reais<br/>5.98E24&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// mass of earth in kilograms<br/>9.11e-31&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// mass of an electron in kilograms</p>
<p>As you might have noticed, E notation is most useful for very large and very small numbers.</p>
<p>E notation guarantees that a number is stored in floating-point format, even if no decimal point is used. Note that you can use either <code>E</code> or <code>e</code>, and the exponent can have a positive or negative sign (see <a href="#ch03fig03">Figure 3.3</a>). However, you can&#8217;t have spaces in the number, so, for example, <code>7.2 E6</code> is invalid.</p>
<p class="caption"><a id="ch03fig03"/><strong>Figure 3.3. E notation.</strong></p>
<p class="image"><img src="graphics/03fig03.jpg" alt="Image"/></p>
<p>To use a negative exponent means to divide by a power of 10 instead of to multiply by a power of 10. So 8.33E-4 means 8.33 / 10<sup>4</sup>, or 0.000833. Similarly, the electron mass 9.11e-31 kg means 0.000000000000000000000000000000911 kg. Take your choice. (Incidentally, note that 911 is the usual emergency telephone number in the United States and that telephone messages are carried by electrons. Coincidence or scientific conspiracy? You be the judge.) Note that &#8211;8.33E4 means &#8211;83300. A sign in front applies to the number value, and a sign in the exponent applies to the scaling.</p>
<div class="note"><hr/>
<p class="title"><a id="ch03note06"/>Note</p>
<p class="notepara">The form <code>d.dddE+n</code> means move the decimal point <code>n</code> places to the right, and the form <code>d.dddE-n</code> means move the decimal point <code>n</code> places to the left. This moveable decimal point is the origin of the term &#8220;floating-point.&#8221;</p>
<hr/></div>
<h4 id="ch03lev2sec11">Floating-Point Types</h4>
<p><a id="page_94"/>Like ANSI C, C++ has three floating-point types: <code>float</code>, <code>double</code>, and <code>long double</code>. These types are described in terms of the number of significant figures they can represent and the minimum allowable range of exponents. <em>Significant figures</em> are the meaningful digits in a number. For example, writing the height of Mt. Shasta in California as 14,162 feet uses five significant figures, for it specifies the height to the nearest foot. But writing the height of Mt. Shasta as about 14,000 feet tall uses two significant figures, for the result is rounded to the nearest thousand feet; in this case, the remaining three digits are just placeholders. The number of significant figures doesn&#8217;t depend on the location of the decimal point. For example, you can write the height as 14.179 thousand feet. Again, this uses five significant digits because the value is accurate to the fifth digit.</p>
<p>In effect, the C and C++ requirements for significant digits amount to <code>float</code> being at least 32 bits, <code>double</code> being at least 48 bits and certainly no smaller than <code>float</code>, and <code>long double</code> being at least as big as <code>double</code>. All three can be the same size. Typically, however, <code>float</code> is 32 bits, <code>double</code> is 64 bits, and <code>long double</code> is 80, 96, or 128 bits. Also the range in exponents for all three types is at least &#8211;37 to +37. You can look in the <code>cfloat</code> or <code>float.h</code> header files to find the limits for your system. (<code>cfloat</code> is the C++ version of the C <code>float.h</code> file.) Here, for example, are some annotated entries from the <code>float.h</code> file for Borland C++Builder:</p>
<p class="programlisting">// the following are the minimum number of significant digits<br/>#define DBL_DIG 15&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// double<br/>#define FLT_DIG 6&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// float<br/>#define LDBL_DIG 18&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// long double<br/><br/>// the following are the number of bits used to represent the mantissa<br/>#define DBL_MANT_DIG&#160;&#160;&#160;&#160;&#160;53<br/>#define FLT_MANT_DIG&#160;&#160;&#160;&#160;&#160;24<br/>#define LDBL_MANT_DIG&#160;&#160;&#160;&#160;64<br/><br/>// the following are the maximum and minimum exponent values<br/>#define DBL_MAX_10_EXP&#160;&#160;&#160;+308<br/>#define FLT_MAX_10_EXP&#160;&#160;&#160;+38<br/>#define LDBL_MAX_10_EXP&#160;&#160;+4932<br/><br/>#define DBL_MIN_10_EXP&#160;&#160;&#160;-307<br/>#define FLT_MIN_10_EXP&#160;&#160;&#160;-37<br/>#define LDBL_MIN_10_EXP&#160;&#160;-4931</p>
<p><a href="#ch03ex08">Listing 3.8</a> examines types <code>float</code> and <code>double</code> and how they can differ in the precision to which they represent numbers (that&#8217;s the significant figure aspect). The program previews an <code>ostream</code> method called <code>setf()</code> from <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>.&#8221; This particular call forces output to stay in fixed-point notation so that you can better see the precision. It prevents the program from switching to E notation for large values and causes the program to display six digits to the right of the decimal. The arguments <a id="page_95"/><code>ios_base::fixed</code> and <code>ios_base::floatfield</code> are constants provided by including <code>iostream</code>.</p>
<p class="caption1"><a id="ch03ex08"/><strong>Listing 3.8. <code>floatnum.cpp</code></strong></p><hr/>
<p class="programlisting1">// floatnum.cpp -- floating-point types<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield); // fixed-point<br/>&#160;&#160;&#160;&#160;float tub = 10.0 / 3.0;&#160;&#160;&#160;&#160;&#160;// good to about 6 places<br/>&#160;&#160;&#160;&#160;double mint = 10.0 / 3.0;&#160;&#160;&#160;// good to about 15 places<br/>&#160;&#160;&#160;&#160;const float million = 1.0e6;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "tub = " &lt;&lt; tub;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", a million tubs = " &lt;&lt; million * tub;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ",\nand ten million tubs = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; 10 * million * tub &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "mint = " &lt;&lt; mint &lt;&lt; " and a million mints = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; million * mint &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output from the program in <a href="#ch03ex08">Listing 3.8</a>:</p>
<p class="programlisting">tub = 3.333333, a million tubs = 3333333.250000,<br/>and ten million tubs = 33333332.000000<br/>mint = 3.333333 and a million mints = 3333333.333333</p>
<h5 id="ch03lev3sec11">Program Notes</h5>
<p>Normally <code>cout</code> drops trailing zeros. For example, it would display 3333333.250000 as 3333333.25. The call to <code>cout.setf()</code> overrides that behavior, at least in new implementations. The main thing to note in <a href="#ch03ex08">Listing 3.8</a> is how <code>float</code> has less precision than <code>double</code>. Both <code>tub</code> and <code>mint</code> are initialized to 10.0 / 3.0. That should evaluate to 3.33333333333333333...(etc.). Because <code>cout</code> prints six figures to the right of the decimal, you can see that both <code>tub</code> and <code>mint</code> are accurate that far. But after the program multiplies each number by a million, you see that <code>tub</code> diverges from the proper value after the seventh three. <code>tub</code> is good to seven significant figures. (This system guarantees six significant figures for <code>float</code>, but that&#8217;s the worst-case scenario.) The type <code>double</code> variable, however, shows 13 threes, so it&#8217;s good to at least 13 significant figures. Because the system guarantees 15, this shouldn&#8217;t surprise you. Also note that multiplying a million <code>tub</code>s by 10 doesn&#8217;t quite result in the correct answer; this again points out the limitations of <code>float</code> precision.</p>
<p><a id="page_96"/>The <code>ostream</code> class to which <code>cout</code> belongs has class member functions that give you precise control over how the output is formatted&#8212;field widths, places to the right of the decimal point, decimal form or E form, and so on. <a href="ch17.html#ch17">Chapter 17</a> outlines those choices. This book&#8217;s examples keep it simple and usually just use the <code>&lt;&lt;</code> operator. Occasionally, this practice displays more digits than necessary, but that causes only aesthetic harm. If you do mind, you can skim <a href="ch17.html#ch17">Chapter 17</a> to see how to use the formatting methods. Don&#8217;t, however, expect to fully follow the explanations at this point.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch03sb05"/>Reading Include Files</p>
<p class="sidebarpara">The include directives found at the top of C++ source files often take on the air of a magical incantation; novice C++ programmers learn, through reading and experience, which header files add particular functionalities, and they include them solely to make their programs work. Don&#8217;t rely on the include files only as a source of mystic and arcane knowledge; feel free to open them up and read them. They are text files, so you can read them easily. All the files you include in your programs exist on your computer or in a place where your computer can use them. Find the includes you use and see what they contain. You&#8217;ll quickly see that the source and header files you use are an excellent source of knowledge and information&#8212;in some cases, the best documentation available. Later, as you progress into more complex inclusions and begin to use other, nonstandard libraries in your applications, this habit will serve you well.</p>
<hr/></div>
<h4 id="ch03lev2sec12">Floating-Point Constants</h4>
<p>When you write a floating-point constant in a program, in which floating-point type does the program store it? By default, floating-point constants such as 8.24 and 2.4E8 are type <code>double</code>. If you want a constant to be type <code>float</code>, you use an <code>f</code> or <code>F</code> suffix. For type <code>long double</code>, you use an <code>l</code> or <code>L</code> suffix. (Because the lowercase <code>l</code> looks a lot like the digit <code>1</code>, the uppercase <code>L</code> is a better choice.) Here are some samples:</p>
<p class="programlisting">1.234f&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a float constant<br/>2.45E20F&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a float constant<br/>2.345324E28&#160;&#160;&#160;&#160;// a double constant<br/>2.2L&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a long double constant</p>
<h4 id="ch03lev2sec13">Advantages and Disadvantages of Floating-Point Numbers</h4>
<p>Floating-point numbers have two advantages over integers. First, they can represent values between integers. Second, because of the scaling factor, they can represent a much greater range of values. On the other hand, floating point operations usually are slightly slower than integer operations, and you can lose precision. <a href="#ch03ex09">Listing 3.9</a> illustrates the last point.</p>
<p class="caption1"><a id="ch03ex09"/><strong>Listing 3.9. <code>fltadd.cpp</code></strong></p><hr/>
<p class="programlisting1">// fltadd.cpp -- precision problems with float<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;float a = 2.34E+22f;<br/>&#160;&#160;&#160;&#160;float b = a + 1.0f;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "b - a = " &lt;&lt; b - a &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_97"/>The program in <a href="#ch03ex09">Listing 3.9</a> takes a number, adds 1, and then subtracts the original number. That should result in a value of 1. Does it? Here is the output from the program in <a href="#ch03ex09">Listing 3.9</a> for one system:</p>
<p class="programlisting">a = 2.34e+022<br/>b - a = 0</p>
<p>The problem is that 2.34E+22 represents a number with 23 digits to the left of the decimal. By adding 1, you are attempting to add 1 to the 23rd digit in that number. But type <code>float</code> can represent only the first 6 or 7 digits in a number, so trying to change the 23rd digit has no effect on the value.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch03sb06"/>Classifying Data Types</p>
<p class="sidebarpara">C++ brings some order to its basic types by classifying them into families. Types <code>signed char</code>, <code>short</code>, <code>int</code>, and <code>long</code> are termed <em>signed integer</em> types. C++11 adds <code>long long</code> to that list. The unsigned versions are termed <em>unsigned integer</em> types. The <code>bool</code>, <code>char</code>, <code>wchar_t</code>, signed integer, and unsigned integer types together are termed <em>integral</em> types or <em>integer</em> types. C++11 adds <code>char16_t</code> and <code>char32_t</code> to that list. The <code>float</code>, <code>double</code>, and <code>long double</code> types are termed <em>floating-point</em> types. Integer and floating-point types are collectively termed <em>arithmetic</em> types.</p>
<hr/></div>
<h3 id="ch03lev1sec4">C++ Arithmetic Operators</h3>
<p>Perhaps you have warm memories of doing arithmetic drills in grade school. You can give that same pleasure to your computer. C++ uses operators to do arithmetic. It provides operators for five basic arithmetic calculations: addition, subtraction, multiplication, division, and taking the modulus. Each of these operators uses two values (called <em>operands</em>) to calculate a final answer. Together, the operator and its operands constitute an <em>expression</em>. For example, consider the following statement:</p>
<p class="programlisting">int wheels = 4 + 2;</p>
<p>The values <code>4</code> and <code>2</code> are operands, the <code>+</code> symbol is the addition operator, and <code>4 + 2</code> is an expression whose value is 6.</p>
<p><a id="page_98"/>Here are C++&#8217;s five basic arithmetic operators:</p>
<p class="indenthandingB">&#8226; The <code>+</code> operator adds its operands. For example, <code>4 + 20</code> evaluates to <code>24</code>.</p>
<p class="indenthandingB">&#8226; The <code>-</code> operator subtracts the second operand from the first. For example, <code>12 - 3</code> evaluates to <code>9</code>.</p>
<p class="indenthandingB">&#8226; The <code>*</code> operator multiplies its operands. For example, <code>28 * 4</code> evaluates to <code>112</code>.</p>
<p class="indenthandingB">&#8226; The <code>/</code> operator divides its first operand by the second. For example, <code>1000 / 5</code> evaluates to <code>200</code>. If both operands are integers, the result is the integer portion of the quotient. For example, <code>17 / 3</code> is <code>5</code>, with the fractional part discarded.</p>
<p class="indenthandingB">&#8226; The <code>%</code> operator finds the modulus of its first operand with respect to the second. That is, it produces the remainder of dividing the first by the second. For example, <code>19 % 6</code> is <code>1</code> because <code>6</code> goes into <code>19</code> three times, with a remainder of <code>1</code>. Both operands must be integer types; using the <code>%</code> operator with floating-point values causes a compile-time error. If one of the operands is negative, the sign of the result satisfies the following rule: <code>(a/b)*b + a%b</code> equals <code>a</code>.</p>
<p>Of course, you can use variables as well as constants for operands. <a href="#ch03ex10">Listing 3.10</a> does just that. Because the <code>%</code> operator works only with integers, we&#8217;ll leave it for a later example.</p>
<p class="caption1"><a id="ch03ex10"/><strong>Listing 3.10. <code>arith.cpp</code></strong></p><hr/>
<p class="programlisting1">// arith.cpp -- some C++ arithmetic<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;float hats, heads;<br/><br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield); // fixed-point<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a number: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; hats;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter another number: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; heads;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "hats = " &lt;&lt; hats &lt;&lt; "; heads = " &lt;&lt; heads &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "hats + heads = " &lt;&lt; hats + heads &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "hats - heads = " &lt;&lt; hats - heads &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "hats * heads = " &lt;&lt; hats * heads &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "hats / heads = " &lt;&lt; hats / heads &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>As you can see in the following sample output from the program in <a href="#ch03ex10">Listing 3.10</a>, you can trust C++ to do simple arithmetic:</p>
<p class="programlisting"><a id="page_99"/>Enter a number: <span class="EmpStrong">50.25</span><br/>Enter another number: <span class="EmpStrong">11.17</span><br/>hats = 50.250000; heads = 11.170000<br/>hats + heads = 61.419998<br/>hats - heads = 39.080002<br/>hats * heads = 561.292480<br/>hats / heads = 4.498657</p>
<p>Well, maybe you can&#8217;t trust it completely. Adding 11.17 to 50.25 should yield 61.42, but the output reports 61.419998. This is not an arithmetic problem; it&#8217;s a problem with the limited capacity of type <code>float</code> to represent significant figures. Remember, C++ guarantees just six significant figures for <code>float</code>. If you round 61.419998 to six figures, you get 61.4200, which is the correct value to the guaranteed precision. The moral is that if you need greater accuracy, you should use <code>double</code> or <code>long double</code>.</p>
<h4 id="ch03lev2sec14">Order of Operation: Operator Precedence and Associativity</h4>
<p>Can you trust C++ to do complicated arithmetic? Yes, but you must know the rules C++ uses. For example, many expressions involve more than one operator. That can raise questions about which operator gets applied first. For example, consider this statement:</p>
<p class="programlistingB">int flyingpigs = 3 + 4 * 5;&#160;&#160;// 35 or 23?</p>
<p>The 4 appears to be an operand for both the <code>+</code> and <code>*</code> operators. When more than one operator can be applied to the same operand, C++ uses <em>precedence</em> rules to decide which operator is used first. The arithmetic operators follow the usual algebraic precedence, with multiplication, division, and the taking of the modulus done before addition and subtraction. Thus <code>3 + 4 * 5</code> means <code>3 + (4 * 5)</code>, not <code>(3 + 4) * 5</code>. So the answer is <code>23</code>, not <code>35</code>. Of course, you can use parentheses to enforce your own priorities. <a href="app04.html#app04">Appendix D</a>, &#8220;<a href="app04.html#app04">Operator Precedence</a>,&#8221; shows precedence for all the C++ operators. Note that <code>*</code>, <code>/</code>, and <code>%</code> are all in the same row in <a href="app04.html#app04">Appendix D</a>. That means they have equal precedence. Similarly, addition and subtraction share a lower precedence.</p>
<p>Sometimes the precedence list is not enough. Consider the following statement:</p>
<p class="programlisting">float logs = 120 / 4 * 5;&#160;&#160;&#160;&#160;// 150 or 6?</p>
<p>Once again, 4 is an operand for two operators. But the <code>/</code> and <code>*</code> operators have the same precedence, so precedence alone doesn&#8217;t tell the program whether to first divide 120 by 4 or multiply 4 by 5. Because the first choice leads to a result of 150 and the second to a result of 6, the choice is an important one. When two operators have the same precedence, C++ looks at whether the operators have a left-to-right <em>associativity</em> or a right-to-left associativity. Left-to-right associativity means that if two operators acting on the same operand have the same precedence, you apply the left-hand operator first. For right-to-left associativity, you apply the right-hand operator first. The associativity information, too, is in <a href="app04.html#app04">Appendix D</a>. <a href="app04.html#app04">Appendix D</a> shows that multiplication and division associate left-to-right. That means you use 4 with the leftmost operator first. That is, you divide 120 by 4, get 30 as a result, and then multiply the result by 5 to get 150.</p>
<p><a id="page_100"/>Note that the precedence and associativity rules come into play only when two operators share the same operand. Consider the following expression:</p>
<p class="programlisting">int dues = 20 * 5 + 24 * 6;</p>
<p>Operator precedence tells you two things: The program must evaluate <code>20 * 5</code> before doing addition, and the program must evaluate <code>24 * 6</code> before doing addition. But neither precedence nor associativity says which multiplication takes place first. You might think that associativity says to do the leftmost multiplication first, but in this case, the two <code>*</code> operators do not share a common operand, so the rules don&#8217;t apply. In fact, C++ leaves it to the implementation to decide which order works best on a system. For this example, either order gives the same result, but there are circumstances in which the order can make a difference. You&#8217;ll see one in <a href="ch05.html#ch05">Chapter 5</a>, which discusses the increment operator.</p>
<h4 id="ch03lev2sec15">Division Diversions</h4>
<p>You have yet to see the rest of the story about the division operator (<code>/</code>). The behavior of this operator depends on the type of the operands. If both operands are integers, C++ performs integer division. That means any fractional part of the answer is discarded, making the result an integer. If one or both operands are floating-point values, the fractional part is kept, making the result floating-point. <a href="#ch03ex11">Listing 3.11</a> illustrates how C++ division works with different types of values. As in <a href="#ch03ex10">Listing 3.10</a>, <a href="#ch03ex11">Listing 3.11</a> invokes the <code>setf()</code> member function to modify how the results are displayed.</p>
<p class="caption1"><a id="ch03ex11"/><strong>Listing 3.11. <code>divide.cpp</code></strong></p><hr/>
<p class="programlisting1">// divide.cpp -- integer and floating-point division<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Integer division: 9/5 = " &lt;&lt; 9 / 5&#160;&#160;&lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Floating-point division: 9.0/5.0 = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; 9.0 / 5.0 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Mixed division: 9.0/5 = " &lt;&lt; 9.0 / 5&#160;&#160;&lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "double constants: 1e7/9.0 = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; 1.e7 / 9.0 &lt;&lt;&#160;&#160;endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "float constants: 1e7f/9.0f = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; 1.e7f / 9.0f &lt;&lt;&#160;&#160;endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output from the program in <a href="#ch03ex11">Listing 3.11</a> for one implementation:</p>
<p class="programlisting">Integer division: 9/5 = 1<br/>Floating-point division: 9.0/5.0 = 1.800000<br/>Mixed division: 9.0/5 = 1.800000<br/><a id="page_101"/>double constants: 1e7/9.0 = 1111111.111111<br/>float constants: 1e7f/9.0f = 1111111.125000</p>
<p>The first output line shows that dividing the integer 9 by the integer 5 yields the integer 1. The fractional part of 4 / 5 (or 0.8) is discarded. (You&#8217;ll see a practical use for this kind of division when you learn about the modulus operator, later in this chapter.) The next two lines show that when at least one of the operands is floating-point, you get a floating-point answer of 1.8. Actually, when you try to combine mixed types, C++ converts all the concerned types to the same type. You&#8217;ll learn about these automatic conversions later in this chapter. The relative precisions of the last two lines show that the result is type <code>double</code> if both operands are <code>double</code> and that it is <code>float</code> if both operands are <code>float</code>. Remember, floating-point constants are type <code>double</code> by default.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch03sb07"/>A Glimpse at Operator Overloading</p>
<p class="sidebarpara">In <a href="#ch03ex11">Listing 3.11</a>, the division operator represents three distinct operations: <code>int</code> division, <code>float</code> division, and <code>double</code> division. C++ uses the context&#8212;in this case the type of operands&#8212;to determine which operator is meant. The process of using the same symbol for more than one operation is called <em>operator overloading</em>. C++ has a few examples of overloading built in to the language. C++ also lets you extend operator overloading to user-defined classes, so what you see here is a precursor of an important OOP property (see <a href="#ch03fig04">Figure 3.4</a>).</p>
<p class="caption"><a id="ch03fig04"/><strong>Figure 3.4. Different divisions.</strong></p>
<p class="image"><img src="graphics/03fig04.jpg" alt="Image"/></p>
<hr/></div>
<h4 id="ch03lev2sec16">The Modulus Operator</h4>
<p>Most people are more familiar with addition, subtraction, multiplication, and division than with the modulus operation, so let&#8217;s take a moment to look at the modulus operator in action. The modulus operator returns the remainder of an integer division. In combination with integer division, the modulus operation is particularly useful in problems that require dividing a quantity into different integral units, such as converting inches to feet and inches or converting dollars to quarters, dimes, nickels, and pennies. In <a href="ch02.html#ch02">Chapter 2</a>, <a id="page_102"/><a href="ch02.html#ch02ex06">Listing 2.6</a> converts weight in British stone to pounds. <a href="#ch03ex12">Listing 3.12</a> reverses the process, converting weight in pounds to stone. A stone, you remember, is 14 pounds, and most British bathroom scales are calibrated in this unit. The program uses integer division to find the largest number of whole stone in the weight, and it uses the modulus operator to find the number of pounds left over.</p>
<p class="caption1"><a id="ch03ex12"/><strong>Listing 3.12. <code>modulus.cpp</code></strong></p><hr/>
<p class="programlisting1">// modulus.cpp -- uses % operator to convert lbs to stone<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const int Lbs_per_stn = 14;<br/>&#160;&#160;&#160;&#160;int lbs;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your weight in pounds: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; lbs;<br/>&#160;&#160;&#160;&#160;int stone = lbs / Lbs_per_stn;&#160;&#160;&#160;&#160;&#160;&#160;// whole stone<br/>&#160;&#160;&#160;&#160;int pounds = lbs % Lbs_per_stn;&#160;&#160;&#160;&#160;&#160;// remainder in pounds<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; lbs &lt;&lt; " pounds are " &lt;&lt; stone<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " stone, " &lt;&lt; pounds &lt;&lt; " pound(s).\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch03ex12">Listing 3.12</a>:</p>
<p class="programlisting">Enter your weight in pounds: <span class="EmpStrong">181</span><br/>181 pounds are 12 stone, 13 pound(s).</p>
<p>In the expression <code>lbs / Lbs_per_stn</code>, both operands are type <code>int</code>, so the computer performs integer division. With a <code>lbs</code> value of 181, the expression evaluates to 12. The product of 12 and 14 is 168, so the remainder of dividing 14 into 181 is 13, and that&#8217;s the value of <code>lbs % Lbs_per_stn</code>. Now you are prepared technically, if not emotionally, to respond to questions about your weight when you travel in Great Britain.</p>
<h4 id="ch03lev2sec17">Type Conversions</h4>
<p>C++&#8217;s profusion of types lets you match the type to the need. It also complicates life for the computer. For example, adding two <code>short</code> values may involve different hardware instructions than adding two <code>long</code> values. With 11 integer types and 3 floating-point types, the computer can have a lot of different cases to handle, especially if you start mixing types. To help deal with this potential mishmash, C++ makes many type conversions automatically:</p>
<p class="indenthandingB">&#8226; C++ converts values when you assign a value of one arithmetic type to a variable of another arithmetic type.</p>
<p class="indenthandingB">&#8226; <a id="page_103"/>C++ converts values when you combine mixed types in expressions.</p>
<p class="indenthandingB">&#8226; C++ converts values when you pass arguments to functions.</p>
<p>If you don&#8217;t understand what happens in these automatic conversions, you might find some program results baffling, so let&#8217;s take a more detailed look at the rules.</p>
<h5 id="ch03lev3sec12">Conversion on Initialization and Assignment</h5>
<p>C++ is fairly liberal in allowing you to assign a numeric value of one type to a variable of another type. Whenever you do so, the value is converted to the type of the receiving variable. For example, suppose <code>so_long</code> is type <code>long</code>, <code>thirty</code> is type <code>short</code>, and you have the following statement in a program:</p>
<p class="programlisting">so_long = thirty;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assigning a short to a long</p>
<p>The program takes the value of <code>thirty</code> (typically a 16-bit value) and expands it to a <code>long</code> value (typically a 32-bit value) upon making the assignment. Note that the expansion creates a new value to place into <code>so_long</code>; the contents of <code>thirty</code> are unaltered.</p>
<p>Assigning a value to a type with a greater range usually poses no problem. For example, assigning a <code>short</code> value to a <code>long</code> variable doesn&#8217;t change the value; it just gives the value a few more bytes in which to laze about. However, assigning a large <code>long</code> value such as 2111222333 to a <code>float</code> variable results in the loss of some precision. Because <code>float</code> can have just six significant figures, the value can be rounded to 2.11122E9. So while some conversions are safe, some may pose difficulties. <a href="#ch03table03">Table 3.3</a> points out some possible conversion problems.</p>
<p class="caption"><a id="ch03table03"/><strong>Table 3.3. Potential Numeric Conversion Problems</strong></p>
<p class="image"><img src="graphics/03tab03.jpg" alt="Image"/></p>
<p>A zero value assigned to a <code>bool</code> variable is converted to <code>false</code>, and a nonzero value is converted to <code>true</code>.</p>
<p>Assigning floating-point values to integer types poses a couple problems. First, converting floating-point to integer results in truncating the number (discarding the fractional part). Second, a <code>float</code> value might be too big to fit in a cramped <code>int</code> variable. In that <a id="page_104"/>case, C++ doesn&#8217;t define what the result should be; that means different implementations can respond differently.</p>
<p>Traditional initialization behaves the same as assignment. <a href="#ch03ex13">Listing 3.13</a> shows a few conversions by initialization.</p>
<p class="caption1"><a id="ch03ex13"/><strong>Listing 3.13. <code>init.cpp</code></strong></p><hr/>
<p class="programlisting1">// init.cpp -- type changes on initialization<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;float tree = 3;&#160;&#160;&#160;&#160;&#160;// int converted to float<br/>&#160;&#160;&#160;&#160;int guess(3.9832);&#160;&#160;// double converted to int<br/>&#160;&#160;&#160;&#160;int debt = 7.2E12;&#160;&#160;// result not defined in C++<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "tree = " &lt;&lt; tree &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "guess = " &lt;&lt; guess &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "debt = " &lt;&lt; debt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output from the program in <a href="#ch03ex13">Listing 3.13</a> for one system:</p>
<p class="programlisting">tree = 3.000000<br/>guess = 3<br/>debt = 1634811904</p>
<p>In this case, <code>tree</code> is assigned the floating-point value 3.0. Assigning 3.9832 to the <code>int</code> variable <code>guess</code> causes the value to be truncated to 3; C++ uses truncation (discarding the fractional part) and not rounding (finding the closest integer value) when converting floating-point types to integer types. Finally, note that the <code>int</code> variable <code>debt</code> is unable to hold the value 7.2E12. This creates a situation in which C++ doesn&#8217;t define the result. On this system, <code>debt</code> ends up with the value 1634811904, or about 1.6E09. Well, that&#8217;s a novel way to reduce massive indebtedness!</p>
<p>Some compilers issue warnings of possible data loss for those statements that initialize integer variables to floating-point values. Also the value displayed for <code>debt</code> varies from compiler to compiler. For example, running the same program from <a href="#ch03ex13">Listing 3.13</a> on a second system produced a value of 2147483647.</p>
<h5 id="ch03lev3sec13">Initialization Conversions When <code>{}</code> Are Used (C++11)</h5>
<p>C++11 calls an initialization that uses braces a <em>list-initialization</em>. That&#8217;s because this form can be used more generally to provide lists of values for more complicated data types. It&#8217;s more restrictive in type conversions than the forms used in <a href="ch13.html#ch13ex03">Listing 13.3</a>. In particular, list-initialization doesn&#8217;t permit <em>narrowing</em>, which is when the type of the variable may not be able to represent the assigned value. For example, conversions of floating types to integer <a id="page_105"/>types are not allowed. Converting from integer types to other integer types or floating types may be allowed if the compiler can tell if the target variable can hold the value correctly. For instance, it&#8217;s okay to initialize a <code>long</code> variable to an <code>int</code> value because <code>long</code> is always at least as big as <code>int</code>. Conversions in the other direction may be allowed if the value is a constant that can be handled by the type:</p>
<p class="programlisting">const int code = 66;<br/>int x = 66;<br/>char c1 {31325};&#160;&#160;// narrowing, not allowed<br/>char c2 = {66};&#160;&#160;&#160;// allowed because char can hold 66<br/>char c3 {code};&#160;&#160;&#160;// ditto<br/>char c4 = {x};&#160;&#160;&#160;&#160;// not allowed, x is not constant<br/>x = 31325;<br/>char c5 = x;&#160;&#160;&#160;&#160;&#160;// allowed by this form of initialization</p>
<p>For the initialization of <code>c4</code>, we know <code>x</code> has the value <code>66</code>, but to the compiler, <code>x</code> is a variable and conceivably could have some other, much larger value. It&#8217;s not the compiler&#8217;s job to keep track of what may have happened to <code>x</code> between the time it was initialized and the time it was used in the attempted initialization of <code>c4</code>.</p>
<h5 id="ch03lev3sec14">Conversions in Expressions</h5>
<p>Consider what happens when you combine two different arithmetic types in one expression. C++ makes two kinds of automatic conversions in that case. First, some types are automatically converted whenever they occur. Second, some types are converted when they are combined with other types in an expression.</p>
<p>First, let&#8217;s examine the automatic conversions. When it evaluates expressions, C++ converts <code>bool</code>, <code>char</code>, <code>unsigned char</code>, <code>signed char</code>, and <code>short</code> values to <code>int</code>. In particular, <code>true</code> is promoted to 1 and <code>false</code> to 0. These conversions are termed <em>integral promotions</em>. For example, consider the following fowl statements:</p>
<p class="programlisting">short chickens = 20;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// line 1<br/>short ducks = 35;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// line 2<br/>short fowl = chickens + ducks; // line 3</p>
<p>To execute the statement on line 3, a C++ program takes the values of <code>chickens</code> and <code>ducks</code> and converts both to <code>int</code>. Then the program converts the result back to type <code>short</code> because the answer is assigned to a type <code>short</code> variable. You might find this a bit roundabout, but it does make sense. The <code>int</code> type is generally chosen to be the computer&#8217;s most natural type, which means the computer probably does calculations fastest for that type.</p>
<p>There are more integral promotions: The <code>unsigned short</code> type is converted to <code>int</code> if <code>short</code> is smaller than <code>int</code>. If the two types are the same size, <code>unsigned short</code> is converted to <code>unsigned int</code>. This rule ensures that there&#8217;s no data loss in promoting <code>unsigned short</code>. Similarly, <code>wchar_t</code> is promoted to the first of the following types that is wide enough to accommodate its range: <code>int</code>, <code>unsigned int</code>, <code>long</code>, or <code>unsigned long</code>.</p>
<p><a id="page_106"/>Then there are the conversions that take place when you arithmetically combine different types, such as adding an <code>int</code> to a <code>float</code>. When an operation involves two types, the smaller is converted to the larger. For example, the program in <a href="#ch03ex11">Listing 3.11</a> divides 9.0 by 5. Because 9.0 is type <code>double</code>, the program converts 5 to type <code>double</code> before it does the division. More generally, the compiler goes through a checklist to determine which conversions to make in an arithmetic expression. C++11 has modified the list slightly. Here&#8217;s the C++11 version of the list, which the compiler goes through in order:</p>
<p class="indenthandingN"><strong>1.</strong> If either operand is type <code>long double</code>, the other operand is converted to <code>long double</code>.</p>
<p class="indenthandingN"><strong>2.</strong> Otherwise, if either operand is <code>double</code>, the other operand is converted to <code>double</code>.</p>
<p class="indenthandingN"><strong>3.</strong> Otherwise, if either operand is <code>float</code>, the other operand is converted to <code>float</code>.</p>
<p class="indenthandingN"><strong>4.</strong> Otherwise, the operands are integer types and the integral promotions are made.</p>
<p class="indenthandingN"><strong>5.</strong> In that case, if both operands are signed or if both are unsigned, and one is of lower rank than the other, it is converted to the higher rank.</p>
<p class="indenthandingN"><strong>6.</strong> Otherwise, one operand is signed and one is unsigned. If the unsigned operand is of higher rank than the signed operand, the latter is converted to the type of the unsigned operand.</p>
<p class="indenthandingN"><strong>7.</strong> Otherwise, if the signed type can represent all values of the unsigned type, the unsigned operand is converted to the type of the signed type.</p>
<p class="indenthandingN"><strong>8.</strong> Otherwise, both operands are converted to the unsigned version of the signed type.</p>
<p>ANSI C follows the same rules as ISO 2003 C++, which are slightly different from the preceding rules, and classic K&#38;R C has yet slightly different rules. For example, classic C always promotes <code>float</code> to <code>double</code>, even if both operands are <code>float</code>.</p>
<p>This list introduces the concept of ranking the integer types. In brief, as you might expect, the basic ranking for signed integer types from high to low is <code>long long</code>, <code>long</code>, <code>int</code>, <code>short</code>, and <code>signed char</code>. Unsigned types have the same rank as the corresponding signed type. The three types <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> all have the same rank. The <code>bool</code> type has the lowest rank. The <code>wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code> have the same types as their underlying types.</p>
<h5 id="ch03lev3sec15">Conversions in Passing Arguments</h5>
<p>Normally, C++ function prototyping controls type conversions for the passing of arguments, as you&#8217;ll learn in <a href="ch07.html#ch07">Chapter 7</a>, &#8220;<a href="ch07.html#ch07">Functions: C++&#8217;s Programming Modules</a>.&#8221; However, it is possible, although usually unwise, to waive prototype control for argument passing. In that case, C++ applies the integral promotions to the <code>char</code> and <code>short</code> types (<code>signed</code> <a id="page_107"/>and <code>unsigned</code>). Also to preserve compatibility with huge amounts of code in classic C, C++ promotes <code>float</code> arguments to <code>double</code> when passing them to a function that waives prototyping.</p>
<h5 id="ch03lev3sec16">Type Casts</h5>
<p>C++ empowers you to force type conversions explicitly via the type cast mechanism. (C++ recognizes the need for type rules, and it also recognizes the need to occasionally override those rules.) The type cast comes in two forms. For example, to convert an <code>int</code> value stored in a variable called <code>thorn</code> to type <code>long</code>, you can use either of the following expressions:</p>
<p class="programlisting">(long) thorn&#160;&#160;&#160;&#160;// returns a type long conversion of thorn<br/>long (thorn)&#160;&#160;&#160;&#160;// returns a type long conversion of thorn</p>
<p>The type cast doesn&#8217;t alter the <code>thorn</code> variable itself; instead, it creates a new value of the indicated type, which you can then use in an expression, as in the following:</p>
<p class="programlisting">cout &lt;&lt; int('Q');&#160;&#160;// displays the integer code for 'Q'</p>
<p>More generally, you can do the following:</p>
<p class="programlisting">(<span class="EmpItalic">typeName</span>) <span class="EmpItalic">value</span>&#160;&#160;&#160;// converts value to typeName type<br/><span class="EmpItalic">typeName</span> (<span class="EmpItalic">value</span>)&#160;&#160;&#160;// converts value to typeName type</p>
<p>The first form is straight C. The second form is pure C++. The idea behind the new form is to make a type cast look like a function call. This makes type casts for the built-in types look like the type conversions you can design for user-defined classes.</p>
<p>C++ also introduces four type cast operators that are more restrictive in how they can be used. <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>,&#8221; covers them. Of the four, the <code>static_cast&lt;&gt;</code> operator, can be used for converting values from one numeric type to another. For example, using it to convert <code>thorn</code> to a type <code>long</code> value looks like this:</p>
<p class="programlisting">static_cast&lt;long&gt; (thorn)&#160;&#160;&#160;&#160;&#160;// returns a type long conversion of thorn</p>
<p>More generally, you can do the following:</p>
<p class="programlisting">static_cast&lt;<span class="EmpItalic">typeName</span>&gt; (<span class="EmpItalic">value)</span>&#160;&#160;&#160;// converts value to typeName type</p>
<p>As <a href="ch15.html#ch15">Chapter 15</a> discusses further, Stroustrup felt that the traditional C-style type cast is dangerously unlimited in its possibilities. The <code>static_cast&lt;&gt;</code> operator is more restrictive than the traditional type cast.</p>
<p><a href="#ch03ex14">Listing 3.14</a> briefly illustrates both the basic type cast (two forms) and <code>static_cast&lt;&gt;</code>. Imagine that the first section of this listing is part of a powerful ecological modeling program that does floating-point calculations that are converted to integral numbers of birds and animals. The results you get depend on when you convert. The calculation for <code>auks</code> first adds the floating-point values and then converts the sum to <code>int</code> upon assignment. But the calculations for <code>bats</code> and <code>coots</code> first use type casts to convert the floating-point values to <code>int</code> and then sum the values. The final part of the program shows how you can use a type cast to display the ASCII code for a type <code>char</code> value.</p>
<p class="caption1"><a id="page_108"/><a id="ch03ex14"/><strong>Listing 3.14. <code>typecast.cpp</code></strong></p><hr/>
<p class="programlisting1">// typecast.cpp -- forcing type changes<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int auks, bats, coots;<br/><br/>&#160;&#160;&#160;&#160;// the following statement adds the values as double,<br/>&#160;&#160;&#160;&#160;// then converts the result to int<br/>&#160;&#160;&#160;&#160;auks = 19.99 + 11.99;<br/><br/>&#160;&#160;&#160;&#160;// these statements add values as int<br/>&#160;&#160;&#160;&#160;bats = (int) 19.99 + (int) 11.99;&#160;&#160;&#160;// old C syntax<br/>&#160;&#160;&#160;&#160;coots = int (19.99) + int (11.99);&#160;&#160;// new C++ syntax<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "auks = " &lt;&lt; auks &lt;&lt; ", bats = " &lt;&lt; bats;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", coots = " &lt;&lt; coots &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;char ch = 'Z';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The code for " &lt;&lt; ch &lt;&lt; " is ";&#160;&#160;&#160;&#160;// print as char<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; int(ch) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// print as int<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Yes, the code is ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// using static_cast<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the result of the program in <a href="#ch03ex14">Listing 3.14</a>:</p>
<p class="programlisting">auks = 31, bats = 30, coots = 30<br/>The code for Z is 90<br/>Yes, the code is 90</p>
<p>First, adding 19.99 to 11.99 yields 31.98. When this value is assigned to the <code>int</code> variable <code>auks</code>, it&#8217;s truncated to 31. But using type casts truncates the same two values to 19 and 11 before addition, making 30 the result for both <code>bats</code> and <code>coots</code>. Then two <code>cout</code> statements use type casts to convert a type <code>char</code> value to <code>int</code> before they display the result. These conversions cause <code>cout</code> to print the value as an integer rather than as a character.</p>
<p>This program illustrates two reasons to use type casting. First, you might have values that are stored as type <code>double</code> but are used to calculate a type <code>int</code> value. For example, you might be fitting a position to a grid or modeling integer values, such as populations, with floating-point numbers. You might want the calculations to treat the values as <code>int</code>. Type casting enables you to do so directly. Notice that you get a different result, at least for these values, when you convert to <code>int</code> and add than you do when you add first and then convert to <code>int</code>.</p>
<p><a id="page_109"/>The second part of the program shows the most common reason to use a type cast: the capability to compel data in one form to meet a different expectation. In <a href="#ch03ex14">Listing 3.14</a>, for example, the <code>char</code> variable <code>ch</code> holds the code for the letter Z. Using <code>cout</code> with <code>ch</code> displays the character Z because <code>cout</code> zeros in on the fact that <code>ch</code> is type <code>char</code>. But by type casting <code>ch</code> to type <code>int</code>, you get <code>cout</code> to shift to <code>int</code> mode and print the ASCII code stored in <code>ch</code>.</p>
<h4 id="ch03lev2sec18"><code>auto</code> Declarations in C++11</h4>
<p>C++11 introduces a facility that allows the compiler to deduce a type from the type of an initialization value. For this purpose it redefines the meaning of <code>auto</code>, a keyword dating back to C, but one hardly ever used. (<a href="ch09.html#ch09">Chapter 9</a> discusses the previous meaning of <code>auto</code>.) Just use <code>auto</code> instead of the type name in an initializing declaration, and the compiler assigns the variable the same type as that of the initializer:</p>
<p class="programlisting">auto n = 100;&#160;&#160;&#160;&#160;&#160;// n is int<br/>auto x = 1.5;&#160;&#160;&#160;&#160;&#160;// x is double<br/>auto y = 1.3e12L; // y is long double</p>
<p>However, this automatic type deduction isn&#8217;t really intended for such simple cases. Indeed, you might even go astray. For example, suppose <code>x</code>, <code>y</code>, and <code>z</code> are all intended to be type <code>double</code>. Consider the following code:</p>
<p class="programlisting">auto x = 0.0;&#160;&#160;&#160;// ok, x is double because 0.0 is double<br/>double y = 0;&#160;&#160;&#160;// ok, 0 automatically converted to 0.0<br/>auto z = 0;&#160;&#160;&#160;&#160;&#160;// oops, z is int because 0 is int</p>
<p>Using <code>0</code> instead of <code>0.0</code> doesn&#8217;t cause problems with explicit typing, but it does with automatic type conversion.</p>
<p>Automatic type deduction becomes much more useful when dealing with complicated types, such as those in the STL (Standard Template Library). For example, C++98 code might have this:</p>
<p class="programlisting">std::vector&lt;double&gt; scores;<br/>std::vector&lt;double&gt;::iterator pv = scores.begin();</p>
<p>C++11 allows you to write this instead:</p>
<p class="programlisting">std::vector&lt;double&gt; scores;<br/>auto pv = scores.begin();</p>
<p>We&#8217;ll mention this new meaning of <code>auto</code> again later when it becomes more relevant to the topics at hand.</p>
<h3 id="ch03lev1sec5">Summary</h3>
<p>C++&#8217;s basic types fall into two groups. One group consists of values that are stored as integers. The second group consists of values that are stored in floating-point format. The integer types differ from each other in the amount of memory used to store values and in whether they are signed or unsigned. From smallest to largest, the integer types are <code>bool</code>, <a id="page_110"/><code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>, <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, and, with C++11, <code>long long</code>, and <code>unsigned long long</code>. There is also a <code>wchar_t</code> type whose placement in this sequence of size depends on the implementation. C++11 adds the <code>char16_t</code> and <code>char32_t</code> types, which are wide enough to hold 16-bit and 32-bit character codes, respectively. C++ guarantees that <code>char</code> is large enough to hold any member of the system&#8217;s basic character set, <code>wchar_t</code> can hold any member of the system&#8217;s extended character set, <code>short</code> is at least 16 bits, <code>int</code> is at least as big as <code>short</code>, and <code>long</code> is at least 32 bits and at least as large as <code>int</code>. The exact sizes depend on the implementation.</p>
<p>Characters are represented by their numeric codes. The I/O system determines whether a code is interpreted as a character or as a number.</p>
<p>The floating-point types can represent fractional values and values much larger than integers can represent. The three floating-point types are <code>float</code>, <code>double</code>, and <code>long double</code>. C++ guarantees that <code>float</code> is no larger than <code>double</code> and that <code>double</code> is no larger than <code>long double</code>. Typically, <code>float</code> uses 32 bits of memory, <code>double</code> uses 64 bits, and <code>long double</code> uses 80 to 128 bits.</p>
<p>By providing a variety of types in different sizes and in both signed and unsigned varieties, C++ lets you match the type to particular data requirements.</p>
<p>C++ uses operators to provide the usual arithmetical support for numeric types: addition, subtraction, multiplication, division, and taking the modulus. When two operators seek to operate on the same value, C++&#8217;s precedence and associativity rules determine which operation takes place first.</p>
<p>C++ converts values from one type to another when you assign values to a variable, mix types in arithmetic, and use type casts to force type conversions. Many type conversions are &#8220;safe,&#8221; meaning you can make them with no loss or alteration of data. For example, you can convert an <code>int</code> value to a <code>long</code> value with no problems. Others, such as conversions of floating-point types to integer types, require more care.</p>
<p>At first, you might find the large number of basic C++ types a little excessive, particularly when you take into account the various conversion rules. But most likely you will eventually find occasions when one of the types is just what you need at the time, and you&#8217;ll thank C++ for having it.</p>
<h3 id="ch03lev1sec6">Chapter Review</h3>
<p class="question"><a id="ch03qa1q1" href="app10.html#ch03qa1a1"><strong>1.</strong></a> Why does C++ have more than one integer type?</p>
<p class="question"><a id="ch03qa1q2" href="app10.html#ch03qa1a2"><strong>2.</strong></a> Declare variables matching the following descriptions:</p>
<p class="indenthandinga"><strong>a.</strong> A <code>short</code> integer with the value 80</p>
<p class="indenthandinga"><strong>b.</strong> An <code>unsigned int</code> integer with the value 42,110</p>
<p class="indenthandinga"><strong>c.</strong> An integer with the value 3,000,000,000</p>
<p class="question"><a id="page_111"/><a id="ch03qa1q3" href="app10.html#ch03qa1a3"><strong>3.</strong></a> What safeguards does C++ provide to keep you from exceeding the limits of an integer type?</p>
<p class="question"><a id="ch03qa1q4" href="app10.html#ch03qa1a4"><strong>4.</strong></a> What is the distinction between 33L and 33?</p>
<p class="question"><a id="ch03qa1q5" href="app10.html#ch03qa1a5"><strong>5.</strong></a> Consider the two C++ statements that follow:</p>
<p class="programlistingB">char grade = 65;<br/>char grade = 'A';</p>
<p class="questionp">Are they equivalent?</p>
<p class="question"><a id="ch03qa1q6" href="app10.html#ch03qa1a6"><strong>6.</strong></a> How could you use C++ to find out which character the code 88 represents? Come up with at least two ways.</p>
<p class="question"><a id="ch03qa1q7" href="app10.html#ch03qa1a7"><strong>7.</strong></a> Assigning a <code>long</code> value to a <code>float</code> can result in a rounding error. What about assigning <code>long</code> to <code>double</code>? <code>long long</code> to <code>double</code>?</p>
<p class="question"><a id="ch03qa1q8" href="app10.html#ch03qa1a8"><strong>8.</strong></a> Evaluate the following expressions as C++ would:</p>
<p class="indenthandinga"><strong>a.</strong> 8 * 9 + 2</p>
<p class="indenthandinga"><strong>b.</strong> 6 * 3 / 4</p>
<p class="indenthandinga"><strong>c.</strong> 3 / 4 * 6</p>
<p class="indenthandinga"><strong>d.</strong> 6.0 * 3 / 4</p>
<p class="indenthandinga"><strong>e.</strong> 15 % 4</p>
<p class="question"><a id="ch03qa1q9" href="app10.html#ch03qa1a9"><strong>9.</strong></a> Suppose <code>x1</code> and <code>x2</code> are two type <code>double</code> variables that you want to add as integers and assign to an integer variable. Construct a C++ statement for doing so. What if you want to add them as type <code>double</code> and then convert to <code>int</code>?</p>
<p class="question1"><a id="ch03qa1q10" href="app10.html#ch03qa1a10"><strong>10.</strong></a> What is the variable type for each of the following declarations?</p>
<p class="indenthandinga"><strong>a.</strong> <code>auto cars = 15;</code></p>
<p class="indenthandinga"><strong>b.</strong> <code>auto iou = 150.37f;</code></p>
<p class="indenthandinga"><strong>c.</strong> <code>auto level = 'B';</code></p>
<p class="indenthandinga"><strong>d.</strong> <code>auto crat = U'/U00002155';</code></p>
<p class="indenthandinga"><strong>e.</strong> <code>auto fract = 8.25f/2.5;</code></p>
<h3 id="ch03lev1sec7">Programming Exercises</h3>
<p class="question"><a id="ch03qa2q1"/><strong>1.</strong> Write a short program that asks for your height in integer inches and then converts your height to feet and inches. Have the program use the underscore character to indicate where to type the response. Also use a <code>const</code> symbolic constant to represent the conversion factor.</p>
<p class="question"><a id="page_112"/><a id="ch03qa2q2"/><strong>2.</strong> Write a short program that asks for your height in feet and inches and your weight in pounds. (Use three variables to store the information.) Have the program report your body mass index (BMI). To calculate the BMI, first convert your height in feet and inches to your height in inches (1 foot = 12 inches). Then convert your height in inches to your height in meters by multiplying by 0.0254. Then convert your weight in pounds into your mass in kilograms by dividing by 2.2. Finally, compute your BMI by dividing your mass in kilograms by the square of your height in meters. Use symbolic constants to represent the various conversion factors.</p>
<p class="question"><a id="ch03qa2q3"/><strong>3.</strong> Write a program that asks the user to enter a latitude in degrees, minutes, and seconds and that then displays the latitude in decimal format. There are 60 seconds of arc to a minute and 60 minutes of arc to a degree; represent these values with symbolic constants. You should use a separate variable for each input value. A sample run should look like this:</p>
<p class="programlistingB">Enter a latitude in degrees, minutes, and seconds:<br/>First, enter the degrees: <span class="EmpStrong">37</span><br/>Next, enter the minutes of arc: <span class="EmpStrong">51</span><br/>Finally, enter the seconds of arc: <span class="EmpStrong">19</span><br/>37 degrees, 51 minutes, 19 seconds = 37.8553 degrees</p>
<p class="question"><a id="ch03qa2q4"/><strong>4.</strong> Write a program that asks the user to enter the number of seconds as an integer value (use type <code>long</code>, or, if available, <code>long long</code>) and that then displays the equivalent time in days, hours, minutes, and seconds. Use symbolic constants to represent the number of hours in the day, the number of minutes in an hour, and the number of seconds in a minute. The output should look like this:</p>
<p class="programlistingB">Enter the number of seconds: <span class="EmpStrong">31600000</span><br/>31600000 seconds = 365 days, 17 hours, 46 minutes, 40 seconds</p>
<p class="question"><a id="ch03qa2q5"/><strong>5.</strong> Write a program that requests the user to enter the current world population and the current population of the U.S. (or of some other nation of your choice). Store the information in variables of type <code>long long</code>. Have the program display the percent that the U.S. (or other nation&#8217;s) population is of the world&#8217;s population. The output should look something like this:</p>
<p class="programlistingB">Enter the world's population: <span class="EmpStrong">6898758899</span><br/>Enter the population of the US: <span class="EmpStrong">310783781</span><br/>The population of the US is 4.50492% of the world population.</p>
<p class="questionp">You can use the Internet to get more recent figures.</p>
<p class="question"><a id="ch03qa2q6"/><strong>6.</strong> Write a program that asks how many miles you have driven and how many gallons of gasoline you have used and then reports the miles per gallon your car has gotten. Or, if you prefer, the program can request distance in kilometers and petrol in liters and then report the result European style, in liters per 100 kilometers.</p>
<p class="question"><a id="page_113"/><a id="ch03qa2q7"/><strong>7.</strong> Write a program that asks you to enter an automobile gasoline consumption figure in the European style (liters per 100 kilometers) and converts to the U.S. style of miles per gallon. Note that in addition to using different units of measurement, the U.S. approach (distance / fuel) is the inverse of the European approach (fuel / distance). Note that 100 kilometers is 62.14 miles, and 1 gallon is 3.875 liters. Thus, 19 mpg is about 12.4 l/100 km, and 27 mpg is about 8.7 l/100 km.</p>
</body>
</html>
