## 5。循环和关系表达式

在本章中，您将了解以下内容：

• `for`循环• 表达和陈述•增量和递减运算符：`++`和`--`•组合分配运算符•复合语句（块）•逗号运算符•关系运算符：`>`、`>=`、`==`、`<=`、`<`和`!=`•`while`循环• `typedef`设施• 循环`do while`• `get()`字符输入方法•文件结束状态•嵌套循环和二维阵列

计算机不仅能存储数据。他们分析、整合、重新排列、提取、修改、推断、合成和以其他方式操作数据。有时，他们甚至会扭曲和垃圾数据，但我们会尽量避开这种行为。为了实现他们的操纵奇迹，程序需要执行重复行动和决策的工具。当然，C++提供了这样的工具。事实上，它`for`循环使用相同的方法，`while`循环，`do while`循环，`if`语句，以及正则C使用的`switch`语句，因此，如果您知道C，您可以压缩本章和第6[章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch06.html#ch06)“[分支语句和逻辑运算符](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch06.html#ch06)”。（但不要拉得太快——你不想错过`cin`如何处理字符输入！）这些不同的程序控制语句通常使用关系表达式和逻辑表达式来控制它们的行为。本章讨论了循环和关系表达式，[第6章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch06.html#ch06)接着是分支语句和逻辑表达式。

### Loops 简介

情况通常要求程序执行重复性任务，例如逐个将数组的元素组合在一起，或打印一些对生产力的赞歌20次。循环`for`C++使这些任务变得容易。我们来看看[清单 5.1 ](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex01)中的一个循环，看看它的作用，然后讨论它是如何工作的。

**清单5.1。`forloop.cpp`**

------

```
// forloop.cpp -- 引入for循环
#include <iostream>
int main（）
{
使用命名空间std；
int i; // 创建一个计数器
// 初始化; 测试 ; 更新
为（i = 0；i < 5；i++）
cout << "C++ knows loops.\n";
cout << "C++知道什么时候停止。\n";
返回0；
}
```

以下是[清单5.1](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex01)中程序的输出：

C++知道循环。
C++知道循环。
C++知道循环。
C++知道循环。
C++知道循环。
C++知道什么时候停止。

此循环首先将整数`i`设置为0：

i = 0

这是*循环*的*循环初始化*部分。然后在*循环测试*中，程序测试`i`是否小于5：

我 < 5

如果是，程序将执行以下语句，称为*循环体*：

cout << "C++ knows loops.\n";

然后，程序使用*循环*的*循环更新*部分将`i`增加1：

i++

循环的*循环更新*部分使用`++`运算符，称为*增量运算符*。它将操作数的值增加1。（增量运算符不限于循环。例如，您可以使用`i++;`而不是`i = i + 1;`作为程序中的语句。）递增`i`完成循环的第一个周期。

接下来，循环通过将新的`i`值与5进行比较来开始一个新的循环。由于新值（1）也小于5，循环打印另一行，然后通过再次增加`i`来完成。这为新的测试周期、执行语句和更新`i`的值奠定了基础。这个过程一直持续到循环更新到5。然后下一个测试失败，程序转到循环后的下一个语句。循环部件A `for` loop provides a step-by-step recipe for performing repeated actions. Let’s take a more detailed look at how it’s set up. The usual parts of a `for` loop handle these steps:**1。**最初设置一个值**2。**进行测试，看看循环是否应该继续**3。**执行循环操作**4。**更新用于测试的值C++循环设计定位这些元素，以便您可以一目了然地发现它们。初始化、测试和更新操作构成了括号内的三部分控制部分。每个部分都是一个表达式，分号将表达式彼此分开。控制部分后面的语句称为循环的*主体*，只要测试表达式保持为真，它就会执行：用于（*初始化*；*测试表达式*；*更新表达式*）
   *身体*C++语法将完整的语句计为单个语句，即使它可以在正文部分包含一个或多个语句。（拥有多个语句需要使用复合语句或块，如本章后面讨论的那样。）该循环只执行一次初始化。通常，程序使用此表达式将变量设置为起始值，然后使用该变量来计算循环周期。

*`test-expression`*确定循环主体是否被执行。通常，这个表达式是一个关系表达式，即比较两个值的表达式。我们的示例将`i`的值与5进行比较，检查`i`是否小于5。如果比较为真，程序将执行循环主体。实际上，C++并不将*`test-expression`*限制为真/假比较。您可以使用任何表达式，C++将键入cast it to type `bool`。因此，值为0的表达式转换为`bool`值`false`，循环终止。如果表达式计算为非零，则类型转换为`bool`值`true`，循环继续。[清单5.2](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex02)通过使用表达式`i`作为测试条件来证明这一点。（在更新部分，`i--`类似于`i++`，只是每次使用时都会将`i`的值降低1。）

**清单5.2。`num_test.cpp`**

------

// num_test.cpp -- 在循环中使用数字测试
\#include <iostream>
int main（）
{
使用命名空间std；
cout << "输入起始倒计时值: ";
限制；
cin >> 限制；
int i;
for (i = limit; i; i--) // 当我为 0 时退出
cout << "i = " << i << "\n";
cout << "Done now that i = " << i << "\n";
返回0；
}

以下是[清单5.2](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex02)中程序[的](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex02)输出：

输入起始倒计时值**：4**
i = 4
i = 3
i = 2
i = 1
现在完成，i = 0

请注意，`i`达到0时，循环终止。

关系表达式（如`i < 5`如何适合这个以0值终止循环的框架？在引入`bool`类型之前，关系表达式如果true，则计算为1，如果为false，则计算为0。因此，表达式`3 < 5`的值为1，`5 < 5`的值为`0`。然而，现在C++添加了`bool`类型，关系表达式计算为`bool`文字`true`和`false`，而不是`1`和`0`。然而，这种变化不会导致不兼容性，因为C++程序在整数值预期的情况下将`true`和`false`转换为`1`和`0`，并将`0`转换为`false`，将非零转换为`true`，在预期的`bool`值时。

`for`循环是一个*入门条件*循环。这意味着测试表达式在每个循环周期*之前*进行计算。当测试表达式为false时，循环永远不会执行循环主体。例如，假设您在[清单5.2](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex02)中重新运行程序，但给0作为起始值。由于测试条件在第一次评估时就失败了，因此循环主体永远不会被执行：

输入起始倒计时值：**0**
现在完成，i = 0

这种环前看的态度可以帮助让程序远离麻烦。

*`update-expression`*在主体执行后，在循环结束时进行评估。通常，它用于增加或减少变量的值，跟踪循环周期的数量。然而，它可以是任何有效的C++表达式，其他控制表达式也是如此。这使得`for`循环能够比第一个循环示例简单地从0数到5要多得多。稍后，您将看到一些这方面的示例。



`for`循环主体由单个陈述组成，但您很快就会学习如何扩展该规则。[图5.1](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05fig01)总结了循环设计。

**图5.1。循环的设计。**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05fig01.jpg)A `for` statement looks something like a function call because it uses a name followed by paired parentheses. However, `for`’s status as a C++ keyword prevents the compiler from thinking `for` is a function. It also prevents you from naming a function `for`.



提示

常见的C++风格是在`for`和以下括号之间留出空格，并在函数名和以下括号之间省略空格：用于（i = 6；i < 10；i++）
smart_function（i）；

Other control statements, such as `if` and `while`, are treated similarly to `for`. This serves to visually reinforce the distinction between a control statement and a function call. Also common practice is to indent the body of a `for` statement to make it stand out visually.



表达和陈述A`for`控制部分使用三个表达式。在自我强加的语法范围内，C++是一种非常富有表现力的语言。任何值或任何值和运算符的有效组合都构成一个表达式。例如，`10`是值为10的表达式（不足为奇），`28 * 20`是值为560的表达式。在C++中，每个表达式都有一个值。通常，价值是显而易见的。例如，以下表达式由两个值和加法运算符组成，其值为49：22 + 27有时价值不那么明显。例如，以下是一个表达式，因为它是由两个值和赋值运算符组成的：x = 20C++将赋值表达式的值定义为左侧成员的值，因此表达式的值为20。赋值表达式具有值的事实允许以下语句：女仆=（厨师=4）+ 3；表达式`cooks = 4`的值为4，因此`maids`被分配为值7。然而，仅仅因为C++允许这种行为并不意味着你应该鼓励它。但使这种特殊陈述成为可能的同一规则也使以下有用的陈述成为可能：x = y = z = 0；

这是将多个变量设置为相同值的快速方法。优先级表（见[附录D](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app04.html#app04)“[操作员优先级](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app04.html#app04)”）显示，分配从右到左关联，因此首先将`0`分配给`z`，然后将`z = 0`分配给`y`，以此类推。

最后，如前所述，`x < y`等关系表达式计算为`bool`值`true`或`false`。[清单5.3](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex03)中的简短程序说明了有关表达式值的一些要点。`<<`运算符的优先级高于表达式中使用的运算符，因此代码使用括号来执行正确的顺序。

**清单5.3。`express.cpp`**

------

// express.cpp -- 表达式值
\#include <iostream>
int main（）
{
使用命名空间std；
int x；

cout << "表达式 x = 100 具有值 ";
cout << (x = 100) << endl;
cout << "Now x = " << x << endl;
cout << "表达式 x < 3 具有值 ";
cout << (x < 3) << endl;
cout << "表达式 x > 3 具有值 ";
cout << (x > 3) << endl;
cout.setf(ios_base::boolalpha); // 较新的C++功能
cout << "表达式 x < 3 具有值 ";
cout << (x < 3) << endl;
cout << "表达式 x > 3 具有值 ";
cout << (x > 3) << endl;
返回0；
}

以下是[清单5.3](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex03)中程序[的](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex03)输出：

表达式x = 100的值为100
现在x = 100
表达式x < 3的值为0
表达式x > 3的值为1
表达式x < 3的值为false
表达式x > 3的值为true

通常，`cout`在显示`bool`值之前将它们转换为`int`，但`cout.setf(ios::boolalpha)`函数调用设置了一个标志，指示`cout`显示单词`true`和`false`，而不是`1`和`0`。

------

备注

C++表达式是值和运算符的值或组合，每个C++表达式都有一个值。

要计算表达式`x = 100`，C++必须将值`100`分配给`x`。当计算表达式的行为改变内存中数据的值时，我们说评估有*副作用*。因此，计算赋值表达式具有更改受让人值的副作用。您可能认为赋值是预期效果，但从如何构建C++的角度来看，评估表达式是主要效果。并非所有表达式都有副作用。例如，评估`x + 15`计算出一个新值，但它不会改变`x`的值。但评估`++x + 15`确实有副作用，因为它涉及增加`x`。从表达式到语句是一个简短的步骤；您只需添加一个分号即可。因此，以下是表达式：年龄=100而以下陈述：年龄=100；

更具体地说，它是一种*表达式陈述*。如果您添加分号，任何表达式都可以成为语句，但结果可能没有编程意义。例如，如果`rodents`是一个变量，那么以下是有效的C++语句：

啮齿动物+ 6; // 有效但无用的声明编译器允许它，但语句没有完成任何有用的事情。该程序只是计算总和，不做任何事情，然后继续下一个陈述。（智能编译器甚至可能会跳过语句。）非表达式和陈述一些概念，例如了解`for`循环的结构，对于理解C++至关重要。但语法中也有一些相对较小的方面，当你认为自己理解语言时，可能会突然困扰你。我们现在来看看其中的几个。虽然向任何表达式添加分号使其成为语句是真的，但事实并非如此。也就是说，从语句中删除分号不一定将其转换为表达式。在我们迄今为止使用的语句类型中，返回语句、声明语句和`for`不符合*语句=表达式+分号*模式。例如，这是一个陈述：int toad；但`int toad`的片段不是一个表达式，也没有价值。这使得以下代码无效：eggs = int toad * 1000; //无效，不是表达式
cin >> int toad; // 无法将声明与cin结合同样，您不能将`for`循环分配给变量。在以下示例中，`for`循环不是一个表达式，因此它没有值，您无法分配它：int fx = for（i = 0；i< 4；i++）
cout >> i; // 不可能弯曲规则C++为C循环添加了一项功能，需要对`for`循环语法进行一些巧妙的调整。这是原始语法：用于（*表达*；*表达*；*表达*）
   *声明*特别是，a `for`结构的控制部分由本章前面定义的三个表达式组成，由分号分隔。然而，C++循环允许您对以下事情进行操作：用于（int i = 0；i < 5；i++）

That is, you can declare a variable in the initialization area of a `for` loop. This can be convenient, but it doesn’t fit the original syntax because a declaration is not an expression. This once outlaw behavior was originally accommodated by defining a new kind of expression, the *declaration-statement expression*, which was a declaration stripped of the semicolon, and which could appear only in a `for` statement. That adjustment has been dropped, however. Instead, the syntax for the `for` statement has been modified to the following:

对于（*用于init声明条件*；*表达式*）
   *声明*乍一看，这看起来很奇怪，因为只有一个分号，而不是两个分号。但没关系，因为*`for-init-statement`*被标识为语句，而语句有自己的分号。至于*`for-init-statement`*，它被标识为表达式语句或声明。这个语法规则用语句替换后跟分号的表达式，语句有自己的分号。归根结底，C++程序员希望能够在`for`循环初始化中声明和初始化变量，他们将对C++语法和英语进行任何必要的操作，使其成为可能。在*`for-init-statement`*中声明变量有一个实际方面，您应该了解。这种变量只存在`for`语句中。也就是说，在程序离开循环后，变量将被消除：用于（int i = 0；i < 5；i++）
cout << "C++ knows loops.\n";
cout << i << endl; // oops!我不再定义您应该知道的另一件事是，一些较旧的C++实现遵循早期的规则，并将前面的循环视为在循环*之前*声明的，从而在循环终止后可用。Back to the `for` Loop

让我们在循环方面更加雄心勃勃。[清单5.4](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex04)使用循环来计算和存储前16个阶乘。因子对于计算赔率很方便，按以下方式计算。零阶乘，写成0！，定义为1。然后，1！是1 * 0！，或1。下一个，2！是2 * 1！，或2。然后，3！是3 * 2！，或6，依此类推，每个整数的阶乘是该整数与前面阶乘积。（已故钢琴家兼喜剧家Victor Borge最著名的独白之一以语音标点符号为特色，感叹号发音类似于phffft pptz，带有潮湿的口音。然而，在这种情况下，“！”发音为“factorial”。）该程序使用一个循环来计算连续阶乘的值，并将其存储在数组中。然后，它使用第二个循环来显示结果。此外，该程序还引入了对值使用外部声明。

**清单5.4。`formore.cpp`**

------

// formore.cpp -- more looping with for
\#include <iostream>
const int ArSize = 16; // 外部声明示例
int main（）
{
长长阶乘[ArSize]；
阶乘[1] = 阶乘[0] = 1LL；
for (int i = 2; i < ArSize; i++)
阶乘[i] = i *阶乘[i-1]；
for (int i = 0; i < ArSize; i++)
std::cout << i << "!= " << 阶乘[i] << std::endl;
返回0；
}

以下是[清单5.4](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex04)中程序的输出：

0！= 1
1！= 1
2！= 2
3！= 6
4！= 24
5！= 120
6！= 720
7！= 5040
8！= 40320
9！=362880
10！= 3628800
11！= 39916800
12！= 479001600
13！= 6227020800
14！= 87178291200
15！= 1307674368000

派系很快就变大了！

------

备注

此列表使用`long long`类型。如果您的系统没有该类型，您可以使用`double`。然而，整数格式提供了更好的可视化表示数字如何变大。

计划备注

[清单5.4](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex04)中的程序创建一个数组来保存阶乘值。元素0是0！，元素1是1！以此类死。由于前两个阶乘等于1，程序将`factorials`组的前两个元素设置为1.0。（请记住，数组的第一个元素的索引值为0。）之后，程序使用循环将每个阶乘设置为具有上一个阶乘的索引乘积。循环说明了您可以将循环计数器用作循环主体中的变量。

[清单5.4](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex04)中的程序通过提供方便的方式来依次访问每个数组成员，演示了`for`循环如何与数组携手工作。Alsoformore`formore.cpp`使用`const`为数组大小创建符号表示（`ArSize`）。然后，无论数组大小在哪里起作用，它都会使用`ArSize`，例如在数组定义和处理数组的循环限制中。现在，如果您想将程序扩展到（例如）20个阶乘，您只需在程序中将`ArSize`设置为20并重新编译。通过使用符号常量，您可以避免单独更改16到20的每次事件。





提示

通常最好定义一个`const`值来表示数组中的元素数量。您可以在数组声明和对数组大小的所有其他引用中使用`const`值，例如`for`循环。

极限`expression i < ArSize`反映了一个事实，即带有`ArSize`元素的数组的下标从`0`运行到`ArSize - 1`，因此数组索引应该停止`ArSize`的短一个。你可以改用测试`i <= ArSize - 1`，但相比之下，它看起来很尴尬。

请注意，程序在`main()`正文之外声明`const int`变量`ArSize`。正如第4[章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch04.html#ch04)“[复合类型](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch04.html#ch04)”的结尾所提到的那样，这使得`ArSize`外部数据。以这种方式声明`ArSize`的两个后果是，`ArSize`在程序期间存在，并且程序文件中的所有功能都可以使用它。在这种情况下，程序只有一个功能，因此在外部声明`ArSize`几乎没有实际效果。但多功能程序通常受益于共享外部常量，因此我们接下来将练习使用它们。

此外，这个示例提醒我们，我们可以使用`std::`而不是`using`指令来提供选定的标准名称。

#### 更改步长

到目前为止，本章中的循环示例在每个周期中将循环计数器增加或减少一个。您可以通过更改更新表达式来更改它。例如，[清单5.5](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex05)中的程序通过用户选择的步幅来增加循环计数器。它不使用`i++`作为更新表达式，而是使用表达式`i = i + by`，其中`by`用户选择的步进大小。

**清单5.5。`bigstep.cpp`**

------

// bigstep.cpp -- 按指示计数
\#include <iostream>
int main（）
{

使用std::cout; // a using declaration
使用std::cin；
使用std::endl;
cout << "输入整数: ";
int by；
cin >> by;
cout << "Counting by " << by << "s:\n";
for (int i = 0; i < 100; i = i + by)
cout << i << endl;
返回0；
}

以下是[清单5.5](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex05)中程序的示例运行：

输入整数：**17**
按17岁计数：
0
17
34
51
68
85

```
i`达到值102时，循环退出。这里的要点是，更新表达式可以是任何有效的表达式。例如，如果您想在每个周期中将`i`平方并添加`10`，您可以使用`i = i * i + 10
```

需要注意的另一点是，测试不平等往往比平等更好。例如，在这种情况下，测试`i == 100`会失败`i`因为我跳过了值`100`。

最后，这个例子说明了`using`声明而不是`using`指令。

#### Inside Strings with the `for` Loop

The `for` loop provides a direct way to access each character in a string in turn. For example, [Listing 5.6](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex06) enables you to enter a string and then displays the string character-by-character, in reverse order. You could use either a `string` class object or an array of `char` in this example because both allow you to use array notation to access individual characters in a string; [Listing 5.6](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex06) uses a `string` class object. The `string` class `size()` method yields the number of characters in the string; the loop uses that value in its initializing expression to set `i` to the index of the last character in the string, not counting the null character. To count backward, the program uses the decrement operator (`--`) to decrease the array subscript by one in each loop. Also [Listing 5.6](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex06) uses the greater-than-or-equal-to relational operator (`>=`) to test whether the loop has reached the first element. We’ll summarize all the relational operators soon.

**清单5.6。`forstr1.cpp`**

------

// forstr1.cpp -- 将 for 与字符串一起使用
\#include <iostream>
\#include <string>
int main（）
{
使用命名空间std；
cout << "输入一个单词: ";
字符串单词；
cin >> word;

// 按相反的顺序显示字母
for (int i = word.size() - 1; i >= 0; i--)
cout << word[i];
cout << "\nBye.\n";
返回0；
}

以下是[清单5.6](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex06)中程序的示例运行：

输入一个词：**动物**
拉米纳
再见。

Yes, the program succeeds in printing `animal` backward; choosing `animal` as a test word more clearly illustrates the effect of this program than choosing, say, a palindrome such as `rotator`, `redder,` or `stats`.

#### 增量（`++`）和递减（`--`）运算符

C++具有几个经常在循环中使用的运算符；让我们现在花点时间检查一下它们。您已经看到两个：启发C++名称的增量运算符（`++`）和递减运算符（`--`）。这些运算符执行两个非常常见的循环操作：将循环计数器增加和减少一个。然而，他们的故事比你目前看到的要多。每个运算符有两种。*前缀*版本位于操作数之前，如`++x`。*后缀*版本出现在操作数之后，如`x++`。这两个版本对操作数有相同的效果，但在发生时间方面有所不同。这就像提前或之后修剪草坪的报酬；这两种方法对你的钱包有相同的最终影响，但当增加钱时，它们会有所不同。[清单5.7](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex07)显示了增量运算符的这种差异。

**清单5.7。`plus_one.cpp`**

------

// plus_one.cpp -- 增量运算符
\#include <iostream>
int main（）
{

使用std::cout；
int a = 20；
int b = 20；

cout << "a = " << a << ": b = " << b << "\n";
cout << "a++ = " << a++ << ": ++b = " << ++b << "\n";
cout << "a = " << a << ": b = " << b << "\n";
返回0；
}

以下是[清单5.7](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex07)中程序的输出：

a = 20：b = 20
a++ = 20：++b = 21
a = 21：b = 21

粗略地说，符号`a++`的意思是“在评估表达式时使用`a`的当前值，然后增加`a`的值。”同样，符号`++b`的意思是“首先增加`b`的值，然后在评估表达式时使用新值”。例如，我们有以下关系：

int x = 5；
int y = ++x; // 更改 x，然后分配给 y
// y是6，x是6

int z = 5；
int y = z++; // 分配给 y，然后更改 z
// y是5，z是6

使用增量和递减运算符是一种简洁、方便的方式来处理将值增加或减少一个的常见任务。

增量和递减运算符是漂亮的小运算符，但不要被带走，在同一语句中多次增加或递减相同的值。问题在于，使用-然后-更改-然后使用规则可能会变得模棱两可。也就是说，像以下这样的陈述可以在不同的系统上产生完全不同的结果：

x = 2 * x++ * (3 - ++x); // 除非作为实验，否则不要这样做

C++没有为这种语句定义正确的行为。

#### 副作用和序列点

让我们仔细看看C++在增量运算符何时生效时做什么和不做什么。首先，请记住，*副作用*是评估表达式修改某些东西（例如存储在变量中的值）时发生的影响。*序列点*是程序执行中的一个点，保证在下一步之前评估所有副作用。在C++中，语句中的分号标记一个序列点。这意味着语句中的赋值运算符、增量运算符和递减运算符所做的所有更改都必须在程序进入下一个语句之前进行。我们将在后面的章节中讨论的一些运算符有序列点。此外，任何完整表达式的结尾都是一个序列点。

什么是完整的表达？这是一个不是更大表达式的子表达式的表达式。完整表达式的示例包括表达式语句的表达式部分和作为`while`循环测试条件的表达式。

序列点有助于澄清后缀递增何时发生。例如，考虑以下代码：而（客人++ < 10）
cout << guests << endl;（本章后面讨论的`while`循环，就像一个只有测试表达式的`for`循环。）有时，C++新人假设“使用值，然后增加它”在这种情况下，意味着在`cout`语句中使用后增加`guests`。然而，来宾`guests++ < 10`表达式是一个完整的表达式，因为它是一个`while`循环测试条件，因此该表达式的结尾是一个序列点。因此，C++保证副作用（增加`guests`）发生在程序开始之前。然而，使用后缀形式可以保证`guests`在与`10`进行比较后会增加。现在考虑以下陈述：y = (4 + x++) + (6 + x++);表达式`4 + x++`不是一个完整的表达式，因此C++不保证`x`将在子表达式`4 + x++`计算后立即递增。这里的完整表达式是整个赋值语句，分号标记序列点，因此C++保证的只是，到程序移动到以下语句时，`x`将增加两次。C++没有指定`x`是在每个子表达式计算后递增的，还是仅在所有表达式都经过计算后递增的，这就是为什么您应该避免此类语句。C++11文档删除了“序列点”一词，因为在讨论多个执行线程时，该概念没有很好地延续。相反，描述是按顺序构建的，一些事件被描述为在其他事件之前排序。这种描述性方法无意改变规则；目标是提供能够更清晰地处理多线程编程的语言。前缀与后缀显然，如果该值用于某种目的，例如函数参数或分配给变量，无论您使用前缀还是后缀形式都会有所不同。但是，如果不使用增量或递减表达式的值怎么办？例如，x++；和++x；彼此不同？或者是

对于（n = lim；n > 0；--n）
...；

和for (n = lim; n > 0; n--)
...；彼此不同？从逻辑上讲，在这两种情况下，使用前缀还是后缀形式都没有区别。不使用表达式的值，所以唯一的效果是副作用。在这里，使用运算符的表达式是完整的表达式，因此在程序进入下一步时，保证执行增量`x`和递减`n`的副作用；前缀形式和后缀形式导致相同的最终结果。然而，尽管前缀和后缀形式之间的选择对程序的行为没有影响，但选择可能会对执行速度产生很小的影响。对于内置类型和现代编译器来说，这似乎不成问题。但C++允许您为类定义这些运算符。在这种情况下，用户定义了一个前缀函数，该函数通过增加一个值然后返回它来工作。但后缀版本的工作原理是首先堆藏值的副本，增加值，然后返回藏匿的副本。因此，对于类来说，前缀版本比后缀版本更有效率。简而言之，对于内置类型，您使用哪种形式很可能没有区别。对于具有用户定义增量和递减运算符的用户定义类型，前缀表单更有效。增量/减量运算符和指针您可以将增量运算符与指针以及基本变量一起使用。请记住，向指针添加增量运算符会增加其值，增加其指向的类型中的字节数。相同的规则适用于增量和减量指针：double arr[5] = {21.1, 32.8, 23.4, 45.2, 37.4};
double *pt = arr; // pt指向arr[0]，即21.1
++pt; // pt指向arr[1]，即32.8您还可以使用这些运算符来更改指针指向的数量，方法是将它们与`*`运算符一起使用。`*`和`++`应用于指针会引发什么被取消引用，什么会增加的问题。这些行动由运营商的位置和优先级决定。前缀增量、前缀递减和去引用运算符都具有相同的优先级，并从右到左关联。后缀增量和递减运算符都有相同的优先级，这高于前缀优先级。这两个操作员从左到右关联。前缀运算符的从右到左关联规则意味着`*++pt`意味着首先将`++`应用于`pt`（因为`++`在`*`的右侧），然后将`*`应用于`pt`的新值：double x = *++pt; // 增量指针，取值；即arr[2]或23.4

另一方面，`++*pt`意味着获得`pt`指向的值，然后增加该值：

++*pt; // 增加指向值；即将23.4更改为24.4在这里，`pt`仍然指向`arr[2]`。接下来，考虑以下组合：(*pt)++; // 增量指向值括号表示首先取消引用指针，生成`24.4`。然后，`++`运算符将值增量到`25.4`；`pt`仍然指向`arr[2]`。最后，考虑一下这个组合：x = *pt++; // 取消引用原始位置，然后是增量指针后缀`++`运算符的优先级较高意味着`++`运算符在`pt`上运行，而不是在`*pt`上运行，因此指针是递增的。但使用后缀运算符的事实意味着被取消引用的地址是原始地址`&arr[2]`，而不是新地址。因此，`*pt++`的值是`arr[2]`或`25.4`，但语句完成后`pt`的值是`arr[3]`的地址。



备注

增量和减量指针遵循指针算术规则。因此，如果`pt`指向数组的第一个成员，`++pt`会更改`pt`，使其指向第二个成员。

组合分配运算符

[清单5.5](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex05)使用以下表达式来更新循环计数器：

i = i + by

C++有一个组合的加法和赋值运算符，可以更简洁地完成相同的结果：

i += 由

`+=`运算符添加其两个操作数的值，并将结果分配给左侧的操作数。这意味着左操作数必须是您可以分配值的东西，例如变量、数组元素、结构成员或您通过取消引用指针识别的数据：

int k = 5；
k += 3; // 好的，k设置为8
int *pa = new int[10]; // pa指向pa[0]
pa[4] = 12；
pa[4] += 6; // 好的，pa[4]设置为18
*(pa + 4) += 7; // 好的，pa[4]设置为25
pa += 2; // 好的，pa指向前pa[2]
34 += 10; // 相当错误

每个算术运算符都有一个相应的赋值运算符，如[表5.1](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05table01)所示。每个运算符的工作原理类似于`+=`。因此，例如，以下语句将当前`k`的值替换为大10倍的值：

k *= 10；

**表5.1。联合分配运营商**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05tab01.jpg)复合语句或块

编写C++语句`for`格式或语法可能对您来说似乎具有限制性，因为循环的主体必须是单个语句。如果您希望循环主体包含多个语句，那就太尴尬了。幸运的是，C++提供了一个语法漏洞，您可以通过它将任意数量的语句塞入循环主体中。诀窍是使用配对大括号来构造*复合语句*或*块*。该块由配对的大括号和它们包含的语句组成，为了语法的目的，算作单个语句。例如，[清单5.8](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex08)中的程序使用大括号将三个单独的语句组合成一个块。这使循环主体能够提示用户、读取输入并进行计算。该程序计算您输入的数字的运行和，这为使用`+=`运算符提供了自然场合。

**清单5.8。`block.cpp`**

------

// block.cpp -- 使用block语句
\#include <iostream>
int main（）
{
使用命名空间std；
回合<<“The Amazing Accounto将总和和平均”；
cout << "five numbers for you.\n";
cout << "请输入五个值:\n";
双倍数；
双和= 0.0；
for (int i = 1; i <= 5; i++)
{ // 块从这里开始
cout << "Value " << i << ": ";
cin >> 编号；
总和+=数字；
} // 块在这里结束
比赛<<“确实有五个精致的选择！"；
cout << "他们总和为" << sum << endl;
cout << "and average to " << sum / 5 << ".\n";
cout << "The Amazing Accounto bids you adieu!\n";
返回0；
}

以下是[清单5.8](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex08)中程序的示例运行：

Amazing Accounto将为您汇总和平均五个数字。
请输入五个值：
值1：**1942**
值2：1848
值3：1957
值4：**1974**
值5：**1980**
确实有五个精致的选择！他们的总和是9801
平均到1960.2。
Amazing Accounto告别你！

假设您留在缩进中，但省略大括号：

for (int i = 1; i <= 5; i++)
cout << "Value " << i << ": "; // loop ends here
cin >> number; // 循环后
总和+=数字；
比赛<<“确实有五个精致的选择！"；

编译器忽略缩进，因此只有第一个语句在循环中。因此，循环将打印五个提示，而不再做。循环完成后，程序移动到以下行，只读取和求和一个数字。

复合语句还有另一个有趣的特性。如果您在块内定义了一个新变量，则该变量仅在程序在块中执行语句时保持不变。当执行离开块时，变量被释放。这意味着变量仅在块内已知：

\#include <iostream>
int main（）
{
使用命名空间std；
int x = 20；
{ // 阻止开始
int y = 100；
cout << x << endl; // ok
cout << y << endl; // ok
} // 块结束
cout << x << endl; // ok
cout << y << endl; //无效，不会编译
返回0；

请注意，在外块中定义的变量仍然在内块中定义。

如果您在块中声明一个变量与块外名称相同的变量，会发生什么？新变量将旧变量从外观隐藏到块末尾。然后旧的再次可见，如以下示例所示：#include <iostream>
int main（）
{
使用std::cout；
使用std::endl;
int x = 20; // 原始 x
{ // 阻止开始
cout << x << endl; // 使用原始 x
int x = 100; // 新x
cout << x << endl; // 使用新 x
} // 块结束
cout << x << endl; // 使用原始 x
返回0；
}更多语法技巧—逗号运算符正如您所看到的，块使您可以将两个或多个语句偷偷带到C++语法只允许一个语句的地方。逗号运算符对表达式也是如此，使您可以将两个表达式偷偷带到C++语法只允许一个表达式的地方。例如，假设您有一个循环，其中每个周期增加一个变量，每个周期增加一个变量。在`for`循环控制部分的更新部分同时做两者都很方便，但循环语法只允许一个表达式。解决方案是使用逗号运算符将两个表达式组合成一个：++j，--i // 为了语法目的，两个表达式算作一个逗号并不总是逗号运算符。例如，此声明中的逗号用于在变量列表中分离相邻名称：int i, j; // 逗号在这里是一个分隔符，而不是运算符

[清单5.9](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex09)在反转`string`类对象内容的程序中使用逗号运算符两次。（您也可以使用`char`数组编写程序，但单词的长度将受到您选择的数组大小的限制。）请注意，[清单5.6](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex06)以相反的顺序显示数组的内容，但[清单5.9](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex09)实际上在数组中移动字符。[清单5.9](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex09)中的程序还使用块将多个语句分组为一个。

**清单5.9。`forstr2.cpp`**

------

// forstr2.cpp -- 反转数组
\#include <iostream>
\#include <string>
int main（）
{
使用命名空间std；
cout << "输入一个单词: ";
字符串单词；
cin >> word;

// 物理修改字符串对象
char temp；
int i, j;
for (j = 0, i = word.size() - 1; j < i; --i, ++j)
{ // 开始块
temp = word[i];
word[i] = word[j];
word[j] = temp；
} // 结束块
cout << word << "\nDone\n";
返回0；
}

以下是[清单5.9](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex09)中程序的示例运行：

输入一个单词：**强调**
甜点
完成

顺便说一句，`string`类提供了更简洁的反转字符串的方法，但我们会将这些方法留到[第16章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch16.html#ch16)“`string`类和标准模板库”。

##### 计划备注

查看[清单5.9](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex09)中程序的控制部分。首先，它使用逗号运算符将两个初始化压缩到控制部分第一部分的一个表达式中。然后，它再次使用逗号运算符将两个更新组合成一个表达式，用于控制部分的最后一部分。

接下来，看看身体。该程序使用大括号将多个语句组合成一个单元。在正文中，程序通过将数组的第一个元素与最后一个元素切换来反转单词。然后它递增`j`和递减`i`，以便他们现在指的是下一个元素和下一个元素。完成后，程序会交换这些元素。请注意，测试条件`j<i`使循环在到达数组中心时停止。如果它继续超过这一点，它将开始将切换的元素换回原来的位置（见[图5.2](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05fig02)）。

**图5.2。反转字符串。**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05fig02.jpg)另一件需要注意的事情是声明变量`temp`、`i`和`j`的位置。代码在循环之前声明`i`和`j`，因为您无法将两个声明与逗号运算符组合在一起。这是因为声明已经将逗号用于其他目的——在列表中分隔项目。您可以使用单个声明语句表达式来创建和初始化两个变量，但在视觉上有点混乱：int j = 0，i = word.size() - 1;在这种情况下，逗号只是一个列表分隔符，而不是逗号运算符，因此表达式声明并初始化`j`和`i`。然而，它看起来好像只声明了`j`。顺便说一句，您可以在`for`循环中声明`temp`：int temp = word[i];这可能会导致在每个循环周期中分配和分配`temp`。这可能比循环前宣布一次`temp`要慢一点。另一方面，循环完成后，如果`temp`循环中声明，则会丢弃温度。逗号运算符小道

到目前为止，逗号运算符最常见的用途是将两个或多个表达式安装到一个循环表达式中。但C++确实为运算符提供了两个额外的属性。首先，它保证在第二个表达式之前计算第一个表达式。（换句话说，逗号运算符是一个序列点。）如下表达式是安全的：

i = 20, j = 2 * i // i set to 20, then j set to 40其次，C++声明，逗号表达式的值是表达式第二部分的值。例如，前面表达式的值是40，因为这是`j = 2 * i`的值。逗号运算符的优先级是所有运算符中最低的。例如，以下陈述：cata = 17,240；读起来如下：（猫=17），240；也就是说，`cats`被设置为17，`240`什么都不做。但由于括号具有很高的优先级，以下结果导致`cats`被设置为`240`，即逗号右侧表达式的值：猫=（17,240）；关系表达

计算机不仅仅是无情的数字运算器。他们有能力比较值，这种能力是计算机决策的基础。在C++中，关系运算符体现了这种能力。C++提供了六个关系运算符来比较数字。由于字符由其ASCII代码表示，您也可以将这些运算符与字符一起使用。它们不适用于C风格的字符串，但它们确实适用于`string`类对象。如果比较为真，每个关系表达式都简化为`bool`值`true`，如果比较为false，则简化为`bool`值`false`，因此这些运算符非常适合用于循环测试表达式。（旧的实现将真实关系表达式计算为`1`，将假关系表达式计算为`0`。）[表5.2](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05table02)总结了这些运算符。

**表5.2。关系运算符**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05tab02.jpg)

六个关系运算符耗尽了C++使您能够对数字进行比较。如果你想比较两个值，看看哪个更漂亮还是更幸运，你必须看看其他地方。

以下是一些示例测试：对于（x = 20；x > 5；x--）//当x大于5时继续
对于（x = 1；y！= x; ++x) // 当y不等于x时继续
对于（cin >> x; x == 0; cin >> x）//当x为0时继续关系运算符的优先级低于算术运算符。这意味着这个表达：x + 3 > y - 2 // 表达式 1对应于此：(x + 3) > (y - 2) // 表达式 2而不是以下内容：x + (3 > y) - 2 // 表达式 3由于表达式`(3 > y)`在`bool`值提升为`int`后为`1`或`0`，因此表达式2和3都是有效的。但我们大多数人都希望表达式1表示表达式2，这就是C++所做的。分配、比较和你可能会犯的错误不要将测试is-equal-to运算符（`==`与赋值运算符（=）混淆。这个表达式提出了音乐问题：“`musicians`等于4吗？”：音乐家== 4 // 比较该表达式的值为`true`或`false`。此表达式将值`4`分配给`musicians`：音乐家 = 4 // 分配在这种情况下，整个表达式的值为`4`，因为这是左侧的值。`for`循环的灵活设计为错误创造了一个有趣的机会。如果您不小心从`==`运算符中删除了一个等号（=）并使用赋值表达式而不是`for`循环测试部分的关系表达式，您仍然会生成有效的代码。这是因为您可以将任何有效的C++表达式用于`for`循环测试条件。请记住，非零值测试为`true`，零测试为`false`。将`4`分配给`musicians`的表达式具有值`4`，并被视为`true`。如果您来自一种语言，如Pascal或BASIC，使用`=`来测试平等，您可能特别容易出现此错误。

[清单5.10](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex10)显示了您可以犯这种错误的情况。该计划试图检查一系列测验分数，并在达到第一个不是20分时停止。它显示了一个正确使用比较的循环，然后在测试条件下错误地使用赋值的循环。该程序还有另一个令人震惊的设计错误，您将稍后了解如何修复。（您从错误中吸取教训，[列出5.10](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex10)很乐意在这方面提供帮助。）

**清单5.10。`equal.cpp`**

------

// equal.cpp -- equal vs assignment
\#include <iostream>
int main（）
{
使用命名空间std；
int quizscores[10] =
{ 20, 20, 20, 20, 20, 19, 20, 18, 20, 20};

cout << "做对了:\n";
int i;
用于（i = 0；quizcores[i] == 20；i++）
cout << "quiz " << i << " is a 20\n";
//警告：您可能更喜欢阅读此程序
// 实际运行它。
cout << "做危险的错误:\n";
对于（i = 0；quizcores[i] = 20；i++）
cout << "quiz " << i << " is a 20\n";

返回0；
}

由于[清单5.10](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex10)中的程序存在严重问题，您可能更喜欢阅读它而不是实际运行它。以下是该程序的一些示例输出：

做对了：
测验0是20
测验1是20
测验2是20
测验3是20
测验4是20
做错了危险的错误：
测验0是20
测验1是20
测验2是20
测验3是20
测验4是20
测验5是20
测验6是20
测验7是20
测验8是20
测验9是20
测验10是20
测验11是20
测验12是20
测验13是20
...

第一个循环在显示前五个测验分数后正确停止。但第二个从显示整个数组开始。更糟糕的是，它说每个值都是20。更糟糕的是，它不会停在阵列的末尾！最糟糕的是，该程序可以（尽管不一定）冻结当时运行的其他应用程序，并需要重新启动计算机。当然，事情出错的地方是以下测试表达式：quizscores[i] = 20首先，仅仅因为它为数组元素分配了一个非零值，表达式总是非零，因此总是为真。其次，由于表达式为数组元素分配值，它实际上会更改数据。第三，由于测试表达式仍然正确，程序继续在数组末尾更改数据。它只是不断将越来越多的20多岁留在记忆中！这不好。这种错误的困难在于代码在语法上是正确的，因此编译器不会将其标记为错误。（然而，多年来，C和C++程序员犯了这个错误，最终导致许多编译器发出警告，询问这是否是您真正想要做的。）



警告

不要使用`=`来比较平等；使用`==`。



与C一样，C++比大多数编程语言赋予您更多的自由。这以要求您承担更大责任为代价。只有您自己的良好计划，什么都无法防止程序超越标准C++数组的范围。然而，使用C++类，您可以设计一种受保护的数组类型来防止这种胡说八道。[第13章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch13.html#ch13)“[阶级继承](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch13.html#ch13)”提供了一个例子。目前，您应该在需要时将保护构建到程序中。例如，[清单5.10](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex10)中的循环应该包括一个测试，防止它超过最后一个成员。即使是“好”循环也是如此。如果所有分数都是20分，那么“好”循环也会超过数组界限。简而言之，循环需要测试数组的值和数组索引。[第6章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch06.html#ch06)展示了如何使用逻辑运算符将两个这样的测试合并到一个条件中。

#### 比较C型字符串

假设您想看看字符数组中的字符串是否是单词`mate`。如果`word`是数组名称，以下测试可能无法执行您认为它应该做的事情：

word == "mate"

请记住，数组的名称是其地址的同义词。同样，引号字符串常量是其地址的同义词。因此，前面的关系表达式不会测试字符串是否相同；它会检查它们是否存储在同一地址。答案是否定的，即使这两个字符串具有相同的字符。

由于C++将C风格的字符串作为地址处理，因此如果您尝试使用关系运算符来比较字符串，您将不太满意。相反，您可以转到C风格的字符串库，并使用strcmp`strcmp()`函数来比较字符串。此函数将两个字符串地址作为参数。这意味着参数可以是指针、字符串常量或字符数组名称。如果两个字符串相同，则函数返回值`0`。如果第一个字符串按字母顺序排在第二个字符串之前，`strcmp()`返回负值，如果第一个字符串按字母顺序跟随第二个字符串，`strcmp()`返回一个正值。实际上，“在系统整理序列中”比“字母顺序”更准确。这意味着根据字符的系统代码进行比较。例如，在ASCII代码中，大写字母的代码比小写字母小，因此在整理序列中大写字母在小写字母之前。因此，字符串`"Zoo"`在字符串`"aviary"`之前。比较基于代码值这一事实也意味着大写字母和小写字母不同，因此字符串`"FOO"`与字符串`"foo"`不同。在一些语言中，如BASIC和standard Pascal，存储在不同大小的数组中的字符串必然是不平等的。但C风格的字符串是由终止的空字符定义的，而不是由包含数组的大小定义的。这意味着两个字符串即使包含在不同大小的数组中，也可以是相同的：char big[80] = "Daffy"; // 5个字母加 \0
char little[6] = "Daffy"; // 5个字母加 \0顺便说一句，虽然你不能使用关系运算符来比较字符串，但你可以用它们来比较字符，因为字符实际上是整数类型。因此，以下是显示字母表字符的有效代码，至少对于ASCII和Unicode字符集：对于（ch = 'a'; ch <= 'z'; ch++）
cout << ch;

[清单5.11](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex11)中的程序在`for`循环的测试条件下使用`strcmp()`。该程序显示一个单词，更改其第一个字母，再次显示该单词，并一直持续到`strcmp()`确定该`word`与字符串`"mate"`相同。请注意，该列表包括`cstring`文件，因为它为`strcmp()`提供了一个函数原型。

**清单5.11。`compstr1.cpp`**

------

// compstr1.cpp -- 使用数组比较字符串
\#include <iostream>
\#include <cstring> // strcmp()的原型
int main（）
{
使用命名空间std；
char word[5] = "?吃了"；

for (char ch = 'a'; strcmp(word, "mate"); ch++)
{
cout << word << endl;
word[0] = ch；
}
cout << "循环结束后，单词是 " << word << endl;
返回0；
}

以下是[清单5.11](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex11)中程序[的](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex11)输出：

？吃了
吃
巴特
卡特
日期
吃
命运
闸门
讨厌
吃饭
杰特
凯特
迟到
循环结束后，单词是伴侣

##### 计划备注

[清单5.11](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex11)中的程序有一些有趣的要点。当然，一个是测试。只要`word`不是`mate`，你就希望循环继续下去。也就是说，只要`strcmp()`说两个字符串不相同，您就希望测试继续。最明显的测试是：

strcmp（单词，“伴侣”）！= 0 // 字符串不相同

如果字符串不等，则此语句的值为`1`（`true`），如果字符串相等，则值为`0`（`false`）。但是strcmp`strcmp(word, "mate")`本身呢？如果字符串不等，则具有非零值（`true`），如果字符串相等，则值为`0`（`false`）。本质上，如果字符串不同，则函数返回`true`，如果字符串相同，则返回`false`。您可以只使用函数，而不是整个关系表达式。这会导致相同的行为，并且涉及更少的打字。这也是C和C++程序员传统上使用`strcmp()`的方式。

------

平等或秩序测试

您可以使用`strcmp()`测试C风格的字符串是否相等或有序。如果`str1`和`str2`相同，则以下表达式为真：strcmp（str1，str2）== 0表达strcmp（str1，str2）！= 0和strcmp（str1，str2）如果`str1`和`str2`不相同，则为真。如果`str1`在str`str2`之前，则以下表达式为真：strcmp（str1，str2）<0如果`str1`跟随`str2`则以下表达式为真：strcmp（str1，str2）> 0因此，`strcmp()`函数可以扮演`==`的角色，`!=`、`<`和`>`运算符，具体取决于您如何设置测试条件。



接下来，`compstr1.cpp`使用增量运算符将变量`ch`行进到字母表中：

ch++您可以将增量和递减运算符与字符变量一起使用，因为类型`char`确实是整数类型，因此该操作实际上会更改存储在变量中的整数代码。另请注意，使用数组索引可以轻松更改字符串中的单个字符：word[0] = ch；比较`string`类字符串

如果您使用`string`类字符串而不是C样式的字符串，生活会简单一些，因为类设计允许您使用关系运算符进行比较。这是可能的，因为可以定义“重载”或重新定义运算符的类函数。[第12章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch12.html#ch12)“[类和动态内存分配](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch12.html#ch12)”讨论了如何将此功能集成到类设计中，但从实际角度来看，您现在只需要知道，您可以将关系运算符与`string`类对象一起使用。[列表5.12](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex12)修订了[清单5.11](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex11)，以使用`string`对象而不是`char`数组。

**清单5.12。`compstr2.cpp`**

------

// compstr2.cpp -- 使用数组比较字符串
\#include <iostream>
\#include <string> // 字符串类
int main（）
{
使用命名空间std；
字符串单词=“？吃了"；

for (char ch = 'a'; word != "mate"; ch++)
{
cout << word << endl;
word[0] = ch；
}
cout << "循环结束后，单词是 " << word << endl;
返回0；
}

[清单5.12](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex12)中程序的输出与[清单5.11](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex11)中程序的输出相同。

##### 计划备注

在[清单5.12](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex12)中，以下测试条件使用左侧为`string`对象，右侧为C样式字符串的关系运算符：

单词！= "伴侣"

`string`类超载的方式`!=`运算符允许您使用它，只要至少一个操作数是`string`对象；剩余的操作数可以是`string`对象或C风格的字符串。

`string`类设计允许您将`string`对象用作单个实体，如关系测试表达式，或用作聚合对象，您可以使用数组符号来提取单个字符。

如您所见，您可以使用C风格的字符串实现与`string`对象相同的结果，但使用`string`对象编程更简单、更直观。

最后，与您到目前为止看到的大多数`for`循环不同，最后两个循环不计算循环。也就是说，他们不会执行指定次数的语句块。相反，每个循环都关注特定情况（`word`是`"mate"`，以表明是时候停止了。更典型的是，C++程序用于第二种测试的循环，所以接下来让我们检查一下该表单。

### 循环

`while`循环是`for`删除初始化和更新部分的循环；它只有一个测试条件和一个正文：

而（*测试条件*）
     *身体*

首先，程序评估括号内*`test-condition`*表达式。如果表达式计算为`true`，程序将执行正文中的语句。`for`循环一样，主体由单个语句或由配对大括号定义的块组成。在主体完成后，程序返回测试状态并重新评估它。如果条件为非零，程序将再次执行正文。这个测试和执行周期一直持续到测试条件计算为`false`（见[图5.3](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05fig03)）。显然，如果您希望循环最终终止，则循环主体中的某些内容必须做一些事情来影响*`test-condition`*表达式。例如，循环可以增加测试条件中使用的变量，或从键盘输入读取新值。与`for`循环一样，`while`循环是一个入门条件循环。因此，iftest*`test-condition`*在开始时计算为`false`，程序永远不会执行循环的主体。



**图5.3。`while`循环的结构。**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05fig03.jpg)

[列出5.13](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex13)会让`while`循环发挥作用。该循环循环穿过字符串中的每个字符，并显示该字符及其ASCII代码。当循环达到空字符时，循环就会退出。这种逐个字符浏览字符串直到达到空字符的技术是处理C样式字符串的标准C++方法。由于字符串包含自己的终止标记，程序通常不需要有关字符串持续时间的显式信息。

**清单5.13。`while.cpp`**

------

// while.cpp -- 引入while循环
\#include <iostream>
const int ArSize = 20；
int main（）
{
使用命名空间std；
char name[ArSize];
cout << "请说出你的名字: ";
cin >> 名称；
cout << "这是你的名字，垂直化和ASCII化：\n";
int i = 0; // 从字符串开头开始
而（名字[i]！= '\0') // 进程到字符串末尾
{
cout << name[i] << ": " << int(name[i]) << endl;
i++; // 别忘了这个步骤
}
返回0；
}

以下是[清单5.13](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex13)中程序的示例运行：

请问你的名字：**Muffy**
这是您的姓名，垂直化和ASCII化：
提示：77
u：117
f：102
f：102
y：121

（不，垂直化和ASCII化不是真正的单词，甚至不是好的可能词。但他们确实为输出添加了可爱的技术基调。）

#### 计划备注

[清单5.13](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex13)中的`while`条件如下所示：

而（名字[i]！= '\0')

它测试数组中的特定字符是否为空字符。为了使这个测试最终成功，循环体需要改变`i`的值。它通过在循环体的末端增加`i`来做到这一点。省略此步骤会使循环卡在同一数组元素上，打印字符及其代码，直到您设法杀死程序。获取这样一个无限循环是循环最常见的问题之一。通常，当您忘记更新循环主体中的一些值时，您可能会引起它。

您可以这样重写`while`行：

而（名字[i]）

随着这一变化，该计划的工作原理与以前一样。这是因为当`name[i]`是一个普通字符时，其值是字符代码，它是非零或`true`。但当`name[i]`是空字符时，其字符代码值为`0`或`false`。这个符号更简洁（也更常用），但比[清单5.13](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex13)使用的要不清晰。愚蠢的编译器可能会为第二个版本生成更快的代码，但智能编译器为这两个版本生成相同的代码。

要打印字符的ASCII代码，程序使用类型转换将`name[i]`转换为整数类型。然后`cout`将值打印为整数，而不是将其解释为字符代码。



与C风格的字符串不同，`string`类对象不使用空字符来标识字符串的末尾，因此您不能仅通过将`char`数组替换为`string`对象来将[Listing 5.13](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex13)转换为`string`类版本。[第16章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch16.html#ch16)讨论了可用于`string`对象识别最后一个字符的技术。

#### `for`对抗`while`

在C++中，`for`和`while`循环本质上是等价的。例如，`for`循环

对于（*init表达式*；*测试表达式*；*更新表达式*）
{
  *声明*
}

可以这样重写：

*init-expression*；
而（*测试表达*）
{
  *声明*
  *更新表达*；
}

同样，`while`循环

而（*测试表达*）
  *身体*

可以这样重写：

对于（；*测试表达*；）
  *身体*

This `for` loop requires three expressions (or, more technically, one statement followed by two expressions), but they can be empty expressions (or statements). Only the two semicolons are mandatory. Incidentally, a missing test expression in a `for` loop is construed as true, so this loop runs forever:

为（ ; ; ）
  *身体*

因为`for`循环，`while`循环几乎等价，但你使用的循环在很大程度上取决于风格问题。有三个区别。如前所述，一个是`for`循环中省略的测试条件被解释为`true`。其次，您可以使用`for`循环中的初始化语句来声明循环的本地变量；您不能在`while`循环中这样做。最后，如果正文包含一个`continue`陈述，则略有不同，[第6章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch06.html#ch06)对此进行了讨论。通常，程序员使用`for`循环来计数循环，因为`for`循环格式使您可以将所有相关信息（初始值、终止值和更新计数器的方法）放在一个地方。当程序员事先不知道循环将执行多少次时，他们最常使用循环。





提示

在设计循环时，请记住以下准则：•识别终止循环执行的条件。•在第一次测试之前初始化该条件。•在再次测试条件之前，在每个循环周期中更新条件。One nice thing about `for` loops is that their structure provides a place to implement these three guidelines, thus helping you to remember to do so. But these guidelines apply to a `while` loop, too.





标点符号不好

`for`循环和`while`循环都有由括号表达式后面的单个语句组成的主体。正如您所看到的，该单个语句可以是一个块，可以包含多个语句。请记住，大括号，而不是缩进，定义了一个块。例如，考虑以下循环：i = 0；
而（名字[i]！= '\0')
cout << name[i] << endl;
i++；
cout << "Done\n";缩进告诉您，程序作者希望`i++;`语句成为循环主体的一部分。然而，没有大括号告诉编译器，正文仅由第一个`cout`语句组成。因此，循环不断无限期地打印数组的第一个字符。该程序永远不会到达`i++;`语句，因为它不在循环中。以下示例显示了另一个潜在的陷阱：i = 0；
而（名字[i]！= '\0'); // 问题分号
{
cout << name[i] << endl;
i++；
}
cout << "Done\n";这一次，代码可以正确使用大括号，但它也插入了一个额外的分号。请记住，分号终止语句，因此该分号终止`while`循环。换句话说，循环的主体是一个*空语句*——也就是说，后面没有分号。现在，大括号中的所有材料都出现在循环*之后*，从未到达。相反，循环循环，永远什么都不做。当心掉队分号。

稍等片刻—构建延时循环

有时，在程序中构建时间延迟是有用的。例如，您可能遇到过程序，这些程序在屏幕上闪烁消息，然后在阅读消息之前继续其他内容。你最终会担心你错过了至关重要的不可挽回的信息。如果程序在继续之前暂停5秒，那就更好了。`while`循环对于产生这种效果很方便。个人电脑早期的一项技术是让计算机计数一段时间以消耗时间：

长时间等待 = 0;
而（等待<10000）
wait++; // 静静地计数这种方法的问题在于，当您更改计算机处理器速度时，您必须更改计数限制。例如，为原始IBM PC编写的几款游戏在更快的继任者上运行时变得难以管理的速度。如今，编译器甚至可以推断，它只需设置为`wait``1000`并跳过循环。更好的方法是让系统时钟为您计时。ANSI C和C++库有一个功能来帮助您做到这一点。该函数称为`clock()`，它返回自程序开始执行以来的系统时间。不过，有一些并发症。首先，`clock()`不一定以秒为单位返回时间。其次，该函数的返回类型在某些系统上可能`long`，在其他系统上`unsigned long`，在其他系统上可能很长，而在其他系统上可能是其他类型。

但`ctime`头文件（当前较少实现上的`time.h`）为这些问题提供了解决方案。首先，它定义了一个符号常量`CLOCKS_PER_SEC`，等于每秒的系统时间单位数。因此，将系统时间除以该值会产生秒。或者，您可以将秒乘以`CLOCKS_PER_SEC`来获得系统单元的时间。其次，`ctime`将`clock_t`建立为`clock()`返回类型的别名。（请参阅本章后面的边栏“[键入别名](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05sb03)”。）这意味着您可以将变量声明为类型`clock_t`，编译器将其转换为`long`或`unsigned int`或任何适合您系统的类型。

[清单5.14](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex14)展示了如何使用`clock()`和`ctime`标头来创建时间延迟循环。

**清单5.14。`waiting.cpp`**

------

// waiting.cpp -- 在延时循环中使用clock()
\#include <iostream>
\#include <ctime> // 描述 clock() 函数，clock_t 类型
int main（）
{
使用命名空间std；
cout << "输入延迟时间，以秒为单位: ";
浮动秒；
cin >>秒；
clock_t delay = secs * CLOCKS_PER_SEC; // 转换为时钟滴答声
球手 << "starting\a\n";
clock_t start = clock();
while (clock() - start < delay ) // 等到时间流逝
; // 注意分号
cout << "done \a\n";
返回0；
}

通过计算系统单元而不是秒的延迟时间，[清单5.14](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex14)中的程序避免了在每个循环周期中将系统时间转换为秒。

------

类型别名

C++有两种方法可以将新名称建立为类型的别名。一个是使用预处理器：#define BYTE char // 预处理器用char替换BYTE然后，当您编译程序时，预处理器会将`BYTE`的所有出现替换为`char`，从而使`BYTE`成为`char`的别名。第二种方法是使用C++（和C）关键字`typedef`创建别名。例如，要使`byte`成为`char`的别名，请使用以下内容：typedef char字节; //使字节成为char的别名以下是一般形式：typedef *typeName别名名称*；In other words, if you want `aliasName` to be an alias for a particular type, you declare `aliasName` as if it were a variable of that type and then prefix the declaration with the `typedef` keyword. For example, to make `byte_pointer` an alias for pointer-to-`char`, you could declare `byte_pointer` as a pointer-to-`char` and then stick `typedef` in front:typedef char * byte_pointer; // 指向char类型的指针您可以尝试使用`#define`类似的东西，但如果您声明变量列表，则不起作用。例如，请考虑以下几点：#define FLOAT_POINTER 浮动 *
FLOAT_POINTER pa，pb；预处理器替换将声明转换为：float * pa, pb; // pa a pointer to float, pb just a float`typedef`方法没有这个问题。它处理更复杂的类型别名的能力使使用`typedef`成为比`#define`更好的选择——有时这是唯一的选择。请注意，`typedef`不会创建新类型。它只是为旧类型创建一个新名称。如果您将`word`设置为`int`的别名，`cout`会将类型`word`值视为其实际的`int`。

Loop `do while`

You’ve now seen the `for` loop and the `while` loop. The third C++ loop is the `do while`. It’s different from the other two because it’s an *exit-condition* loop. That means this devil-may-care loop first executes the body of the loop and only then evaluates the test expression to see whether it should continue looping. If the condition evaluates to `false`, the loop terminates; otherwise, a new cycle of execution and testing begins. Such a loop always executes at least once because its program flow must pass through the body of the loop before reaching the test. Here’s the syntax for the `do while` loop:

做
   *身体*
而（测试表达）；

*`body`*部分可以是单个语句或大括号分隔的语句块。[图5.4](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05fig04)总结了循环`do while`的程序流程。

**图5.4。`do while`循环的结构。**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05fig04.jpg)

通常，入口条件循环比出口条件循环更好，因为入口条件循环在循环前会检查。例如，假设[清单5.13](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex13)使用`do while`而不是`while`。在这种情况下，循环将打印空字符及其代码，然后发现它已经到达字符串的末尾。但有时`do while`测试确实有意义。例如，如果您请求用户输入，程序必须在测试之前获取输入。[清单5.15](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex15)显示了在这种情况下如何使用`do while`。

**清单5.15。`dowhile.cpp`**

------

// dowhile.cpp -- 退出条件循环
\#include <iostream>
int main（）
{
使用命名空间std；
int n；

cout << "输入1-10范围内的数字以找到"；
cout << "我最喜欢的数字\n";
做
{
cin >> n; // 执行正文
}当（n！= 7); // 然后测试
cout << "是的，7是我的最爱。\n" ;
返回0；
}

以下是[清单5.15](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex15)中程序的示例运行：

输入1-10范围内的数字以找到我最喜欢的数字
**9**
**4**
**7**
是的，7是我的最爱。

------

循环很奇怪

这并不常见，但您可能会偶尔看到类似于以下内容的代码：int I = 0;
for(;;) // 有时被称为“forever loop”
{
I++；
//做某事...
if (30 >= I) break; // if statement and break (Chapter 6)
}或者这里有另一个变体：int I = 0;
为（;;I++）
{
如果（30 >= I）断裂；
//做某事...
}该代码依赖于这样一个事实，即`for`循环中的空测试条件被视为true。这些示例都不容易阅读，也不应该用作编写循环的一般模型。第一个示例的功能可以在循环`do while`更清楚地表达：int I = 0;
做{
I++；
//做某事；
而（30 > I）；同样，第二个例子可以更清楚地表示为`while`循环：而（我<30）
{
// 做某事
I++；
}一般来说，编写清晰易懂的代码比展示利用语言模糊特征的能力更有用的目标。

基于循环的范围（C++11）

C++11添加了一种新的循环形式，称为*基于范围*`for`循环。它简化了一个常见的循环任务——对数组的每个元素做一些事情，或者更一般地说，对其中一个容器类（如`vector`或`array`）做一些事情。这里有一个例子：

双价[5] = {4.99, 10.99, 6.87, 7.99, 8.49};
对于（双x：价格）
cout << x << std::endl;这里`x`最初代表`prices`数组的第一个成员。显示第一个元素后，循环循环`x`依次表示数组的其余元素，因此此代码将打印所有五个成员，每行一个。简而言之，此循环显示数组范围内包含的每个值。要修改数组值，您需要循环变量的不同语法：对于（双倍和x：价格）
x = x * 0.80; //20%的折扣

`&`符号将`x`标识为参考变量，我们将在[第8章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch08.html#ch08)“[函数中的冒险”](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch08.html#ch08)中讨论这个主题。这里的重要性在于，这种形式的声明允许后续代码修改数组内容，而第一种形式则不允许。

基于范围`for`循环也可以与初始化列表一起使用：

（int x : {3, 5, 2, 8, 6}）
出局 << x << " ";
cout << '\n';

然而，这个循环可能最常用于[第16章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch16.html#ch16)讨论的各种模板容器类。

### 循环和文本输入

现在您已经了解了循环的工作原理，让我们看看分配给循环的最常见和最重要的任务之一：从文件或键盘逐个字符读取文本。例如，您可能想编写一个程序来计算输入中的字符、行和单词数量。传统上，C++和C一样，对此类任务使用`while`循环。接下来，我们将调查如何做到这一点。如果您已经知道C，请不要过快浏览以下部分。虽然C++ `while`循环与C相同，但C++的I/O设施不同。这可以让C++循环看起来与C循环略有不同。事实上，`cin`对象支持三种不同的单字符输入模式，每种模式都有不同的用户界面。让我们看看如何将这些选项与`while`循环一起使用。

#### 使用无装饰的`cin`进行输入

如果程序要使用循环从键盘读取文本输入，它必须有某种方式知道何时停止。它怎么知道什么时候停止？一种方法是选择一些特殊字符，有时称为*哨兵字符*，作为停止标志。例如，当程序遇到`#`字符时，[清单5.16](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex16)停止读取输入。该程序计算其读取的字符数，然后回声它们。也就是说，它重新显示已阅读的字符。（按下键盘键不会自动将字符放在屏幕上；程序必须通过响应输入字符来完成这项工作。通常，操作系统会处理该任务。在这种情况下，操作系统和测试程序都呼应输入。）完成后，程序会报告处理的字符总数。[清单5.16](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex16)显示了程序。

**清单5.16。`textin1.cpp`**

------

// textin1.cpp -- 用一段时间循环阅读字符
\#include <iostream>
int main（）
{
使用命名空间std；
char ch；
int count = 0; // 使用基本输入
cout << "输入字符; 输入 # 退出:\n";
cin >> ch; // 获取角色
而（ch！= '#') // 测试字符
{
cout << ch; // 呼应字符
++count; // 计数字符
cin >> ch; // 获取下一个字符
}
cout << endl << count << " characters read\n";
返回0；
}

以下是[清单5.16](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex16)中程序的示例运行：

输入字符；输入#退出：
**看到ken run#really fast**
看肯伦
9个字符读取

显然，Ken跑得如此之快，以至于他消灭了空间本身——或者至少消除了输入中的空间字符。

##### 计划备注

注意[清单5.16](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex16)中程序的结构。程序在到达循环之前读取第一个输入字符。这样，当程序到达循环语句时，可以测试第一个字符。这很重要，因为第一个字符可能是`#`。由于`textin1.cpp`使用入门条件循环，在这种情况下，程序会正确跳过整个循环。由于变量`count`之前设置为`0`，因此`count`具有正确的值。

假设读取的第一个字符不是`#`。在这种情况下，程序进入循环，显示字符，增加计数，并读取下一个字符。最后一步至关重要。没有它，循环会永远重复处理第一个输入字符。最后一步，程序会进入下一个字符。

请注意，循环设计遵循前面提到的准则。终止循环的条件是，最后一个读取的字符是`#`。该条件通过在循环开始前读取字符进行初始化。通过在循环结束时读取新字符来更新条件。

这一切听起来都很合理。那么，为什么程序会省略输出上的空格呢？责怪`cin`。当读取类型`char`值时，就像读取其他基本类型时一样，`cin`跳过空格和换行符。输入中的空格没有回声，因此它们不被计算在内。

为了使事情进一步复杂化，对`cin`的输入被缓冲。这意味着在您按Enter键之前，您键入的字符不会发送到程序。这就是为什么您可以在[清单5.16](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex16)中运行程序时在`#`之后键入字符。按Enter键后，整个字符序列将发送到程序，但程序在到达`#`字符后退出处理输入。

#### `cin.get(char)`救援

通常，逐个字符读取输入的程序需要检查每个字符，包括空格、选项卡和换行符。`cin`所属的`istream`类（在`iostream`中定义）包括满足此需求的成员函数。特别是，成员函数`cin.get(ch)`从输入中读取下一个字符，即使它是一个空格，并将其分配给变量`ch`。通过将`cin>>ch`替换为此函数调用，您可以修复[清单5.16](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex16)。[清单5.17](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex17)显示了结果。

**清单5.17。`textin2.cpp`**

------

// textin2.cpp -- 使用cin.get(char)
\#include <iostream>
int main（）
{
使用命名空间std；
char ch；
int count = 0；

cout << "输入字符; 输入 # 退出:\n";
cin.get(ch); // 使用cin.get(ch)函数
而（ch！='#'）
{
cout << ch;
++计数；
cin.get(ch); // 再次使用它
}
cout << endl << count << " characters read\n";
返回0；
}

以下是[清单5.17](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex17)中程序的示例运行：

输入字符；输入#退出：
**你用了#2铅笔吗？**
你用过
14个字符读取

现在，该程序回声并计算每个字符，包括空格。输入仍然是缓冲的，因此仍然可以键入比最终到达程序的输入更多的输入。

如果你熟悉C，这个程序可能会给你大错特错。`cin.get(ch)`调用在`ch`变量中放置一个值，这意味着它改变了变量的值。在C中，如果您想更改变量的值，您必须将变量的地址传递给函数。但在[清单5.17](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex17)中对`cin.get()`[的](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex17)调用传递`ch`，而不是`&ch`。在C中，像这样的代码不起作用。在C++中，只要函数将参数声明为*引用*，它就可以工作。引用类型是C++添加到C中的内容。`iostream`头文件将参数声明为`cin.get(ch)`作为引用类型，因此此函数可以更改其参数的值。您将了解第8[章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch08.html#ch08)中的详细信息。与此同时，你们中的C专家可以放松；通常，在C++中传递的参数就像在C中传递一样。然而，对于`cin.get(ch)`它不是。

#### 你应该使用哪个`cin.get()`？

[第4章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch04.html#ch04)中的[清单4.5](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch04.html#ch04ex05)使用以下代码：

char name[ArSize];
...
cout << "输入你的名字:\n";
cin.get(name, ArSize).get();

最后一行相当于两个连续的函数调用：

cin.get（名称，ArSize）；
cin.get（）；

`cin.get()`的一个版本需要两个参数：数组名称，即字符串的地址（技术上，类型`char*`）和`ArSize`，即类型`int`的整数。（请记住，数组的名称是其第一个元素的地址，因此字符数组的名称是`char*`类型。）然后，该程序使用`cin.get()`，没有参数。最近，我们以这种方式使用`cin.get()`：

char ch；
cin.get（ch）；

这次`cin.get()`有一个参数，它是`char`类型。

再次，你们这些熟悉C的人是时候兴奋或困惑了。在C中，如果函数以指针到`char`和`int`作为参数，则无法在不同类型的单个参数中成功使用相同的函数。但您可以在C++中这样做，因为该语言支持称为*函数重载的*OOP功能。函数重载允许您创建名称相同的不同函数，前提是它们具有不同的参数列表。例如，如果您在C++中使用`cin.get(name, ArSize)`编译器会找到使用`char*`和`int`作为参数的`cin.get()`版本。但是，如果您使用`cin.get(ch)`编译器将获取使用单个类型`char`参数的版本。如果代码不提供参数，编译器将使用不接受参数的`cin.get()`版本。

函数重载使您能够对以不同方式或不同类型的执行相同基本任务的相关函数使用相同的名称。这是[第8章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch08.html#ch08)中等待你的另一个话题。同时，您可以使用`istream`类附带的`get()`示例来习惯函数重载。为了区分不同的函数版本，我们将在引用它们时包含参数列表。因此，`cin.get()`表示不接受参数的版本，`cin.get(char)`表示接受一个参数的版本。

#### 文件结束条件

如[清单5.17](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex17)所示，使用`#`等符号来表示输入结束并不总是令人满意的，因为这种符号可能是合法输入的一部分。其他任意选择的符号也是如此，例如`@`和`%`。如果输入来自文件，您可以使用更强大的技术——检测文件末尾（EOF）。C++输入设施与操作系统合作，检测输入何时到达文件末尾，并将该信息报告回程序。

乍一看，从文件中读取信息似乎与`cin`和键盘输入几乎没有关系，但有两个连接。首先，许多操作系统，包括Unix、Linux和Windows命令提示符模式，都支持*重定向*，这使您能够用文件代替键盘输入。例如，假设在Windows中，您有一个名为`gofish.exe`可执行程序和一个名为`fishtale`的文本文件。在这种情况下，您可以在命令提示符模式下给出此命令行：gofish <fishtale这导致程序从`fishtale`文件中而不是键盘接收输入。`<`符号是Unix和Windows命令提示符模式的重定向运算符。其次，许多操作系统允许您从键盘模拟EOF条件。在Unix中，您可以通过在行开头按Ctrl+D来做到这一点。在Windows命令提示模式下，您按Ctrl+Z，然后按线路上的任意位置输入。C++的一些实现支持类似行为，即使底层操作系统不支持。键盘输入的EOF概念实际上是命令行环境的遗留物。然而，Mac版赛门铁克C++模仿Unix，并将Ctrl+D识别为模拟EOF。Metrowerks Codewarrior在Macintosh和Windows环境中识别Ctrl+Z。适用于PC的Microsoft Visual C++、Borland C++ 5.5和GNU C++在Ctrl+Z是行上的第一个字符时识别Ctrl+Z，但它们需要随后的Enter。简而言之，许多PC编程环境将Ctrl+Z识别为模拟EOF，但确切的细节（行上的任何地方与行上的第一个字符，需要或不需要输入键）各不相同。

如果您的编程环境可以测试EOF，您可以使用类似于[清单5.17](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex17)的程序和重定向文件，并且您可以使用它进行键盘输入，以模拟EOF。这听起来很有用，所以让我们看看它是如何做到的。

当`cin`检测到EOF时，它将两个位（*eofbit*和*故障位*）设置为1。您可以使用名为`eof()`的成员函数来查看eofbit是否已设置；如果检测到EOF，callcin`cin.eof()`返回`bool`值`true`，否则返回`false`。同样，如果eofbit或failbit设置为`1`，则`fail()`成员函数返回`true`，否则返回`false`。请注意，`eof()`和`fail()`方法报告了最近尝试阅读的结果；也就是说，它们报告过去，而不是展望未来。因此，`cin.eof()`或`cin.fail()`测试应始终遵循读取尝试。[清单5.18](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex18)的设计反映了这一事实。它使用`fail()`而不是`eof()`，因为前一种方法似乎适用于更广泛的实现。

------

备注



某些系统不支持键盘上的模拟EOF。其他系统不完全支持它。如果您一直在使用`cin.get()`冻结屏幕，直到您可以读取它，这在这里不起作用，因为检测EOF会关闭进一步读取输入的尝试。但是，您可以使用像[listing 5.14](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex14)这样的计时循环来保持屏幕可见一段时间。或者，您可以使用`cin.clear(),`如[第6章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch06.html#ch06)和第17章所述，重置输入流。

------

**清单5.18。`textin3.cpp`**

------

// textin3.cpp -- 将字符读取到文件末尾
\#include <iostream>
int main（）
{
使用命名空间std；
char ch；
int count = 0；
cin.get(ch); // 尝试读取字符
while (cin.fail() == false) // 测试 EOF
{
cout << ch; // echo字符
++计数；
cin.get(ch); // 尝试读取另一个字符
}
cout << endl << count << " characters read\n";
返回0；
}

以下是[清单5.18](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex18)中程序的示例输出：

**这只绿鸟在冬天唱歌。<输入>**
这只绿鸟在冬天唱歌。
**是的，但是乌鸦在黎明时分飞翔。<输入>**
是的，但是乌鸦在黎明时分飞翔。
**<CTRL>+<Z><ENTER>**
读取73个字符

由于我在Windows 7系统上运行了程序，所以我按了Ctrl+Z，然后按Enter来模拟EOF条件。Unix和Linux用户将按Ctrl+D。请注意，在Unix和类Unix系统中，包括Linux和Cygwin，Ctrl+Z暂停程序的执行；`fg`命令允许恢复执行。

通过使用重定向，您可以使用[清单5.18](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex18)中的程序来显示文本文件并报告其字符数。这一次，我们有一个程序从Unix系统的两行文件中读取、回声和计数字符（`$`是Unix提示符）：

$ textin3 < 东西
我是一个Unix文件。我很自豪
是一个Unix文件。
48个字符读取
¥

##### EOF结束输入

请记住，当`cin`方法检测到EOF时，它会在`cin`对象中设置一个标志，指示EOF条件。设置此标志后，`cin`不再读取输入，对`cin`进一步调用没有效果。对于文件输入，这是有道理的，因为你不应该读过文件的末尾。然而，对于键盘输入，您可以使用模拟EOF终止循环，但希望稍后阅读更多输入。`cin.clear()`方法清除EOF标志，并让输入再次继续。[第17章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch17.html#ch17)“[输入、输出和文件](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch17.html#ch17)”进一步讨论了这个问题。然而，请记住，在某些系统中，键入Ctrl+Z有效地终止了`cin.clear()`功能之外的输入和输出以恢复它们。

##### 字符输入的常见成语

以下是循环的基本设计，旨在一次读取字符文本，直到EOF：

cin.get(ch); // 尝试读取字符
while (cin.fail() == false) // 测试 EOF
{
... // 做事
cin.get(ch); // 尝试读取另一个字符
}

您可以使用此代码进行一些快捷方式。[第6章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch06.html#ch06)介绍了`!`运算符，切换为`false`，反之亦然。您可以使用它来重写`while`测试，使其看起来像这样：

而（！cin.fail()) // 当输入没有失败时

`cin.get(char)`方法的返回值是`cin`，一个对象。然而，`istream`类提供了一个函数，可以将`cin`等`istream`对象转换为`bool`值；当`cin`出现在预期`bool`的位置时，例如`while`循环的测试条件中，会调用此转换函数。此外，如果上次尝试读取成功，则转换的`bool`值为`true`，否则为`false`。这意味着您可以重写`while`测试如下所示：

当（cin）//当输入成功时

这比使用更一般一点`!cin.fail()`或`!cin.eof()`，因为它检测到其他可能的故障原因，例如磁盘故障。

最后，由于`cin.get(char)`的返回值为`cin`，您可以将循环压缩为以下格式：

当（cin.get(ch)）//当输入成功时
{
... // 做事
}

在这里，`cin.get(char)`在测试条件下调用一次，而不是两次——一次在循环之前，一次在循环结束时。要计算循环测试，程序首先必须执行对`cin.get(ch)`的调用，如果成功，则将值放入`ch`中。然后，程序从函数调用中获取返回值，即`cin`。然后，它将`bool`转换应用于`cin`，如果输入有效，则生成`true`，否则为`false`。这三个准则（识别终止条件、初始化条件和更新条件）都被压缩为一个循环测试条件。

另一个版本`cin.get()`怀旧C用户可能渴望C的字符I/O函数`getchar()`和`putchar()`）。如果你想要的话，它们有C++版本。您只需像在C中一样使用`stdio.h`头文件（或使用更最新的`cstdio`）。或者，您可以使用`istream`和`ostream`类的成员函数，这些函数的工作方式大致相同。接下来，我们来看看这个方法。没有参数的`cin.get()`成员函数从输入返回下一个字符。也就是说，你以这种方式使用它：ch = cin.get();

（请记住，`cin.get(ch)`返回一个对象，而不是读取的字符。）此函数的工作原理与C的`getchar()`大致相同，将字符代码作为类型`int`值返回。同样，您可以使用`cout.put()`函数（见[第3章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch03.html#ch03)“[处理数据](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch03.html#ch03)”）来显示字符：

cout.put（ch）；

它的工作原理与C的`putchar()`非常相似，只是它的参数应该是type `char`而不是type `int`。

------

备注

最初，`put()`成员有单个原型`put(char)`您可以传递一个`int`参数，然后键入`char`。该标准还要求单一的原型。然而，一些C++实现提供了三个原型：`put(char)``put(signed char)`和`put(unsigned char)`在这些实现中使用`put()`和`int`参数会生成错误消息，因为转换`int`有多个选择。显式类型转换，如`cin.put(char(ch))`适用于`int`类型。



要成功使用`cin.get()`，您需要知道它如何处理EOF条件。当函数到达EOF时，不再返回字符。相反，`cin.get()`返回一个特殊值，由符号常量`EOF`表示。此常量在`iostream`头文件中定义。`EOF`值必须与任何有效的字符值不同，以便程序不会将`EOF`与常规字符混淆。通常，`EOF`被定义为值`-1`，因为没有字符的ASCII代码为`-1`，但您不需要知道实际值。您只需在程序中使用`EOF`即可。例如，[清单5.18](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex18)的核心如下所示：

char ch；
cin.get（ch）；
while (cin.fail() == false) // 测试 EOF
{
cout << ch;
++计数；
cin.get（ch）；
}

您可以使用`int ch`，将`cin.get(char)`替换为`cin.get()`，将`cout`替换为`cout.put()`，并将`cin.fail()`测试替换为`EOF`测试：int ch; /// 与 EOF 值兼容
ch = cin.get();
而（ch！= EOF）
{
cout.put(ch); // cout.put(char(ch)) 对于某些实现
++计数；
ch = cin.get();
}如果`ch`是一个字符，循环会显示它。如果`ch`是`EOF`，则循环终止。



提示

您应该意识到，`EOF`不代表输入中的字符。相反，这是一个信号，表明不再有角色了。

There’s a subtle but important point about using `cin.get()` beyond the changes made so far. Because `EOF` represents a value outside the valid character codes, it’s possible that it might not be compatible with the `char` type. For example, on some systems type `char` is unsigned, so a `char` variable could never have the usual `EOF` value of `-1`. For this reason, if you use `cin.get()` (with no argument) and test for `EOF`, you must assign the return value to type `int` instead of to type `char`. Also if you make `ch` type `int`instead of type `char`, you might have to do a type cast to `char` when displaying `ch`.

[清单5.19](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex19)将`cin.get()`方法纳入[清单5.18](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex18)的新版本。它还通过将字符输入与`while`循环测试相结合来压缩代码。

**清单5.19。`textin4.cpp`**

------

// textin4.cpp -- 用cin.get()阅读字符
\#include <iostream>
int main（无效）
{
使用命名空间std；
int ch; // 应该是int，而不是char
int count = 0；

while ((ch = cin.get()) != EOF) // 测试文件末尾
{
cout.put（char（ch））；
++计数；
}
cout << endl << count << " characters read\n";
返回0；
}



备注



一些系统要么不支持键盘的模拟EOF，要么不完全支持它，这可能会阻止[清单5.19](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex19)中的示例按所述运行。如果您一直在使用`cin.get()`冻结屏幕，直到您可以读取它，这在这里不起作用，因为检测EOF会关闭进一步读取输入的尝试。但是，您可以使用[清单5.14](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex14)中的计时循环来保持屏幕可见一段时间。或者，您可以使用`cin.clear(),`如[第17章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch17.html#ch17)所述，重置输入流。

------

以下是[清单5.19](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex19)中程序的示例运行：

**闷闷不乐的鲭鱼在阴暗的浅滩上起闷气。<输入>**
闷闷不乐的鲭鱼在阴暗的浅滩上起闷气。
**是的，但幸福的蓝鸟蕴藏着秘密。<输入>**
是的，但幸福的蓝鸟蕴藏着秘密。
**<CTRL>+<Z><ENTER>**
读取104个字符

让我们分析一下循环条件：

while ((ch = cin.get()) != EOF）

包含子表达式`ch = cin.get()`的括号导致程序首先计算该表达式。要进行评估，程序必须首先调用thecin`cin.get()`函数。接下来，它将函数返回值分配给`ch`。由于赋值语句的值是左操作数的值，因此整个子表达式简化为`ch`的值。如果此值为`EOF`，循环将终止；否则，它将继续。测试条件需要所有括号。假设你省略了一些括号：

而（ch = cin.get()！= EOF）

`!=`运算符的优先级高于`=`，因此首先程序将`cin.get()`的返回值与`EOF`进行比较。比较会产生`false`或`true`结果；该`bool`值转换为`0`或1，这就是分配给`ch`的值。

另一方面，使用`cin.get(ch)`带有参数）进行输入不会产生任何类型问题。请记住，`cin.get(char)`函数不会在EOF为`ch`分配特殊值。事实上，在这种情况下，它不会为`ch`分配任何东西。`ch`从未被要求持有非`char`值。[表5.3](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05table03)总结了`cin.get(char)`和`cin.get()`之间的区别。

**Table 5.3. `cin.get(ch)` Versus `cin.get()`**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05tab03.jpg)那么，你应该使用哪个，`cin.get()`还是`cin.get(char)`？带有字符参数的形式更充分地集成到对象方法中，因为它的返回值是`istream`对象。例如，这意味着您可以链式使用。例如，以下代码意味着将下一个输入字符读取到`ch1`，将以下输入字符读取到`ch2`：cin.get(ch1).get(ch2);这之所以有效，是因为函数调用`cin.get(ch1)`返回`cin`对象，然后作为`get(ch2)`附加的对象。`get()`表单的主要用途可能是让您从`stdio.h`的`getchar()`和`putchar()`函数快速肮脏地转换为`iostream`的`cin.get()`和`cout.put()`方法。您只需将一个头文件替换为另一个头文件，然后用它们的行为方法等价物全局替换`getchar()`和`putchar()`）。（如果旧代码使用类型`int`变量进行输入，如果您的实现具有多个`put()`原型，则必须进行进一步调整。）嵌套循环和二维阵列在本章早些时候，您看到`for`循环是处理数组的自然工具。现在让我们更进一步，看看`for`循环（嵌套循环）中的`for`循环如何用于处理二维数组。首先，让我们检查一下什么是二维数组。本章迄今为止使用的数组被称为*一维数组*，因为您可以将每个数组可视化为一行数据。您可以将二维数组可视化为更像表，同时具有数据行和列。例如，您可以使用二维数组来表示六个独立地区的季度销售数字，每个地区有一行数据。或者，您可以使用二维数组来表示RoboDork在计算机游戏板上的位置。C++不提供特殊的二维数组类型。相反，您创建一个数组，每个元素本身就是一个数组。例如，假设您想在4年内存储五个城市的最高温度数据。在这种情况下，您可以声明数组如下：int maxtemps[4][5]；

此声明意味着`maxtemps`是一个包含四个元素的数组。每个元素都是由五个整数组成的数组（见[图5.5](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05fig05)）。您可以将`maxtemps`数组视为表示四行，每行五个温度值。

**图5.5。数组数组。**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05fig05.jpg)

表达式`maxtemps[0]`是`maxtemps`数组的第一个元素；因此`maxtemps[0]`本身是一个由五个`int`组成的数组。`maxtemps[0]`数组的第一个元素是`maxtemps[0][0]`，这个元素是单个`int`。因此，您需要使用两个下标来访问`int`元素。您可以将第一个下标视为代表行，将第二个下标视为代表列（见[图5.6](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05fig06)）。

**图5.6。使用下标访问数组元素。**

![图像](http://localhost:63343/C_Primer_Plus_Source_Code/C++%20Primer%20Plus%20by%20Prata,%20Stephen%20(z-lib.org)/OEBPS/html/graphics/05fig06.jpg)

假设您想打印所有数组内容。在这种情况下，您可以使用一个循环更改行，第二个嵌套循环更改列：

for (int row = 0; row < 4; row++)
{
for（int col = 0；col < 5；++col）
cout << maxtemps[row][col] << "\t";
cout << endl;
}对于`row`的每个值，循环`for`内部循环贯穿所有`col`值。此示例在每个值后打印一个制表符（C++转义字符表示法中的`\t`），并在每个完整行后打印一个换行符。初始化二维数组当您创建二维数组时，您可以选择初始化每个元素。该技术基于初始化一维数组的技术。请记住，您通过提供大括号中括起来的以逗号分隔的值列表来做到这一点：// 初始化一维数组
int btus[5] = { 23, 26, 24, 31, 28};对于二维数组，每个元素本身就是一个数组，因此您可以使用上一个代码示例中的类似形式初始化每个元素。因此，初始化由逗号分隔的一系列一维初始化组成，全部包含在一组大括号中：int maxtemps[4][5] = // 二维数组
{
{96, 100, 87, 101, 105}, // maxtemps的值[0]
{96, 98, 91, 107, 104}, // maxtemps的值[1]
{97, 101, 93, 108, 107}, // maxtemps的值[2]
{98, 103, 95, 109, 108} // maxtemps的值[3]
}；您可以将最大温度可视化为四行，每行五个数字。术语`{94, 98, 87, 103, 101}`初始化了第一行，由`maxtemps[0]`表示。作为风格问题，如果可能的话，将每一行数据放在自己的行上，使数据更容易阅读。使用二维数组

[清单5.20](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex20)将初始化的二维数组和嵌套循环集成到程序中。这一次，程序颠倒了循环的顺序，将列循环（城市索引）放在外部，将行循环（年索引）放在内部。它还使用常见的C++实践来初始化指向一组字符串常量的指针数组。也就是说，`cities`被宣布为一系列指向`char`的指针。这使得每个元素，如`cities[0]`，都是一个指向`char`的指针，可以初始化到字符串的地址。程序将`cities[0]`初始化为`"Gribble City"`字符串的地址，以此类操作。因此，这个指针数组的行为就像一个字符串数组。



**清单5.20。`nested.cpp`**

------

// nested.cpp -- 嵌套循环和二维数组
\#include <iostream>
限制城市=5；
年份=4；
int main（）
{
使用命名空间std；
const char * cities[Cities] = // 指针数组
{ // 到 5 个字符串
"格里布城",
"格里布尔敦"，
"新运球"，
"圣格里布尔",
"Gribble Vista"
}；

int maxtemps[年份][城市] = // 2-D数组
{
{96, 100, 87, 101, 105}, // maxtemps的值[0]
{96, 98, 91, 107, 104}, // maxtemps的值[1]
{97, 101, 93, 108, 107}, // maxtemps的值[2]
{98, 103, 95, 109, 108} // maxtemps的值[3]
}；

cout << "2008 - 2011\n\n"的最大温度"；
用于（int city = 0；city < Cities; ++city）
{
cout << cities[city] << ":\t";
（int year = 0；year < Years; ++year）
cout << maxtemps[year][city] << "\t";
cout << endl;
}
// cin.get();
返回0；
}

以下是[清单5.20](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex20)中程序的输出：

2008-2009年最高气温


格里布尔市：96 96 97 98
Gribbletown：100 98 101 103
新运球：87 91 93 95
圣格里布尔：101 107 108 109
Gribble Vista：105 104 107 108

在输出空间中使用制表符比使用空格更经常地使用数据。然而，不同的选项卡设置可能会导致输出在不同系统上的外观不同。[第17章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch17.html#ch17)提出了更精确但更复杂的输出格式化方法。

更尴尬的是，您可以使用`char`数组数组，而不是字符串数据的指针数组。该宣言如下所示：

char cities[Cities][25] = // 25 char的5个数组数组
{
"格里布城",
"格里布尔敦"，
"新运球"，
"圣格里布尔",
"Gribble Vista"
}；

这种方法将五个字符串中的每个字符串限制在最多24个字符。指针数组存储五个字符串文字的地址，但`char`数组将五个字符串文本中的每个复制到相应的五个25个`char`数组。因此，指针阵列在空间方面要经济得多。但是，如果您打算修改任何字符串，二维数组将是一个更好的选择。奇怪的是，两个选项都使用相同的初始化列表，循环代码相同来显示字符串。

您还可以使用`string`类对象数组，而不是字符串数据的指针数组。该宣言如下所示：

const string cities[Cities] = // 5个字符串数组
{
"格里布城",
"格里布尔敦"，
"新运球"，
"圣格里布尔",
"Gribble Vista"
}；

如果您打算使字符串可修改，则省略`const`限定符。此表单使用与其他两个表单相同的初始化器列表和相同的循环显示代码。如果您想要可修改的字符串，`string`类的自动大小功能使这种方法比二维数组方法更方便使用。

摘要C++ offers three varieties of loops: `for` loops, `while` loops, and `do while` loops. A loop cycles through the same set of instructions repetitively, as long as the loop test condition evaluates to `true` or nonzero and the loop terminates execution when the test condition evaluates to `false` or zero. The `for` loop and the `while` loop are entry-condition loops, meaning that they examine the test condition before executing the statements in the body of the loop. The `do while` loop is an exit-condition loop, meaning that it examines the test condition after executing the statements in the body of the loop.每个循环的语法要求循环主体由单个语句组成。然而，该语句可以是复合语句或块，通过在配对的花括号中包含多个语句而形成。比较两个值的关系表达式通常用作循环测试条件。关系表达式是通过使用六个关系运算符之一形成的：`<`,`<=`, `==`, `>=`, `>`, or `!=`。关系表达式计算为类型`bool`值为`true`和`false`。许多程序逐个字符读取文本输入或文本文件。`istream`类提供了几种方法。如果`ch`是类型`char`变量，则以下语句将下一个输入字符读取到`ch`中：cin >> ch;然而，它跳过空格、换行符和选项卡。以下成员函数调用读取下一个输入字符，无论其值如何，并将其放置在`ch`中：cin.get（ch）；成员函数调用`cin.get()`返回下一个输入字符，包括空格、换行符和制表符，因此可以使用如下：ch = cin.get();`cin.get(char)`成员函数调用通过返回带有`false`的`bool`转换的值来报告遇到EOF条件，而`cin.get()`成员函数调用通过返回`iostream`文件中定义的值`EOF`报告EOF。嵌套循环是循环中的循环。嵌套循环提供了处理二维数组的自然方式。章节回顾

[**1。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a1)入门条件循环和退出条件循环有什么区别？每个C++循环都是哪种？

[**2。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a2)如果是有效程序的一部分，以下代码片段会打印什么？

int i;
为（i = 0；i < 5；i++）
cout << i;
cout << endl;

[**3。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a3)如果是有效程序的一部分，以下代码片段会打印什么？

int j;
用于（j = 0；j < 11；j += 3）
出局 << j;
cout << endl << j << endl;

[**4。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a4)如果是有效程序的一部分，以下代码片段会打印什么？

int j = 5；
而（++j < 9）
cout << j++ << endl;

[**5。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a5)如果是有效程序的一部分，以下代码片段会打印什么？

int k = 8；
做
cout <<" k = " << k << endl;
而（k++ < 5）；

[**6。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a6)写一个`for`循环，通过在每个周期中将计数变量的值增加两倍来打印值1 2 4 8 16 32 64。

[**7。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a7)你如何使循环主体包含多个语句？

[**8。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a8)以下陈述是否有效？如果没有，为什么不呢？如果是这样，它是做什么的？

int x = (1,024)；

以下内容呢？

int y；
y = 1,024；

[**9。**](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/app10.html#ch05qa1a9)`cin>>ch`查看输入的方式上与`cin.get(ch)`和`ch=cin.get()`有何不同？

### 编程练习

**1。**编写一个程序，要求用户输入两个整数。然后，程序应该计算和报告两个整数之间所有整数的总和。此时，假设首先输入较小的整数。例如，如果用户输入**`2`**和9，程序应该报告从2到9的所有整数的总和是44。



**2。**使用类型`array`对象而不是内置数组，并使用`long double`而不是`long long`做[清单5.4](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch05.html?_ijt=416gsjb5khdop46fe9huj5our5&_ij_reload=RELOAD_ON_SAVE#ch05ex04)。找到100的价值！

**3。**编写一个程序，要求用户输入数字。在每个条目之后，程序应该报告迄今为止条目的累计总和。当用户输入**`0`**时，程序应该终止。



**4。**达芙妮以10%的简单利息投资100美元。也就是说，每年，投资收入为原始投资的10%，即每年10美元：

利息=0.10×原始余额与此同时，Cleo以5%的复利投资了100美元。也就是说，利息是当前余额的5%，包括之前增加的利息：利息=0.05×当前余额Cleo第一年收入为100美元的5%，给了她105美元。第二年，她的收入为105美元的5%，即5.25美元，以此类拉。编写一个程序，找到Cleo投资价值需要多少年才能超过Daphne的投资价值，然后显示当时这两种投资的价值。

**5。**你*为傻瓜*卖*C++*这本书。编写一个程序，让您输入一年的月销售额（按书籍数量而不是金钱计算）。程序应使用循环按月提示您，使用初始化为月字符串的`char *`数组（或`string`对象数组，如果您愿意），并将输入数据存储在`int`数组中。然后，程序应该找到数组内容的总和，并报告当年的总销售额。



**6。**做编程练习5，但使用二维数组存储输入，每月销售3年。报告每个年份和合并年份的总销售额。



**7。**设计一种名为`car`结构，其中包含有关汽车的以下信息：其品牌，作为字符数组或`string`对象中的字符串，以及作为整数构建年份。编写一个程序，询问用户要编目多少辆车。然后，该程序应该使用`new`来创建这么多`car`结构的动态阵列。接下来，它应该提示用户为每个结构输入make（可能由多个单词组成）和年份信息。请注意，这需要一些注意，因为它将读取字符串与数字数据交替使用（见[第4章](http://localhost:63343/C_Primer_Plus_Source_Code/C++ Primer Plus by Prata, Stephen (z-lib.org)/OEBPS/html/ch04.html#ch04)）。最后，它应该显示每个结构的内容。示例运行应该如下所示：

你想对多少辆车进行编目？**2**
汽车#1：
请输入制作：**哈德逊大黄蜂**
请输入年份：1952**年**
第2辆车：
请输入制作：**Kaiser**
请输入年份：1951**年**
这是您的收藏：
1952年哈德逊大黄蜂
1951年凯撒

**8。**编写一个程序，使用`char`数组和循环一次读取一个单词，直到输入单词`done`。然后，程序应该报告输入的字数（不计算`done`）。示例运行可能如下所示：

输入单词（停止，键入完成的单词）：
**食蚁兽生日类别垃圾箱**
**嫉妒的几何形状肯定完成了**
您总共输入了7个单词。您应该包含`cstring`头文件，并使用strcmp`strcmp()`函数进行比较测试。

**9。**编写一个与编程练习8中程序描述相匹配的程序，但使用`string`类对象而不是数组。包括`string`头文件，并使用关系运算符进行比较测试。



**10。**使用嵌套循环编写程序，要求用户输入要显示的行数的值。然后，它应该显示许多行星号，第一行有一个星号，第二行两个星号，以此类此类所起。对于每行，星号前面都有所需的句号，以使所有行显示等于行数的字符总数。示例运行如下所示：

输入行数**：5**
....*
...**
..***
。****
*****