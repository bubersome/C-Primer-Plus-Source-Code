<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>4. Compound Types</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch04">4. Compound Types</h2>
<p><a id="page_115"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Creating and using arrays</p>
<p class="indenthandingB">&#8226; Creating and using C-style strings</p>
<p class="indenthandingB">&#8226; Creating and using <code>string</code>-class strings</p>
<p class="indenthandingB">&#8226; Using the <code>getline()</code> and <code>get()</code> methods for reading strings</p>
<p class="indenthandingB">&#8226; Mixing string and numeric input</p>
<p class="indenthandingB">&#8226; Creating and using structures</p>
<p class="indenthandingB">&#8226; Creating and using unions</p>
<p class="indenthandingB">&#8226; Creating and using enumerations</p>
<p class="indenthandingB">&#8226; Creating and using pointers</p>
<p class="indenthandingB">&#8226; Managing dynamic memory with <code>new</code> and <code>delete</code></p>
<p class="indenthandingB">&#8226; Creating dynamic arrays</p>
<p class="indenthandingB">&#8226; Creating dynamic structures</p>
<p class="indenthandingB">&#8226; Automatic, static, and dynamic storage</p>
<p class="indenthandingB">&#8226; The <code>vector</code> and <code>array</code> classes (an introduction)</p>
<p>Say you&#8217;ve developed a computer game called User-Hostile in which players match wits with a cryptic and abusive computer interface. Now you must write a program that keeps track of your monthly game sales for a five-year period. Or you want to inventory your accumulation of hacker-hero trading cards. You soon conclude that you need something more than C++&#8217;s simple basic types to meet these data requirements, and C++ offers something more&#8212;compound types. These are types built from the basic integer and floating-point types. The most far-reaching compound type is the class, that bastion of OOP toward which we are progressing. But C++ also supports several more modest compound types taken from C. The array, for example, can hold several values of the same type. A particular kind of array can hold a string, which is a series of characters. Structures can hold several values of differing types. Then there are pointers, which are variables that tell a computer where data is placed. You&#8217;ll examine all these compound forms (except <a id="page_116"/>classes) in this chapter, take a first look at <code>new</code> and <code>delete</code> and how you can use them to manage data, and take an introductory look at the C++ <code>string</code> class, which gives you an alternative way to work with strings.</p>
<h3 id="ch04lev1sec1">Introducing Arrays</h3>
<p>An <em>array</em> is a data form that can hold several values, all of one type. For example, an array can hold 60 type <code>int</code> values that represent five years of game sales data, 12 <code>short</code> values that represent the number of days in each month, or 365 <code>float</code> values that indicate your food expenses for each day of the year. Each value is stored in a separate array element, and the computer stores all the elements of an array consecutively in memory.</p>
<p>To create an array, you use a declaration statement. An array declaration should indicate three things:</p>
<p class="indenthandingB">&#8226; The type of value to be stored in each element</p>
<p class="indenthandingB">&#8226; The name of the array</p>
<p class="indenthandingB">&#8226; The number of elements in the array</p>
<p>You accomplish this in C++ by modifying the declaration for a simple variable and adding brackets that contain the number of elements. For example, the following declaration creates an array named <code>months</code> that has 12 elements, each of which can hold a type <code>short</code> value:</p>
<p class="programlisting">short months[12];&#160;&#160;&#160;&#160;&#160;// creates array of 12 short</p>
<p>Each element, in essence, is a variable that you can treat as a simple variable.</p>
<p>This is the general form for declaring an array:</p>
<p class="programlisting"><span class="EmpItalic">typeName arrayName</span>[<span class="EmpItalic">arraySize</span>];</p>
<p>The expression <em><code>arraySize</code></em>, which is the number of elements, must be an integer constant, such as 10 or a <code>const</code> value, or a constant expression, such as <code>8 * sizeof (int)</code>, for which all values are known at the time compilation takes place. In particular, <em><code>arraySize</code></em> cannot be a variable whose value is set while the program is running. However, later in this chapter you&#8217;ll learn how to use the <code>new</code> operator to get around that restriction.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch04sb01"/>The Array as Compound Type</p>
<p class="sidebarpara">An array is called a <em>compound type</em> because it is built from some other type. (C uses the term <em>derived type,</em> but because C++ uses the term <em>derived</em> for class relationships, it had to come up with a new term.) You can&#8217;t simply declare that something is an array; it always has to be an array of some particular type. There is no generalized array type. Instead, there are many specific array types, such as array of <code>char</code> or array of <code>long</code>. For example, consider this declaration:</p>
<p class="programlistingB">float loans[20];</p>
<p class="sidebarpara">The type for <code>loans</code> is not &#8220;array&#8221;; rather, it is &#8220;array of <code>float</code>.&#8221; This emphasizes that the <code>loans</code> array is built from the <code>float</code> type.</p>
<hr/></div>
<p><a id="page_117"/>Much of the usefulness of the array comes from the fact that you can access array elements individually. The way to do this is to use a <em>subscript</em>, or an <em>index</em>, to number the elements. C++ array numbering starts with zero. (This is nonnegotiable; you have to start at zero. Pascal and BASIC users will have to adjust.) C++ uses a bracket notation with the index to specify an array element. For example, <code>months[0]</code> is the first element of the <code>months</code> array, and <code>months[11]</code> is the last element. Note that the index of the last element is one less than the size of the array (see <a href="#ch04fig01">Figure 4.1</a>). Thus, an array declaration enables you to create a lot of variables with a single declaration, and you can then use an index to identify and access individual elements.</p>
<p class="caption"><a id="ch04fig01"/><strong>Figure 4.1. Creating an array.</strong></p>
<p class="image"><img src="graphics/04fig01.jpg" alt="Image"/></p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch04sb02"/>The Importance of Valid Subscript Values</p>
<p class="sidebarpara">The compiler does not check to see if you use a valid subscript. For instance, the compiler won&#8217;t complain if you assign a value to the nonexistent element <code>months[101]</code>. But that assignment could cause problems when the program runs, possibly corrupting data or code, possibly causing the program to abort. So it is your responsibility to make sure that your program uses only valid subscript values.</p>
<hr/></div>
<p>The yam analysis program in <a href="#ch04ex01">Listing 4.1</a> demonstrates a few properties of arrays, including declaring an array, assigning values to array elements, and initializing an array.</p>
<p class="caption1"><a id="ch04ex01"/><strong>Listing 4.1. <code>arrayone.cpp</code></strong></p><hr/>
<p class="programlisting1">// arrayone.cpp -- small arrays of integers<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int yams[3];&#160;&#160;&#160;&#160;// creates array with three elements<br/>&#160;&#160;&#160;&#160;yams[0] = 7;&#160;&#160;&#160;&#160;// assign value to first element<br/>&#160;&#160;&#160;&#160;yams[1] = 8;<br/>&#160;&#160;&#160;&#160;yams[2] = 6;<br/><br/>&#160;&#160;&#160;&#160;int yamcosts[3] = {20, 30, 5}; // create, initialize array<br/>// NOTE: If your C++ compiler or translator can't initialize<br/>// this array, use static int yamcosts[3] instead of<br/>// int yamcosts[3]<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Total yams = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; yams[0] + yams[1] + yams[2] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The package with " &lt;&lt; yams[1] &lt;&lt; " yams costs ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; yamcosts[1] &lt;&lt; " cents per yam.\n";<br/>&#160;&#160;&#160;&#160;int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];<br/>&#160;&#160;&#160;&#160;total = total + yams[2] * yamcosts[2];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The total yam expense is " &lt;&lt; total &lt;&lt; " cents.\n";<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nSize of yams array = " &lt;&lt; sizeof yams;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " bytes.\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Size of one element = " &lt;&lt; sizeof yams[0];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " bytes.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_118"/>Here is the output from the program in <a href="#ch04ex01">Listing 4.1</a>:</p>
<p class="programlisting">Total yams = 21<br/>The package with 8 yams costs 30 cents per yam.<br/>The total yam expense is 410 cents.<br/><br/>Size of yams array = 12 bytes.<br/>Size of one element = 4 bytes.</p>
<h4 id="ch04lev2sec1">Program Notes</h4>
<p>First, the program in <a href="#ch04ex01">Listing 4.1</a> creates a three-element array called <code>yams</code>. Because <code>yams</code> has three elements, the elements are numbered from <code>0</code> through <code>2</code>, and <code>arrayone.cpp</code> uses index values of <code>0</code> through <code>2</code> to assign values to the three individual elements. Each individual <code>yam</code> element is an <code>int</code> with all the rights and privileges of an <code>int</code> type, so <code>arrayone.cpp</code> can, and does, assign values to elements, add elements, multiply elements, and display elements.</p>
<p>The program uses the long way to assign values to the <code>yam</code> elements. C++ also lets you initialize array elements within the declaration statement. <a href="#ch04ex01">Listing 4.1</a> uses this shortcut to assign values to the <code>yamcosts</code> array:</p>
<p class="programlisting">int yamcosts[3] = {20, 30, 5};</p>
<p><a id="page_119"/>It simply provides a comma-separated list of values (the <em>initialization list</em>) enclosed in braces. The spaces in the list are optional. If you don&#8217;t initialize an array that&#8217;s defined inside a function, the element values remain undefined. That means the element takes on whatever value previously resided at that location in memory.</p>
<p>Next, the program uses the array values in a few calculations. This part of the program looks cluttered with all the subscripts and brackets. The <code>for</code> loop, coming up in <a href="ch05.html#ch05">Chapter 5</a>, &#8220;<a href="ch05.html#ch05">Loops and Relational Expressions</a>,&#8221; provides a powerful way to deal with arrays and eliminates the need to write each index explicitly. For the time being, we&#8217;ll stick to small arrays.</p>
<p>As you should recall, the <code>sizeof</code> operator returns the size, in bytes, of a type or data object. Note that if you use the <code>sizeof</code> operator with an array name, you get the number of bytes in the whole array. But if you use <code>sizeof</code> with an array element, you get the size, in bytes, of the element. This illustrates that <code>yams</code> is an array, but <code>yams[1]</code> is just an <code>int</code>.</p>
<h4 id="ch04lev2sec2">Initialization Rules for Arrays</h4>
<p>C++ has several rules about initializing arrays. They restrict when you can do it, and they determine what happens if the number of array elements doesn&#8217;t match the number of values in the initializer. Let&#8217;s examine these rules.</p>
<p>You can use the initialization form <em>only</em> when defining the array. You cannot use it later, and you cannot assign one array wholesale to another:</p>
<p class="programlisting">int cards[4] = {3, 6, 8, 10};&#160;&#160;&#160;&#160;&#160;&#160;&#160;// okay<br/>int hand[4];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// okay<br/>hand[4] = {5, 6, 7, 9};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed<br/>hand = cards;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed</p>
<p>However, you can use subscripts and assign values to the elements of an array individually.</p>
<p>When initializing an array, you can provide fewer values than array elements. For example, the following statement initializes only the first two elements of <code>hotelTips</code>:</p>
<p class="programlisting">float hotelTips[5] = {5.0, 2.5};</p>
<p>If you partially initialize an array, the compiler sets the remaining elements to zero. Thus, it&#8217;s easy to initialize all the elements of an array to zero&#8212;just explicitly initialize the first element to zero and then let the compiler initialize the remaining elements to zero:</p>
<p class="programlisting">long totals[500] = {0};</p>
<p>Note that if you initialize to <code>{1}</code> instead of to <code>{0}</code>, just the first element is set to <code>1</code>; the rest still get set to <code>0</code>.</p>
<p>If you leave the square brackets (<code>[]</code>) empty when you initialize an array, the C++ compiler counts the elements for you. Suppose, for example, that you make this declaration:</p>
<p class="programlisting">short things[] = {1, 5, 3, 8};</p>
<p>The compiler makes <code>things</code> an array of four elements.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch04sb03"/><a id="page_120"/>Letting the Compiler Do It</p>
<p class="sidebarpara">Often, letting the compiler count the number of elements is poor practice because its count can be different from what you think it should be. You could, for instance, accidently omit an initial value from the list. However, this approach can be a safe one for initializing a character array to a string, as you&#8217;ll soon see. And if your main concern is that the program, not you, knows how large an array is, you can do something like this:</p>
<p class="programlistingB">short things[] = {1, 5, 3, 8};<br/>int num_elements = sizeof things / sizeof (short);</p>
<p class="sidebarpara">Whether this is useful or lazy depends on the circumstances.</p>
<hr/></div>
<h4 id="ch04lev2sec3">C++11 Array Initialization</h4>
<p>As <a href="ch03.html#ch03">Chapter 3</a>, &#8220;<a href="ch03.html#ch03">Dealing with Data</a>,&#8221; mentioned, C++11 makes the brace form of initialization (list-initialization) a universal form for all types. Arrays already use list-initialization, but the C++11 version adds a few more features.</p>
<p>First, you can drop the <code>=</code> sign when initializing an array:</p>
<p class="programlisting">double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};&#160;&#160;// okay with C++11</p>
<p>Second, you can use empty braces to set all the elements to 0:</p>
<p class="programlisting">unsigned int counts[10] = {};&#160;&#160;// all elements set to 0<br/>float balances[100] {};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// all elements set to 0</p>
<p>Third, as discussed in <a href="ch03.html#ch03">Chapter 3</a>, list-initialization protects against narrowing:</p>
<p class="programlisting">long plifs[] = {25, 92, 3.0};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed<br/>char slifs[4] {'h', 'i', 1122011, '\0'}; // not allowed<br/>char tlifs[4] {'h', 'i', 112, '\0'};&#160;&#160;&#160;&#160;&#160;// allowed</p>
<p>The first initialization fails because converting from a floating-point type to an integer type is narrowing, even if the floating-point value has only zeros after the decimal point. The second initialization fails because <code>1122011</code> is outside the range of a <code>char</code>, assuming we have an 8-bit <code>char</code>. The third succeeds because, even though <code>112</code> is an <code>int</code> value, it still is in the range of a <code>char</code>.</p>
<p>The C++ Standard Template Library (STL) provides an alternative to arrays called the <code>vector</code> template class, and C++11 adds an <code>array</code> template class. These alternatives are more sophisticated and flexible than the built-in array composite type. This chapter will discuss them briefly later, and <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library,&#8221; discusses them more fully.</p>
<h3 id="ch04lev1sec2">Strings</h3>
<p>A <em>string</em> is a series of characters stored in consecutive bytes of memory. C++ has two ways of dealing with strings. The first, taken from C and often called a <em>C-style string</em>, is the first one this chapter examines. Later, this chapter discusses an alternative method based on a <code>string</code> class library.</p>
<p><a id="page_121"/>The idea of a series of characters stored in consecutive bytes implies that you can store a string in an array of <code>char</code>, with each character kept in its own array element. Strings provide a convenient way to store text information, such as messages to the user (<em>&#8220;Please tell me your secret Swiss bank account number&#8221;</em>) or responses from the user (<em>&#8220;You must be joking&#8221;</em>). C-style strings have a special feature: The last character of every string is the <em>null character</em>. This character, written <code>\0</code>, is the character with ASCII code 0, and it serves to mark the string&#8217;s end. For example, consider the following two declarations:</p>
<p class="programlisting">char dog[8] = { 'b', 'e', 'a', 'u', 'x', ' ', 'I', 'I'};&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not a string!<br/>char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a string!</p>
<p>Both of these arrays are arrays of <code>char</code>, but only the second is a string. The null character plays a fundamental role in C-style strings. For example, C++ has many functions that handle strings, including those used by <code>cout</code>. They all work by processing a string character-by-character until they reach the null character. If you ask <code>cout</code> to display a nice string like <code>cat</code> in the preceding example, it displays the first seven characters, detects the null character, and stops. But if you are ungracious enough to tell <code>cout</code> to display the <code>dog</code> array from the preceding example, which is not a string, <code>cout</code> prints the eight letters in the array and then keeps marching through memory byte-by-byte, interpreting each byte as a character to print, until it reaches a null character. Because null characters, which really are bytes set to zero, tend to be common in memory, the damage is usually contained quickly; nonetheless, you should not treat nonstring character arrays as strings.</p>
<p>The <code>cat</code> array example makes initializing an array to a string look tedious&#8212;all those single quotes and then having to remember the null character. Don&#8217;t worry. There is a better way to initialize a character array to a string. Just use a quoted string, called a <em>string constant</em> or <em>string literal</em>, as in the following:</p>
<p class="programlisting">char bird[11] = "Mr. Cheeps";&#160;&#160;&#160;&#160;&#160;// the \0 is understood<br/>char fish[] = "Bubbles";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// let the compiler count</p>
<p>Quoted strings always include the terminating null character implicitly, so you don&#8217;t have to spell it out (see <a href="#ch04fig02">Figure 4.2</a>). Also the various C++ input facilities for reading a string from keyboard input into a <code>char</code> array automatically add the terminating null character for you. (If, when you run the program in <a href="#ch04ex01">Listing 4.1</a>, you discover that you have to use the keyword <code>static</code> to initialize an array, you have to use it with these <code>char</code> arrays, too.)</p>
<p class="caption"><a id="ch04fig02"/><strong>Figure 4.2. Initializing an array to a string.</strong></p>
<p class="image"><img src="graphics/04fig02.jpg" alt="Image"/></p>
<p>Of course, you should make sure the array is large enough to hold all the characters of the string, including the null character. Initializing a character array with a string constant is one case where it may be safer to let the compiler count the number of elements for you. There is no harm, other than wasted space, in making an array larger than the string. That&#8217;s because functions that work with strings are guided by the location of the null character, not by the size of the array. C++ imposes no limits on the length of a string.</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note01"/>Caution</p>
<p class="notepara">When determining the minimum array size necessary to hold a string, remember to include the terminating null character in your count.</p>
<hr/></div>
<p><a id="page_122"/>Note that a string constant (with double quotes) is not interchangeable with a character constant (with single quotes). A character constant, such as <code>'S'</code>, is a shorthand notation for the code for a character. On an ASCII system, <code>'S'</code> is just another way of writing 83. Thus, the following statement assigns the value 83 to <code>shirt_size</code>:</p>
<p class="programlisting">char shirt_size = 'S';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// this is fine</p>
<p>But <code>"S"</code> is not a character constant; it represents the string consisting of two characters, the <code>S</code> and the <code>\0</code> characters. Even worse, <code>"S"</code> actually represents the memory address at which the string is stored. So a statement like the following attempts to assign a memory address to <code>shirt_size</code>:</p>
<p class="programlisting">char shirt_size = "S";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// illegal type mismatch</p>
<p>Because an address is a separate type in C++, a C++ compiler won&#8217;t allow this sort of nonsense. (We&#8217;ll return to this point later in this chapter after we&#8217;ve discussed pointers.)</p>
<h4 id="ch04lev2sec4">Concatenating String Literals</h4>
<p>Sometimes a string may be too long to conveniently fit on one line of code. C++ enables you to concatenate string literals&#8212;that is, to combine two quoted strings into one. Indeed, any two string constants separated only by whitespace (spaces, tabs, and newlines) are automatically joined into one. Thus, all the following output statements are equivalent to each other:</p>
<p class="programlisting">cout &lt;&lt; "I'd give my right arm to be" " a great violinist.\n";<br/>cout &lt;&lt; "I'd give my right arm to be a great violinist.\n";<br/>cout &lt;&lt; "I'd give my right ar"<br/>"m to be a great violinist.\n";</p>
<p>Note that the join doesn&#8217;t add any spaces to the joined strings. The first character of the second string immediately follows the last character, not counting <code>\0</code>, of the first string. The <code>\0</code> character from the first string is replaced by the first character of the second string.</p>
<h4 id="ch04lev2sec5">Using Strings in an Array</h4>
<p><a id="page_123"/>The two most common ways of getting a string into an array are to initialize an array to a string constant and to read keyboard or file input into an array. <a href="#ch04ex02">Listing 4.2</a> demonstrates these approaches by initializing one array to a quoted string and using <code>cin</code> to place an input string into a second array. The program also uses the standard C library function <code>strlen()</code> to get the length of a string. The standard <code>cstring</code> header file (or <code>string.h</code> for older implementations) provides declarations for this and many other string-related functions.</p>
<p class="caption1"><a id="ch04ex02"/><strong>Listing 4.2. <code>strings.cpp</code></strong></p><hr/>
<p class="programlisting1">// strings.cpp -- storing strings in an array<br/>#include &lt;iostream&gt;<br/>#include &lt;cstring&gt;&#160;&#160;// for the strlen() function<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const int Size = 15;<br/>&#160;&#160;&#160;&#160;char name1[Size];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// empty array<br/>&#160;&#160;&#160;&#160;char name2[Size] = "C++owboy";&#160;&#160;// initialized array<br/>&#160;&#160;&#160;&#160;// NOTE: some implementations may require the static keyword<br/>&#160;&#160;&#160;&#160;// to initialize the array name2<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Howdy! I'm " &lt;&lt; name2;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "! What's your name?\n";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; name1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Well, " &lt;&lt; name1 &lt;&lt; ", your name has ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; strlen(name1) &lt;&lt; " letters and is stored\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "in an array of " &lt;&lt; sizeof(name1) &lt;&lt; " bytes.\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your initial is " &lt;&lt; name1[0] &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;name2[3] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set to null character<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the first 3 characters of my name: ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; name2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch04ex02">Listing 4.2</a>:</p>
<p class="programlisting">Howdy! I'm C++owboy! What's your name?<br/><span class="EmpStrong">Basicman</span><br/>Well, Basicman, your name has 8 letters and is stored<br/>in an array of 15 bytes.<br/>Your initial is B.<br/>Here are the first 3 characters of my name: C++</p>
<h5 id="ch04lev3sec1">Program Notes</h5>
<p><a id="page_124"/>What can you learn from <a href="#ch04ex02">Listing 4.2</a>? First, note that the <code>sizeof</code> operator gives the size of the entire array, 15 bytes, but the <code>strlen()</code> function returns the size of the string stored in the array and not the size of the array itself. Also <code>strlen()</code> counts just the visible characters and not the null character. Thus, it returns a value of <code>8</code>, not <code>9</code>, for the length of <code>Basicman</code>. If <code>cosmic</code> is a string, the minimum array size for holding that string is <code>strlen(cosmic) + 1</code>.</p>
<p>Because <code>name1</code> and <code>name2</code> are arrays, you can use an index to access individual characters in the array. For example, the program uses <code>name1[0]</code> to find the first character in that array. Also the program sets <code>name2[3]</code> to the null character. That makes the string end after three characters, even though more characters remain in the array (see <a href="#ch04fig03">Figure 4.3</a>).</p>
<p class="caption"><a id="ch04fig03"/><strong>Figure 4.3. Shortening a string with <code>\0</code>.</strong></p>
<p class="image"><img src="graphics/04fig03.jpg" alt="Image"/></p>
<p>Note that the program in <a href="#ch04ex02">Listing 4.2</a> uses a symbolic constant for the array size. Often the size of an array appears in several statements in a program. Using a symbolic constant to represent the size of an array simplifies revising the program to use a different array size; you just have to change the value once, where the symbolic constant is defined.</p>
<h4 id="ch04lev2sec6">Adventures in String Input</h4>
<p>The <code>strings.cpp</code> program has a blemish that is concealed through the often useful technique of carefully selected sample input. <a href="#ch04ex03">Listing 4.3</a> removes the veils and shows that string input can be tricky.</p>
<p class="caption1"><a id="page_125"/><a id="ch04ex03"/><strong>Listing 4.3. <code>instr1.cpp</code></strong></p><hr/>
<p class="programlisting1">// instr1.cpp -- reading more than one string<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const int ArSize = 20;<br/>&#160;&#160;&#160;&#160;char name[ArSize];<br/>&#160;&#160;&#160;&#160;char dessert[ArSize];<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your name:\n";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; name;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your favorite dessert:\n";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; dessert;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "I have some delicious " &lt;&lt; dessert;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " for you, " &lt;&lt; name &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>The intent of the program in <a href="#ch04ex03">Listing 4.3</a> is simple: Read a user&#8217;s name and favorite dessert from the keyboard and then display the information. Here is a sample run:</p>
<p class="programlisting">Enter your name:<br/><span class="EmpStrong">Alistair Dreeb</span><br/>Enter your favorite dessert:<br/>I have some delicious Dreeb for you, Alistair.</p>
<p>We didn&#8217;t even get a chance to respond to the dessert prompt! The program showed it and then immediately moved on to display the final line.</p>
<p>The problem lies with how <code>cin</code> determines when you&#8217;ve finished entering a string. You can&#8217;t enter the null character from the keyboard, so <code>cin</code> needs some other means for locating the end of a string. The <code>cin</code> technique is to use whitespace&#8212;spaces, tabs, and newlines&#8212;to delineate a string. This means <code>cin</code> reads just one word when it gets input for a character array. After it reads this word, <code>cin</code> automatically adds the terminating null character when it places the string into the array.</p>
<p>The practical result in this example is that <code>cin</code> reads <code>Alistair</code> as the entire first string and puts it into the <code>name</code> array. This leaves poor <code>Dreeb</code> still sitting in the input queue. When <code>cin</code> searches the input queue for the response to the favorite dessert question, it finds <code>Dreeb</code> still there. Then <code>cin</code> gobbles up <code>Dreeb</code> and puts it into the <code>dessert</code> array (see <a href="#ch04fig04">Figure 4.4</a>).</p>
<p class="caption"><a id="ch04fig04"/><strong>Figure 4.4. The <code>cin</code> view of string input.</strong></p>
<p class="image"><img src="graphics/04fig04.jpg" alt="Image"/></p>
<p>Another problem, which didn&#8217;t surface in the sample run, is that the input string might turn out to be longer than the destination array. Using <code>cin</code> as this example did offers no protection against placing a 30-character string in a 20-character array.</p>
<p><a id="page_126"/>Many programs depend on string input, so it&#8217;s worthwhile to explore this topic further. We&#8217;ll have to draw on some of the more advanced features of <code>cin</code>, which are described in <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>.&#8221;</p>
<h4 id="ch04lev2sec7">Reading String Input a Line at a Time</h4>
<p>Reading string input a word at a time is often not the most desirable choice. For instance, suppose a program asks the user to enter a city, and the user responds with <strong><code>New York</code></strong> or <strong><code>Sao Paulo</code></strong>. You would want the program to read and store the full names, not just <code>New</code> and <code>Sao</code>. To be able to enter whole phrases instead of single words as a string, you need a different approach to string input. Specifically, you need a line-oriented method instead of a word-oriented method. You are in luck, for the <code>istream</code> class, of which <code>cin</code> is an example, has some line-oriented class member functions: <code>getline()</code> and <code>get()</code>. Both read an entire input line&#8212;that is, up until a newline character. However, <code>getline()</code> then discards the newline character, whereas <code>get()</code> leaves it in the input queue. Let&#8217;s look at the details, beginning with <code>getline()</code>.</p>
<h5 id="ch04lev3sec2">Line-Oriented Input with <code>getline()</code></h5>
<p>The <code>getline()</code> function reads a whole line, using the newline character transmitted by the Enter key to mark the end of input. You invoke this method by using <code>cin.getline()</code> as a function call. The function takes two arguments. The first argument is the name of the target (that is, the array destined to hold the line of input), and the second argument is a limit on the number of characters to be read. If this limit is, say, 20, the function reads no more than 19 characters, leaving room to automatically add the null character at the end. The <code>getline()</code> member function stops reading input when it reaches this numeric limit or when it reads a newline character, whichever comes first.</p>
<p>For example, suppose you want to use <code>getline()</code> to read a name into the 20-element name array. You would use this call:</p>
<p class="programlisting">cin.getline(name,20);</p>
<p><a id="page_127"/>This reads the entire line into the <code>name</code> array, provided that the line consists of 19 or fewer characters. (The <code>getline()</code> member function also has an optional third argument, which <a href="ch17.html#ch17">Chapter 17</a> discusses.)</p>
<p><a href="#ch04ex04">Listing 4.4</a> modifies <a href="#ch04ex03">Listing 4.3</a> to use <code>cin.getline()</code> instead of a simple <code>cin</code>. Otherwise, the program is unchanged.</p>
<p class="caption1"><a id="ch04ex04"/><strong>Listing 4.4. <code>instr2.cpp</code></strong></p><hr/>
<p class="programlisting1">// instr2.cpp -- reading more than one word with getline<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const int ArSize = 20;<br/>&#160;&#160;&#160;&#160;char name[ArSize];<br/>&#160;&#160;&#160;&#160;char dessert[ArSize];<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your name:\n";<br/>&#160;&#160;&#160;&#160;cin.getline(name, ArSize);&#160;&#160;// reads through newline<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your favorite dessert:\n";<br/>&#160;&#160;&#160;&#160;cin.getline(dessert, ArSize);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "I have some delicious " &lt;&lt; dessert;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " for you, " &lt;&lt; name &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is some sample output for <a href="#ch04ex04">Listing 4.4</a>:</p>
<p class="programlisting">Enter your name:<br/><span class="EmpStrong">Dirk Hammernose</span><br/>Enter your favorite dessert:<br/><span class="EmpStrong">Radish Torte</span><br/>I have some delicious Radish Torte for you, Dirk Hammernose.</p>
<p>The program now reads complete names and delivers the user his just desserts! The <code>getline()</code> function conveniently gets a line at a time. It reads input through the newline character marking the end of the line, but it doesn&#8217;t save the newline character. Instead, it replaces it with a null character when storing the string (see <a href="#ch04fig05">Figure 4.5</a>).</p>
<p class="caption"><a id="ch04fig05"/><strong>Figure 4.5. <code>getline()</code> reads and replaces the newline character.</strong></p>
<p class="image"><img src="graphics/04fig05.jpg" alt="Image"/></p>
<h5 id="ch04lev3sec3">Line-Oriented Input with <code>get()</code></h5>
<p>Let&#8217;s try another approach. The <code>istream</code> class has another member function, <code>get()</code>, which comes in several variations. One variant works much like <code>getline()</code>. It takes the same arguments, interprets them the same way, and reads to the end of a line. But rather than read and discard the newline character, <code>get()</code> leaves that character in the input queue. Suppose you use two calls to <code>get()</code> in a row:</p>
<p class="programlisting">cin.get(name, ArSize);<br/>cin.get(dessert, Arsize);&#160;&#160;&#160;// a problem</p>
<p><a id="page_128"/>Because the first call leaves the newline character in the input queue, that newline character is the first character the second call sees. Thus, <code>get()</code> concludes that it&#8217;s reached the end of line without having found anything to read. Without help, <code>get()</code> just can&#8217;t get past that newline character.</p>
<p>Fortunately, there is help in the form of a variation of <code>get()</code>. The call <code>cin.get()</code> (with no arguments) reads the single next character, even if it is a newline, so you can use it to dispose of the newline character and prepare for the next line of input. That is, this sequence works:</p>
<p class="programlisting">cin.get(name, ArSize);&#160;&#160;&#160;&#160;&#160;&#160;// read first line<br/>cin.get();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read newline<br/>cin.get(dessert, Arsize);&#160;&#160;&#160;// read second line</p>
<p>Another way to use <code>get()</code> is to <em>concatenate</em>, or join, the two class member functions, as follows:</p>
<p class="programlisting">cin.get(name, ArSize).get(); // concatenate member functions</p>
<p>What makes this possible is that <code>cin.get(name, ArSize)</code> returns the <code>cin</code> object, which is then used as the object that invokes the <code>get()</code> function. Similarly, the following <a id="page_129"/>statement reads two consecutive input lines into the arrays <code>name1</code> and <code>name2</code>; it&#8217;s equivalent to making two separate calls to <code>cin.getline()</code>:</p>
<p class="programlisting">cin.getline(name1, ArSize).getline(name2, ArSize);</p>
<p><a href="#ch04ex05">Listing 4.5</a> uses concatenation. In <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>,&#8221; you&#8217;ll learn how to incorporate this feature into your class definitions.</p>
<p class="caption1"><a id="ch04ex05"/><strong>Listing 4.5. <code>instr3.cpp</code></strong></p><hr/>
<p class="programlisting1">// instr3.cpp -- reading more than one word with get() &#38; get()<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const int ArSize = 20;<br/>&#160;&#160;&#160;&#160;char name[ArSize];<br/>&#160;&#160;&#160;&#160;char dessert[ArSize];<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your name:\n";<br/>&#160;&#160;&#160;&#160;cin.get(name, ArSize).get();&#160;&#160;&#160;&#160;// read string, newline<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your favorite dessert:\n";<br/>&#160;&#160;&#160;&#160;cin.get(dessert, ArSize).get();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "I have some delicious " &lt;&lt; dessert;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " for you, " &lt;&lt; name &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch04ex05">Listing 4.5</a>:</p>
<p class="programlisting">Enter your name:<br/><span class="EmpStrong">Mai Parfait</span><br/>Enter your favorite dessert:<br/><span class="EmpStrong">Chocolate Mousse</span><br/>I have some delicious Chocolate Mousse for you, Mai Parfait.</p>
<p>One thing to note is how C++ allows multiple versions of functions, provided that they have different argument lists. If you use, say, <code>cin.get(name, ArSize)</code>, the compiler notices you&#8217;re using the form that puts a string into an array and sets up the appropriate member function. If, instead, you use <code>cin.get()</code>, the compiler realizes you want the form that reads one character. <a href="ch08.html#ch08">Chapter 8</a>, &#8220;<a href="ch08.html#ch08">Adventures in Functions</a>,&#8221; explores this feature, which is called <em>function overloading</em>.</p>
<p>Why use <code>get()</code> instead of <code>getline()</code> at all? First, older implementations may not have <code>getline()</code>. Second, <code>get()</code> lets you be a bit more careful. Suppose, for example, you used <code>get()</code> to read a line into an array. How can you tell if it read the whole line rather than stopped because the array was filled? Look at the next input character. If it is a newline character, then the whole line was read. If it is not a newline character, then there is still <a id="page_130"/>more input on that line. <a href="ch17.html#ch17">Chapter 17</a> investigates this technique. In short, <code>getline()</code> is a little simpler to use, but <code>get()</code> makes error checking simpler. You can use either one to read a line of input; just keep the slightly different behaviors in mind.</p>
<h5 id="ch04lev3sec4">Empty Lines and Other Problems</h5>
<p>What happens after <code>getline()</code> or <code>get()</code> reads an empty line? The original practice was that the next input statement picked up where the last <code>getline()</code> or <code>get()</code> left off. However, the current practice is that after <code>get()</code> (but not <code>getline()</code>) reads an empty line, it sets something called the <em>failbit</em>. The implications of this act are that further input is blocked, but you can restore input with the following command:</p>
<p class="programlisting">cin.clear();</p>
<p>Another potential problem is that the input string could be longer than the allocated space. If the input line is longer than the number of characters specified, both <code>getline()</code> and <code>get()</code> leave the remaining characters in the input queue. However, <code>getline()</code> additionally sets the failbit and turns off further input.</p>
<p><a href="ch05.html#ch05">Chapters 5</a>, <a href="ch06.html#ch06">6</a>, and <a href="ch17.html#ch17">17</a> investigate these properties and how to program around them.</p>
<h4 id="ch04lev2sec8">Mixing String and Numeric Input</h4>
<p>Mixing numeric input with line-oriented string input can cause problems. Consider the simple program in <a href="#ch04ex06">Listing 4.6</a>.</p>
<p class="caption1"><a id="ch04ex06"/><strong>Listing 4.6. <code>numstr.cpp</code></strong></p><hr/>
<p class="programlisting1">// numstr.cpp -- following number input with line input<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "What year was your house built?\n";<br/>&#160;&#160;&#160;&#160;int year;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; year;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "What is its street address?\n";<br/>&#160;&#160;&#160;&#160;char address[80];<br/>&#160;&#160;&#160;&#160;cin.getline(address, 80);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Year built: " &lt;&lt; year &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Address: " &lt;&lt; address &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_131"/>Running the program in <a href="#ch04ex06">Listing 4.6</a> would look something like this:</p>
<p class="programlisting">What year was your house built?<br/><span class="EmpStrong">1966</span><br/>What is its street address?<br/>Year built: 1966<br/>Address<br/>Done!</p>
<p>You never get the opportunity to enter the address. The problem is that when <code>cin</code> reads the year, it leaves the newline generated by the Enter key in the input queue. Then <code>cin.getline()</code> reads the newline as an empty line and assigns a null string to the <code>address</code> array. The fix is to read and discard the newline before reading the address. This can be done several ways, including by using <code>get()</code> with a <code>char</code> argument or with no argument, as described in the preceding example. You can make these calls separately:</p>
<p class="programlisting">cin &gt;&gt; year;<br/>cin.get();&#160;&#160;&#160;// or cin.get(ch);</p>
<p>Or you can concatenate the calls, making use of the fact that the expression <code>cin &gt;&gt; year</code> returns the <code>cin</code> object:</p>
<p class="programlisting">(cin &gt;&gt; year).get();&#160;&#160;// or (cin &gt;&gt; year).get(ch);</p>
<p>If you make one of these changes to <a href="#ch04ex06">Listing 4.6</a>, it works properly:</p>
<p class="programlisting">What year was your house built?<br/><span class="EmpStrong">1966</span><br/>What is its street address?<br/><span class="EmpStrong">43821 Unsigned Short Street</span><br/>Year built: 1966<br/>Address: 43821 Unsigned Short Street<br/>Done!</p>
<p>C++ programs frequently use pointers instead of arrays to handle strings. We&#8217;ll take up that aspect of strings after talking a bit about pointers. Meanwhile, let&#8217;s take a look at a more recent way to handle strings: the C++ <code>string</code> class.</p>
<h3 id="ch04lev1sec3">Introducing the <code>string</code> Class</h3>
<p>The ISO/ANSI C++98 Standard expanded the C++ library by adding a <code>string</code> class. So now, instead of using a character array to hold a string, you can use a type <code>string</code> variable (or object, to use C++ terminology). As you&#8217;ll see, the <code>string</code> class is simpler to use than the array and also provides a truer representation of a string as a type.</p>
<p>To use the <code>string</code> class, a program has to include the <code>string</code> header file. The <code>string</code> class is part of the <code>std</code> namespace, so you have to provide a <code>using</code> directive or declaration or else refer to the class as <code>std::string</code>. The class definition hides the array nature of a string and lets you treat a string much like an ordinary variable. <a href="#ch04ex07">Listing 4.7</a> illustrates some of the similarities and differences between <code>string</code> objects and character arrays.</p>
<p class="caption1"><a id="page_132"/><a id="ch04ex07"/><strong>Listing 4.7. <code>strtype1.cpp</code></strong></p><hr/>
<p class="programlisting1">// strtype1.cpp -- using the C++ string class<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// make string class available<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char charr1[20];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create an empty array<br/>&#160;&#160;&#160;&#160;char charr2[20] = "jaguar"; // create an initialized array<br/>&#160;&#160;&#160;&#160;string str1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create an empty string object<br/>&#160;&#160;&#160;&#160;string str2 = "panther";&#160;&#160;&#160;&#160;// create an initialized string<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a kind of feline: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; charr1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter another kind of feline: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; str1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use cin for input<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are some felines:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; charr1 &lt;&lt; " " &lt;&lt; charr2 &lt;&lt; " "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; str1 &lt;&lt; " " &lt;&lt; str2 // use cout for output<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The third letter in " &lt;&lt; charr2 &lt;&lt; " is "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; charr2[2] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The third letter in " &lt;&lt; str2 &lt;&lt; " is "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; str2[2] &lt;&lt; endl;&#160;&#160;&#160;&#160;// use array notation<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch04ex07">Listing 4.7</a>:</p>
<p class="programlisting">Enter a kind of feline: <span class="EmpStrong">ocelot</span><br/>Enter another kind of feline: <span class="EmpStrong">tiger</span><br/>Here are some felines:<br/>ocelot jaguar tiger panther<br/>The third letter in jaguar is g<br/>The third letter in panther is n</p>
<p>You should learn from this example that, in many ways, you can use a string object in the same manner as a character array:</p>
<p class="indenthandingB">&#8226; You can initialize a <code>string</code> object to a C-style string.</p>
<p class="indenthandingB">&#8226; You can use <code>cin</code> to store keyboard input in a <code>string</code> object.</p>
<p class="indenthandingB">&#8226; You can use <code>cout</code> to display a <code>string</code> object.</p>
<p class="indenthandingB">&#8226; You can use array notation to access individual characters stored in a <code>string</code> object.</p>
<p><a id="page_133"/>The main difference between <code>string</code> objects and character arrays shown in <a href="#ch04ex07">Listing 4.7</a> is that you declare a <code>string</code> object as a simple variable, not as an array:</p>
<p class="programlisting">string str1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create an empty string object<br/>string str2 = "panther";&#160;&#160;&#160;&#160;// create an initialized string</p>
<p>The class design allows the program to handle the sizing automatically. For instance, the declaration for <code>str1</code> creates a <code>string</code> object of length zero, but the program automatically resizes <code>str1</code> when it reads input into <code>str1</code>:</p>
<p class="programlisting">cin &gt;&gt; str1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// str1 resized to fit input</p>
<p>This makes using a <code>string</code> object both more convenient and safer than using an array. Conceptually, one thinks of an array of <code>char</code> as a collection of <code>char</code> storage units used to store a string but of a <code>string</code> class variable as a single entity representing the string.</p>
<h4 id="ch04lev2sec9">C++11 String Initialization</h4>
<p>As you might expect by now, C++11 enables list-initialization for C-style strings and <code>string</code> objects:</p>
<p class="programlisting">char first_date[] = {"Le Chapon Dodu"};<br/>char second_date[] {"The Elegant Plate"};<br/>string third_date = {"The Bread Bowl"};<br/>string fourth_date {"Hank's Fine Eats"};</p>
<h4 id="ch04lev2sec10">Assignment, Concatenation, and Appending</h4>
<p>The <code>string</code> class makes some operations simpler than is the case for arrays. For example, you can&#8217;t simply assign one array to another. But you can assign one string object to another:</p>
<p class="programlisting">char charr1[20];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create an empty array<br/>char charr2[20] = "jaguar"; // create an initialized array<br/>string str1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create an empty string object<br/>string str2 = "panther";&#160;&#160;&#160;&#160;// create an initialized string<br/>charr1 = charr2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// INVALID, no array assignment<br/>str1 = str2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// VALID, object assignment ok</p>
<p>The <code>string</code> class simplifies combining strings. You can use the <code>+</code> operator to add two <code>string</code> objects together and the <code>+=</code> operator to tack on a string to the end of an existing <code>string</code> object. Continuing with the preceding code, we have the following possibilities:</p>
<p class="programlisting">string str3;<br/>str3 = str1 + str2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assign str3 the joined strings<br/>str1 += str2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// add str2 to the end of str1</p>
<p><a href="#ch04ex08">Listing 4.8</a> illustrates these usages. Note that you can add and append C-style strings as well as <code>string</code> objects to a <code>string</code> object.</p>
<p class="caption1"><a id="page_134"/><a id="ch04ex08"/><strong>Listing 4.8. <code>strtype2.cpp</code></strong></p><hr/>
<p class="programlisting1">// strtype2.cpp &#8211;- assigning, adding, and appending<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// make string class available<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;string s1 = "penguin";<br/>&#160;&#160;&#160;&#160;string s2, s3;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You can assign one string object to another: s2 = s1\n";<br/>&#160;&#160;&#160;&#160;s2 = s1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "s1: " &lt;&lt; s1 &lt;&lt; ", s2: " &lt;&lt; s2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You can assign a C-style string to a string object.\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "s2 = \"buzzard\"\n";<br/>&#160;&#160;&#160;&#160;s2 = "buzzard";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You can concatenate strings: s3 = s1 + s2\n";<br/>&#160;&#160;&#160;&#160;s3 = s1 + s2;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "s3: " &lt;&lt; s3 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You can append strings.\n";<br/>&#160;&#160;&#160;&#160;s1 += s2;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;"s1 += s2 yields s1 = " &lt;&lt; s1 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;s2 += " for a day";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;"s2 += \" for a day\" yields s2 = " &lt;&lt; s2 &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Recall that the escape sequence <code>\"</code> represents a double quotation mark that is used as a literal character rather than as marking the limits of a string. Here is the output from the program in <a href="#ch04ex08">Listing 4.8</a>:</p>
<p class="programlisting">You can assign one string object to another: s2 = s1<br/>s1: penguin, s2: penguin<br/>You can assign a C-style string to a string object.<br/>s2 = "buzzard"<br/>s2: buzzard<br/>You can concatenate strings: s3 = s1 + s2<br/>s3: penguinbuzzard<br/>You can append strings.<br/>s1 += s2 yields s1 = penguinbuzzard<br/>s2 += " for a day" yields s2 = buzzard for a day</p>
<h4 id="ch04lev2sec11">More <code>string</code> Class Operations</h4>
<p><a id="page_135"/>Even before the string class was added to C++, programmers needed to do things like assign strings. For C-style strings, they used functions from the C library for these tasks. The <code>cstring</code> header file (formerly <code>string.h</code>) supports these functions. For example, you can use the <code>strcpy()</code> function to copy a string to a character array, and you can use the <code>strcat()</code> function to append a string to a character array:</p>
<p class="programlisting">strcpy(charr1, charr2);&#160;&#160;// copy charr2 to charr1<br/>strcat(charr1, charr2);&#160;&#160;// append contents of charr2 to char1</p>
<p><a href="#ch04ex09">Listing 4.9</a> compares techniques used with <code>string</code> objects with techniques used with character arrays.</p>
<p class="caption1"><a id="ch04ex09"/><strong>Listing 4.9. <code>strtype3.cpp</code></strong></p><hr/>
<p class="programlisting1">// strtype3.cpp -- more string class features<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// make string class available<br/>#include &lt;cstring&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C-style string library<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char charr1[20];<br/>&#160;&#160;&#160;&#160;char charr2[20] = "jaguar";<br/>&#160;&#160;&#160;&#160;string str1;<br/>&#160;&#160;&#160;&#160;string str2 = "panther";<br/><br/>&#160;&#160;&#160;&#160;// assignment for string objects and character arrays<br/>&#160;&#160;&#160;&#160;str1 = str2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// copy str2 to str1<br/>&#160;&#160;&#160;&#160;strcpy(charr1, charr2);&#160;&#160;&#160;&#160;&#160;// copy charr2 to charr1<br/><br/>&#160;&#160;&#160;&#160;// appending for string objects and character arrays<br/>&#160;&#160;&#160;&#160;str1 += " paste";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// add paste to end of str1<br/>&#160;&#160;&#160;&#160;strcat(charr1, " juice");&#160;&#160;&#160;// add juice to end of charr1<br/><br/>&#160;&#160;&#160;&#160;// finding the length of a string object and a C-style string<br/>&#160;&#160;&#160;&#160;int len1 = str1.size();&#160;&#160;&#160;&#160;&#160;// obtain length of str1<br/>&#160;&#160;&#160;&#160;int len2 = strlen(charr1);&#160;&#160;// obtain length of charr1<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The string " &lt;&lt; str1 &lt;&lt; " contains "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; len1 &lt;&lt; " characters.\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The string " &lt;&lt; charr1 &lt;&lt; " contains "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; len2 &lt;&lt; " characters.\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_136"/>Here is the output:</p>
<p class="programlisting">The string panther paste contains 13 characters.<br/>The string jaguar juice contains 12 characters.</p>
<p>The syntax for working with string objects tends to be simpler than using the C string functions. This is especially true for more complex operations. For example, the C library equivalent of</p>
<p class="programlisting">str3 = str1 + str2;</p>
<p>is this:</p>
<p class="programlisting">strcpy(charr3, charr1);<br/>strcat(charr3, charr2);</p>
<p>Furthermore, with arrays, there is always the danger of the destination array being too small to hold the information, as in this example:</p>
<p class="programlisting">char site[10] = "house";<br/>strcat(site, " of pancakes");&#160;&#160;// memory problem</p>
<p>The <code>strcat()</code> function would attempt to copy all 12 characters into the <code>site</code> array, thus overrunning adjacent memory. This might cause the program to abort, or the program might continue running but with corrupted data. The <code>string</code> class, with its automatic resizing as necessary, avoids this sort of problem. The C library does provide cousins to <code>strcat()</code> and <code>strcpy()</code>, called <code>strncat()</code> and <code>strncpy()</code>, that work more safely by taking a third argument to indicate the maximum allowed size of the target array, but using them adds another layer of complexity in writing programs.</p>
<p>Notice the different syntax used to obtain the number of characters in a string:</p>
<p class="programlisting">int len1 = str1.size();&#160;&#160;&#160;&#160;&#160;// obtain length of str1<br/>int len2 = strlen(charr1);&#160;&#160;// obtain length of charr1</p>
<p>The <code>strlen()</code> function is a regular function that takes a C-style string as its argument and that returns the number of characters in the string. The <code>size()</code> function basically does the same thing, but the syntax for it is different. Instead of appearing as a function argument, <code>str1</code> precedes the function name and is connected to it with a dot. As you saw with the <code>put()</code> method in <a href="ch03.html#ch03">Chapter 3</a>, this syntax indicates that <code>str1</code> is an object and that <code>size()</code> is a class method. A method is a function that can be invoked only by an object belonging to the same class as the method. In this particular case, <code>str1</code> is a <code>string</code> object, and <code>size()</code> is a <code>string</code> method. In short, the C functions use a function argument to identify which string to use, and the C++ <code>string</code> class objects use the object name and the dot operator to indicate which string to use.</p>
<h4 id="ch04lev2sec12">More on <code>string</code> Class I/O</h4>
<p>As you&#8217;ve seen, you can use <code>cin</code> with the <code>&gt;&gt;</code> operator to read a <code>string</code> object and <code>cout</code> with the <code>&lt;&lt;</code> operator to display a <code>string</code> object using the same syntax you use with a <a id="page_137"/>C-style string. But reading a line at a time instead of a word at time uses a different syntax. <a href="#ch04ex10">Listing 4.10</a> shows this difference.</p>
<p class="caption1"><a id="ch04ex10"/><strong>Listing 4.10. <code>strtype4.cpp</code></strong></p><hr/>
<p class="programlisting1">// strtype4.cpp -- line input<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// make string class available<br/>#include &lt;cstring&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C-style string library<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char charr[20];<br/>&#160;&#160;&#160;&#160;string str;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Length of string in charr before input: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; strlen(charr) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Length of string in str before input: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; str.size() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a line of text:\n";<br/>&#160;&#160;&#160;&#160;cin.getline(charr, 20);&#160;&#160;&#160;&#160;&#160;// indicate maximum length<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You entered: " &lt;&lt; charr &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter another line of text:\n";<br/>&#160;&#160;&#160;&#160;getline(cin, str);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// cin now an argument; no length specifier<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You entered: " &lt;&lt; str &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Length of string in charr after input: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; strlen(charr) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Length of string in str after input: "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; str.size() &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s a sample run of the program in <a href="#ch04ex10">Listing 4.10</a>:</p>
<p class="programlisting">Length of string in charr before input: 27<br/>Length of string in str before input: 0<br/>Enter a line of text:<br/><span class="EmpStrong">peanut butter</span><br/>You entered: peanut butter<br/>Enter another line of text:<br/><span class="EmpStrong">blueberry jam</span><br/>You entered: blueberry jam<br/>Length of string in charr after input: 13<br/>Length of string in str after input: 13</p>
<p><a id="page_138"/>Note that the program says the length of the string in the array <code>charr</code> before input is 27, which is larger than the size of the array! Two things are going on here. The first is that the contents of an uninitialized array are undefined. The second is that the <code>strlen()</code> function works by starting at the first element of the array and counting bytes until it reaches a null character. In this case, the first null character doesn&#8217;t appear until several bytes <em>after</em> the end of the array. Where the first null character appears in uninitialized data is essentially random, so you very well could get a different numeric result using this program.</p>
<p>Also note that the length of the string in <code>str</code> before input is 0. That&#8217;s because an uninitialized <code>string</code> object is automatically set to zero size.</p>
<p>This is the code for reading a line into an array:</p>
<p class="programlisting">cin.getline(charr, 20);</p>
<p>The dot notation indicates that the <code>getline()</code> function is a class method for the <code>istream</code> class. (Recall that <code>cin</code> is an <code>istream</code> object.) As mentioned earlier, the first argument indicates the destination array, and the second argument is the array size, which <code>getline()</code> used to avoid overrunning the array.</p>
<p>This is the code for reading a line into a <code>string</code> object:</p>
<p class="programlisting">getline(cin,str);</p>
<p>There is no dot notation, which indicates that <em>this</em> <code>getline()</code> is <em>not</em> a class method. So it takes <code>cin</code> as an argument that tells it where to find the input. Also there isn&#8217;t an argument for the size of the string because the <code>string</code> object automatically resizes to fit the string.</p>
<p>So why is one <code>getline()</code> an <code>istream</code> class method and the other <code>getline()</code> not? The <code>istream</code> class was part of C++ long before the <code>string</code> class was added. So the <code>istream</code> design recognizes basic C++ types such as <code>double</code> and <code>int</code>, but it is ignorant of the <code>string</code> type. Therefore, there are <code>istream</code> class methods for processing <code>double</code>, <code>int</code>, and the other basic types, but there are no <code>istream</code> class methods for processing <code>string</code> objects.</p>
<p>Because there are no <code>istream</code> class methods for processing string objects, you might wonder why code like this works:</p>
<p class="programlisting">cin &gt;&gt; str;&#160;&#160;// read a word into the str string object</p>
<p>It turns out that code like the following does (in disguised notation) use a member function of the <code>istream</code> class:</p>
<p class="programlisting">cin &gt;&gt; x;&#160;&#160;// read a value into a basic C++ type</p>
<p>But the <code>string</code> class equivalent uses a friend function (also in disguised notation) of the <code>string</code> class. You&#8217;ll have to wait until <a href="ch11.html#ch11">Chapter 11</a> to see what a friend function is and how this technique works. In the meantime, you can use <code>cin</code> and <code>cout</code> with <code>string</code> objects and not worry about the inner workings.</p>
<h4 id="ch04lev2sec13">Other Forms of String Literals</h4>
<p><a id="page_139"/>C++, recall, has the <code>wchar_t</code> type in addition to <code>char</code>. And C++11 adds the <code>char16_t</code> and <code>char32_t</code> types. It&#8217;s possible to create arrays of these types and string literals of these types. C++ uses the <code>L</code>, <code>u</code>, and <code>U</code> prefixes, respectively, for string literals of these types. Here&#8217;s an example of how they can be used:</p>
<p class="programlisting">wchar_t title[] = L"Chief Astrogator";&#160;&#160;// w_char string<br/>char16_t name[] = u"Felonia Ripova";&#160;&#160;&#160;&#160;// char_16 string<br/>char32_t car[] = U"Humber Super Snipe"; // char_32 string</p>
<p>C++11 also supports an encoding scheme for Unicode characters called UTF-8. In this scheme a given character may be stored in anywhere from one 8-bit unit, or octet, to four 8-bit units, depending on the numeric value. C++ uses the <code>u8</code> prefix to indicate string literals of that type.</p>
<p>Another C++11 addition is the raw string. In a raw string, characters simply stand for themselves. For example, the sequence <code>\n</code> is not interpreted as representing the newline character; instead, it is two ordinary characters, a backslash and an <code>n</code>, and it would display as those two characters onscreen. As another example, you can use a simple <code>"</code> inside a string instead of the more awkward <code>\"</code> we used in <a href="#ch04ex08">Listing 4.8</a>. Of course, if you allow a <code>"</code> inside a string literal, you no longer can use it to delimit the ends of a string. Therefore, raw strings use <code>"(</code> and <code>)"</code> as delimiters, and they use an <code>R</code> prefix to identify them as raw strings:</p>
<p class="programlisting">cout &lt;&lt; R"(Jim "King" Tutt uses "\n" instead of endl.)" &lt;&lt; '\n';</p>
<p>This would display the following:</p>
<p class="programlisting">Jim "King" Tutt uses \n instead of endl.</p>
<p>The standard string literal equivalent would be this:</p>
<p class="programlisting">cout &lt;&lt; "Jim \"King\" Tutt uses \" \\n\" instead of endl." &lt;&lt; '\n';</p>
<p>Here we had to use <code>\\</code> to display <code>\</code> because a single <code>\</code> is interpreted as the first character of an escape sequence.</p>
<p>If you press the Enter or Return key while typing a raw string, that not only moves the cursor to the next line onscreen, it also places a carriage return character in the raw string.</p>
<p>What if you want to display the combination <code>)"</code> in a raw string? (Who wouldn&#8217;t?) Won&#8217;t the compiler interpret the first occurrence of <code>)"</code> as the end of the string? Yes, it will. But the raw string syntax allows you to place additional characters between the opening <code>"</code> and <code>(</code>. This implies that the same additional characters must appear between the final <code>)</code> and <code>"</code>. So a raw string beginning with <code>R"+*</code> must terminate with <code>)+*"</code>. Thus, the statement</p>
<p class="programlisting">cout &lt;&lt; R"+*("(Who wouldn't?)", she whispered.)+*" &lt;&lt; endl;</p>
<p>would display the following:</p>
<p class="programlisting">"(Who wouldn't?)", she whispered.</p>
<p><a id="page_140"/>In short, the default delimiters of <code>"(</code> and <code>)"</code> have been replaced with <code>"+*(</code> and <code>)+*"</code>. You can use any of the members of the basic character set as part of the delimiter other than the space, the left parenthesis, the right parenthesis, the backslash, and control characters such as a tab or a newline.</p>
<p>The <code>R</code> prefix can be combined with the other string prefixes to produce raw strings of <code>wchar_t</code> and so on. It can be either the first or the last part of a compound prefix: <code>Ru</code>, <code>UR</code>, and so on.</p>
<p>Now let&#8217;s go on to another compound type&#8212;the structure.</p>
<h3 id="ch04lev1sec4">Introducing Structures</h3>
<p>Suppose you want to store information about a basketball player. You might want to store his or her name, salary, height, weight, scoring average, free-throw percentage, assists, and so on. You&#8217;d like some sort of data form that could hold all this information in one unit. An array won&#8217;t do. Although an array can hold several items, each item has to be the same type. That is, one array can hold 20 <code>int</code>s and another can hold 10 <code>float</code>s, but a single array can&#8217;t store <code>int</code>s in some elements and <code>float</code>s in other elements.</p>
<p>The answer to your desire (the one about storing information about a basketball player) is the C++ structure. A <em>structure</em> is a more versatile data form than an array because a single structure can hold items of more than one data type. This enables you to unify your data representation by storing all the related basketball information in a single structure variable. If you want to keep track of a whole team, you can use an array of structures. The structure type is also a stepping stone to that bulwark of C++ OOP, the class. Learning a little about structures now takes you that much closer to the OOP heart of C++.</p>
<p>A structure is a user-definable type, with a structure declaration serving to define the type&#8217;s data properties. After you define the type, you can create variables of that type. Thus, creating a structure is a two-part process. First, you define a structure description that describes and labels the different types of data that can be stored in a structure. Then you can create structure variables, or, more generally, structure data objects, that follow the description&#8217;s plan.</p>
<p>For example, suppose that Bloataire, Inc., wants to create a type to describe members of its product line of designer inflatables. In particular, the type should hold the name of the item, its volume in cubic feet, and its selling price. Here is a structure description that meets those needs:</p>
<p class="programlisting">struct inflatable&#160;&#160;&#160;// structure declaration<br/>{<br/>&#160;&#160;&#160;&#160;char name[20];<br/>&#160;&#160;&#160;&#160;float volume;<br/>&#160;&#160;&#160;&#160;double price;<br/>};</p>
<p>The keyword <code>struct</code> indicates that the code defines the layout for a structure. The identifier <code>inflatable</code> is the name, or <em>tag</em>, for this form; this makes <code>inflatable</code> the name <a id="page_141"/>for the new type. Thus, you can now create variables of type <code>inflatable</code> just as you create variables of type <code>char</code> or <code>int</code>. Next, between braces are the list of data types to be held in the structure. Each list item is a declaration statement. You can use any of the C++ types here, including arrays and other structures. This example uses an array of <code>char</code>, which is suitable for storing a string, a <code>float</code>, and a <code>double</code>. Each individual item in the list is called a structure <em>member</em>, so the inflatable structure has three members (see <a href="#ch04fig06">Figure 4.6</a>). In short, the structure definition defines the characteristics of a type&#8212;in this case, the <code>inflatable</code> type.</p>
<p class="caption"><a id="ch04fig06"/><strong>Figure 4.6. Parts of a structure description.</strong></p>
<p class="image"><img src="graphics/04fig06.jpg" alt="Image"/></p>
<p>After you have defined the structure, you can create variables of that type:</p>
<p class="programlisting">inflatable hat;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// hat is a structure variable of type inflatable<br/>inflatable woopie_cushion;&#160;&#160;&#160;&#160;// type inflatable variable<br/>inflatable mainframe;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// type inflatable variable</p>
<p>If you&#8217;re familiar with C structures, you&#8217;ll notice (probably with pleasure) that C++ allows you to drop the keyword <code>struct</code> when you declare structure variables:</p>
<p class="programlisting">struct inflatable goose;&#160;&#160;&#160;&#160;&#160;&#160;// keyword struct required in C<br/>inflatable vincent;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// keyword struct not required in C++</p>
<p>In C++, the structure tag is used just like a fundamental type name. This change emphasizes that a structure declaration defines a new type. It also removes omitting <code>struct</code> from the list of curse-inducing errors.</p>
<p>Given that <code>hat</code> is type <code>inflatable</code>, you use the membership operator (<code>.</code>) to access individual members. For example, <code>hat.volume</code> refers to the <code>volume</code> member of the structure, and <code>hat.price</code> refers to the <code>price</code> member. Similarly, <code>vincent.price</code> is the <code>price</code> member of the <code>vincent</code> variable. In short, the member names enable you to access members of a structure much as indices enable you to access elements of an array. Because the <code>price</code> member is declared as type <code>double</code>, <code>hat.price</code> and <code>vincent.price</code> are both equivalent to type <code>double</code> variables and can be used in any manner an ordinary type <code>double</code> variable can be used. In short, <code>hat</code> is a structure, but <code>hat.price</code> is a <code>double</code>. By <a id="page_142"/>the way, the method used to access class member functions such as <code>cin.getline()</code> has its origins in the method used to access structure member variables such as <code>vincent.price</code>.</p>
<h4 id="ch04lev2sec14">Using a Structure in a Program</h4>
<p>Now that we&#8217;ve covered some of the main features of structures, it&#8217;s time to put the ideas together in a structure-using program. <a href="#ch04ex11">Listing 4.11</a> illustrates these points about a structure. Also it shows how to initialize one.</p>
<p class="caption1"><a id="ch04ex11"/><strong>Listing 4.11. <code>structur.cpp</code></strong></p><hr/>
<p class="programlisting1">// structur.cpp -- a simple structure<br/>#include &lt;iostream&gt;<br/>struct inflatable&#160;&#160;&#160;// structure declaration<br/>{<br/>&#160;&#160;&#160;&#160;char name[20];<br/>&#160;&#160;&#160;&#160;float volume;<br/>&#160;&#160;&#160;&#160;double price;<br/>};<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;inflatable guest =<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Glorious Gloria",&#160;&#160;// name value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.88,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// volume value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;29.99&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// price value<br/>&#160;&#160;&#160;&#160;};&#160;&#160;// guest is a structure variable of type inflatable<br/>// It's initialized to the indicated values<br/>&#160;&#160;&#160;&#160;inflatable pal =<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Audacious Arthur",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.12,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;32.99<br/>&#160;&#160;&#160;&#160;};&#160;&#160;// pal is a second variable of type inflatable<br/>// NOTE: some implementations require using<br/>// static inflatable guest =<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Expand your guest list with " &lt;&lt; guest.name;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " and " &lt;&lt; pal.name &lt;&lt; "!\n";<br/>// pal.name is the name member of the pal variable<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "You can have both for $";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; guest.price + pal.price &lt;&lt; "!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_143"/>Here is the output from the program in <a href="#ch04ex11">Listing 4.11</a>:</p>
<p class="programlisting">Expand your guest list with Glorious Gloria and Audacious Arthur!<br/>You can have both for $62.98!</p>
<h5 id="ch04lev3sec5">Program Notes</h5>
<p>One important matter related to the program in <a href="#ch04ex11">Listing 4.11</a> is where to place the structure declaration. There are two choices for <code>structur.cpp</code>. You could place the declaration inside the <code>main()</code> function, just after the opening brace. The second choice, and the one made here, is to place it outside and preceding <code>main()</code>. When a declaration occurs outside any function, it&#8217;s called an <em>external declaration</em>. For this program, there is no practical difference between the two choices. But for programs consisting of two or more functions, the difference can be crucial. The external declaration can be used by all the functions following it, whereas the internal declaration can be used only by the function in which the declaration is found. Most often, you want an external structure declaration so that all the functions can use structures of that type (see <a href="#ch04fig07">Figure 4.7</a>).</p>
<p class="caption"><a id="ch04fig07"/><strong>Figure 4.7. Local and external structure declarations.</strong></p>
<p class="image"><img src="graphics/04fig07.jpg" alt="Image"/></p>
<p>Variables, too, can be defined internally or externally, with external variables shared among functions. (<a href="ch09.html#ch09">Chapter 9</a>, &#8220;<a href="ch09.html#ch09">Memory Models and Namespaces</a>,&#8221; looks further into that topic.) C++ practices discourage the use of external variables but encourage the use of <a id="page_144"/>external structure declarations. Also it often makes sense to declare symbolic constants externally.</p>
<p>Next, notice the initialization procedure:</p>
<p class="programlisting">inflatable guest =<br/>{<br/>&#160;&#160;&#160;&#160;"Glorious Gloria",&#160;&#160;// name value<br/>&#160;&#160;&#160;&#160;1.88,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// volume value<br/>&#160;&#160;&#160;&#160;29.99&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// price value<br/>};</p>
<p>As with arrays, you use a comma-separated list of values enclosed in a pair of braces. The program places one value per line, but you can place them all on the same line. Just remember to separate items with commas:</p>
<p class="programlisting">inflatable duck = {"Daphne", 0.12, 9.98};</p>
<p>You can initialize each member of the structure to the appropriate kind of data. For example, the <code>name</code> member is a character array, so you can initialize it to a string.</p>
<p>Each structure member is treated as a variable of that type. Thus, <code>pal.price</code> is a <code>double</code> variable, and <code>pal.name</code> is an array of <code>char</code>. And when the program uses <code>cout</code> to display <code>pal.name</code>, it displays the member as a string. By the way, because <code>pal.name</code> is a character array, we can use subscripts to access individual characters in the array. For example, <code>pal.name[0]</code> is the character <code>A</code>. But <code>pal[0]</code> is meaningless because <code>pal</code> is a structure, not an array.</p>
<h4 id="ch04lev2sec15">C++11 Structure Initialization</h4>
<p>As with arrays, C++11 extends the features of list-initialization. The <code>=</code> sign is optional:</p>
<p class="programlisting">inflatable duck {"Daphne", 0.12, 9.98};&#160;&#160;// can omit the = in C++11</p>
<p>Next, empty braces result in the individual members being set to 0. For example, the following declaration results in <code>mayor.volume</code> and <code>mayor.price</code> being set to 0 and all the bytes in <code>mayor.name</code> being set to 0:</p>
<p class="programlisting">inflatable mayor {};</p>
<p>Finally, narrowing is not allowed.</p>
<h4 id="ch04lev2sec16">Can a Structure Use a <code>string</code> Class Member?</h4>
<p>Can you use a <code>string</code> class object instead of a character array for the <code>name</code> member? That is, can you declare a structure like this:</p>
<p class="programlisting">#include &lt;string&gt;<br/>struct inflatable&#160;&#160;&#160;// structure definition<br/>{<br/>&#160;&#160;&#160;&#160;std::string name;<br/>&#160;&#160;&#160;&#160;float volume;<br/>&#160;&#160;&#160;&#160;double price;<br/>};</p>
<p><a id="page_145"/>The answer is yes unless you are using an obsolete compiler that does not support initialization of structures with <code>string</code> class members.</p>
<p>Make sure that the structure definition has access to the <code>std</code> namespace. You can do this by moving the <code>using</code> directive so that it is above the structure definition. The better choice, as shown previously, is to declare <code>name</code> as having type <code>std::string</code>.</p>
<h4 id="ch04lev2sec17">Other Structure Properties</h4>
<p>C++ makes user-defined types as similar as possible to built-in types. For example, you can pass structures as arguments to a function, and you can have a function use a structure as a return value. Also you can use the assignment operator (<code>=</code>) to assign one structure to another of the same type. Doing so causes each member of one structure to be set to the value of the corresponding member in the other structure, even if the member is an array. This kind of assignment is called <em>memberwise assignment</em>. We&#8217;ll defer passing and returning structures until we discuss functions in <a href="ch07.html#ch07">Chapter 7</a>, &#8220;<a href="ch07.html#ch07">Functions: C++&#8217;s Programming Modules</a>,&#8221; but we can take a quick look at structure assignment now. <a href="#ch04ex12">Listing 4.12</a> provides an example.</p>
<p class="caption1"><a id="ch04ex12"/><strong>Listing 4.12. <code>assgn_st.cpp</code></strong></p><hr/>
<p class="programlisting1">// assgn_st.cpp -- assigning structures<br/>#include &lt;iostream&gt;<br/>struct inflatable<br/>{<br/>&#160;&#160;&#160;&#160;char name[20];<br/>&#160;&#160;&#160;&#160;float volume;<br/>&#160;&#160;&#160;&#160;double price;<br/>};<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;inflatable bouquet =<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"sunflowers",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;0.20,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12.49<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;inflatable choice;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "bouquet: " &lt;&lt; bouquet.name &lt;&lt; " for $";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; bouquet.price &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;choice = bouquet;&#160;&#160;// assign one structure to another<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "choice: " &lt;&lt; choice.name &lt;&lt; " for $";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; choice.price &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_146"/>Here&#8217;s the output from the program in <a href="#ch04ex12">Listing 4.12</a>:</p>
<p class="programlisting">bouquet: sunflowers for $12.49<br/>choice: sunflowers for $12.49</p>
<p>As you can see, memberwise assignment is at work, for the members of the <code>choice</code> structure are assigned the same values stored in the <code>bouquet</code> structure.</p>
<p>You can combine the definition of a structure form with the creation of structure variables. To do so, you follow the closing brace with the variable name or names:</p>
<p class="programlisting">struct perks<br/>{<br/>&#160;&#160;&#160;&#160;int key_number;<br/>&#160;&#160;&#160;&#160;char car[12];<br/>} mr_smith, ms_jones;&#160;&#160;&#160;// two perks variables</p>
<p>You even can initialize a variable you create in this fashion:</p>
<p class="programlisting">struct perks<br/>{<br/>&#160;&#160;&#160;&#160;int key_number;<br/>&#160;&#160;&#160;&#160;char car[12];<br/>} mr_glitz =<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;7,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// value for mr_glitz.key_number member<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Packard"&#160;&#160;&#160;&#160;&#160;&#160;// value for mr_glitz.car member<br/>};</p>
<p>However, keeping the structure definition separate from the variable declarations usually makes a program easier to read and follow.</p>
<p>Another thing you can do with structures is create a structure with no type name. You do this by omitting a tag name while simultaneously defining a structure form and a variable:</p>
<p class="programlisting">struct&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no tag<br/>{<br/>&#160;&#160;&#160;&#160;int x;&#160;&#160;&#160;// 2 members<br/>&#160;&#160;&#160;&#160;int y;<br/>} position;&#160;&#160;// a structure variable</p>
<p>This creates one structure variable called <code>position</code>. You can access its members with the membership operator, as in <code>position.x</code>, but there is no general name for the type. You can&#8217;t subsequently create other variables of the same type. This book doesn&#8217;t use that limited form of structure.</p>
<p>Aside from the fact that a C++ program can use the structure tag as a type name, C structures have all the features discussed so far for C++ structures, apart from the C++11 changes. But C++ structures go further. Unlike C structures, for example, C++ structures can have member functions in addition to member variables. But these more advanced features most typically are used with classes rather than structures, so we&#8217;ll discuss them when we cover classes, beginning with <a href="ch10.html#ch10">Chapter 10</a>, &#8220;<a href="ch10.html#ch10">Objects and Classes</a>.&#8221;</p>
<h4 id="ch04lev2sec18">Arrays of Structures</h4>
<p><a id="page_147"/>The <code>inflatable</code> structure contains an array (the <code>name</code> array). It&#8217;s also possible to create arrays whose elements are structures. The technique is exactly the same as for creating arrays of the fundamental types. For example, to create an array of 100 <code>inflatable</code> structures, you could do the following:</p>
<p class="programlisting">inflatable gifts[100];&#160;&#160;// array of 100 inflatable structures</p>
<p>This makes <code>gifts</code> an array of <code>inflatable</code>s. Hence each element of the array, such as <code>gifts[0]</code> or <code>gifts[99]</code>, is an <code>inflatable</code> object and can be used with the membership operator:</p>
<p class="programlisting">cin &gt;&gt; gifts[0].volume;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use volume member of first struct<br/>cout &lt;&lt; gifts[99].price &lt;&lt; endl; // display price member of last struct</p>
<p>Keep in mind that <code>gifts</code> itself is an array, not a structure, so constructions such as <code>gifts.price</code> are not valid.</p>
<p>To initialize an array of structures, you combine the rule for initializing arrays (a brace-enclosed, comma-separated list of values for each element) with the rule for structures (a brace-enclosed, comma-separated list of values for each member). Because each element of the array is a structure, its value is represented by a structure initialization. Thus, you wind up with a brace-enclosed, comma-separated list of values, each of which itself is a brace-enclosed, comma-separated list of values:</p>
<p class="programlisting">inflatable guests[2] =&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initializing an array of structs<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{"Bambi", 0.5, 21.99},&#160;&#160;&#160;&#160;&#160;&#160;// first structure in array<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{"Godzilla", 2000, 565.99}&#160;&#160;// next structure in array<br/>&#160;&#160;&#160;&#160;};</p>
<p>As usual, you can format this the way you like. For example, both initializations can be on the same line, or each separate structure member initialization can get a line of its own.</p>
<p><a href="#ch04ex13">Listing 4.13</a> shows a short example that uses an array of structures. Note that because <code>guests</code> is an array of <code>inflatable</code>, <code>guest[0]</code> is type <code>inflatable</code>, so you can use it with the dot operator to access a member of the <code>inflatable</code> structure.</p>
<p class="caption1"><a id="ch04ex13"/><strong>Listing 4.13. <code>arrstruc.cpp</code></strong></p><hr/>
<p class="programlisting1">// arrstruc.cpp -- an array of structures<br/>#include &lt;iostream&gt;<br/>struct inflatable<br/>{<br/>&#160;&#160;&#160;&#160;char name[20];<br/>&#160;&#160;&#160;&#160;float volume;<br/>&#160;&#160;&#160;&#160;double price;<br/>};<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;inflatable guests[2] =&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initializing an array of structs<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{"Bambi", 0.5, 21.99},&#160;&#160;&#160;&#160;&#160;&#160;// first structure in array<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{"Godzilla", 2000, 565.99}&#160;&#160;// next structure in array<br/>&#160;&#160;&#160;&#160;};<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The guests " &lt;&lt; guests[0].name &lt;&lt; " and " &lt;&lt; guests[1].name<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "\nhave a combined volume of "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; guests[0].volume + guests[1].volume &lt;&lt; " cubic feet.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_148"/>Here is the output of the program in <a href="#ch04ex13">Listing 4.13</a>:</p>
<p class="programlisting">The guests Bambi and Godzilla<br/>have a combined volume of 2000.5 cubic feet.</p>
<h4 id="ch04lev2sec19">Bit Fields in Structures</h4>
<p>C++, like C, enables you to specify structure members that occupy a particular number of bits. This can be handy for creating a data structure that corresponds, say, to a register on some hardware device. The field type should be an integral or enumeration type (enumerations are discussed later in this chapter), and a colon followed by a number indicates the actual number of bits to be used. You can use unnamed fields to provide spacing. Each member is termed a <em>bit field</em>. Here&#8217;s an example:</p>
<p class="programlisting">struct torgle_register<br/>{<br/>&#160;&#160;&#160;&#160;unsigned int SN : 4;&#160;&#160;&#160;// 4 bits for SN value<br/>&#160;&#160;&#160;&#160;unsigned int : 4;&#160;&#160;&#160;&#160;&#160;&#160;// 4 bits unused<br/>&#160;&#160;&#160;&#160;bool goodIn : 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid input (1 bit)<br/>&#160;&#160;&#160;&#160;bool goodTorgle : 1;&#160;&#160;&#160;// successful torgling<br/>};</p>
<p>You can initialize the fields in the usual manner, and you use standard structure notation to access bit fields:</p>
<p class="programlisting">torgle_register tr = { 14, true, false };<br/>...<br/>if (tr.goodIn)&#160;&#160;&#160;// if statement covered in Chapter 6<br/>...</p>
<p>Bit fields are typically used in low-level programming. Often, using an integral type and the bitwise operators listed in <a href="app05.html#app05">Appendix E</a>, &#8220;<a href="app05.html#app05">Other Operators</a>,&#8221; provides an alternative approach.</p>
<h3 id="ch04lev1sec5">Unions</h3>
<p><a id="page_149"/>A <em>union</em> is a data format that can hold different data types but only one type at a time. That is, whereas a structure can hold, say, an <code>int</code> <em>and</em> a <code>long</code> <em>and</em> a <code>double</code>, a union can hold an <code>int</code> <em>or</em> a <code>long</code> <em>or</em> a <code>double</code>. The syntax is like that for a structure, but the meaning is different. For example, consider the following declaration:</p>
<p class="programlisting">union one4all<br/>{<br/>&#160;&#160;&#160;&#160;int int_val;<br/>&#160;&#160;&#160;&#160;long long_val;<br/>&#160;&#160;&#160;&#160;double double_val;<br/>};</p>
<p>You can use a <code>one4all</code> variable to hold an <code>int</code>, a <code>long</code>, or a <code>double</code>, just as long as you do so at different times:</p>
<p class="programlisting">one4all pail;<br/>pail.int_val = 15;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// store an int<br/>cout &lt;&lt; pail.int_val;<br/>pail.double_val = 1.38;&#160;&#160;&#160;// store a double, int value is lost<br/>cout &lt;&lt; pail.double_val;</p>
<p>Thus, <code>pail</code> can serve as an <code>int</code> variable on one occasion and as a <code>double</code> variable at another time. The member name identifies the capacity in which the variable is acting. Because a union holds only one value at a time, it has to have space enough to hold its largest member. Hence, the size of the union is the size of its largest member.</p>
<p>One use for a union is to save space when a data item can use two or more formats but never simultaneously. For example, suppose you manage a mixed inventory of widgets, some of which have an integer ID, and some of which have a string ID. In that case, you could use the following:</p>
<p class="programlisting">struct widget<br/>{<br/>char brand[20];<br/>int type;<br/>union id&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// format depends on widget type<br/>{<br/>&#160;&#160;&#160;&#160;long id_num;&#160;&#160;&#160;&#160;&#160;&#160;// type 1 widgets<br/>&#160;&#160;&#160;&#160;char id_char[20]; // other widgets<br/>} id_val;<br/>};<br/>...<br/>widget prize;<br/>...<br/>if (prize.type == 1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// if-else statement (Chapter 6)<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; prize.id_val.id_num;&#160;&#160;&#160;&#160;// use member name to indicate mode<br/>else<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; prize.id_val.id_char;</p>
<p><a id="page_150"/>An <em>anonymous union</em> has no name; in essence, its members become variables that share the same address. Naturally, only one member can be current at a time:</p>
<p class="programlisting">struct widget<br/>{<br/>&#160;&#160;&#160;&#160;char brand[20];<br/>&#160;&#160;&#160;&#160;int type;<br/>&#160;&#160;&#160;&#160;union&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// anonymous union<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;long id_num;&#160;&#160;&#160;&#160;&#160;&#160;// type 1 widgets<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char id_char[20]; // other widgets<br/>&#160;&#160;&#160;&#160;};<br/>};<br/>...<br/>widget prize;<br/>...<br/>if (prize.type == 1)<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; prize.id_num;<br/>else<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; prize.id_char;</p>
<p>Because the union is anonymous, <code>id_num</code> and <code>id_char</code> are treated as two members of <code>prize</code> that share the same address. The need for an intermediate identifier <em><code>id_val</code></em> is eliminated. It is up to the programmer to keep track of which choice is active.</p>
<p>Unions often (but not exclusively) are used to save memory space. That may not seem that necessary in these days of gigabytes of RAM and terabytes of storage, but not all C++ programs are written for such systems. C++ also is used for embedded systems, such as the processors used to control a toaster oven, an MP3 player, or a Mars rover. In these applications space may be at a premium. Also unions often are used when working with operating systems or hardware data structures.</p>
<h3 id="ch04lev1sec6">Enumerations</h3>
<p>The C++ <code>enum</code> facility provides an alternative to <code>const</code> for creating symbolic constants. It also lets you define new types but in a fairly restricted fashion. The syntax for <code>enum</code> resembles structure syntax. For example, consider the following statement:</p>
<p class="programlisting">enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};</p>
<p>This statement does two things:</p>
<p class="indenthandingB">&#8226; It makes <code>spectrum</code> the name of a new type; <code>spectrum</code> is termed an <em>enumeration</em>, much as a <code>struct</code> variable is called a structure.</p>
<p class="indenthandingB">&#8226; It establishes <code>red</code>, <code>orange</code>, <code>yellow</code>, and so on, as symbolic constants for the integer values 0&#8211;7. These constants are called <em>enumerators</em>.</p>
<p><a id="page_151"/>By default, enumerators are assigned integer values starting with 0 for the first enumerator, 1 for the second enumerator, and so forth. You can override the default by explicitly assigning integer values. You&#8217;ll see how later in this chapter.</p>
<p>You can use an enumeration name to declare a variable of the enumeration type:</p>
<p class="programlisting">spectrum band;&#160;&#160;// band a variable of type spectrum</p>
<p>An enumeration variable has some special properties, which we&#8217;ll examine now.</p>
<p>The only valid values that you can assign to an enumeration variable without a type cast are the enumerator values used in defining the type. Thus, we have the following:</p>
<p class="programlisting">band = blue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid, blue is an enumerator<br/>band = 2000;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invalid, 2000 not an enumerator</p>
<p>Thus, a <code>spectrum</code> variable is limited to just eight possible values. Some compilers issue a compiler error if you attempt to assign an invalid value, whereas others issue a warning. For maximum portability, you should regard assigning a non-<code>enum</code> value to an <code>enum</code> variable as an error.</p>
<p>Only the assignment operator is defined for enumerations. In particular, arithmetic operations are not defined:</p>
<p class="programlisting">band = orange;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid<br/>++band;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not valid, ++ discussed in Chapter 5<br/>band = orange + red;&#160;&#160;&#160;&#160;&#160;// not valid, but a little tricky<br/>...</p>
<p>However, some implementations do not honor this restriction. That can make it possible to violate the type limits. For example, if <code>band</code> has the value <code>ultraviolet</code>, or <code>7</code>, then <code>++band</code>, if valid, increments <code>band</code> to <code>8</code>, which is not a valid value for a <code>spectrum</code> type. Again, for maximum portability, you should adopt the stricter limitations.</p>
<p>Enumerators are of integer type and can be promoted to type <code>int</code>, but <code>int</code> types are not converted automatically to the enumeration type:</p>
<p class="programlisting">int color = blue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid, spectrum type promoted to int<br/>band = 3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invalid, int not converted to spectrum<br/>color = 3 + red;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid, red converted to int<br/>...</p>
<p>Note that in this example, even though <code>3</code> corresponds to the enumerator <code>green</code>, assigning <code>3</code> to <code>band</code> is a type error. But assigning <code>green</code> to <code>band</code> is fine because they are both type <code>spectrum</code>. Again, some implementations do not enforce this restriction. In the expression <code>3 + red</code>, addition isn&#8217;t defined for enumerators. However, <code>red</code> is converted to type <code>int</code>, and the result is type <code>int</code>. Because of the conversion from enumeration to <code>int</code> in this situation, you can use enumerations in arithmetic expressions to combine them with ordinary integers, even though arithmetic isn&#8217;t defined for enumerations themselves.</p>
<p>The earlier example</p>
<p class="programlisting">band = orange + red;&#160;&#160;&#160;&#160;&#160;// not valid, but a little tricky</p>
<p><a id="page_152"/>fails for a somewhat involved reason. It is true that the <code>+</code> operator is not defined for enumerators. But it is also true that enumerators are converted to integers when used in arithmetic expressions, so the expression <code>orange + red</code> gets converted to <code>1 + 0</code>, which is a valid expression. But it is of type <code>int</code> and hence cannot be assigned to the type <code>spectrum</code> variable <code>band</code>.</p>
<p>You can assign an <code>int</code> value to an <code>enum</code>, provided that the value is valid and that you use an explicit type cast:</p>
<p class="programlisting">band = spectrum(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// typecast 3 to type spectrum</p>
<p>What if you try to type cast an inappropriate value? The result is undefined, meaning that the attempt won&#8217;t be flagged as an error but that you can&#8217;t rely on the value of the result:</p>
<p class="programlisting">band = spectrum(40003);&#160;&#160;&#160;&#160;// undefined</p>
<p>(See the section &#8220;<a href="#ch04lev2sec21">Value Ranges for Enumerations</a>,&#8221; later in this chapter for a discussion of what values are and are not appropriate.)</p>
<p>As you can see, the rules governing enumerations are fairly restrictive. In practice, enumerations are used more often as a way of defining related symbolic constants than as a means of defining new types. For example, you might use an enumeration to define symbolic constants for a <code>switch</code> statement. (See <a href="ch06.html#ch06">Chapter 6</a>, &#8220;<a href="ch06.html#ch06">Branching Statements and Logical Operators</a>,&#8221; for an example.) If you plan to use just the constants and not create variables of the enumeration type, you can omit an enumeration type name, as in this example:</p>
<p class="programlisting">enum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};</p>
<h4 id="ch04lev2sec20">Setting Enumerator Values</h4>
<p>You can set enumerator values explicitly by using the assignment operator:</p>
<p class="programlisting">enum bits{one = 1, two = 2, four = 4, eight = 8};</p>
<p>The assigned values must be integers. You also can define just some of the enumerators explicitly:</p>
<p class="programlisting">enum bigstep{first, second = 100, third};</p>
<p>In this case, <code>first</code> is <code>0</code> by default. Subsequent uninitialized enumerators are larger by one than their predecessors. So, <code>third</code> would have the value <code>101</code>.</p>
<p>Finally, you can create more than one enumerator with the same value:</p>
<p class="programlisting">enum {zero, null = 0, one, numero_uno = 1};</p>
<p>Here, both <code>zero</code> and <code>null</code> are <code>0</code>, and both <code>one</code> and <code>numero_uno</code> are <code>1</code>. In earlier versions of C++, you could assign only <code>int</code> values (or values that promote to <code>int</code>) to enumerators, but that restriction has been removed so that you can use type <code>long</code> or even <code>long long</code> values.</p>
<h4 id="ch04lev2sec21">Value Ranges for Enumerations</h4>
<p><a id="page_153"/>Originally, the only valid values for an enumeration were those named in the declaration. However, C++ has expanded the list of valid values that can be assigned to an enumeration variable through the use of a type cast. Each enumeration has a <em>range</em>, and you can assign any integer value in the range, even if it&#8217;s not an enumerator value, by using a type cast to an enumeration variable. For example, suppose that <code>bits</code> and <code>myflag</code> are defined this way:</p>
<p class="programlisting">enum bits{one = 1, two = 2, four = 4, eight = 8};<br/>bits myflag;</p>
<p>In this case, the following is valid:</p>
<p class="programlisting">myflag = bits(6);&#160;&#160;&#160;&#160;// valid, because 6 is in bits range</p>
<p>Here <code>6</code> is not one of the enumerations, but it lies in the range the enumerations define.</p>
<p>The range is defined as follows. First, to find the upper limit, you take the largest enumerator value. Then you find the smallest power of two greater than this largest value and subtract one; the result is the upper end of the range. (For example, the largest <code>bigstep</code> value, as previously defined, is 101. The smallest power of two greater than this is 128, so the upper end of the range is 127.) Next, to find the lower limit, you find the smallest enumerator value. If it is 0 or greater, the lower limit for the range is 0. If the smallest enumerator is negative, you use the same approach as for finding the upper limit but toss in a minus sign. (For example, if the smallest enumerator is -6, the next power of two [times a minus sign] is -8, and the lower limit is -7.)</p>
<p>The idea is that the compiler can choose how much space to use to hold an enumeration. It might use 1 byte or less for an enumeration with a small range and 4 bytes for an enumeration with type <code>long</code> values.</p>
<p>C++11 extends enumerations with a form called the <em>scoped enumeration</em>. <a href="ch10.html#ch10">Chapter 10</a> discusses this form briefly in the section &#8220;<a href="ch10.html#ch10lev1sec6">Class Scope</a>.&#8221;</p>
<h3 id="ch04lev1sec7">Pointers and the Free Store</h3>
<p>The beginning of <a href="ch03.html#ch03">Chapter 3</a> mentions three fundamental properties of which a computer program must keep track when it stores data. To save the book the wear and tear of your thumbing back to that chapter, here are those properties again:</p>
<p class="indenthandingB">&#8226; Where the information is stored</p>
<p class="indenthandingB">&#8226; What value is kept there</p>
<p class="indenthandingB">&#8226; What kind of information is stored</p>
<p>You&#8217;ve used one strategy for accomplishing these ends: defining a simple variable. The declaration statement provides the type and a symbolic name for the value. It also causes the program to allocate memory for the value and to keep track of the location internally.</p>
<p><a id="page_154"/>Let&#8217;s look at a second strategy now, one that becomes particularly important in developing C++ classes. This strategy is based on pointers, which are variables that store addresses of values rather than the values themselves. But before discussing pointers, let&#8217;s talk about how to explicitly find addresses for ordinary variables. You just apply the address operator, represented by <code>&#38;</code>, to a variable to get its location; for example, if <code>home</code> is a variable, <code>&#38;home</code> is its address. <a href="#ch04ex14">Listing 4.14</a> demonstrates this operator.</p>
<p class="caption1"><a id="ch04ex14"/><strong>Listing 4.14. <code>address.cpp</code></strong></p><hr/>
<p class="programlisting1">// address.cpp -- using the &#38; operator to find addresses<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int donuts = 6;<br/>&#160;&#160;&#160;&#160;double cups = 4.5;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "donuts value = " &lt;&lt; donuts;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " and donuts address = " &lt;&lt; &#38;donuts &lt;&lt; endl;<br/>// NOTE: you may need to use unsigned (&#38;donuts)<br/>// and unsigned (&#38;cups)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "cups value = " &lt;&lt; cups;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " and cups address = " &lt;&lt; &#38;cups &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output from the program in <a href="#ch04ex14">Listing 4.14</a> on one system:</p>
<p class="programlisting">donuts value = 6 and donuts address = 0x0065fd40<br/>cups value = 4.5 and cups address = 0x0065fd44</p>
<p>The particular implementation of <code>cout</code> shown here uses hexadecimal notation when displaying address values because that is the usual notation used to specify a memory address. (Some implementations use base 10 notation instead.) Our implementation stores <code>donuts</code> at a lower memory location than <code>cups</code>. The difference between the two addresses is 0x0065fd44 - 0x0065fd40, or 4. This makes sense because <code>donuts</code> is type <code>int</code>, which uses 4 bytes. Different systems, of course, will give different values for the address. Also some may store <code>cups</code> first, then <code>donuts</code>, giving a difference of 8 bytes because <code>cups</code> is <code>double</code>. And some may not even use adjacent locations.</p>
<p>Using ordinary variables, then, treats the value as a named quantity and the location as a derived quantity. Now let&#8217;s look at the pointer strategy, one that is essential to the C++ programming philosophy of memory management. (See the following sidebar, &#8220;<a href="#ch04sb04">Pointers and the C++ Philosophy</a>.&#8221;)</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch04sb04"/><a id="page_155"/>Pointers and the C++ Philosophy</p>
<p class="sidebarpara">Object-oriented programming differs from traditional procedural programming in that OOP emphasizes making decisions during runtime instead of during compile time. <em>Runtime</em> means while a program is running, and <em>compile time</em> means when the compiler is putting a program together. A runtime decision is like, when on vacation, choosing what sights to see depending on the weather and your mood at the moment, whereas a compile-time decision is more like adhering to a preset schedule, regardless of the conditions.</p>
<p class="sidebarpara">Runtime decisions provide the flexibility to adjust to current circumstances. For example, consider allocating memory for an array. The traditional way is to declare an array. To declare an array in C++, you have to commit yourself to a particular array size. Thus, the array size is set when the program is compiled; it is a compile-time decision. Perhaps you think an array of 20 elements is sufficient 80% of the time but that occasionally the program will need to handle 200 elements. To be safe, you use an array with 200 elements. This results in your program wasting memory most of the time it&#8217;s used. OOP tries to make a program more flexible by delaying such decisions until runtime. That way, after the program is running, you can tell it you need only 20 elements one time or that you need 205 elements another time.</p>
<p class="sidebarpara">In short, with OOP you would like to make the array size a runtime decision. To make this approach possible, the language has to allow you to create an array&#8212;or the equivalent&#8212;while the program runs. The C++ method, as you soon see, involves using the keyword <code>new</code> to request the correct amount of memory and using pointers to keep track of where the newly allocated memory is found.</p>
<p class="sidebarpara">Making runtime decisions is not unique to OOP. But C++ makes writing the code a bit more straightforward than does C.</p>
<hr/></div>
<p>The new strategy for handling stored data switches things around by treating the location as the named quantity and the value as a derived quantity. A special type of variable&#8212;the <em>pointer</em>&#8212;holds the address of a value. Thus, the name of the pointer represents the location. Applying the <code>*</code> operator, called the <em>indirect value</em> or the <em>dereferencing</em> operator, yields the value at the location. (Yes, this is the same <code>*</code> symbol used for multiplication; C++ uses the context to determine whether you mean multiplication or dereferencing.) Suppose, for example, that <code>manly</code> is a pointer. In that case, <code>manly</code> represents an address, and <code>*manly</code> represents the value at that address. The combination <code>*manly</code> becomes equivalent to an ordinary type <code>int</code> variable. <a href="#ch04ex15">Listing 4.15</a> demonstrates these ideas. It also shows how to declare a pointer.</p>
<p class="caption1"><a id="ch04ex15"/><strong>Listing 4.15. <code>pointer.cpp</code></strong></p><hr/>
<p class="programlisting1">// pointer.cpp -- our first pointer variable<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int updates = 6;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// declare a variable<br/>&#160;&#160;&#160;&#160;int * p_updates;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// declare pointer to an int<br/>&#160;&#160;&#160;&#160;p_updates = &#38;updates;&#160;&#160;&#160;// assign address of int to pointer<br/><br/>// express values two ways<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Values: updates = " &lt;&lt; updates;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", *p_updates = " &lt;&lt; *p_updates &lt;&lt; endl;<br/><br/>// express address two ways<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Addresses: &#38;updates = " &lt;&lt; &#38;updates;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", p_updates = " &lt;&lt; p_updates &lt;&lt; endl;<br/><br/>// use pointer to change value<br/>&#160;&#160;&#160;&#160;*p_updates = *p_updates + 1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Now updates = " &lt;&lt; updates &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_156"/>Here is the output from the program in <a href="#ch04ex15">Listing 4.15</a>:</p>
<p class="programlisting">Values: updates = 6, *p_updates = 6<br/>Addresses: &#38;updates = 0x0065fd48, p_updates = 0x0065fd48<br/>Now updates = 7</p>
<p>As you can see, the <code>int</code> variable <code>updates</code> and the pointer variable <code>p_updates</code> are just two sides of the same coin. The <code>updates</code> variable represents the value as primary and uses the <code>&#38;</code> operator to get the address, whereas the <code>p_updates</code> variable represents the address as primary and uses the <code>*</code> operator to get the value (see <a href="#ch04fig08">Figure 4.8</a>). Because <code>p_updates</code> points to <code>updates</code>, <code>*p_updates</code> and <code>updates</code> are completely equivalent. You can use <code>*p_updates</code> exactly as you would use a type <code>int</code> variable. As the program in <a href="#ch04ex15">Listing 4.15</a> shows, you can even assign values to <code>*p_updates</code>. Doing so changes the value of the pointed-to value, <code>updates</code>.</p>
<p class="caption"><a id="ch04fig08"/><strong>Figure 4.8. Two sides of a coin.</strong></p>
<p class="image"><img src="graphics/04fig08.jpg" alt="Image"/></p>
<h4 id="ch04lev2sec22">Declaring and Initializing Pointers</h4>
<p><a id="page_157"/>Let&#8217;s examine the process of declaring pointers. A computer needs to keep track of the type of value to which a pointer refers. For example, the address of a <code>char</code> typically looks the same as the address of a <code>double</code>, but <code>char</code> and <code>double</code> use different numbers of bytes and different internal formats for storing values. Therefore, a pointer declaration must specify what type of data to which the pointer points.</p>
<p>For example, the preceding example has this declaration:</p>
<p class="programlisting">int * p_updates;</p>
<p>This states that the combination <code>* p_updates</code> is type <code>int</code>. Because you use the <code>*</code> operator by applying it to a pointer, the <code>p_updates</code> variable itself must <em>be</em> a pointer. We say that <code>p_updates</code> points to type <code>int</code>. We also say that the type for <code>p_updates</code> is pointer-to-<code>int</code> or, more concisely, <code>int *</code>. To repeat: <code>p_updates</code> is a pointer (an address), and <code>*p_updates</code> is an <code>int</code> and not a pointer (see <a href="#ch04fig09">Figure 4.9</a>).</p>
<p class="caption"><a id="ch04fig09"/><strong>Figure 4.9. Pointers store addresses.</strong></p>
<p class="image"><img src="graphics/04fig09.jpg" alt="Image"/></p>
<p>Incidentally, the use of spaces around the <code>*</code> operator are optional. Traditionally, C programmers have used this form:</p>
<p class="programlisting">int *ptr;</p>
<p>This accentuates the idea that the combination <code>*ptr</code> is a type <code>int</code> value. Many C++ programmers, on the other hand, use this form:</p>
<p class="programlisting">int* ptr;</p>
<p><a id="page_158"/>This emphasizes the idea that <code>int*</code> is a type, pointer-to-<code>int</code>. Where you put the spaces makes no difference to the compiler. You could even do this:</p>
<p class="programlisting">int*ptr;</p>
<p>Be aware, however, that the following declaration creates one pointer (<code>p1</code>) and one ordinary <code>int</code> (<code>p2</code>):</p>
<p class="programlisting">int* p1, p2;</p>
<p>You need an <code>*</code> for each pointer variable name.</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note02"/>Note</p>
<p class="notepara">In C++, the combination <code>int *</code> is a compound type, pointer-to-<code>int</code>.</p>
<hr/></div>
<p>You use the same syntax to declare pointers to other types:</p>
<p class="programlisting">double * tax_ptr; // tax_ptr points to type double<br/>char * str;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// str points to type char</p>
<p>Because you declare <code>tax_ptr</code> as a pointer-to-<code>double</code>, the compiler knows that <code>*tax_ptr</code> is a type <code>double</code> value. That is, it knows that <code>*tax_ptr</code> represents a number stored in floating-point format that occupies (on most systems) 8 bytes. A pointer variable is never simply a pointer. It is always a pointer to a specific type. <code>tax_ptr</code> is type pointer-to-<code>double</code> (or type <code>double *</code>), and <code>str</code> is type pointer-to-<code>char</code> (or <code>char *</code>). Although both are pointers, they are pointers of two different types. Like arrays, pointers are based on other types.</p>
<p>Note that whereas <code>tax_ptr</code> and <code>str</code> point to data types of two different sizes, the two variables <code>tax_ptr</code> and <code>str</code> themselves are typically the same size. That is, the address of a <code>char</code> is the same size as the address of a <code>double</code>, much as 1016 might be the street address for a department store, whereas 1024 could be the street address of a small cottage. The size or value of an address doesn&#8217;t really tell you anything about the size or kind of variable or building you find at that address. Usually, addresses require 2 or 4 bytes, depending on the computer system. (Some systems might have larger addresses, and a system can use different address sizes for different types.)</p>
<p>You can use a declaration statement to initialize a pointer. In that case, the pointer, not the pointed-to value, is initialized. That is, the following statements set <code>pt</code> and not <code>*pt</code> to the value <code>&#38;higgens</code>:</p>
<p class="programlisting">int higgens = 5;<br/>int * pt = &#38;higgens;</p>
<p><a href="#ch04ex16">Listing 4.16</a> demonstrates how to initialize a pointer to an address.</p>
<p class="caption1"><a id="ch04ex16"/><strong>Listing 4.16. <code>init_ptr.cpp</code></strong></p><hr/>
<p class="programlisting1">// init_ptr.cpp -- initialize a pointer<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int higgens = 5;<br/>&#160;&#160;&#160;&#160;int * pt = &#38;higgens;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Value of higgens = " &lt;&lt; higgens<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "; Address of higgens = " &lt;&lt; &#38;higgens &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Value of *pt = " &lt;&lt; *pt<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "; Value of pt = " &lt;&lt; pt &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_159"/>Here is some sample output from the program in <a href="#ch04ex16">Listing 4.16</a>:</p>
<p class="programlisting">Value of higgens = 5; Address of higgens = 0012FED4<br/>Value of *pt = 5; Value of pt = 0012FED4</p>
<p>You can see that the program initializes <code>pt</code>, not <code>*pt</code>, to the address of <code>higgens</code>. (Your system most likely will show different values for the addresses and may display them in a different format.)</p>
<h4 id="ch04lev2sec23">Pointer Danger</h4>
<p>Danger awaits those who incautiously use pointers. One extremely important point is that when you create a pointer in C++, the computer allocates memory to hold an address, but it does not allocate memory to hold the data to which the address points. Creating space for the data involves a separate step. Omitting that step, as in the following, is an invitation to disaster:</p>
<p class="programlisting">long * fellow;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create a pointer-to-long<br/>*fellow = 223323;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// place a value in never-never land</p>
<p>Sure, <code>fellow</code> is a pointer. But where does it point? The code failed to assign an address to <code>fellow</code>. So where is the value <code>223323</code> placed? We can&#8217;t say. Because <code>fellow</code> wasn&#8217;t initialized, it could have any value. Whatever that value is, the program interprets it as the address at which to store <code>223323</code>. If <code>fellow</code> happens to have the value <code>1200</code>, then the computer attempts to place the data at address <code>1200</code>, even if that happens to be an address in the middle of your program code. Chances are that wherever <code>fellow</code> points, that is not where you want to put the number <code>223323</code>. This kind of error can produce some of the most insidious and hard-to-trace bugs.</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note03"/>Caution</p>
<p class="notepara">Pointer Golden Rule: <em>Always</em> initialize a pointer to a definite and appropriate address before you apply the dereferencing operator (<code>*</code>) to it.</p>
<hr/></div>
<h4 id="ch04lev2sec24">Pointers and Numbers</h4>
<p><a id="page_160"/>Pointers are not integer types, even though computers typically handle addresses as integers. Conceptually, pointers are distinct types from integers. Integers are numbers you can add, subtract, divide, and so on. But a pointer describes a location, and it doesn&#8217;t make sense, for example, to multiply two locations by each other. In terms of the operations you can perform with them, pointers and integers are different from each other. Consequently, you can&#8217;t simply assign an integer to a pointer:</p>
<p class="programlisting">int * pt;<br/>pt = 0xB8000000;&#160;&#160;// type mismatch</p>
<p>Here, the left side is a pointer to <code>int</code>, so you can assign it an address, but the right side is just an integer. You might know that 0xB8000000 is the combined segment-offset address of video memory on your aging computer system, but nothing in the statement tells the program that this number is an address. C prior to C99 lets you make assignments like this. But C++ more stringently enforces type agreement, and the compiler will give you an error message saying you have a type mismatch. If you want to use a numeric value as an address, you should use a type cast to convert the number to the appropriate address type:</p>
<p class="programlisting">int * pt;<br/>pt = (int *) 0xB8000000; // types now match</p>
<p>Now both sides of the assignment statement represent addresses of integers, so the assignment is valid. Note that just because it is the address of a type <code>int</code> value doesn&#8217;t mean that <code>pt</code> itself is type <code>int</code>. For example, one might have a platform for which type <code>int</code> is a 2-byte value and the addresses are 4-byte values.</p>
<p>Pointers have some other interesting properties that we&#8217;ll discuss as they become relevant. Meanwhile, let&#8217;s look at how pointers can be used to manage runtime allocation of memory space.</p>
<h4 id="ch04lev2sec25">Allocating Memory with <code>new</code></h4>
<p>Now that you have a feel for how pointers work, let&#8217;s see how they can implement the important technique of allocating memory as a program runs. So far, you&#8217;ve initialized pointers to the addresses of variables; the variables are <em>named</em> memory allocated during compile time, and each pointer merely provides an alias for memory you could access directly by name anyway. The true worth of pointers comes into play when you allocate <em>unnamed</em> memory during runtime to hold values. In this case, pointers become the only access to that memory. In C, you can allocate memory with the library function <code>malloc()</code>. You can still do so in C++, but C++ also has a better way: the <code>new</code> operator.</p>
<p>Let&#8217;s try out this new technique by creating unnamed runtime storage for a type <code>int</code> value and accessing the value with a pointer. The key is the C++ <code>new</code> operator. You tell <code>new</code> for what data type you want memory; <code>new</code> finds a block of the correct size and <a id="page_161"/>returns the address of the block. You assign this address to a pointer, and you&#8217;re in business. Here&#8217;s an example of the technique:</p>
<p class="programlisting">int * pn = new int;</p>
<p>The <code>new int</code> part tells the program you want some new storage suitable for holding an <code>int</code>. The <code>new</code> operator uses the type to figure out how many bytes are needed. Then it finds the memory and returns the address. Next, you assign the address to <code>pn</code>, which is declared to be of type pointer-to-<code>int</code>. Now <code>pn</code> is the address and <code>*pn</code> is the value stored there. Compare this with assigning the address of a variable to a pointer:</p>
<p class="programlisting">int higgens;<br/>int * pt = &#38;higgens;</p>
<p>In both cases (<code>pn</code> and <code>pt</code>), you assign the address of an <code>int</code> to a pointer. In the second case, you can also access the <code>int</code> by name: <code>higgens</code>. In the first case, your only access is via the pointer. That raises a question: Because the memory to which <code>pn</code> points lacks a name, what do you call it? We say that <code>pn</code> points to a <em>data object</em>. This is not &#8220;object&#8221; in the sense of &#8220;object-oriented programming&#8221;; it&#8217;s just &#8220;object&#8221; in the sense of &#8220;thing.&#8221; The term &#8220;data object&#8221; is more general than the term &#8220;variable&#8221; because it means any block of memory allocated for a data item. Thus, a variable is also a data object, but the memory to which <code>pn</code> points is not a variable. The pointer method for handling data objects may seem more awkward at first, but it offers greater control over how your program manages memory.</p>
<p>The general form for obtaining and assigning memory for a single data object, which can be a structure as well as a fundamental type, is this:</p>
<p class="programlisting"><span class="EmpItalic">typeName</span> * <span class="EmpItalic">pointer_name</span> = new <span class="EmpItalic">typeName</span>;</p>
<p>You use the data type twice: once to specify the kind of memory requested and once to declare a suitable pointer. Of course, if you&#8217;ve already declared a pointer of the correct type, you can use it rather than declare a new one. <a href="#ch04ex17">Listing 4.17</a> illustrates using <code>new</code> with two different types.</p>
<p class="caption1"><a id="ch04ex17"/><strong>Listing 4.17. <code>use_new.cpp</code></strong></p><hr/>
<p class="programlisting1">// use_new.cpp -- using the new operator<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int nights = 1001;<br/>&#160;&#160;&#160;&#160;int * pt = new int;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// allocate space for an int<br/>&#160;&#160;&#160;&#160;*pt = 1001;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// store a value there<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "nights value = ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; nights &lt;&lt; ": location " &lt;&lt; &#38;nights &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "int ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "value = " &lt;&lt; *pt &lt;&lt; ": location = " &lt;&lt; pt &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;double * pd = new double;&#160;&#160;&#160;// allocate space for a double<br/>&#160;&#160;&#160;&#160;*pd = 10000001.0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// store a double there<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "double ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "value = " &lt;&lt; *pd &lt;&lt; ": location = " &lt;&lt; pd &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "location of pointer pd: " &lt;&lt; &#38;pd &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "size of pt = " &lt;&lt; sizeof(pt);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ": size of *pt = " &lt;&lt; sizeof(*pt) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "size of pd = " &lt;&lt; sizeof pd;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ": size of *pd = " &lt;&lt; sizeof(*pd) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_162"/>Here is the output from the program in <a href="#ch04ex17">Listing 4.17</a>:</p>
<p class="programlisting">nights value = 1001: location 0028F7F8<br/>int value = 1001: location = 00033A98<br/>double value = 1e+007: location = 000339B8<br/>location of pointer pd: 0028F7FC<br/>size of pt = 4: size of *pt = 4<br/>size of pd = 4: size of *pd = 8</p>
<p>Of course, the exact values for the memory locations differ from system to system.</p>
<h5 id="ch04lev3sec6">Program Notes</h5>
<p>The program in <a href="#ch04ex17">Listing 4.17</a> uses <code>new</code> to allocate memory for the type <code>int</code> and type <code>double</code> data objects. This occurs while the program is running. The pointers <code>pt</code> and <code>pd</code> point to these two data objects. Without them, you cannot access those memory locations. With them, you can use <code>*pt</code> and <code>*pd</code> just as you would use variables. You assign values to <code>*pt</code> and <code>*pd</code> to assign values to the new data objects. Similarly, you print <code>*pt</code> and <code>*pd</code> to display those values.</p>
<p>The program in <a href="#ch04ex17">Listing 4.17</a> also demonstrates one of the reasons you have to declare the type a pointer points to. An address in itself reveals only the beginning address of the object stored, not its type or the number of bytes used. Look at the addresses of the two values. They are just numbers with no type or size information. Also note that the size of a pointer-to-<code>int</code> is the same as the size of a pointer-to-<code>double</code>. Both are just addresses. But because <code>use_new.cpp</code> declares the pointer types, the program knows that <code>*pd</code> is a <code>double</code> value of 8 bytes, whereas <code>*pt</code> is an <code>int</code> value of 4 bytes. When <code>use_new.cpp</code> prints the value of <code>*pd</code>, <code>cout</code> can tell how many bytes to read and how to interpret them.</p>
<p>Another point to note is that typically <code>new</code> uses a different block of memory than do the ordinary variable definitions that we have been using. Both the variables <code>nights</code> and <code>pd</code> have their values stored in a memory region called the <em>stack</em>, whereas the memory allocated by <code>new</code> is in a region called the <em>heap</em> or <em>free store</em>. <a href="ch09.html#ch09">Chapter 9</a> discusses this a bit further.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch04sb05"/><a id="page_163"/>Out of Memory?</p>
<p class="sidebarpara">It&#8217;s possible that a computer might not have sufficient memory available to satisfy a <code>new</code> request. When that is the case, <code>new</code> normally responds by throwing an exception, an error-handling technique discussed in <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>.&#8221; In older implementations <code>new</code> returns the value <code>0</code>. In C++, a pointer with the value <code>0</code> is called the <em>null pointer.</em> C++ guarantees that the null pointer never points to valid data, so it is often used to indicate failure for operators or functions that otherwise return usable pointers. The <code>if</code> statement, discussed in <a href="ch06.html#ch06">Chapter 6</a>, helps you deal with this possibility. For now, the important point is that C++ provides the tools to detect and respond to allocation failures.</p>
<hr/></div>
<h4 id="ch04lev2sec26">Freeing Memory with <code>delete</code></h4>
<p>Using <code>new</code> to request memory when you need it is just the more glamorous half of the C++ memory-management package. The other half is the <code>delete</code> operator, which enables you to return memory to the memory pool when you are finished with it. That is an important step toward making the most effective use of memory. Memory that you return, or <em>free</em>, can then be reused by other parts of the program. You use <code>delete</code> by following it with a pointer to a block of memory originally allocated with <code>new</code>:</p>
<p class="programlisting">int * ps = new int; // allocate memory with new<br/>. . .&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use the memory<br/>delete ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free memory with delete when done</p>
<p>This removes the memory to which <code>ps</code> points; it doesn&#8217;t remove the pointer <code>ps</code> itself. You can reuse <code>ps</code>, for example, to point to another <code>new</code> allocation. You should always balance a use of <code>new</code> with a use of <code>delete</code>; otherwise, you can wind up with a <em>memory leak</em>&#8212;that is, memory that has been allocated but can no longer be used. If a memory leak grows too large, it can bring a program seeking more memory to a halt.</p>
<p>You should not attempt to free a block of memory that you have previously freed. The C++ Standard says the result of such an attempt is undefined, meaning that the consequences could be anything. Also you cannot use <code>delete</code> to free memory created by declaring ordinary variables:</p>
<p class="programlisting">int * ps = new int;&#160;&#160;&#160;// ok<br/>delete ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok<br/>delete ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not ok now<br/>int jugs = 5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok<br/>int * pi = &#38;jugs;&#160;&#160;&#160;&#160;&#160;// ok<br/>delete pi;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed, memory not allocated by new</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note04"/>Caution</p>
<p class="notepara">You should use <code>delete</code> only to free memory allocated with <code>new</code>. However, it is safe to apply <code>delete</code> to a null pointer.</p>
<hr/></div>
<p><a id="page_164"/>Note that the critical requirement for using <code>delete</code> is to use it with memory allocated by <code>new</code>. This doesn&#8217;t mean you have to use the same pointer you used with <code>new</code>; instead, you have to use the same address:</p>
<p class="programlisting">int * ps = new int;&#160;&#160;&#160;// allocate memory<br/>int * pq = ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set second pointer to same block<br/>delete pq;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// delete with second pointer</p>
<p>Ordinarily, you won&#8217;t create two pointers to the same block of memory because that raises the possibility that you will mistakenly try to delete the same block twice. But as you&#8217;ll soon see, using a second pointer does make sense when you work with a function that returns a pointer.</p>
<h4 id="ch04lev2sec27">Using <code>new</code> to Create Dynamic Arrays</h4>
<p>If all a program needs is a single value, you might as well declare a simple variable because that is simpler, if less impressive, than using <code>new</code> and a pointer to manage a single small data object. More typically, you use <code>new</code> with larger chunks of data, such as arrays, strings, and structures. This is where <code>new</code> is useful. Suppose, for example, you&#8217;re writing a program that might or might not need an array, depending on information given to the program while it is running. If you create an array by declaring it, the space is allocated when the program is compiled. Whether or not the program finally uses the array, the array is there, using up memory. Allocating the array during compile time is called <em>static binding</em>, meaning that the array is built in to the program at compile time. But with <code>new</code>, you can create an array during runtime if you need it and skip creating the array if you don&#8217;t need it. Or you can select an array size after the program is running. This is called <em>dynamic binding</em>, meaning that the array is created while the program is running. Such an array is called a <em>dynamic array</em>. With static binding, you must specify the array size when you write the program. With dynamic binding, the program can decide on an array size while the program runs.</p>
<p>For now, we&#8217;ll look at two basic matters concerning dynamic arrays: how to use C++&#8217;s <code>new</code> operator to create an array and how to use a pointer to access array elements.</p>
<h5 id="ch04lev3sec7">Creating a Dynamic Array with <code>new</code></h5>
<p>It&#8217;s easy to create a dynamic array in C++; you tell <code>new</code> the type of array element and number of elements you want. The syntax requires that you follow the type name with the number of elements, in brackets. For example, if you need an array of 10 <code>int</code>s, you use this:</p>
<p class="programlisting">int * psome = new int [10]; // get a block of 10 ints</p>
<p>The <code>new</code> operator returns the address of the first element of the block. In this example, that value is assigned to the pointer <code>psome</code>.</p>
<p>As always, you should balance the call to <code>new</code> with a call to <code>delete</code> when the program finishes using that block of memory. However, using <code>new</code> with brackets to create an array requires using an alternative form of <code>delete</code> when freeing the array:</p>
<p class="programlisting">delete [] psome;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free a dynamic array</p>
<p><a id="page_165"/>The presence of the brackets tells the program that it should free the whole array, not just the element pointed to by the pointer. Note that the brackets are between <code>delete</code> and the pointer. If you use <code>new</code> without brackets, you should use <code>delete</code> without brackets. If you use <code>new</code> with brackets, you should use <code>delete</code> with brackets. Earlier versions of C++ might not recognize the bracket notation. For the ANSI/ISO Standard, however, the effect of mismatching <code>new</code> and <code>delete</code> forms is undefined, meaning that you can&#8217;t rely on some particular behavior. Here&#8217;s an example:</p>
<p class="programlisting">int * pt = new int;<br/>short * ps = new short [500];<br/>delete [] pt;&#160;&#160;// effect is undefined, don't do it<br/>delete ps;&#160;&#160;&#160;&#160;&#160;// effect is undefined, don't do it</p>
<p>In short, you should observe these rules when you use <code>new</code> and <code>delete</code>:</p>
<p class="indenthandingB">&#8226; Don&#8217;t use <code>delete</code> to free memory that <code>new</code> didn&#8217;t allocate.</p>
<p class="indenthandingB">&#8226; Don&#8217;t use <code>delete</code> to free the same block of memory twice in succession.</p>
<p class="indenthandingB">&#8226; Use <code>delete []</code> if you used <code>new []</code> to allocate an array.</p>
<p class="indenthandingB">&#8226; Use <code>delete</code> (no brackets) if you used <code>new</code> to allocate a single entity.</p>
<p class="indenthandingB">&#8226; It&#8217;s safe to apply <code>delete</code> to the null pointer (nothing happens).</p>
<p>Now let&#8217;s return to the dynamic array. Note that <code>psome</code> is a pointer to a single <code>int</code>, the first element of the block. It&#8217;s your responsibility to keep track of how many elements are in the block. That is, because the compiler doesn&#8217;t keep track of the fact that <code>psome</code> points to the first of 10 integers, you have to write your program so that it keeps track of the number of elements.</p>
<p>Actually, the program does keep track of the amount of memory allocated so that it can be correctly freed at a later time when you use the <code>delete []</code> operator. But that information isn&#8217;t publicly available; you can&#8217;t use the <code>sizeof</code> operator, for example, to find the number of bytes in a dynamically allocated array.</p>
<p>The general form for allocating and assigning memory for an array is this:</p>
<p class="programlisting"><span class="EmpItalic">type_name * pointer_name</span> = new <span class="EmpItalic">type_name</span> [<span class="EmpItalic">num_elements</span>];</p>
<p>Invoking the <code>new</code> operator secures a block of memory large enough to hold <em><code>num_elements</code></em> elements of type <em><code>type_name</code></em>, with <em><code>pointer_name</code></em> pointing to the first element. As you&#8217;re about to see, you can use <em><code>pointer_name</code></em> in many of the same ways you can use an array name.</p>
<h5 id="ch04lev3sec8">Using a Dynamic Array</h5>
<p>After you create a dynamic array, how do you use it? First, think about the problem conceptually. The following statement creates a pointer, <code>psome</code>, that points to the first element of a block of 10 <code>int</code> values:</p>
<p class="programlisting">int * psome = new int [10]; // get a block of 10 ints</p>
<p><a id="page_166"/>Think of it as a finger pointing to that element. Suppose an <code>int</code> occupies 4 bytes. Then, by moving your finger 4 bytes in the correct direction, you can point to the second element. Altogether, there are 10 elements, which is the range over which you can move your finger. Thus, the <code>new</code> statement supplies you with all the information you need to identify every element in the block.</p>
<p>Now think about the problem practically. How do you access one of these elements? The first element is no problem. Because <code>psome</code> points to the first element of the array, <code>*psome</code> is the value of the first element. That leaves nine more elements to access. The simplest way to access the elements may surprise you if you haven&#8217;t worked with C: Just use the pointer as if it were an array name. That is, you can use <code>psome[0]</code> instead of <code>*psome</code> for the first element, <code>psome[1]</code> for the second element, and so on. It turns out to be very simple to use a pointer to access a dynamic array, even if it may not immediately be obvious why the method works. The reason you can do this is that C and C++ handle arrays internally by using pointers anyway. This near equivalence of arrays and pointers is one of the beauties of C and C++. (It&#8217;s also sometimes a problem, but that&#8217;s another story.) You&#8217;ll learn more about this equivalence in a moment. First, <a href="#ch04ex18">Listing 4.18</a> shows how you can use <code>new</code> to create a dynamic array and then use array notation to access the elements. It also points out a fundamental difference between a pointer and a true array name.</p>
<p class="caption1"><a id="ch04ex18"/><strong>Listing 4.18. <code>arraynew.cpp</code></strong></p><hr/>
<p class="programlisting1">// arraynew.cpp -- using the new operator for arrays<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double * p3 = new double [3]; // space for 3 doubles<br/>&#160;&#160;&#160;&#160;p3[0] = 0.2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// treat p3 like an array name<br/>&#160;&#160;&#160;&#160;p3[1] = 0.5;<br/>&#160;&#160;&#160;&#160;p3[2] = 0.8;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "p3[1] is " &lt;&lt; p3[1] &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;p3 = p3 + 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// increment the pointer<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Now p3[0] is " &lt;&lt; p3[0] &lt;&lt; " and ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "p3[1] is " &lt;&lt; p3[1] &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;p3 = p3 - 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// point back to beginning<br/>&#160;&#160;&#160;&#160;delete [] p3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free the memory<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output from the program in <a href="#ch04ex18">Listing 4.18</a>:</p>
<p class="programlisting">p3[1] is 0.5.<br/>Now p3[0] is 0.5 and p3[1] is 0.8.</p>
<p><a id="page_167"/>As you can see, <code>arraynew.cpp</code> uses the pointer <code>p3</code> as if it were the name of an array, with <code>p3[0]</code> as the first element, and so on. The fundamental difference between an array name and a pointer appears in the following line:</p>
<p class="programlisting">p3 = p3 + 1; // okay for pointers, wrong for array names</p>
<p>You can&#8217;t change the value of an array name. But a pointer is a variable, hence you can change its value. Note the effect of adding 1 to <code>p3</code>. The expression <code>p3[0]</code> now refers to the former second element of the array. Thus, adding 1 to <code>p3</code> causes it to point to the second element instead of the first. Subtracting one takes the pointer back to its original value so that the program can provide <code>delete []</code> with the correct address.</p>
<p>The actual addresses of consecutive <code>int</code>s typically differ by 2 or 4 bytes, so the fact that adding 1 to <code>p3</code> gives the address of the next element suggests that there is something special about pointer arithmetic. There is.</p>
<h3 id="ch04lev1sec8">Pointers, Arrays, and Pointer Arithmetic</h3>
<p>The near equivalence of pointers and array names stems from <em>pointer arithmetic</em> and how C++ handles arrays internally. First, let&#8217;s check out the arithmetic. Adding one to an integer variable increases its value by one, but adding one to a pointer variable increases its value by the number of bytes of the type to which it points. Adding one to a pointer to <code>double</code> adds 8 to the numeric value on systems with 8-byte <code>double</code>, whereas adding one to a pointer-to-<code>short</code> adds two to the pointer value if <code>short</code> is 2 bytes. <a href="#ch04ex19">Listing 4.19</a> demonstrates this amazing point. It also shows a second important point: C++ interprets the array name as an address.</p>
<p class="caption1"><a id="ch04ex19"/><strong>Listing 4.19. <code>addpntrs.cpp</code></strong></p><hr/>
<p class="programlisting1">// addpntrs.cpp -- pointer addition<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double wages[3] = {10000.0, 20000.0, 30000.0};<br/>&#160;&#160;&#160;&#160;short stacks[3] = {3, 2, 1};<br/><br/>// Here are two ways to get the address of an array<br/>&#160;&#160;&#160;&#160;double * pw = wages;&#160;&#160;&#160;&#160;&#160;// name of an array = address<br/>&#160;&#160;&#160;&#160;short * ps = &#38;stacks[0]; // or use address operator<br/>// with array element<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "pw = " &lt;&lt; pw &lt;&lt; ", *pw = " &lt;&lt; *pw &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;pw = pw + 1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "add 1 to the pw pointer:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "pw = " &lt;&lt; pw &lt;&lt; ", *pw = " &lt;&lt; *pw &lt;&lt; "\n\n";<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "ps = " &lt;&lt; ps &lt;&lt; ", *ps = " &lt;&lt; *ps &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;ps = ps + 1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "add 1 to the ps pointer:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "ps = " &lt;&lt; ps &lt;&lt; ", *ps = " &lt;&lt; *ps &lt;&lt; "\n\n";<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "access two elements with array notation\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "stacks[0] = " &lt;&lt; stacks[0]<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ", stacks[1] = " &lt;&lt; stacks[1] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "access two elements with pointer notation\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "*stacks = " &lt;&lt; *stacks<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ", *(stacks + 1) =&#160;&#160;" &lt;&lt; *(stacks + 1) &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; sizeof(wages) &lt;&lt; " = size of wages array\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; sizeof(pw) &lt;&lt; " = size of pw pointer\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_168"/>Here is the output from the program in <a href="#ch04ex19">Listing 4.19</a>:</p>
<p class="programlisting">pw = 0x28ccf0, *pw = 10000<br/>add 1 to the pw pointer:<br/>pw = 0x28ccf8, *pw = 20000<br/><br/>ps = 0x28ccea, *ps = 3<br/>add 1 to the ps pointer:<br/>ps = 0x28ccec, *ps = 2<br/><br/>access two elements with array notation<br/>stacks[0] = 3, stacks[1] = 2<br/>access two elements with pointer notation<br/>*stacks = 3, *(stacks + 1) =&#160;&#160;2<br/>24 = size of wages array<br/>4 = size of pw pointer</p>
<h4 id="ch04lev2sec28">Program Notes</h4>
<p>In most contexts, C++ interprets the name of an array as the address of its first element. Thus, the following statement makes <code>pw</code> a pointer to type <code>double</code> and then initializes <code>pw</code> to <code>wages</code>, which is the address of the first element of the <code>wages</code> array:</p>
<p class="programlisting">double * pw = wages;</p>
<p>For <code>wages</code>, as with any array, we have the following equality:</p>
<p class="programlisting">wages = &#38;wages[0] = address of first element of array</p>
<p>Just to show that this is no jive, the program explicitly uses the address operator in the expression <code>&#38;stacks[0]</code> to initialize the <code>ps</code> pointer to the first element of the stacks array.</p>
<p><a id="page_169"/>Next, the program inspects the values of <code>pw</code> and <code>*pw</code>. The first is an address, and the second is the value at that address. Because <code>pw</code> points to the first element, the value displayed for <code>*pw</code> is that of the first element, <code>10000</code>. Then the program adds one to <code>pw</code>. As promised, this adds eight to the numeric address value because <code>double</code> on this system is 8 bytes. This makes <code>pw</code> equal to the address of the second element. Thus, <code>*pw</code> is now <code>20000</code>, the value of the second element (see <a href="#ch04fig10">Figure 4.10</a>). (The address values in the figure are adjusted to make the figure clearer.)</p>
<p class="caption"><a id="ch04fig10"/><strong>Figure 4.10. Pointer addition.</strong></p>
<p class="image"><img src="graphics/04fig10.jpg" alt="Image"/></p>
<p>After this, the program goes through similar steps for <code>ps</code>. This time, because <code>ps</code> points to type <code>short</code> and because <code>short</code> is 2 bytes, adding 1 to the pointer increases its value by 2 (0x28ccea + 2 = 0x28ccec in hexadecimal). Again, the result is to make the pointer point to the next element of the array.</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note05"/>Note</p>
<p class="notepara">Adding one to a pointer variable increases its value by the number of bytes of the type to which it points.</p>
<hr/></div>
<p>Now consider the array expression <code>stacks[1]</code>. The C++ compiler treats this expression exactly as if you wrote it as <code>*(stacks + 1)</code>. The second expression means calculate the address of the second element of the array and then find the value stored there. The end result is precisely what <code>stacks[1]</code> means. (Operator precedence requires that you use the parentheses. Without them, <code>1</code> would be added to <code>*stacks</code> instead of to <code>stacks</code>.)</p>
<p>The program output demonstrates that <code>*(stacks + 1)</code> and <code>stacks[1</code>] are the same. Similarly, <code>*(stacks + 2)</code> is the same as <code>stacks[2]</code>. In general, wherever you use array notation, C++ makes the following conversion:</p>
<p class="programlisting">arrayname[i] becomes *(arrayname + i)</p>
<p><a id="page_170"/>And if you use a pointer instead of an array name, C++ makes the same conversion:</p>
<p class="programlisting">pointername[i] becomes *(pointername + i)</p>
<p>Thus, in many respects you can use pointer names and array names in the same way. You can use the array brackets notation with either. You can apply the dereferencing operator (<code>*</code>) to either. In most expressions, each represents an address. One difference is that you can change the value of a pointer, whereas an array name is a constant:</p>
<p class="programlisting">pointername = pointername + 1; // valid<br/>arrayname = arrayname + 1;&#160;&#160;&#160;&#160;&#160;// not allowed</p>
<p>A second difference is that applying the <code>sizeof</code> operator to an array name yields the size of the array, but applying <code>sizeof</code> to a pointer yields the size of the pointer, even if the pointer points to the array. For example, in <a href="#ch04ex19">Listing 4.19</a>, both <code>pw</code> and <code>wages</code> refer to the same array. But applying the <code>sizeof</code> operator to them produces the following results:</p>
<p class="indenthanding">24 = size of <code>wages</code> array <code>&lt;&lt;</code> displaying <code>sizeof wages</code></p>
<p class="indenthanding">4 = size of <code>pw</code> pointer <code>&lt;&lt;</code> displaying <code>sizeof pw</code></p>
<p>This is one case in which C++ doesn&#8217;t interpret the array name as an address.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch04sb06"/>The Address of an Array</p>
<p class="sidebarpara">Taking the address of an array is another case in which the name of an array is not interpreted as its address. But wait, isn&#8217;t the name of an array interpreted as the address of the array? Not quite&#8212;the name of the array is interpreted as the address of the first element of an array, whereas applying the address operator yields the address of the whole array:</p>
<p class="programlistingB">short tell[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// tell an array of 20 bytes<br/>cout &lt;&lt; tell &lt;&lt; endl;&#160;&#160;// displays &#38;tell[0]<br/>cout &lt;&lt; &#38;tell &lt;&lt; endl; // displays address of whole array</p>
<p class="sidebarpara">Numerically, these two addresses are the same, but conceptually <code>&#38;tell[0]</code>, and hence <code>tell</code>, is the address of a 2-byte block of memory, whereas <code>&#38;tell</code> is the address of a 20-byte block of memory. So the expression <code>tell + 1</code> adds <code>2</code> to the address value, whereas <code>&#38;tell + 1</code> adds <code>20</code> to the address value. Another way of expressing this is to say that <code>tell</code> is type pointer-to-<code>short</code>, or <code>short *</code>, and <code>&#38;tell</code> is type pointer-to-array-of-20-<code>short</code>s, or <code>short (*)[20]</code>.</p>
<p class="sidebarpara">Now you might be wondering about the genesis of that last type description. First, here is how you could declare and initialize a pointer of that type:</p>
<p class="programlistingB">short (*pas)[20] = &#38;tell;&#160;&#160;// pas points to array of 20 shorts</p>
<p class="sidebarpara">If you omit the parentheses, precedence rules would first associate <code>[20]</code> with <code>pas</code>, making <code>pas</code> an array of 20 pointers-to-<code>short</code>, so the parentheses are necessary. Next, if you wish to describe the type of a variable, you can use the declaration of that variable as a guide and remove the variable name. Thus, the type of <code>pas</code> is <code>short (*)[20]</code>. Also note that because <code>pas</code> is set to <code>&#38;tell</code>, <code>*pas</code> is equivalent to <code>tell</code>, so <code>(*pas)[0]</code> would be the first element of the <code>tell</code> array.</p>
<hr/></div>
<p><a id="page_171"/>In short, using <code>new</code> to create an array and using a pointer to access the different elements is a simple matter. You just treat the pointer as an array name. Understanding why this works, however, is an interesting challenge. If you actually want to understand arrays and pointers, you should review their mutual relationships carefully.</p>
<h4 id="ch04lev2sec29">Summarizing Pointer Points</h4>
<p>You&#8217;ve been exposed to quite a bit of pointer knowledge lately, so let&#8217;s summarize what&#8217;s been revealed about pointers and arrays to date.</p>
<h5 id="ch04lev3sec9">Declaring Pointers</h5>
<p>To declare a pointer to a particular type, use this form:</p>
<p class="programlisting"><span class="EmpItalic">typeName</span> * <span class="EmpItalic">pointerName</span>;</p>
<p>Here are some examples:</p>
<p class="programlisting">double * pn;&#160;&#160;&#160;&#160;&#160;&#160;// pn can point to a double value<br/>char * pc;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pc can point to a char value</p>
<p>Here <code>pn</code> and <code>pc</code> are pointers, and <code>double *</code> and <code>char *</code> are the C++ notations for the types pointer-to-<code>double</code> and pointer-to-<code>char</code>.</p>
<h5 id="ch04lev3sec10">Assigning Values to Pointers</h5>
<p>You should assign a memory address to a pointer. You can apply the <code>&#38;</code> operator to a variable name to get an address of named memory, and the <code>new</code> operator returns the address of unnamed memory.</p>
<p>Here are some examples:</p>
<p class="programlisting">double * pn;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pn can point to a double value<br/>double * pa;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// so can pa<br/>char * pc;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pc can point to a char value<br/>double bubble = 3.2;<br/>pn = &#38;bubble;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assign address of bubble to pn<br/>pc = new char;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// assign address of newly allocated char memory to pc<br/>pa = new double[30];&#160;&#160;// assign address of 1st element of array of 30 double to pa</p>
<h5 id="ch04lev3sec11">Dereferencing Pointers</h5>
<p>Dereferencing a pointer means referring to the pointed-to value. You apply the dereferencing, or indirect value, operator (<code>*</code>) to a pointer to dereference it. Thus, if <code>pn</code> is a pointer to <code>bubble</code>, as in the preceding example, then <code>*pn</code> is the pointed-to value, or 3.2, in this case.</p>
<p>Here are some examples:</p>
<p class="programlisting">cout &lt;&lt; *pn; // print the value of bubble<br/>*pc = 'S';&#160;&#160;&#160;// place 'S' into the memory location whose address is pc</p>
<p><a id="page_172"/>Array notation is a second way to dereference a pointer; for instance, <code>pn[0]</code> is the same as <code>*pn</code>. You should never dereference a pointer that has not been initialized to a proper address.</p>
<h5 id="ch04lev3sec12">Distinguishing Between a Pointer and the Pointed-to Value</h5>
<p>Remember, if <code>pt</code> is a pointer-to-<code>int</code>, <code>*pt</code> is not a pointer-to-<code>int</code>; instead, <code>*pt</code> is the complete equivalent to a type <code>int</code> variable. It is <code>pt</code> that is the pointer.</p>
<p>Here are some examples:</p>
<p class="programlisting">int * pt = new int;&#160;&#160;&#160;&#160;&#160;// assigns an address to the pointer pt<br/>*pt = 5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// stores the value 5 at that address</p>
<h5 id="ch04lev3sec13">Array Names</h5>
<p>In most contexts, C++ treats the name of an array as equivalent to the address of the first element of an array.</p>
<p>Here is an example:</p>
<p class="programlisting">int tacos[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// now tacos is the same as &#38;tacos[0]</p>
<p>One exception is when you use the name of an array with the <code>sizeof</code> operator. In that case, <code>sizeof</code> returns the size of the entire array, in bytes.</p>
<h5 id="ch04lev3sec14">Pointer Arithmetic</h5>
<p>C++ allows you to add an integer to a pointer. The result of adding one equals the original address value plus a value equal to the number of bytes in the pointed-to object. You can also subtract an integer from a pointer to take the difference between two pointers. The last operation, which yields an integer, is meaningful only if the two pointers point into the same array (pointing to one position past the end is allowed, too); it then yields the separation between the two elements.</p>
<p>Here are some examples:</p>
<p class="programlisting">int tacos[10] = {5,2,8,4,1,2,2,4,6,8};<br/>int * pt = tacos;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// suppose pf and tacos are the address 3000<br/>pt = pt + 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// now pt is 3004 if a int is 4 bytes<br/>int *pe = &#38;tacos[9];&#160;&#160;&#160;&#160;// pe is 3036 if an int is 4 bytes<br/>pe = pe - 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// now pe is 3032, the address of tacos[8]<br/>int diff = pe - pt;&#160;&#160;&#160;&#160;&#160;// diff is 7, the separation between<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// tacos[8] and tacos[1]</p>
<h5 id="ch04lev3sec15">Dynamic Binding and Static Binding for Arrays</h5>
<p>You can use an array declaration to create an array with static binding&#8212;that is, an array whose size is set during the compilation process:</p>
<p class="programlisting">int tacos[10]; // static binding, size fixed at compile time</p>
<p><a id="page_173"/>You use the <code>new []</code> operator to create an array with dynamic binding (a dynamic array)&#8212;that is, an array that is allocated and whose size can be set during runtime. You free the memory with <code>delete []</code> when you are done:</p>
<p class="programlisting">int size;<br/>cin &gt;&gt; size;<br/>int * pz = new int [size];&#160;&#160;&#160;// dynamic binding, size set at run time<br/>...<br/>delete [] pz;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free memory when finished</p>
<h5 id="ch04lev3sec16">Array Notation and Pointer Notation</h5>
<p>Using bracket array notation is equivalent to dereferencing a pointer:</p>
<p class="programlisting">tacos[0] means *tacos means the value at address tacos<br/>tacos[3] means *(tacos + 3) means the value at address tacos + 3</p>
<p>This is true for both array names and pointer variables, so you can use either pointer notation or array notation with pointers and array names.</p>
<p>Here are some examples:</p>
<p class="programlisting">int * pt = new int [10];&#160;&#160;&#160;// pt points to block of 10 ints<br/>*pt = 5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set element number 0 to 5<br/>pt[0] = 6;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// reset element number 0 to 6<br/>pt[9] = 44;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set tenth element (element number 9) to 44<br/>int coats[10];<br/>*(coats + 4) = 12;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set coats[4] to 12</p>
<h4 id="ch04lev2sec30">Pointers and Strings</h4>
<p>The special relationship between arrays and pointers extends to C-style strings. Consider the following code:</p>
<p class="programlisting">char flower[10] = "rose";<br/>cout &lt;&lt; flower &lt;&lt; "s are red\n";</p>
<p>The name of an array is the address of its first element, so <code>flower</code> in the <code>cout</code> statement is the address of the <code>char</code> element containing the character <code>r</code>. The <code>cout</code> object assumes that the address of a <code>char</code> is the address of a string, so it prints the character at that address and then continues printing characters until it runs into the null character (<code>\0</code>). In short, if you give <code>cout</code> the address of a character, it prints everything from that character to the first null character that follows it.</p>
<p>The crucial element here is not that <code>flower</code> is an array name but that <code>flower</code> acts as the address of a <code>char</code>. This implies that you can use a pointer-to-<code>char</code> variable as an argument to <code>cout</code> also because it, too, is the address of a <code>char</code>. Of course, that pointer should point to the beginning of a string. We&#8217;ll check that out in a moment.</p>
<p>But what about the final part of the preceding <code>cout</code> statement? If <code>flower</code> is actually the address of the first character of a string, what is the expression <code>"s are red\n"</code>? To be consistent with <code>cout</code>&#8217;s handling of string output, this quoted string should also be an <a id="page_174"/>address. And it is, for in C++ a quoted string, like an array name, serves as the address of its first element. The preceding code doesn&#8217;t really send a whole string to <code>cout</code>; it just sends the string address. This means strings in an array, quoted string constants, and strings described by pointers are all handled equivalently. Each is really passed along as an address. That&#8217;s certainly less work than passing each and every character in a string.</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note06"/>Note</p>
<p class="notepara">With <code>cout</code> and with most C++ expressions, the name of an array of <code>char</code>, a pointer-to-<code>char</code>, and a quoted string constant are all interpreted as the address of the first character of a string.</p>
<hr/></div>
<p><a href="#ch04ex20">Listing 4.20</a> illustrates the use of the different forms of strings. It uses two functions from the string library. The <code>strlen()</code> function, which you&#8217;ve used before, returns the length of a string. The <code>strcpy()</code> function copies a string from one location to another. Both have function prototypes in the <code>cstring</code> header file (or <code>string.h</code>, on less up-to-date implementations). The program also uses comments to showcase some pointer misuses that you should try to avoid.</p>
<p class="caption1"><a id="ch04ex20"/><strong>Listing 4.20. <code>ptrstr.cpp</code></strong></p><hr/>
<p class="programlisting1">// ptrstr.cpp -- using pointers to strings<br/>#include &lt;iostream&gt;<br/>#include &lt;cstring&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// declare strlen(), strcpy()<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char animal[20] = "bear";&#160;&#160;&#160;// animal holds bear<br/>&#160;&#160;&#160;&#160;const char * bird = "wren"; // bird holds address of string<br/>&#160;&#160;&#160;&#160;char * ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// uninitialized<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; animal &lt;&lt; " and ";&#160;&#160;// display bear<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; bird &lt;&lt; "\n";&#160;&#160;&#160;&#160;&#160;&#160;&#160;// display wren<br/>&#160;&#160;&#160;&#160;// cout &lt;&lt; ps &lt;&lt; "\n";&#160;&#160;&#160;&#160;&#160;&#160;//may display garbage, may cause a crash<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a kind of animal: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; animal;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok if input &lt; 20 chars<br/>&#160;&#160;&#160;&#160;// cin &gt;&gt; ps; Too horrible a blunder to try; ps doesn't<br/>&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;point to allocated space<br/><br/>&#160;&#160;&#160;&#160;ps = animal;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set ps to point to string<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ps &lt;&lt; "!\n";&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok, same as using animal<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Before using strcpy():\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; animal &lt;&lt; " at " &lt;&lt; (int *) animal &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ps &lt;&lt; " at " &lt;&lt; (int *) ps &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;ps = new char[strlen(animal) + 1];&#160;&#160;// get new storage<br/>&#160;&#160;&#160;&#160;strcpy(ps, animal);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// copy string to new storage<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After using strcpy():\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; animal &lt;&lt; " at " &lt;&lt; (int *) animal &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ps &lt;&lt; " at " &lt;&lt; (int *) ps &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;delete [] ps;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_175"/>Here is a sample run of the program in <a href="#ch04ex20">Listing 4.20</a>:</p>
<p class="programlisting">bear and wren<br/>Enter a kind of animal: <span class="EmpStrong">fox</span><br/>fox!<br/>Before using strcpy():<br/>fox at 0x0065fd30<br/>fox at 0x0065fd30<br/>After using strcpy():<br/>fox at 0x0065fd30<br/>fox at 0x004301c8</p>
<h5 id="ch04lev3sec17">Program Notes</h5>
<p>The program in <a href="#ch04ex20">Listing 4.20</a> creates one <code>char</code> array (<code>animal</code>) and two pointers-to-<code>char</code> variables (<code>bird</code> and <code>ps</code>). The program begins by initializing the <code>animal</code> array to the <code>"bear"</code> string, just as you&#8217;ve initialized arrays before. Then, the program does something new. It initializes a pointer-to-<code>char</code> to a string:</p>
<p class="programlisting">const char * bird = "wren"; // bird holds address of string</p>
<p>Remember, <code>"wren"</code> actually represents the address of the string, so this statement assigns the address of <code>"wren"</code> to the <code>bird</code> pointer. (Typically, a compiler sets aside an area in memory to hold all the quoted strings used in the program source code, associating each stored string with its address.) This means you can use the pointer <code>bird</code> just as you would use the string <code>"wren"</code>, as in this example:</p>
<p class="programlisting">cout &lt;&lt; "A concerned " &lt;&lt; bird &lt;&lt; " speaks\n";</p>
<p>String literals are constants, which is why the code uses the <code>const</code> keyword in the declaration. Using <code>const</code> in this fashion means you can use <code>bird</code> to access the string but not to change it. <a href="ch07.html#ch07">Chapter 7</a> takes up the topic of <code>const</code> pointers in greater detail. Finally, the pointer <code>ps</code> remains uninitialized, so it doesn&#8217;t point to any string. (As you know, that is usually a bad idea, and this example is no exception.)</p>
<p>Next, the program illustrates that you can use the array name <code>animal</code> and the pointer <code>bird</code> equivalently with <code>cout</code>. Both, after all, are the addresses of strings, and <code>cout</code> displays the two strings (<code>"bear"</code> and <code>"wren"</code>) stored at those addresses. If you activate the code that makes the error of attempting to display <code>ps</code>, you might get a blank line, you might get garbage displayed, and you might get a program crash. Creating an uninitialized pointer is a bit like distributing a blank signed check: You lack control over how it will be used.</p>
<p><a id="page_176"/>For input, the situation is a bit different. It&#8217;s safe to use the array <code>animal</code> for input as long as the input is short enough to fit into the array. It would not be proper to use <code>bird</code> for input, however:</p>
<p class="indenthandingB">&#8226; Some compilers treat string literals as read-only constants, leading to a runtime error if you try to write new data over them. That string literals be constants is the mandated behavior in C++, but not all compilers have made that change from older behavior yet.</p>
<p class="indenthandingB">&#8226; Some compilers use just one copy of a string literal to represent all occurrences of that literal in a program.</p>
<p>Let&#8217;s amplify the second point. C++ doesn&#8217;t guarantee that string literals are stored uniquely. That is, if you use a string literal <code>"wren"</code> several times in a program, the compiler might store several copies of the string or just one copy. If it does the latter, then setting <code>bird</code> to point to one <code>"wren"</code> makes it point to the only copy of that string. Reading a value into one string could affect what you thought was an independent string elsewhere. In any case, because the <code>bird</code> pointer is declared as <code>const</code>, the compiler prevents any attempt to change the contents of the location pointed to by <code>bird</code>.</p>
<p>Worse yet is trying to read information into the location to which <code>ps</code> points. Because <code>ps</code> is not initialized, you don&#8217;t know where the information will wind up. It might even overwrite information that is already in memory. Fortunately, it&#8217;s easy to avoid these problems: You just use a sufficiently large <code>char</code> array to receive input and don&#8217;t use string constants to receive input or uninitialized pointers to receive input. (Or you can sidestep all these issues and use <code>std::string</code> objects instead of arrays.)</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note07"/>Caution</p>
<p class="notepara">When you read a string into a program-style string, you should always use the address of previously allocated memory. This address can be in the form of an array name or of a pointer that has been initialized using <code>new</code>.</p>
<hr/></div>
<p>Next, notice what the following code accomplishes:</p>
<p class="programlisting">ps = animal;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set ps to point to string<br/>...<br/>cout &lt;&lt; animal &lt;&lt; " at " &lt;&lt; (int *) animal &lt;&lt; endl;<br/>cout &lt;&lt; ps &lt;&lt; " at " &lt;&lt; (int *) ps &lt;&lt; endl;</p>
<p>It produces the following output:</p>
<p class="programlisting">fox at 0x0065fd30<br/>fox at 0x0065fd30</p>
<p>Normally, if you give <code>cout</code> a pointer, it prints an address. But if the pointer is type <code>char *</code>, <code>cout</code> displays the pointed-to string. If you want to see the address of the string, you have to type cast the pointer to another pointer type, such as <code>int *</code>, which this code does. <a id="page_177"/>So <code>ps</code> displays as the string <code>"fox"</code>, but <code>(int *) ps</code> displays as the address where the string is found. Note that assigning <code>animal</code> to <code>ps</code> does not copy the string; it copies the address. This results in two pointers (<code>animal</code> and <code>ps)</code> to the same memory location and string.</p>
<p>To get a copy of a string, you need to do more. First, you need to allocate memory to hold the string. You can do this by declaring a second array or by using <code>new</code>. The second approach enables you to custom fit the storage to the string:</p>
<p class="programlisting">ps = new char[strlen(animal) + 1]; // get new storage</p>
<p>The string <code>"fox"</code> doesn&#8217;t completely fill the <code>animal</code> array, so this approach wastes space. This bit of code uses <code>strlen()</code> to find the length of the string; it adds one to get the length, including the null character. Then the program uses <code>new</code> to allocate just enough space to hold the string.</p>
<p>Next, you need a way to copy a string from the <code>animal</code> array to the newly allocated space. It doesn&#8217;t work to assign <code>animal</code> to <code>ps</code> because that just changes the address stored in <code>ps</code> and thus loses the only way the program had to access the newly allocated memory. Instead, you need to use the <code>strcpy()</code> library function:</p>
<p class="programlisting">strcpy(ps, animal);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// copy string to new storage</p>
<p>The <code>strcpy()</code> function takes two arguments. The first is the destination address, and the second is the address of the string to be copied. It&#8217;s up to you to make certain that the destination really is allocated and has sufficient space to hold the copy. That&#8217;s accomplished here by using <code>strlen()</code> to find the correct size and using <code>new</code> to get free memory.</p>
<p>Note that by using <code>strcpy()</code> and <code>new</code>, you get two separate copies of <code>"fox"</code>:</p>
<p class="programlisting">fox at 0x0065fd30<br/>fox at 0x004301c8</p>
<p>Also note that <code>new</code> located the new storage at a memory location quite distant from that of the array <code>animal</code>.</p>
<p>Often you encounter the need to place a string into an array. You use the <code>=</code> operator when you initialize an array; otherwise, you use <code>strcpy()</code> or <code>strncpy()</code>. You&#8217;ve seen the <code>strcpy()</code> function; it works like this:</p>
<p class="programlisting">char food[20] = "carrots"; // initialization<br/>strcpy(food, "flan");&#160;&#160;&#160;&#160;&#160;&#160;// otherwise</p>
<p>Note that something like the following can cause problems because the <code>food</code> array is smaller than the string:</p>
<p class="programlisting">strcpy(food, "a picnic basket filled with many goodies");</p>
<p>In this case, the function copies the rest of the string into the memory bytes immediately following the array, which can overwrite other memory the program is using. To avoid that problem, you should use <code>strncpy()</code> instead. It takes a third argument: the maximum number of characters to be copied. Be aware, however, that if this function runs out <a id="page_178"/>of space before it reaches the end of the string, it doesn&#8217;t add the null character. Thus, you should use the function like this:</p>
<p class="programlisting">strncpy(food, "a picnic basket filled with many goodies", 19);<br/>food[19] = '\0';</p>
<p>This copies up to 19 characters into the array and then sets the last element to the null character. If the string is shorter than 19 characters, <code>strncpy()</code> adds a null character earlier to mark the true end of the string.</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note08"/>Caution</p>
<p class="notepara">Use <code>strcpy()</code> or <code>strncpy()</code>, not the assignment operator, to assign a string to an array.</p>
<hr/></div>
<p>Now that you&#8217;ve seen some aspects of using C-style strings and the <code>cstring</code> library, you can appreciate the comparative simplicity of using the C++ <code>string</code> type. You (normally) don&#8217;t have to worry about a string overflowing an array, and you can use the assignment operator instead of <code>strcpy()</code> or <code>strncpy()</code>.</p>
<h4 id="ch04lev2sec31">Using <code>new</code> to Create Dynamic Structures</h4>
<p>You&#8217;ve seen how it can be advantageous to create arrays during runtime rather than at compile time. The same holds true for structures. You need to allocate space for only as many structures as a program needs during a particular run. Again, the <code>new</code> operator is the tool to use. With it, you can create dynamic structures. Again, <em>dynamic</em> means the memory is allocated during runtime, not at compile time. Incidentally, because classes are much like structures, you are able to use the techniques you&#8217;ll learn in this section for structures with classes, too.</p>
<p>Using <code>new</code> with structures has two parts: creating the structure and accessing its members. To create a structure, you use the structure type with <code>new</code>. For example, to create an unnamed structure of the <code>inflatable</code> type and assign its address to a suitable pointer, you can use the following:</p>
<p class="programlisting">inflatable * ps = new inflatable;</p>
<p>This assigns to <code>ps</code> the address of a chunk of free memory large enough to hold a structure of the <code>inflatable</code> type. Note that the syntax is exactly the same as it is for C++&#8217;s built-in types.</p>
<p>The tricky part is accessing members. When you create a dynamic structure, you can&#8217;t use the dot membership operator with the structure name because the structure has no name. All you have is its address. C++ provides an operator just for this situation: the arrow membership operator (<code>-&gt;</code>). This operator, formed by typing a hyphen and then a greater-than symbol, does for pointers to structures what the dot operator does for structure names. For example, if <code>ps</code> points to a type <code>inflatable</code> structure, then <code>ps-&gt;price</code> is the <code>price</code> member of the pointed-to structure (see <a href="#ch04fig11">Figure 4.11</a>).</p>
<p class="caption"><a id="page_179"/><a id="ch04fig11"/><strong>Figure 4.11. Identifying structure members.</strong></p>
<p class="image"><img src="graphics/04fig11.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch04note09"/>Tip</p>
<p class="notepara">Sometimes new C++ users become confused about when to use the dot operator and when to use the arrow operator to specify a structure member. The rule is simple: If the structure identifier is the name of a structure, use the dot operator. If the identifier is a pointer to the structure, use the arrow operator.</p>
<hr/></div>
<p>A second, uglier approach to accessing structure members is to realize that if <code>ps</code> is a pointer to a structure, then <code>*ps</code> represents the pointed-to value&#8212;the structure itself. Then, because <code>*ps</code> is a structure, <code>(*ps).price</code> is the <code>price</code> member of the structure. C++&#8217;s operator precedence rules require that you use parentheses in this construction.</p>
<p><a href="#ch04ex21">Listing 4.21</a> uses <code>new</code> to create an unnamed structure and demonstrates both pointer notations for accessing structure members.</p>
<p class="caption1"><a id="ch04ex21"/><strong>Listing 4.21. <code>newstrct.cpp</code></strong></p><hr/>
<p class="programlisting1">// newstrct.cpp -- using new with a structure<br/>#include &lt;iostream&gt;<br/>struct inflatable&#160;&#160;&#160;// structure definition<br/>{<br/>&#160;&#160;&#160;&#160;char name[20];<br/>&#160;&#160;&#160;&#160;float volume;<br/>&#160;&#160;&#160;&#160;double price;<br/>};<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;inflatable * ps = new inflatable; // allot memory for structure<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter name of inflatable item: ";<br/>&#160;&#160;&#160;&#160;cin.get(ps-&gt;name, 20);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// method 1 for member access<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter volume in cubic feet: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; (*ps).volume;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// method 2 for member access<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter price: $";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ps-&gt;price;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: " &lt;&lt; (*ps).name &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// method 2<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Volume: " &lt;&lt; ps-&gt;volume &lt;&lt; " cubic feet\n"; // method 1<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Price: $" &lt;&lt; ps-&gt;price &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// method 1<br/>&#160;&#160;&#160;&#160;delete ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free memory used by structure<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_180"/>Here is a sample run of the program in <a href="#ch04ex21">Listing 4.21</a>:</p>
<p class="programlisting">Enter name of inflatable item: <span class="EmpStrong">Fabulous Frodo</span><br/>Enter volume in cubic feet: <span class="EmpStrong">1.4</span><br/>Enter price: <span class="EmpStrong">$27.99</span><br/>Name: Fabulous Frodo<br/>Volume: 1.4 cubic feet<br/>Price: $27.99</p>
<h5 id="ch04lev3sec18">An Example of Using <code>new</code> and <code>delete</code></h5>
<p>Let&#8217;s look at an example that uses <code>new</code> and <code>delete</code> to manage storing string input from the keyboard. <a href="#ch04ex22">Listing 4.22</a> defines a function <code>getname()</code> that returns a pointer to an input string. This function reads the input into a large temporary array and then uses <code>new []</code> with an appropriate size to create a chunk of memory sized to fit to the input string. Then the function returns the pointer to the block. This approach could conserve a lot of memory for programs that read in a large number of strings. (In real life, where many of us live, it would be easier to use the <code>string</code> class, which has the use of <code>new</code> and <code>delete</code> built in to its design.)</p>
<p>Suppose your program has to read 1,000 strings and that the largest string might be 79 characters long, but most of the strings are much shorter than that. If you used <code>char</code> arrays to hold the strings, you&#8217;d need 1,000 arrays of 80 characters each. That&#8217;s 80,000 bytes, and much of that block of memory would wind up being unused. Alternatively, you could create an array of 1,000 pointers to <code>char</code> and then use <code>new</code> to allocate only the amount of memory needed for each string. That could save tens of thousands of bytes. Instead of having to use a large array for every string, you fit the memory to the input. Even better, you could also use <code>new</code> to find space to store only as many pointers as needed. Well, that&#8217;s a little too ambitious for right now. Even using an array of 1,000 pointers is a little too ambitious for right now, but <a href="#ch04ex22">Listing 4.22</a> illustrates some of the technique. Also just to illustrate how <code>delete</code> works, the program uses it to free memory for reuse.</p>
<p class="caption1"><a id="page_181"/><a id="ch04ex22"/><strong>Listing 4.22. <code>delete.cpp</code></strong></p><hr/>
<p class="programlisting1">// delete.cpp -- using the delete operator<br/>#include &lt;iostream&gt;<br/>#include &lt;cstring&gt;&#160;&#160;&#160;&#160;&#160;&#160;// or string.h<br/>using namespace std;<br/>char * getname(void);&#160;&#160;&#160;// function prototype<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;char * name;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create pointer but no storage<br/><br/>&#160;&#160;&#160;&#160;name = getname();&#160;&#160;&#160;// assign address of string to name<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; name &lt;&lt; " at " &lt;&lt; (int *) name &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;delete [] name;&#160;&#160;&#160;&#160;&#160;// memory freed<br/><br/>&#160;&#160;&#160;&#160;name = getname();&#160;&#160;&#160;// reuse freed memory<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; name &lt;&lt; " at " &lt;&lt; (int *) name &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;delete [] name;&#160;&#160;&#160;&#160;&#160;// memory freed again<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>char * getname()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// return pointer to new string<br/>{<br/>&#160;&#160;&#160;&#160;char temp[80];&#160;&#160;&#160;&#160;&#160;&#160;// temporary storage<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter last name: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; temp;<br/>&#160;&#160;&#160;&#160;char * pn = new char[strlen(temp) + 1];<br/>&#160;&#160;&#160;&#160;strcpy(pn, temp);&#160;&#160;&#160;// copy string into smaller space<br/><br/>&#160;&#160;&#160;&#160;return pn;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// temp lost when function ends<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch04ex22">Listing 4.22</a>:</p>
<p class="programlisting">Enter last name: Fredeldumpkin<br/>Fredeldumpkin at 0x004326b8<br/>Enter last name: Pook<br/>Pook at 0x004301c8</p>
<h5 id="ch04lev3sec19">Program Notes</h5>
<p>Consider the function <code>getname()</code> in the program in <a href="#ch04ex22">Listing 4.22</a>. It uses <code>cin</code> to place an input word into the <code>temp</code> array. Next, it uses <code>new</code> to allocate new memory to hold the word. Including the null character, the program needs <code>strlen(temp) + 1</code> characters to store the string, so that&#8217;s the value given to <code>new</code>. After the space becomes available, <code>getname()</code> uses the standard library function <code>strcpy()</code> to copy the string from <code>temp</code> to the new block. The function doesn&#8217;t check to see whether the string fits, but <code>getname()</code> <a id="page_182"/>covers that by requesting the right number of bytes with <code>new</code>. Finally, the function returns <code>pn</code>, the address of the string copy.</p>
<p>In <code>main()</code>, the return value (the address) is assigned to the pointer <code>name</code>. This pointer is defined in <code>main()</code>, but it points to the block of memory allocated in the <code>getname()</code> function. The program then prints the string and the address of the string.</p>
<p>Next, after it frees the block pointed to by <code>name</code>, <code>main()</code> calls <code>getname()</code> a second time. C++ doesn&#8217;t guarantee that newly freed memory is the first to be chosen the next time <code>new</code> is used, and in this sample run, it isn&#8217;t.</p>
<p>Note in this example that <code>getname()</code> allocates memory and <code>main()</code> frees it. It&#8217;s usually not a good idea to put <code>new</code> and <code>delete</code> in separate functions because that makes it easier to forget to use <code>delete</code>. But this example does separate <code>new</code> from <code>delete</code> just to show that it is possible.</p>
<p>To appreciate some of the more subtle aspects of this program, you should know a little more about how C++ handles memory. So let&#8217;s preview some material that&#8217;s covered more fully in <a href="ch09.html#ch09">Chapter 9</a>.</p>
<h4 id="ch04lev2sec32">Automatic Storage, Static Storage, and Dynamic Storage</h4>
<p>C++ has three ways of managing memory for data, depending on the method used to allocate memory: automatic storage, static storage, and dynamic storage, sometimes called the <em>free store</em> or <em>heap.</em> Data objects allocated in these three ways differ from each other in how long they remain in existence. We&#8217;ll take a quick look at each type. (C++11 adds a fourth form called <em>thread storage</em> that we&#8217;ll discuss briefly in <a href="ch09.html#ch09">Chapter 9</a>.)</p>
<h5 id="ch04lev3sec20">Automatic Storage</h5>
<p>Ordinary variables defined inside a function use <em>automatic storage</em> and are called <em>automatic variables</em>. These terms mean that the variables come into existence automatically when the function containing them is invoked, and they expire when the function terminates. For example, the <code>temp</code> array in <a href="#ch04ex22">Listing 4.22</a> exists only while the <code>getname()</code> function is active. When program control returns to <code>main()</code>, the memory used for <code>temp</code> is freed automatically. If <code>getname()</code> returned the address of <code>temp</code>, the <code>name</code> pointer in <code>main()</code> would be left pointing to a memory location that would soon be reused. That&#8217;s one reason you have to use <code>new</code> in <code>getname()</code>. Actually, automatic values are local to the block that contains them. A <em>block</em> is a section of code enclosed between braces. So far, all our blocks have been entire functions. But as you&#8217;ll see in the next chapter, you can have blocks within a function. If you define a variable inside one of those blocks, it exists only while the program is executing statements inside the block.</p>
<p>Automatic variables typically are stored on a <em>stack</em>. This means that when program execution enters a block of code, its variables are added consecutively to the stack in memory and then are freed in reverse order when execution leaves the block. (This is called a <em>last-in, first-out</em>, or <em>LIFO</em>, process.) So the stack grows and shrinks as execution proceeds.</p>
<h5 id="ch04lev3sec21">Static Storage</h5>
<p><a id="page_183"/>Static storage is storage that exists throughout the execution of an entire program. There are two ways to make a variable static. One is to define it externally, outside a function. The other is to use the keyword <code>static</code> when declaring a variable:</p>
<p class="programlisting">static double fee = 56.50;</p>
<p>Under K&#38;R C, you can initialize only static arrays and structures, whereas C++ Release 2.0 (and later) and ANSI C allow you to initialize automatic arrays and structures, too. However, as you may have discovered, some C++ implementations do not yet implement initialization for automatic arrays and structures.</p>
<p><a href="ch09.html#ch09">Chapter 9</a> discusses static storage in more detail. The main point you should note now about automatic and static storage is that these methods rigidly define the lifetime of a variable. Either the variable exists for the entire duration of a program (a static variable) or it exists only while a particular function is being executed (an automatic variable).</p>
<h5 id="ch04lev3sec22">Dynamic Storage</h5>
<p>The <code>new</code> and <code>delete</code> operators provide a more flexible approach than automatic and static variables. They manage a pool of memory, which C++ refers to as the <em>free store</em> or <em>heap</em>. This pool is separate from the memory used for static and automatic variables. As <a href="#ch04ex22">Listing 4.22</a> shows, <code>new</code> and <code>delete</code> enable you to allocate memory in one function and free it in another. Thus, the lifetime of the data is not tied arbitrarily to the life of the program or the life of a function. Using <code>new</code> and <code>delete</code> together gives you much more control over how a program uses memory than does using ordinary variables. However, memory management becomes more complex. In a stack, the automatic addition and removal mechanism results in the part of memory in use always being contiguous. But the interplay between <code>new</code> and <code>delete</code> can leave holes in the free store, making keeping track of where to allocate new memory requests more difficult.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch04sb07"/>Stacks, Heaps, and Memory Leaks</p>
<p class="sidebarpara">What happens if you <em>don&#8217;t</em> call <code>delete</code> after creating a variable on the free store (or heap) with the <code>new</code> operator? The variable or construct dynamically allocated on the free store continues to persist if <code>delete</code> is not called, even though the memory that contains the pointer has been freed due to rules of scope and object lifetime. In essence, you have no way to access the construct on the free store because the pointer to the memory that contains it is gone. You have now created a <em>memory leak</em>. Memory that has been leaked remains unusable through the life of the program; it&#8217;s been allocated but can&#8217;t be deallocated. In extreme (though not uncommon) cases, memory leaks can be so severe that they use up all the memory available to the application, causing it to crash with an out-of-memory error. In addition, these leaks may negatively affect some operating systems or other applications running in the same memory space, causing them, in turn, to fail.</p>
<p class="sidebarpara">Even the best programmers and software companies create memory leaks. To avoid them, it&#8217;s best to get into the habit of joining your <code>new</code> and <code>delete</code> operators immediately, planning for and entering the deletion of your construct as soon as you dynamically allocate it on the free store. C++&#8217;s smart pointers (<a href="ch16.html#ch16">Chapter 16</a>) help automate the task.</p>
<hr/></div>
<div class="note"><hr/>
<p class="title"><a id="ch04note10"/><a id="page_184"/>Note</p>
<p class="notepara">Pointers are among the most powerful of C++ tools. They are also the most dangerous because they permit computer-unfriendly actions, such as using an uninitialized pointer to access memory or attempting to free the same memory block twice. Furthermore, until you get used to pointer notation and pointer concepts through practice, pointers can be confusing. Because pointers are an important part of C++ programming, they weave in and out of future discussions in this book. This book discusses pointers several more times. The hope is that each exposure will make you more comfortable with them.</p>
<hr/></div>
<h3 id="ch04lev1sec9">Combinations of Types</h3>
<p>This chapter has introduced arrays, structures, and pointers. These can be combined in various ways, so let&#8217;s review some of the possibilities, starting with a structure:</p>
<p class="programlisting">struct antarctica_years_end<br/>{<br/>&#160;&#160;&#160;&#160;int year;<br/>&#160;/* some really interesting data, etc. */<br/>};</p>
<p>We can create variables of this type:</p>
<p class="programlisting">antarctica_years_end s01, s02, s03;&#160;&#160;// s01, s02, s03 are structures</p>
<p>We can then access members using the membership operator:</p>
<p class="programlisting">s01.year = 1998;</p>
<p>We can create a pointer to such a structure:</p>
<p class="programlisting">antarctica_years_end * pa = &#38;s02;</p>
<p>Provided the pointer has been set to a valid address, we then can use the indirect membership operator to access members:</p>
<p class="programlisting">pa-&gt;year = 1999;</p>
<p>We can create arrays of structures:</p>
<p class="programlisting">antarctica_years_end trio[3]; // array of 3 structures</p>
<p>We then can use the membership operator to access members of an element:</p>
<p class="programlisting">trio[0].year = 2003;&#160;&#160;// trio[0] is a structure</p>
<p>Here, <code>trio</code> is an array, but <code>trio[0]</code> is a structure, and <code>trio[0].year</code> is a member of that structure. Because an array name is a pointer, we also can use the indirect membership operator:</p>
<p class="programlisting">(trio+1)-&gt;year = 2004; // same as trio[1].year = 2004;</p>
<p>We can create an array of pointers:</p>
<p class="programlisting">const antarctica_years_end * arp[3] = {&#38;s01, &#38;s02, &#38;s03};</p>
<p><a id="page_185"/>This is starting to look a bit complicated. How can we access data with this array? Well, if <code>arp</code> is an array of pointers, then <code>arp[1]</code> must be a pointer, and we can use the indirect membership operator with it to access a member:</p>
<p class="programlisting">std::cout &lt;&lt; arp[1]-&gt;year &lt;&lt; std::endl;</p>
<p>We can create a pointer to such an array:</p>
<p class="programlisting">const antarctica_years_end ** ppa = arp;</p>
<p>Here, <code>arp</code> is the name of an array; hence, it is the address of its first element. But its first element is a pointer, so <code>ppa</code> has to be a pointer to a pointer to <code>const antarctica_years_end</code>, hence the <code>**</code>. There are several ways you could mess up this declaration. For example, you could omit the <code>const</code>, forget an <code>*</code> or two, transpose letters, or otherwise mangle the structure type. Here is an instance for which the C++11 version of <code>auto</code> is convenient. The compiler is perfectly aware of what type <code>arp</code> is, so it can deduce the correct type for you:</p>
<p class="programlisting">auto ppb = arp; // C++11 automatic type deduction</p>
<p>In the past, the compiler used its knowledge of the correct type to complain about errors you may have made in the declaration; now it can let its knowledge work for you.</p>
<p>How can you use <code>ppa</code> to access data? Because <code>ppa</code> is a pointer to a pointer to a structure, <code>*ppa</code> is a pointer to a structure, so you can use it with the indirect membership operator:</p>
<p class="programlisting">std::cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; std::endl;<br/>std::cout &lt;&lt; (*(ppb+1))-&gt;year &lt;&lt; std::endl;</p>
<p>Because <code>ppa</code> points to the first member of <code>arp</code>, <code>*ppa</code> is the first member, which is <code>&#38;s01</code>. So <code>(*ppa)-&gt;year</code> is the <code>year</code> member of <code>s01</code>. In the second statement, <code>ppb+1</code> points to the next element, <code>arp[1]</code>, which is <code>&#38;s02</code>. The parentheses are needed to get the correct associations. For example, <code>*ppa-&gt;year</code> would attempt to apply the <code>*</code> operator to <code>ppa-&gt;year</code>, which fails because the <code>year</code> member is not a pointer.</p>
<p>Is all this really true? <a href="#ch04ex23">Listing 4.23</a> incorporates all the preceding statements into a short program.</p>
<p class="caption1"><a id="ch04ex23"/><strong>Listing 4.23. <code>mixtypes.cpp</code></strong></p><hr/>
<p class="programlisting1">// mixtypes.cpp -- some type combinations<br/>#include &lt;iostream&gt;<br/><br/>struct antarctica_years_end<br/>{<br/>&#160;&#160;&#160;&#160;int year;<br/>&#160;/* some really interesting data, etc. */<br/>};<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;antarctica_years_end s01, s02, s03;<br/>&#160;&#160;&#160;&#160;s01.year = 1998;<br/>&#160;&#160;&#160;&#160;antarctica_years_end * pa = &#38;s02;<br/>&#160;&#160;&#160;&#160;pa-&gt;year = 1999;<br/>&#160;&#160;&#160;&#160;antarctica_years_end trio[3]; // array of 3 structures<br/>&#160;&#160;&#160;&#160;trio[0].year = 2003;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; trio-&gt;year &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;const antarctica_years_end * arp[3] = {&#38;s01, &#38;s02, &#38;s03};<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; arp[1]-&gt;year &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;const antarctica_years_end ** ppa = arp;<br/>&#160;&#160;&#160;&#160;auto ppb = arp; // C++11 automatic type deduction<br/>// or else&#160;&#160;use const antarctica_years_end ** ppb = arp;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; (*(ppb+1))-&gt;year &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_186"/>Here&#8217;s the output:</p>
<p class="programlisting">2003<br/>1999<br/>1998<br/>1999</p>
<p>The program compiles and works as promised.</p>
<h3 id="ch04lev1sec10">Array Alternatives</h3>
<p>Earlier this chapter mentioned the <code>vector</code> and <code>array</code> template classes as alternatives to the built-in array. Let&#8217;s take a brief look now at how they are used and at some of the benefits of using them.</p>
<h4 id="ch04lev2sec33">The <code>vector</code> Template Class</h4>
<p>The <code>vector</code> template class is similar to the <code>string</code> class in that it is a dynamic array. You can set the size of a <code>vector</code> object during runtime, and you can append new data to the end or insert new data in the middle. Basically, it&#8217;s an alternative to using <code>new</code> to create a dynamic array. Actually, the <code>vector</code> class does use <code>new</code> and <code>delete</code> to manage memory, but it does so automatically.</p>
<p>At this time we won&#8217;t venture very deeply into what it means to be a template class. Instead, we&#8217;ll look at a few basic practical matters. First, to use a <code>vector</code> object, you need to include the <code>vector</code> header file. Second, the <code>vector</code> identifier is part of the <code>std</code> namespace, so you can use a <code>using</code> directive, a <code>using</code> declaration, or <code>std::vector</code>. Third, <a id="page_187"/>templates use a different syntax to indicate the type of data stored. Fourth, the <code>vector</code> class uses a different syntax to indicate the number of elements. Here are some examples:</p>
<p class="programlisting">#include &lt;vector&gt;<br/>...<br/>using namespace std;<br/>vector&lt;int&gt; vi;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create a zero-size array of int<br/>int n;<br/>cin &gt;&gt; n;<br/>vector&lt;double&gt; vd(n);&#160;&#160;// create an array of n doubles</p>
<p>We say that <code>vi</code> is an object of type <code>vector&lt;int&gt;</code> and that <code>vd</code> is an object of type <code>vector&lt;double&gt;</code>. Because <code>vector</code> objects resize automatically when you insert or add values to them, it&#8217;s okay for <code>vi</code> to start with 0 size. But for the resizing to work, you would use the various methods that are part of the <code>vector</code> package.</p>
<p>In general, the following declaration creates a <code>vector</code> object <code>vt</code> that can hold <em><code>n_elem</code></em> elements of type <em><code>typeName</code></em>:</p>
<p class="programlisting">vector&lt;<span class="EmpItalic">typeName</span>&gt; vt(<span class="EmpItalic">n_elem</span>);</p>
<p>The parameter <em><code>n_elem</code></em> can be an integer constant or an integer variable.</p>
<h4 id="ch04lev2sec34">The <code>array</code> Template Class (C++11)</h4>
<p>The <code>vector</code> class has more capabilities than the built-in array type, but this comes at a cost of slightly less efficiency. If all you need is a fixed-size array, it could be advantageous to use the built-in type. However, that has its own costs of lessened convenience and safety. C++11 responded to this situation by adding the <code>array</code> template class, which is part of the <code>std</code> namespace. Like the built-in type, an array object has a fixed size and uses the stack (or else static memory allocation) instead of the free store, so it shares the efficiency of built-in arrays. To this it adds convenience and additional safety. To create an <code>array</code> object, you need to include the <code>array</code> header file. The syntax is a bit different from that for a <code>vector</code>:</p>
<p class="programlisting">#include &lt;array&gt;<br/>...<br/>using namespace std;<br/>array&lt;int, 5&gt; ai;&#160;&#160;&#160;// create array object of 5 ints<br/>array&lt;double, 4&gt; ad = {1.2, 2.1, 3.43. 4.3};</p>
<p>More general, the following declaration creates an <code>array</code> object <code>arr</code> with <em><code>n_elem</code></em> elements of <em><code>typeName</code></em>:</p>
<p class="programlisting">array&lt;<span class="EmpItalic">typeName</span>, <span class="EmpItalic">n_elem</span>&gt; arr;</p>
<p>Unlike the case for vector, <em><code>n_elem</code></em> can&#8217;t be a variable.</p>
<p>With C++11, you can use list-initialization with <code>vector</code> and <code>array</code> objects. However, that was not an option with C++98 <code>vector</code> objects.</p>
<h4 id="ch04lev2sec35">Comparing Arrays, <code>Vector</code> Objects, and <code>Array</code> Objects</h4>
<p><a id="page_188"/>Perhaps the simplest way to understand the similarities and differences between arrays, <code>vector</code> objects, and <code>array</code> objects is to look at a brief example (<a href="#ch04ex24">Listing 4.24</a>) that uses all three approaches.</p>
<p class="caption1"><a id="ch04ex24"/><strong>Listing 4.24. <code>choices.cpp</code></strong></p><hr/>
<p class="programlisting1">// choices.cpp -- array variations<br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;&#160;&#160;&#160;// STL C++98<br/>#include &lt;array&gt;&#160;&#160;&#160;&#160;// C++11<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>// C, original C++<br/>&#160;&#160;&#160;&#160;double a1[4] = {1.2, 2.4, 3.6, 4.8};<br/>// C++98 STL<br/>&#160;&#160;&#160;&#160;vector&lt;double&gt; a2(4);&#160;&#160;&#160;// create vector with 4 elements<br/>// no simple way to initialize in C98<br/>&#160;&#160;&#160;&#160;a2[0] = 1.0/3.0;<br/>&#160;&#160;&#160;&#160;a2[1] = 1.0/5.0;<br/>&#160;&#160;&#160;&#160;a2[2] = 1.0/7.0;<br/>&#160;&#160;&#160;&#160;a2[3] = 1.0/9.0;<br/>// C++11 -- create and initialize array object<br/>&#160;&#160;&#160;&#160;array&lt;double, 4&gt; a3 = {3.14, 2.72, 1.62, 1.41};<br/>&#160;&#160;&#160;&#160;array&lt;double, 4&gt; a4;<br/>&#160;&#160;&#160;&#160;a4 = a3;&#160;&#160;&#160;&#160;&#160;// valid for array objects of same size<br/>// use array notation<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a1[2]: " &lt;&lt; a1[2] &lt;&lt; " at " &lt;&lt; &#38;a1[2] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a2[2]: " &lt;&lt; a2[2] &lt;&lt; " at " &lt;&lt; &#38;a2[2] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a3[2]: " &lt;&lt; a3[2] &lt;&lt; " at " &lt;&lt; &#38;a3[2] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a4[2]: " &lt;&lt; a4[2] &lt;&lt; " at " &lt;&lt; &#38;a4[2] &lt;&lt; endl;<br/>// misdeed<br/>&#160;&#160;&#160;&#160;a1[-2] = 20.2;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a1[-2]: " &lt;&lt; a1[-2] &lt;&lt;" at " &lt;&lt; &#38;a1[-2] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a3[2]: " &lt;&lt; a3[2] &lt;&lt; " at " &lt;&lt; &#38;a3[2] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a4[2]: " &lt;&lt; a4[2] &lt;&lt; " at " &lt;&lt; &#38;a4[2] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s some sample output:</p>
<p class="programlisting">a1[2]: 3.6 at 0x28cce8<br/>a2[2]: 0.142857 at 0xca0328<br/>a3[2]: 1.62 at 0x28ccc8<br/>a4[2]: 1.62 at 0x28cca8<br/><a id="page_189"/>a1[-2]: 20.2 at 0x28ccc8<br/>a3[2]: 20.2 at 0x28ccc8<br/>a4[2]: 1.62 at 0x28cca8</p>
<h5 id="ch04lev3sec23">Program Notes</h5>
<p>First, notice that whether we use a built-in array, a <code>vector</code> object, or an <code>array</code> object, we can use the standard array notation to access individual members. Second, you can see from the addresses that <code>array</code> objects use the same region of memory (the stack, in this case) as the built-in array, whereas the <code>vector</code> object is stored in a different region (the free store, or heap). Third, note that you can assign an <code>array</code> object to another <code>array</code> object. For built-in arrays, you have to copy the data element-by-element.</p>
<p>Next, and this deserves special attention, note this line:</p>
<p class="programlisting">a1[-2] = 20.2;</p>
<p>What does an index of <code>-2</code> mean? Recall that this translates to the following:</p>
<p class="programlisting">*(a1-2) = 20.2;</p>
<p>Expressing this in words, see where <code>a1</code> points, move backward two <code>double</code> elements, and put <code>20.2</code> there. That is, store the information at a location outside of the array. C++, like C, does not check for such out-of-range errors. In this particular case, that location turned out to be in the <code>array</code> object <code>a3</code>. Another compiler placed the wayward <code>20.2</code> in <code>a4</code>, and other compilers might make yet other bad choices. This is an example of the unsafe behavior of built-in arrays.</p>
<p>Do the <code>vector</code> and <code>array</code> objects protect against this behavior? They can if you let them. That is, you still can write unsafe code, such as the following:</p>
<p class="programlisting">a2[-2] = .5;&#160;&#160;&#160;&#160;// still allowed<br/>a3[200] = 1.4;</p>
<p>However, you have alternatives. One is using the <code>at()</code> member function. Just as you can use the <code>getline()</code> member function with the <code>cin</code> object, you can use the <code>at()</code> member function with objects of the <code>vector</code> or <code>array</code> type:</p>
<p class="programlisting">a2.at(1) = 2.3;&#160;&#160;// assign 2.3 to a2[1]</p>
<p>The difference between using bracket notation and the <code>at()</code> member function is that if you use <code>at(</code>), an invalid index is caught during runtime and the program, by default, aborts. This added checking does come at the cost of increased run time, which is why C++ gives you the option of using either notation. More than that, these classes offer ways of using objects that reduce the chances of accidental range errors. For example, the classes have <code>begin()</code> and <code>end()</code> member functions that let you delimit the range without accidentally exceeding the bounds. But we&#8217;ll save that discussion until <a href="ch16.html#ch16">Chapter 16</a>.</p>
<h3 id="ch04lev1sec11">Summary</h3>
<p><a id="page_190"/>Arrays, structures, and pointers are three C++ compound types. An array can hold several values, all of the same type, in a single data object. By using an index, or subscript, you can access the individual elements in an array.</p>
<p>A structure can hold several values of different types in a single data object, and you can use the membership operator (<code>.</code>) to access individual members. The first step in using structures is to create a structure template that defines what members the structure holds. The name, or tag, for this template then becomes a new type identifier. You can then declare structure variables of that type.</p>
<p>A union can hold a single value, but it can be of a variety of types, with the member name indicating which mode is being used.</p>
<p>Pointers are variables that are designed to hold addresses. We say a pointer points to the address it holds. The pointer declaration always states to what type of object a pointer points. Applying the dereferencing operator (<code>*</code>) to a pointer yields the value at the location to which the pointer points.</p>
<p>A string is a series of characters terminated by a null character. A string can be represented by a quoted string constant, in which case the null character is implicitly understood. You can store a string in an array of <code>char</code>, and you can represent a string with a pointer-to-<code>char</code> that is initialized to point to the string. The <code>strlen()</code> function returns the length of a string, not counting the null character. The <code>strcpy()</code> function copies a string from one location to another. When using these functions, you include the <code>cstring</code> or the <code>string.h</code> header file.</p>
<p>The C++ <code>string</code> class, supported by the <code>string</code> header file, offers an alternative, more user-friendly means to deal with strings. In particular, <code>string</code> objects are automatically resized to accommodate stored strings, and you can use the assignment operator to copy a string.</p>
<p>The <code>new</code> operator lets you request memory for a data object while a program is running. The operator returns the address of the memory it obtains, and you can assign that address to a pointer. The only means to access that memory is to use the pointer. If the data object is a simple variable, you can use the dereferencing operator (<code>*</code>) to indicate a value. If the data object is an array, you can use the pointer as if it were an array name to access the elements. If the data object is a structure, you can use the pointer dereferencing operator (<code>-&gt;</code>) to access structure members.</p>
<p>Pointers and arrays are closely connected. If <code>ar</code> is an array name, then the expression <code>ar[i]</code> is interpreted as <code>*(ar + i)</code>, with the array name interpreted as the address of the first element of the array. Thus, the array name plays the same role as a pointer. In turn, you can use a pointer name with array notation to access elements in an array allocated by <code>new</code>.</p>
<p>The <code>new</code> and <code>delete</code> operators let you explicitly control when data objects are allocated and when they are returned to the memory pool. Automatic variables, which are those declared within a function, and static variables, which are defined outside a function or with the keyword <code>static</code>, are less flexible. An automatic variable comes into being <a id="page_191"/>when the block containing it (typically a function definition) is entered, and it expires when the block is left. A static variable persists for the duration of a program.</p>
<p>The Standard Template Library (STL), added by the C++98 standard, provides a <code>vector</code> template class that provides an alternative to do-it-yourself dynamic arrays. C++11 provides an <code>array</code> template class that offers an alternative to fixed-sized built-in arrays.</p>
<h3 id="ch04lev1sec12">Chapter Review</h3>
<p class="question"><a id="ch04qa1q1" href="app10.html#ch04qa1a1"><strong>1.</strong></a> How would you declare each of the following?</p>
<p class="indenthandinga"><strong>a.</strong> <code>actors</code> is an array of 30 <code>char</code>.</p>
<p class="indenthandinga"><strong>b.</strong> <code>betsie</code> is an array of 100 <code>short</code>.</p>
<p class="indenthandinga"><strong>c.</strong> <code>chuck</code> is an array of 13 <code>float</code>.</p>
<p class="indenthandinga"><strong>d.</strong> <code>dipsea</code> is an array of 64 <code>long double</code>.</p>
<p class="question"><a id="ch04qa1q2" href="app10.html#ch04qa1a2"><strong>2.</strong></a> Does Chapter Review Question 1 use the array template class instead of built-in arrays.</p>
<p class="question"><a id="ch04qa1q3" href="app10.html#ch04qa1a3"><strong>3.</strong></a> Declare an array of five <code>int</code>s and initialize it to the first five odd positive integers.</p>
<p class="question"><a id="ch04qa1q4" href="app10.html#ch04qa1a4"><strong>4.</strong></a> Write a statement that assigns the sum of the first and last elements of the array in Question 3 to the variable <code>even</code>.</p>
<p class="question"><a id="ch04qa1q5" href="app10.html#ch04qa1a5"><strong>5.</strong></a> Write a statement that displays the value of the second element in the <code>float</code> array <code>ideas</code>.</p>
<p class="question"><a id="ch04qa1q6" href="app10.html#ch04qa1a6"><strong>6.</strong></a> Declare an array of <code>char</code> and initialize it to the string <code>"cheeseburger"</code>.</p>
<p class="question"><a id="ch04qa1q7" href="app10.html#ch04qa1a7"><strong>7.</strong></a> Declare a <code>string</code> object and initialize it to the string <code>"Waldorf Salad"</code>.</p>
<p class="question"><a id="ch04qa1q8" href="app10.html#ch04qa1a8"><strong>8.</strong></a> Devise a structure declaration that describes a fish. The structure should include the kind, the weight in whole ounces, and the length in fractional inches.</p>
<p class="question"><a id="ch04qa1q9" href="app10.html#ch04qa1a9"><strong>9.</strong></a> Declare a variable of the type defined in Question 8 and initialize it.</p>
<p class="question1"><a id="ch04qa1q10" href="app10.html#ch04qa1a10"><strong>10.</strong></a> Use <code>enum</code> to define a type called <code>Response</code> with the possible values <code>Yes</code>, <code>No</code>, and <code>Maybe</code>. <code>Yes</code> should be <code>1</code>, <code>No</code> should be <code>0</code>, and <code>Maybe</code> should be <code>2</code>.</p>
<p class="question1"><a id="ch04qa1q11" href="app10.html#ch04qa1a11"><strong>11.</strong></a> Suppose <code>ted</code> is a <code>double</code> variable. Declare a pointer that points to <code>ted</code> and use the pointer to display <code>ted</code>&#8217;s value.</p>
<p class="question1"><a id="ch04qa1q12" href="app10.html#ch04qa1a12"><strong>12.</strong></a> Suppose <code>treacle</code> is an array of 10 <code>float</code>s. Declare a pointer that points to the first element of <code>treacle</code> and use the pointer to display the first and last elements of the array.</p>
<p class="question1"><a id="ch04qa1q13" href="app10.html#ch04qa1a13"><strong>13.</strong></a> Write a code fragment that asks the user to enter a positive integer and then creates a dynamic array of that many <code>int</code>s. Do this by using <code>new</code>, then again using a <code>vector</code> object.</p>
<p class="question1"><a id="page_192"/><a id="ch04qa1q14" href="app10.html#ch04qa1a14"><strong>14.</strong></a> Is the following valid code? If so, what does it print?</p>
<p class="programlistingB">cout &lt;&lt; (int *) "Home of the jolly bytes";</p>
<p class="question1"><a id="ch04qa1q15" href="app10.html#ch04qa1a15"><strong>15.</strong></a> Write a code fragment that dynamically allocates a structure of the type described in Question 8 and then reads a value for the <code>kind</code> member of the structure.</p>
<p class="question1"><a id="ch04qa1q16" href="app10.html#ch04qa1a16"><strong>16.</strong></a> <a href="#ch04ex06">Listing 4.6</a> illustrates a problem created by following numeric input with line-oriented string input. How would replacing this:</p>
<p class="programlistingB">cin.getline(address,80);</p>
<p class="questionp">with this:</p>
<p class="programlistingB">cin &gt;&gt; address;</p>
<p class="questionp">affect the working of this program?</p>
<p class="question1"><a id="ch04qa1q17" href="app10.html#ch04qa1a17"><strong>17.</strong></a> Declare a vector object of 10 string objects and an array object of 10 string objects. Show the necessary header files and don&#8217;t use <code>using</code>. Do use a <code>const</code> for the number of strings.</p>
<h3 id="ch04lev1sec13">Programming Exercises</h3>
<p class="question"><a id="ch04qa2q1"/><strong>1.</strong> Write a C++ program that requests and displays information as shown in the following example of output:</p>
<p class="programlistingB">What is your first name? Betty Sue<br/>What is your last name? Yewe<br/>What letter grade do you deserve? B<br/>What is your age? 22<br/>Name: Yewe, Betty Sue<br/>Grade: C<br/>Age: 22</p>
<p class="questionp">Note that the program should be able to accept first names that comprise more than one word. Also note that the program adjusts the grade downward&#8212;that is, up one letter. Assume that the user requests an A, a B, or a C so that you don&#8217;t have to worry about the gap between a D and an F.</p>
<p class="question"><a id="ch04qa2q2"/><strong>2.</strong> Rewrite <a href="#ch04ex04">Listing 4.4</a>, using the C++ <code>string</code> class instead of <code>char</code> arrays.</p>
<p class="question"><a id="ch04qa2q3"/><strong>3.</strong> Write a program that asks the user to enter his or her first name and then last name, and that then constructs, stores, and displays a third string, consisting of the user&#8217;s last name followed by a comma, a space, and first name. Use <code>char</code> arrays and functions from the <code>cstring</code> header file. A sample run could look like this:</p>
<p class="programlistingB">Enter your first name: <span class="EmpStrong">Flip</span><br/>Enter your last name: <span class="EmpStrong">Fleming</span><br/>Here's the information in a single string: Fleming, Flip</p>
<p class="question"><a id="page_193"/><a id="ch04qa2q4"/><strong>4.</strong> Write a program that asks the user to enter his or her first name and then last name, and that then constructs, stores, and displays a third string consisting of the user&#8217;s last name followed by a comma, a space, and first name. Use <code>string</code> objects and methods from the <code>string</code> header file. A sample run could look like this:</p>
<p class="programlistingB">Enter your first name: <span class="EmpStrong">Flip</span><br/>Enter your last name: <span class="EmpStrong">Fleming</span><br/>Here's the information in a single string: Fleming, Flip</p>
<p class="question"><a id="ch04qa2q5"/><strong>5.</strong> The <code>CandyBar</code> structure contains three members. The first member holds the brand name of a candy bar. The second member holds the weight (which may have a fractional part) of the candy bar, and the third member holds the number of calories (an integer value) in the candy bar. Write a program that declares such a structure and creates a <code>CandyBar</code> variable called <code>snack</code>, initializing its members to <code>"Mocha Munch"</code>, <code>2.3</code>, and <code>350</code>, respectively. The initialization should be part of the declaration for <code>snack</code>. Finally, the program should display the contents of the <code>snack</code> variable.</p>
<p class="question"><a id="ch04qa2q6"/><strong>6.</strong> The <code>CandyBar</code> structure contains three members, as described in Programming Exercise 5. Write a program that creates an array of three <code>CandyBar</code> structures, initializes them to values of your choice, and then displays the contents of each structure.</p>
<p class="question"><a id="ch04qa2q7"/><strong>7.</strong> William Wingate runs a pizza-analysis service. For each pizza, he needs to record the following information:</p>
<p class="indenthandingNB">&#8226; The name of the pizza company, which can consist of more than one word</p>
<p class="indenthandingNB">&#8226; The diameter of the pizza</p>
<p class="indenthandingNB">&#8226; The weight of the pizza</p>
<p class="questionp">Devise a structure that can hold this information and write a program that uses a structure variable of that type. The program should ask the user to enter each of the preceding items of information, and then the program should display that information. Use <code>cin</code> (or its methods) and <code>cout</code>.</p>
<p class="question"><a id="ch04qa2q8"/><strong>8.</strong> Do Programming Exercise 7 but use <code>new</code> to allocate a structure instead of declaring a structure variable. Also have the program request the pizza diameter before it requests the pizza company name.</p>
<p class="question"><a id="ch04qa2q9"/><strong>9.</strong> Do Programming Exercise 6, but instead of declaring an array of three <code>CandyBar</code> structures, use <code>new</code> to allocate the array dynamically.</p>
<p class="question1"><a id="ch04qa2q10"/><strong>10.</strong> Write a program that requests the user to enter three times for the 40-yd dash (or 40-meter, if you prefer) and then displays the times and the average. Use an <code>array</code> object to hold the data. (Use a built-in array if <code>array</code> is not available.)</p>
</body>
</html>
