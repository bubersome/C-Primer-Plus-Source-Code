<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>1. Getting Started with C++</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch01">1. Getting Started with C++</h2>
<p><a id="page_9"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; The history and philosophy of C and of C++</p>
<p class="indenthandingB">&#8226; Procedural versus object-oriented programming</p>
<p class="indenthandingB">&#8226; How C++ adds object-oriented concepts to the C language</p>
<p class="indenthandingB">&#8226; How C++ adds generic programming concepts to the C language</p>
<p class="indenthandingB">&#8226; Programming language standards</p>
<p class="indenthandingB">&#8226; The mechanics of creating a program</p>
<p>Welcome to C++! This exciting language, which blends the C language with support for object-oriented programming and for generic programming, became one of the most important programming languages of the 1990s and continues strongly in the 2000s. Its C ancestry brings to C++ the tradition of an efficient, compact, fast, and portable language. Its object-oriented heritage brings C++ a fresh programming methodology, designed to cope with the escalating complexity of modern programming tasks. Its template features bring yet another new programming methodology: generic programming. This triple heritage is both a blessing and a bane. It makes the language very powerful, but it also means there&#8217;s a lot to learn.</p>
<p>This chapter explores C++&#8217;s background further and then goes over some of the ground rules for creating C++ programs. The rest of the book teaches you to use the C++ language, going from the modest basics of the language to the glory of object-oriented programming (OOP) and its supporting cast of new jargon&#8212;objects, classes, encapsulation, data hiding, polymorphism, and inheritance&#8212;and then on to its support of generic programming. (Of course, as you learn C++, these terms will be transformed from buzzwords to the necessary vocabulary of cultivated discourse.)</p>
<h3 id="ch01lev1sec1">Learning C++: What Lies Before You</h3>
<p><a id="page_10"/>C++ joins three separate programming categories: the procedural language, represented by C; the object-oriented language, represented by the class enhancements C++ adds to C; and generic programming, supported by C++ templates. This chapter looks into those traditions. But first, let&#8217;s consider what this heritage implies about learning C++. One reason to use C++ is to avail yourself of its object-oriented features. To do so, you need a sound background in standard C, for that language provides the basic types, operators, control structures, and syntax rules. So if you already know C, you&#8217;re poised to learn C++. But it&#8217;s not just a matter of learning a few more keywords and constructs. Going from C to C++ involves perhaps more work than learning C in the first place. Also if you know C, you must unlearn some programming habits as you make the transition to C++. If you don&#8217;t know C, you have to master the C components, the OOP components, and the generic components to learn C++, but at least you may not have to unlearn programming habits. If you are beginning to think that learning C++ may involve some mind-stretching effort on your part, you&#8217;re right. This book will guide you through the process in a clear, helpful manner, one step at a time, so the mind-stretching will be sufficiently gentle to leave your brain resilient.</p>
<p><em>C++ Primer Plus</em> approaches C++ by teaching both its C basis and its new components, so it assumes that you have no prior knowledge of C. You&#8217;ll start by learning the features C++ shares with C. Even if you know C, you may find this part of the book a good review. Also it points out concepts that will become important later, and it indicates where C++ differs from C. After you have a good grounding in the basics of C, you&#8217;ll learn about the C++ superstructure. At that point, you&#8217;ll learn about objects and classes and how C++ implements them. And you will learn about templates.</p>
<p>This book is not intended to be a complete C++ reference; it doesn&#8217;t explore every nook and cranny of the language. But you will learn most of the major features of the language, including templates, exceptions, and namespaces.</p>
<p>Now let&#8217;s take a brief look at some of C++&#8217;s background.</p>
<h3 id="ch01lev1sec2">The Origins of C++: A Little History</h3>
<p>Computer technology has evolved at an amazing rate over the past few decades. Today a notebook computer can compute faster and store more information than the mainframe computers of the 1960s. (Quite a few programmers can recall bearing offerings of decks of punched cards to be submitted to a mighty, room-filling computer system with a majestic 100KB of memory&#8212;far less memory than even a smartphone uses today.) Computer languages have evolved, too. The changes may not be as dramatic, but they are important. Bigger, more powerful computers spawn bigger, more complex programs, which, in turn, raise new problems in program management and maintenance.</p>
<p>In the 1970s, languages such as C and Pascal helped usher in an era of structured programming, a philosophy that brought some order and discipline to a field badly in need of these qualities. Besides providing the tools for structured programming, C also <a id="page_11"/>produced compact, fast-running programs, along with the ability to address hardware matters, such as managing communication ports and disk drives. These gifts helped make C the dominant programming language in the 1980s. Meanwhile, the 1980s witnessed the growth of a new programming paradigm: object-oriented programming, or OOP, as embodied in languages such as SmallTalk and C++. Let&#8217;s examine these C and OOP a bit more closely.</p>
<h4 id="ch01lev2sec1">The C Language</h4>
<p>In the early 1970s, Dennis Ritchie of Bell Laboratories was working on a project to develop the Unix operating system. (An <em>operating system</em> is a set of programs that manages a computer&#8217;s resources and handles its interactions with users. For example, it&#8217;s the operating system that puts the system prompt onscreen for a terminal-style interface that manages the windows and mice for graphical interfaces and that runs programs for you.) For this work Ritchie needed a language that was concise, that produced compact, fast programs, and that could control hardware efficiently.</p>
<p>Traditionally, programmers met these needs by using assembly language, which is closely tied to a computer&#8217;s internal machine language. However, assembly language is a <em>low-level</em> language&#8212;that is, it works directly with the hardware (for instance, accessing CPU registers and memory locations directly). Thus, assembly language is specific to a particular computer processor. So if you want to move an assembly program to a different kind of computer, you may have to completely rewrite the program, using a different assembly language. It was a bit as if each time you bought a new car, you found that the designers decided to change where the controls went and what they did, forcing you to relearn how to drive.</p>
<p>But Unix was intended to work on a variety of computer types (or platforms). That suggested using a high-level language. A <em>high-level</em> language is oriented toward problem solving instead of toward specific hardware. Special programs called <em>compilers</em> translate a high-level language to the internal language of a particular computer. Thus, you can use the same high-level language program on different platforms by using a separate compiler for each platform. Ritchie wanted a language that combined low-level efficiency and hardware access with high-level generality and portability. So building from older languages, he created C.</p>
<h4 id="ch01lev2sec2">C Programming Philosophy</h4>
<p>Because C++ grafts a new programming philosophy onto C, we should first take a look at the older philosophy that C follows. In general, computer languages deal with two concepts&#8212;data and algorithms. The <em>data</em> constitutes the information a program uses and processes. The <em>algorithms</em> are the methods the program uses (see <a href="#ch01fig01">Figure 1.1</a>). Like most mainstream languages when C was created, C is a <em>procedural</em> language. That means it emphasizes the algorithm side of programming. Conceptually, procedural programming <a id="page_12"/>consists of figuring out the actions a computer should take and then using the programming language to implement those actions. A program prescribes a set of procedures for the computer to follow to produce a particular outcome, much as a recipe prescribes a set of procedures for a cook to follow to produce a cake.</p>
<p class="caption"><a id="ch01fig01"/><strong>Figure 1.1. Data + algorithms = program.</strong></p>
<p class="image"><img src="graphics/01fig01.jpg" alt="Image"/></p>
<p>Earlier procedural languages, such as FORTRAN and BASIC, ran into organizational problems as programs grew larger. For example, programs often use branching statements, which route execution to one or another set of instructions, depending on the result of some sort of test. Many older programs had such tangled routing (called &#8220;spaghetti programming&#8221;) that it was virtually impossible to understand a program by reading it, and modifying such a program was an invitation to disaster. In response, computer scientists developed a more disciplined style of programming called <em>structured programming</em>. C includes features to facilitate this approach. For example, structured programming limits branching (choosing which instruction to do next) to a small set of well-behaved constructions. C incorporates these constructions (the <code>for</code> loop, the <code>while</code> loop, the <code>do while</code> loop, and the <code>if else</code> statement) into its vocabulary.</p>
<p><em>Top-down</em> design was another of the new principles. With C, the idea is to break a large program into smaller, more manageable tasks. If one of these tasks is still too broad, you divide it into yet smaller tasks. You continue with this process until the program is compartmentalized into small, easily programmed modules. (Organize your study. Aargh! Well, organize your desk, your table top, your filing cabinet, and your bookshelves. Aargh! Well, start with the desk and organize each drawer, starting with the middle one. Hmmm, perhaps I can manage that task.) C&#8217;s design facilitates this approach, encouraging you to <a id="page_13"/>develop program units called <em>functions</em> to represent individual task modules. As you may have noticed, the structured programming techniques reflect a procedural mind-set, thinking of a program in terms of the actions it performs.</p>
<h4 id="ch01lev2sec3">The C++ Shift: Object-Oriented Programming</h4>
<p>Although the principles of structured programming improved the clarity, reliability, and ease of maintenance of programs, large-scale programming still remains a challenge. OOP brings a new approach to that challenge. Unlike procedural programming, which emphasizes algorithms, OOP emphasizes the data. Rather than try to fit a problem to the procedural approach of a language, OOP attempts to fit the language to the problem. The idea is to design data forms that correspond to the essential features of a problem.</p>
<p>In C++, a <em>class</em> is a specification describing such a new data form, and an <em>object</em> is a particular data structure constructed according to that plan. For example, a class could describe the general properties of a corporation executive (name, title, salary, unusual abilities, for example), while an object would represent a specific executive (Guilford Sheepblat, vice president, $925,000, knows how to restore the Windows registry). In general, a class defines what data is used to represent an object <em>and</em> the operations that can be performed on that data. For example, suppose you were developing a computer drawing program capable of drawing a rectangle. You could define a class to describe a rectangle. The data part of the specification could include such things as the location of the corners, the height and width, the color and style of the boundary line, and the color and pattern used to fill the rectangle. The operations part of the specification could include methods for moving the rectangle, resizing it, rotating it, changing colors and patterns, and copying the rectangle to another location. If you then used your program to draw a rectangle, it would create an object according to the class specification. That object would hold all the data values describing the rectangle, and you could use the class methods to modify that rectangle. If you drew two rectangles, the program would create two objects, one for each rectangle.</p>
<p>The OOP approach to program design is to first design classes that accurately represent those things with which the program deals. For example, a drawing program might define classes to represent rectangles, lines, circles, brushes, pens, and the like. The class definitions, recall, include a description of permissible operations for each class, such as moving a circle or rotating a line. Then you would proceed to design a program, using objects of those classes. The process of going from a lower level of organization, such as classes, to a higher level, such as program design, is called <em>bottom-up</em> programming.</p>
<p>There&#8217;s more to OOP than the binding of data and methods into a class definition. For example, OOP facilitates creating reusable code, and that can eventually save a lot of work. Information hiding safeguards data from improper access. Polymorphism lets you create multiple definitions for operators and functions, with the programming context determining which definition is used. Inheritance lets you derive new classes from old ones. As you can see, OOP introduces many new ideas and involves a different approach to programming than does procedural programming. Instead of concentrating on tasks, <a id="page_14"/>you concentrate on representing concepts. Instead of taking a top-down programming approach, you sometimes take a bottom-up approach. This book will guide you through all these points, with plenty of easily grasped examples.</p>
<p>Designing a useful, reliable class can be a difficult task. Fortunately, OOP languages make it simple to incorporate existing classes into your own programming. Vendors provide a variety of useful class libraries, including libraries of classes designed to simplify creating programs for environments such as Windows or the Macintosh. One of the real benefits of C++ is that it lets you easily reuse and adapt existing, well-tested code.</p>
<h4 id="ch01lev2sec4">C++ and Generic Programming</h4>
<p>Generic programming is yet another programming paradigm supported by C++. It shares with OOP the aim of making it simpler to reuse code and the technique of abstracting general concepts. But whereas OOP emphasizes the data aspect of programming, generic programming emphasizes independence from a particular data type. And its focus is different. OOP is a tool for managing large projects, whereas generic programming provides tools for performing common tasks, such as sorting data or merging lists. The term <em>generic</em> refers to code that is type independent. C++ data representations come in many types&#8212;integers, numbers with fractional parts, characters, strings of characters, and user-defined compound structures of several types. If, for example, you wanted to sort data of these various types, you would normally have to create a separate sorting function for each type. Generic programming involves extending the language so that you can write a function for a generic (that is, an unspecified) type once and use it for a variety of actual types. C++ templates provide a mechanism for doing that.</p>
<h4 id="ch01lev2sec5">The Genesis of C++</h4>
<p>Like C, C++ began its life at Bell Labs, where Bjarne Stroustrup developed the language in the early 1980s. In Stroustrup&#8217;s own words, &#8220;C++ was designed primarily so that my friends and I would not have to program in assembler, C, or various modern high-level languages. Its main purpose was to make writing good programs easier and more pleasant for the individual programmer&#8221; (Bjarne Stroustrup, <em>The C++ Programming Language</em>, Third Edition. Reading, MA: Addison-Wesley, 1997).</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch01sb01"/><em>Bjarne Stroustrup&#8217;s Home Page</em></p>
<p class="sidebarpara">Bjarne Stroustrup designed and implemented the C++ programming language and is the author of the definitive reference manuals <em>The C++ Programming Language</em> and <em>The Design and Evolution of C++</em>. His personal website at AT&#38;T Labs Research should be the first C++ bookmark, or favorite, you create:</p>
<p class="sidebarpara"><a href="http://www.research.att.com/~bs">www.research.att.com/~bs</a></p>
<p class="sidebarpara">This site includes an interesting historical perspective of the hows and whys of the C++ language, Stroustrup&#8217;s biographical material, and C++ FAQs. Surprisingly, Stroustrup&#8217;s most frequently asked question may be how to pronounce <em>Bjarne Stroustrup</em>. Check out the FAQ on Stroustrup&#8217;s website and download the <code>.WAV</code> file to hear for yourself!</p>
<hr/></div>
<p><a id="page_15"/>Stroustrup was more concerned with making C++ useful than with enforcing particular programming philosophies or styles. Real programming needs are more important than theoretical purity in determining C++ language features. Stroustrup based C++ on C because of C&#8217;s brevity, its suitability to system programming, its widespread availability, and its close ties to the Unix operating system. C++&#8217;s OOP aspect was inspired by a computer simulation language called Simula67. Stroustrup added OOP features and generic programming support to C without significantly changing the C component. Thus C++ is a superset of C, meaning that any valid C program is a valid C++ program, too. There are some minor discrepancies but nothing crucial. C++ programs can use existing C software libraries. <em>Libraries</em> are collections of programming modules that you can call up from a program. They provide proven solutions to many common programming problems, thus saving you much time and effort. This has helped the spread of C++.</p>
<p>The name <em>C++</em> comes from the C increment operator <code>++</code>, which adds one to the value of a variable. Therefore, the name C++ correctly suggests an augmented version of C.</p>
<p>A computer program translates a real-life problem into a series of actions to be taken by a computer. The OOP aspect of C++ gives the language the ability to relate to concepts involved in the problem, and the C part of C++ gives the language the ability to get close to the hardware (see <a href="#ch01fig02">Figure 1.2</a>). This combination of abilities has enabled the spread of C++. It may also involve a mental shift of gears as you turn from one aspect of a program to another. (Indeed, some OOP purists regard adding OOP features to C as being akin to adding wings to a pig, albeit a lean, efficient pig.) Also because C++ grafts OOP onto C, you can ignore C++&#8217;s object-oriented features. But you&#8217;ll miss a lot if that&#8217;s all you do.</p>
<p class="caption"><a id="ch01fig02"/><strong>Figure 1.2. C++ duality.</strong></p>
<p class="image"><img src="graphics/01fig02.jpg" alt="Image"/></p>
<p>Only after C++ achieved some success did Stroustrup add templates, enabling generic programming. And only after the template feature had been used and enhanced did it become apparent that templates were perhaps as significant an addition as OOP&#8212;or even more significant, some would argue. The fact that C++ incorporates both OOP and generic programming, as well as the more traditional procedural approach, demonstrates that C++ emphasizes the utilitarian over the ideological approach, and that is one of the reasons for the language&#8217;s success.</p>
<h3 id="ch01lev1sec3">Portability and Standards</h3>
<p>Say you&#8217;ve written a handy C++ program for the elderly Pentium PC computer running Windows 2000 at work, but management decides to replace the machine with a new computer using a different operating system, say Mac OS X or Linux, perhaps one with a different processor design, such as a SPARC processor. Can you run your program on the new platform? Of course you&#8217;ll have to recompile the program using a C++ compiler designed for the new platform. But will you have to make any changes to the code you wrote? If you can recompile the program without making changes and it runs without a hitch, we say the program is <em>portable</em>.</p>
<p><a id="page_16"/>There are a couple obstacles to portability, the first of which is hardware. A program that is hardware specific is not likely to be portable. One that takes direct control of an IBM PC video board, for example, speaks gibberish as far as, say, a Sun is concerned. (You can minimize portability problems by localizing the hardware-dependent parts in function modules; then you just have to rewrite those specific modules.) We avoid that sort of programming in this book.</p>
<p>The second obstacle to portability is language divergence. Certainly, that can be a problem with spoken languages. A Yorkshireman&#8217;s description of the day&#8217;s events may not be portable to Brooklyn, even though English is said to be spoken in both areas. Computer languages, too, can develop dialects. Although most implementers would like to make their versions of C++ compatible with others, it&#8217;s difficult to do so without a published standard describing exactly how the language works. Therefore, the American National Standards Institute (ANSI) created a committee in 1990 (ANSI X3J16) to develop a standard for C++. (ANSI had already developed a standard for C.) The International Organization for Standardization (ISO) soon joined the process with its own committee (ISO-WG-21), creating a joint ANSI/ISO effort to develop the standard for C++.</p>
<p><a id="page_17"/>Several years of work eventually led to the International Standard (ISO/IEC 14882:1998), which was adopted in 1998 by the ISO, the International Electrotechnical Commission (IEC), and ANSI. This standard, often called C++98, not only refined the description of existing C++ features but also extended the language with exceptions, runtime type identification (RTTI), templates, and the Standard Template Library (STL). The year 2003 brought the publication of the second edition of the C++ standard (ISO/IEC 14882:2003); the new edition is a technical revision, meaning that it tidies up the first edition&#8212;fixing typos, reducing ambiguities, and the like&#8212;but doesn&#8217;t change the language features. This edition often is called C++03. Because C++03 didn&#8217;t change language features, we&#8217;ll follow a common usage and use C++98 to refer to C++98/C++03.</p>
<p>C++ continues to evolve, and the ISO committee approved a new standard August 2011 titled ISO/IEC 14882:2011 and informally dubbed C++11. Like C++98, C++11 adds many features to the language. In addition, it has the goals of removing inconsistencies and of making C++ easier to learn and use. This standard had been dubbed C++0x, with the original expectation that x would be 7 or 8, but standards work is a slow, exhaustive, and exhausting process. Fortunately, it was soon realized that 0x could be a hexadecimal integer (see <a href="app01.html#app01">Appendix A</a>, &#8220;<a href="app01.html#app01">Number Bases</a>&#8221;), which meant the committee had until 2015 to finish the work. So by that measure, they have finished ahead of schedule.</p>
<p>The ISO C++ Standard additionally draws on the ANSI C Standard because C++ is supposed to be, as far as possible, a superset of C. That means that any valid C program ideally should also be a valid C++ program. There are a few differences between ANSI C and the corresponding rules for C++, but they are minor. Indeed, ANSI C incorporates some features first introduced in C++, such as function prototyping and the <code>const</code> type qualifier.</p>
<p>Prior to the emergence of ANSI C, the C community followed a de facto standard based on the book <em>The C Programming Language</em>, by Kernighan and Ritchie (Addison-Wesley Publishing Company, Reading, MA, 1978). This standard was often termed K&#38;R C; with the emergence of ANSI C, the simpler K&#38;R C is now sometimes called <em>classic C</em>.</p>
<p>The ANSI C Standard not only defines the C language, it also defines a standard C library that ANSI C implementations must support. C++ also uses that library; this book refers to it as the <em>standard C library</em> or the <em>standard library</em>. In addition, the ISO C++ standard provides a standard library of C++ classes.</p>
<p>The C Standard was last revised as C99, which was adopted by the ISO in 1999 and ANSI in 2000. This standard adds some features to C, such as a new integer type, that some C++ compilers support.</p>
<h4 id="ch01lev2sec6">Language Growth</h4>
<p>Originally, the de facto standard for C++ was a 65-page reference manual included in the 328-page <em>The C++ Programming Language</em>, by Stroustrup (Addison-Wesley, 1986).</p>
<p>The next major published de facto standard was <em>The Annotated C++ Reference Manual</em>, by Ellis and Stroustrup (Addison-Wesley, 1990). This is a 453-page work; it includes substantial commentary in addition to reference material.</p>
<p><a id="page_18"/>The C++98 standard, with the addition of many features, reached nearly 800 pages, even with only minimal commentary.</p>
<p>The C++11 standard is over 1,350 pages long, so it augments the old standard substantially.</p>
<h4 id="ch01lev2sec7">This Book and C++ Standards</h4>
<p>Contemporary compilers provide good support for C++98. Some compilers at the time of this writing also support some C++11 features, and we can expect the level of support to increase quickly after the new standard is adopted. This book reflects the current situation, covering C++98 pretty thoroughly and introducing several C++11 features. Some of these features are integrated with the coverage of related C++98 topics. <a href="ch18.html#ch18">Chapter 18</a>, &#8220;<a href="ch18.html#ch18">Visiting with the New C++ Standard</a>,&#8221; concentrates on the new features, summarizing the ones mentioned earlier in the book and presenting additional features.</p>
<p>With the incomplete support available at the time of this writing, it would be very difficult to cover adequately all the new C++11 features. But even when the new standard is completely supported, it&#8217;s clear that comprehensive coverage would be beyond the scope of any reasonably sized single volume book. This book takes the approach of concentrating on features that are already available on some compilers and briefly summarizing many of the other features.</p>
<p>Before getting to the C++ language proper, let&#8217;s cover some of the groundwork related to creating programs.</p>
<h3 id="ch01lev1sec4">The Mechanics of Creating a Program</h3>
<p>Suppose you&#8217;ve written a C++ program. How do you get it running? The exact steps depend on your computer environment and the particular C++ compiler you use, but they should resemble the following steps (see <a href="#ch01fig03">Figure 1.3</a>):</p>
<p class="indenthandingN"><strong>1.</strong> Use a text editor of some sort to write the program and save it in a file. This file constitutes the <em>source code</em> for your program.</p>
<p class="indenthandingN"><strong>2.</strong> Compile the source code. This means running a program that translates the source code to the internal language, called <em>machine language</em>, used by the host computer. The file containing the translated program is the <em>object code</em> for your program.</p>
<p class="indenthandingN"><strong>3.</strong> Link the object code with additional code. For example, C++ programs normally use <em>libraries</em>. A C++ library contains object code for a collection of computer routines, called <em>functions,</em> to perform tasks such as displaying information onscreen or calculating the square root of a number. Linking combines your object code with object code for the functions you use and with some standard startup code to produce a runtime version of your program. The file containing this final product is called the <em>executable code</em>.</p>
<p class="caption"><a id="ch01fig03"/><strong>Figure 1.3. Programming steps.</strong></p>
<p class="image"><img src="graphics/01fig03.jpg" alt="Image"/></p>
<p>You will encounter the term <em>source code</em> throughout this book, so be sure to file it away in your personal random-access memory.</p>
<p><a id="page_19"/>Most of the programs in this book are generic and should run in any system that supports C++98. However, some, particularly those in <a href="ch18.html#ch18">Chapter 18</a>, do require some C++11 support. At the time of this writing, some compilers require additional flags to activate their partial C++11 support. For instance, g++, beginning with version 4.3, currently uses the <code>&#8211;std=c++11</code> flag when compiling a source code file:</p>
<p class="programlisting">g++ -std=c++11 use_auto.cpp</p>
<p>The steps for putting together a program may vary. Let&#8217;s look a little further at these steps.</p>
<h4 id="ch01lev2sec8">Creating the Source Code File</h4>
<p>The rest of the book deals with what goes into a source file; this section discusses the mechanics of creating one. Some C++ implementations, such as Microsoft Visual C++, Embarcadero C++ Builder, Apple Xcode, Open Watcom C++, Digital Mars C++, and Freescale CodeWarrior, provide <em>integrated development environments (IDEs)</em> that let you manage all steps of program development, including editing, from one master program. Other implementations, such as GNU C++ on Unix and Linux, IBM XL C/C++ on AIX, and the free versions of the Borland 5.5 (distributed by Embarcadero) and Digital Mars compilers, just handle the compilation and linking stages and expect you to type commands on the system command line. In such cases, you can use any available text editor to create and modify source code. On a Unix system, for example, you can use <code>vi</code> or <code>ed</code> or <code>ex</code> or <code>emacs</code>. On a Windows system running in the Command Prompt mode you can use <code>edlin</code> <a id="page_20"/>or <code>edit</code> or any of several available program editors. You can even use a word processor, provided that you save the file as a standard ASCII text file instead of in a special word processor format. Alternatively, there may be IDE options for use with these command-line compilers.</p>
<p>In naming a source file, you must use the proper suffix to identify the file as a C++ file. This not only tells you that the file is C++ source code, it tells the compiler that, too. (If a Unix compiler complains to you about a &#8220;bad magic number,&#8221; that&#8217;s just its endearingly obscure way of saying that you used the wrong suffix.) The suffix consists of a period followed by a character or group of characters called the <em>extension</em> (see <a href="#ch01fig04">Figure 1.4</a>).</p>
<p class="caption"><a id="ch01fig04"/><strong>Figure 1.4. The parts of a source code filename.</strong></p>
<p class="image"><img src="graphics/01fig04.jpg" alt="Image"/></p>
<p>The extension you use depends on the C++ implementation. <a href="#ch01table01">Table 1.1</a> shows some common choices. For example, <code>spiffy.C</code> is a valid Unix C++ source code filename. Note that Unix is case sensitive, meaning you should use an uppercase C character. Actually, a lowercase <code>c</code> extension also works, but standard C uses that extension. So to avoid confusion on Unix systems, you should use <code>c</code> with C programs and <code>C</code> with C++ programs. If you don&#8217;t mind typing an extra character or two, you can also use the <code>cc</code> and <code>cxx</code> extensions with some Unix systems. DOS, being a bit simple-minded compared to Unix, doesn&#8217;t distinguish between uppercase and lowercase, so DOS implementations use additional letters, as shown in <a href="#ch01table01">Table 1.1</a>, to distinguish between C and C++ programs.</p>
<p class="caption"><a id="ch01table01"/><strong>Table 1.1. Source Code Extensions</strong></p>
<p class="image"><img src="graphics/01tab01.jpg" alt="Image"/></p>
<h4 id="ch01lev2sec9">Compilation and Linking</h4>
<p><a id="page_21"/>Originally, Stroustrup implemented C++ with a C++-to-C compiler program instead of developing a direct C++-to-object code compiler. This program, called <code>cfront</code> (for <em>C front end</em>), translated C++ source code to C source code, which could then be compiled by a standard C compiler. This approach simplified introducing C++ to the C community. Other implementations have used this approach to bring C++ to other platforms. As C++ has developed and grown in popularity, more and more implementers have turned to creating C++ compilers that generate object code directly from C++ source code. This direct approach speeds up the compilation process and emphasizes that C++ is a separate, if similar, language.</p>
<p>The mechanics of compiling depend on the implementation, and the following sections outline a few common forms. These sections outline the basic steps, but they are no substitute for consulting the documentation for your system.</p>
<h5 id="ch01lev3sec1">Unix Compiling and Linking</h5>
<p>Originally, the Unix <code>CC</code> command invoked <code>cfront</code>. However, <code>cfront</code> didn&#8217;t keep pace with the evolution of C++, and its last release was in 1993. These days a Unix computer instead might have no compiler, a proprietary compiler, or a third-party compiler, perhaps commercial, perhaps freeware, such as the GNU <code>g++</code> compiler. In many of these other cases (but not in the no-compiler case!), the <code>CC</code> command still works, with the actual compiler being invoked differing from system to system. For simplicity, we&#8217;ll assume that <code>CC</code> is available, but realize that you might have to substitute a different command for <code>CC</code> in the following discussion.</p>
<p>You use the <code>CC</code> command to compile your program. The name is in uppercase letters to distinguish it from the standard Unix C compiler <code>cc</code>. The <code>CC</code> compiler is a command-line compiler, meaning you type compilation commands on the Unix command line.</p>
<p>For example, to compile the C++ source code file <code>spiffy.C</code>, you would type this command at the Unix prompt:</p>
<p class="programlisting">CC spiffy.C</p>
<p>If, through skill, dedication, or luck, your program has no errors, the compiler generates an object code file with an <code>o</code> extension. In this case, the compiler produces a file named <code>spiffy.o</code>.</p>
<p>Next, the compiler automatically passes the object code file to the system linker, a program that combines your code with library code to produce the executable file. By default, the executable file is called <code>a.out</code>. If you used just one source file, the linker also deletes the <code>spiffy.o</code> file because it&#8217;s no longer needed. To run the program, you just type the name of the executable file:</p>
<p class="programlisting"><span class="EmpStrong">a.out</span></p>
<p>Note that if you compile a new program, the new <code>a.out</code> executable file replaces the previous <code>a.out</code>. (That&#8217;s because executable files take a lot of space, so overwriting old executable files helps reduce storage demands.) But if you develop an executable program <a id="page_22"/>you want to keep, you just use the Unix <code>mv</code> command to change the name of the executable file.</p>
<p>In C++, as in C, you can spread a program over more than one file. (Many of the programs in this book in <a href="ch08.html#ch08">Chapters 8</a> through <a href="ch16.html#ch16">16</a> do this.) In such a case, you can compile a program by listing all the files on the command line, like this:</p>
<p class="programlisting">CC my.C precious.C</p>
<p>If there are multiple source code files, the compiler does not delete the object code files. That way, if you just change the <code>my.C</code> file, you can recompile the program with this command:</p>
<p class="programlisting">CC my.C precious.o</p>
<p>This recompiles the <code>my.C</code> file and links it with the previously compiled <code>precious.o</code> file.</p>
<p>You might have to identify some libraries explicitly. For example, to access functions defined in the math library, you may have to add the <code>-lm</code> flag to the command line:</p>
<p class="programlisting">CC usingmath.C -lm</p>
<h5 id="ch01lev3sec2">Linux Compiling and Linking</h5>
<p>Linux systems most commonly use <code>g++</code>, the GNU C++ compiler from the Free Software Foundation. The compiler is included in most Linux distributions, but it may not always be installed. The <code>g++</code> compiler works much like the standard Unix compiler. For example, the following produces an executable file call <code>a.out</code>:</p>
<p class="programlisting">g++ spiffy.cxx</p>
<p>Some versions might require that you link in the C++ library:</p>
<p class="programlisting">g++ spiffy.cxx -lg++</p>
<p>To compile multiple source files, you just list them all in the command line:</p>
<p class="programlisting">g++ my.cxx precious.cxx</p>
<p>This produces an executable file called <code>a.out</code> and two object code files, <code>my.o</code> and <code>precious.o</code>. If you subsequently modify just one of the source code files, say <code>my.cxx</code>, you can recompile by using <code>my.cxx</code> and the <code>precious.o</code>:</p>
<p class="programlisting">g++ my.cxx precious.o</p>
<p>The GNU compiler is available for many platforms, including the command-line mode for Windows-based PCs as well as for Unix systems on a variety of platforms.</p>
<h5 id="ch01lev3sec3">Command-Line Compilers for Windows Command Prompt Mode</h5>
<p>An inexpensive route for compiling C++ programs on a Windows PC is to download a free command-line compiler that runs in Windows Command Prompt mode, which opens an MS-DOS-like window. Free Windows downloads that include the GNU C++ compiler are Cygwin and MinGW; they use g++ as the compiler name.</p>
<p><a id="page_23"/>To use the g++ compiler, you first open a command prompt window. Cygwin and MinGW do this for you automatically when you start those programs. To compile a source code file named <code>great.cpp</code>, you type the following command at the prompt:</p>
<p class="programlisting"><span class="EmpStrong">g++ great.cpp</span></p>
<p>If the program compiles successfully, the resultant executable file is named <code>a.exe</code>.</p>
<h5 id="ch01lev3sec4">Windows Compilers</h5>
<p>Windows products are too abundant and too often revised to make it reasonable to describe them all individually. At the present the most popular is Microsoft Visual C++ 2010, which is available in the free Microsoft Visual C++ 2010 Express edition. The Wikipedia link (<a href="http://en.wikipedia.org/wiki/List_of_compilers">http://en.wikipedia.org/wiki/List_of_compilers</a>) provides a comprehensive list of compilers for many platforms, including Windows. Despite different designs and goals, most Windows-based C++ compilers share some common features.</p>
<p>Typically, you must create a project for a program and add to the project the file or files constituting the program. Each vendor supplies an IDE with menu options and, possibly, automated assistance, in creating a project. One very important matter you have to establish is the kind of program you&#8217;re creating. Typically, the compiler offers many choices, such as a Windows application, an MFC Windows application, a dynamic link library, an ActiveX control, a DOS or character-mode executable, a static library, or a console application. Some of these may be available in both 64-bit and 32-bit versions.</p>
<p>Because the programs in this book are generic, you should avoid choices that require platform-specific code, such as Windows applications. Instead, you want to run in a character-based mode. The choice depends on the compiler. In general, you should look to see if there is an option labeled Console, character-mode, or DOS executable and try that. For instance, in Microsoft Visual C++ 2010, select the Win32 Console Application option, click Application Settings, and select the Empty Project option. In C++Builder XE, select Console Application under C++Builder Projects.</p>
<p>After you have the project set up, you have to compile and link your program. The IDE typically gives you several choices, such as Compile, Build, Make, Build All, Link, Execute, Run, and Debug (but not necessarily all these choices in the same IDE!):</p>
<p class="indenthandingB">&#8226; <em>Compile</em> typically means compile the code in the file that is currently open.</p>
<p class="indenthandingB">&#8226; <em>Build</em> or <em>Make</em> typically means compile the code for all the source code files in the project. This is often an incremental process. That is, if the project has three files, and you change just one, and then just that one is recompiled.</p>
<p class="indenthandingB">&#8226; <em>Build All</em> typically means compile all the source code files from scratch.</p>
<p class="indenthandingB">&#8226; As described earlier, <em>Link</em> means combine the compiled source code with the necessary library code.</p>
<p class="indenthandingB">&#8226; <em>Run</em> or <em>Execut</em>e means run the program. Typically, if you have not yet done the earlier steps, Run does them before trying to run a program.</p>
<p class="indenthandingB">&#8226; <em>Debug</em> means run the program with the option of going through step-by-step.</p>
<p class="indenthandingB">&#8226; <a id="page_24"/>A compiler may offer the option of <em>Debug</em> and <em>Release</em> versions. The former contains extra code that increases the program size, slows program execution, but enables detailed debugging features.</p>
<p>A compiler generates an error message when you violate a language rule and identifies the line that has the problem. Unfortunately, when you are new to a language, you may find it difficult to understand the message. Sometimes the actual error may occur before the identified line, and sometimes a single error generates a chain of error messages.</p>
<div class="note"><hr/>
<p class="title"><a id="ch01note01"/>Tip</p>
<p class="notepara">When fixing errors, fix the first error first. If you can&#8217;t find it on the line identified as the line with the error, check the preceding line.</p>
<hr/></div>
<p>Be aware of the fact that a particular compiler accepts a program doesn&#8217;t necessarily mean that the program is valid C++. And the fact that a particular compiler rejects a program doesn&#8217;t necessarily mean that the program is invalid C++. However, current compilers are more compliant with the Standard than their predecessors of a few years ago. Also compilers typically have options to control how strict the compiler is.</p>
<div class="note"><hr/>
<p class="title"><a id="ch01note02"/>Tip</p>
<p class="notepara">Occasionally, compilers get confused after incompletely building a program and respond by giving meaningless error messages that cannot be fixed. In such cases, you can clear things up by selecting Build All to restart the process from scratch. Unfortunately, it is difficult to distinguish this situation from the more common one in which the error messages merely seem to be meaningless.</p>
<hr/></div>
<p>Usually, the IDE lets you run the program in an auxiliary window. Some IDEs close the window as soon as the program finishes execution, and some leave it open. If your compiler closes the window, you&#8217;ll have a hard time seeing the output unless you have quick eyes and a photographic memory. To see the output, you must place some additional code at the end of the program:</p>
<p class="programlisting">&#160;&#160;&#160;&#160;&#160;&#160;cin.get();&#160;&#160;// add this statement<br/>&#160;&#160;&#160;&#160;&#160;&#160;cin.get();&#160;&#160;// and maybe this, too<br/>&#160;&#160;&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p>The <code>cin.get()</code> statement reads the next keystroke, so this statement causes the program to wait until you press the Enter key. (No keystrokes get sent to a program until you press Enter, so there&#8217;s no point in pressing another key.) The second statement is needed if the program otherwise leaves an unprocessed keystroke after its regular input. For example, if you enter a number, you type the number and then press Enter. The program reads the number but leaves the Enter keystroke unprocessed, and it is then read by the first <code>cin.get()</code>.</p>
<h5 id="ch01lev3sec5">C++ on the Macintosh</h5>
<p><a id="page_25"/>Apple currently supplies a developer framework called Xcode with the Mac OS X operating system. It&#8217;s free but normally not preinstalled. You can install it from the operating system installation disks, or you can download it for a nominal fee from Apple. (Be aware that it is over a 4GB download.) Not only does it provide an IDE that supports several programming languages, it also installs a couple of compilers&#8212;g++ and clang&#8212;that can be used as command-line programs in the Unix mode accessible through the Terminal utility.</p>
<div class="note"><hr/>
<p class="title"><a id="ch01note03"/>Tip</p>
<p class="notepara">For IDEs: To save time, you can use just one project for all the sample programs. Just delete the previous sample source code file from the project list and add the current source code. This saves time, effort, and lessens disk clutter.</p>
<hr/></div>
<h3 id="ch01lev1sec5">Summary</h3>
<p>As computers have grown more powerful, computer programs have become larger and more complex. In response to these conditions, computer languages have evolved so that it&#8217;s easier to manage the programming process. The C language incorporated features such as control structures and functions to better control the flow of a program and to enable a more structured, modular approach. To these tools C++ adds support for object-oriented programming and generic programming. This enables even more modularity and facilitates the creation of reusable code, which saves time and increases program reliability.</p>
<p>The popularity of C++ has resulted in a large number of implementations for many computing platforms; the C++ ISO standards (C++98/03 and C++11) provide a basis for keeping these many implementations mutually compatible. The standards establishes the features the language should have, the behavior the language should display, and a standard library of functions, classes, and templates. The standards supports the goal of a portable language across different computing platforms and different implementations of the language.</p>
<p>To create a C++ program, you create one or more source files containing the program as expressed in the C++ language. These are text files that must be compiled and linked to produce the machine-language files that constitute executable programs. These tasks are often accomplished in an IDE that provides a text editor for creating the source files, a compiler and a linker for producing executable files, and other resources, such as project management and debugging capabilities. But the same tasks can also be performed in a command-line environment by invoking the appropriate tools individually.</p>
</body>
</html>
