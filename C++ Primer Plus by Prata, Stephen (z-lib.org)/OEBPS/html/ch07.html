<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>7. Functions: C++&#8217;s Programming Modules</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch07">7. Functions: C++&#8217;s Programming Modules</h2>
<p><a id="page_305"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Function basics</p>
<p class="indenthandingB">&#8226; Function prototypes</p>
<p class="indenthandingB">&#8226; Passing function arguments by value</p>
<p class="indenthandingB">&#8226; Designing functions to process arrays</p>
<p class="indenthandingB">&#8226; Using <code>const</code> pointer parameters</p>
<p class="indenthandingB">&#8226; Designing functions to process text strings</p>
<p class="indenthandingB">&#8226; Designing functions to process structures</p>
<p class="indenthandingB">&#8226; Designing functions to process objects of the <code>string</code> class</p>
<p class="indenthandingB">&#8226; Functions that call themselves (recursion)</p>
<p class="indenthandingB">&#8226; Pointers to functions</p>
<p>Fun is where you find it. Look closely, and you can find it in functions. C++ comes with a large library of useful functions (the standard ANSI C library plus several C++ classes), but real programming pleasure comes with writing your own functions. (On the other hand, real programming productivity can come with learning more about what you can do with the STL and the BOOST C++ libraries.) This chapter and <a href="ch08.html#ch08">Chapter 8</a>, &#8220;<a href="ch08.html#ch08">Adventures in Functions</a>,&#8221; examine how to define functions, convey information to them, and retrieve information from them. After reviewing how functions work, this chapter concentrates on how to use functions in conjunction with arrays, strings, and structures. Finally, it touches on recursion and pointers to functions. If you&#8217;ve paid your C dues, you&#8217;ll find much of this chapter familiar. But don&#8217;t be lulled into a false sense of expertise. C++ has made several additions to what C functions can do, and <a href="ch08.html#ch08">Chapter 8</a> deals primarily with those. Meanwhile, let&#8217;s attend to the fundamentals.</p>
<h3 id="ch07lev1sec1">Function Review</h3>
<p><a id="page_306"/>Let&#8217;s review what you&#8217;ve already seen about functions. To use a C++ function, you must do the following:</p>
<p class="indenthandingB">&#8226; Provide a function definition</p>
<p class="indenthandingB">&#8226; Provide a function prototype</p>
<p class="indenthandingB">&#8226; Call the function</p>
<p>If you&#8217;re using a library function, the function has already been defined and compiled for you. Also you can and should use a standard library header file to provide the prototype. All that&#8217;s left to do is call the function properly. The examples so far in this book have done that several times. For example, the standard C library includes the <code>strlen()</code> function for finding the length of the string. The associated standard header file <code>cstring</code> contains the function prototype for <code>strlen()</code> and several other string-related functions. This advance work allows you to use the <code>strlen()</code> function in programs without further worries.</p>
<p>But when you create your own functions, you have to handle all three aspects&#8212;defining, prototyping, and calling&#8212;yourself. <a href="#ch07ex01">Listing 7.1</a> shows these steps in a short example.</p>
<p class="caption1"><a id="ch07ex01"/><strong>Listing 7.1. <code>calling.cpp</code></strong></p><hr/>
<p class="programlisting1">// calling.cpp -- defining, prototyping, and calling a function<br/>#include &lt;iostream&gt;<br/><br/>void simple();&#160;&#160;&#160;&#160;// function prototype<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "main() will call the simple() function:\n";<br/>&#160;&#160;&#160;&#160;simple();&#160;&#160;&#160;&#160;&#160;// function call<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "main() is finished with the simple() function.\n";<br/>&#160;&#160;&#160;&#160;// cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// function definition<br/>void simple()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "I'm but a simple function.\n";<br/>}</p><hr/>
<p><a id="page_307"/>Here&#8217;s the output of the program in <a href="#ch07ex01">Listing 7.1</a>:</p>
<p class="programlisting">main() will call the simple() function:<br/>I'm but a simple function.<br/>main() is finished with the simple() function.</p>
<p>Program execution in <code>main()</code> halts as control transfers to the <code>simple()</code> function. When <code>simple()</code> finishes, program execution in <code>main()</code> resumes. This example places a <code>using</code> directive inside each function definition because each function uses <code>cout</code>. Alternatively, the program could have a single <code>using</code> directive placed above the function definitions or otherwise use <code>std::cout</code>.</p>
<p>Let&#8217;s take a more detailed look at these steps now.</p>
<h4 id="ch07lev2sec1">Defining a Function</h4>
<p>You can group functions into two categories: those that don&#8217;t have return values and those that do. Functions without return values are termed type <code>void</code> functions and have the following general form:</p>
<p class="programlisting">void <span class="EmpItalic">functionName</span>(<span class="EmpItalic">parameterList</span>)<br/>{<br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">statement(s)</span><br/>&#160;&#160;&#160;&#160;return;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// optional<br/>}</p>
<p>Here <em><code>parameterList</code></em> specifies the types and number of arguments (parameters) passed to the function. This chapter more fully investigates this list later. The optional return statement marks the end of the function. Otherwise, the function terminates at the closing brace. Type <code>void</code> functions correspond to Pascal procedures, FORTRAN subroutines, and modern BASIC subprogram procedures. Typically, you use a <code>void</code> function to perform some sort of action. For example, a function to print <em>Cheers!</em> a given number (<code>n</code>) of times could look like this:</p>
<p class="programlisting">void cheers(int n)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no return value<br/>{<br/><br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Cheers! ";<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; std::endl;<br/>}</p>
<p>The <code>int n</code> parameter list means that <code>cheers()</code> expects to have an <code>int</code> value passed to it as an argument when you call this function.</p>
<p>A function with a return value produces a value that it returns to the function that called it. In other words, if the function returns the square root of 9.0 (<code>sqrt(9.0)</code>), the <a id="page_308"/>function call has the value <code>3.0</code>. Such a function is declared as having the same type as the value it returns. Here is the general form:</p>
<p class="programlisting"><span class="EmpItalic">typeName functionName</span>(<span class="EmpItalic">parameterList</span>)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">statements</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;return <span class="EmpItalic">value</span>;&#160;&#160;&#160;// value is type cast to type <span class="EmpItalic">typeName</span><br/>}</p>
<p>Functions with return values require that you use a return statement so that the value is returned to the calling function. The value itself can be a constant, a variable, or a more general expression. The only requirement is that the expression reduces to a value that has, or is convertible to, the <em><code>typeName</code></em> type. (If the declared return type is, say, <code>double</code>, and the function returns an <code>int</code> expression, the <code>int</code> value is type cast to type <code>double</code>.) The function then returns the final value to the function that called it. C++ does place a restriction on what types you can use for a return value: The return value cannot be an array. Everything else is possible&#8212;integers, floating-point numbers, pointers, and even structures and objects! (Interestingly, even though a C++ function can&#8217;t return an array directly, it can return an array that&#8217;s part of a structure or object.)</p>
<p>As a programmer, you don&#8217;t need to know how a function returns a value, but knowing the method might clarify the concept for you. (Also it gives you something to talk about with your friends and family.) Typically, a function returns a value by copying the return value to a specified CPU register or memory location. Then the calling program examines that location. Both the returning function and the calling function have to agree on the type of data at that location. The function prototype tells the calling program what to expect, and the function definition tells the called program what to return (see <a href="#ch07fig01">Figure 7.1</a>). Providing the same information in the prototype as in the definition might seem like extra work, but it makes good sense. Certainly, if you want a courier to pick up something from your desk at the office, you enhance the odds of the task being done right if you provide a description of what you want both to the courier and to someone at the office.</p>
<p class="caption"><a id="ch07fig01"/><strong>Figure 7.1. A typical return value mechanism.</strong></p>
<p class="image"><img src="graphics/07fig01.jpg" alt="Image"/></p>
<p>A function terminates after executing a return statement. If a function has more than one return statement&#8212;for example, as alternatives to different <code>if else</code> selections&#8212;the function terminates after it executes the first return statement it reaches. For instance, in the following example, the <code>else</code> isn&#8217;t needed, but it does help the casual reader understand the intent:</p>
<p class="programlisting">int bigger(int a, int b)<br/>{<br/>&#160;&#160;&#160;&#160;if (a &gt; b )<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return a;&#160;&#160;// if a &gt; b, function terminates here<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return b;&#160;&#160;// otherwise, function terminates here<br/>}</p>
<p><a id="page_309"/>(Usually, having multiple return statements in a function is considered potentially confusing, and some compilers might issue a warning. However, the code here is simple enough to understand.)</p>
<p>Functions with return values are much like functions in Pascal, FORTRAN, and BASIC. They return a value to the calling program, which can then assign that value to a variable, display the value, or otherwise use it. Here&#8217;s a simple example that returns the cube of a type <code>double</code> value:</p>
<p class="programlisting">double cube(double x)&#160;&#160;&#160;&#160;// x times x times x<br/>{<br/>&#160;&#160;&#160;&#160;return x * x * x; // a type double value<br/>}</p>
<p>For example, the function call <code>cube(1.2)</code> returns the value <code>1.728</code>. Note that this return statement uses an expression. The function computes the value of the expression (<code>1.728</code>, in this case) and returns the value.</p>
<h4 id="ch07lev2sec2">Prototyping and Calling a Function</h4>
<p>By now you are familiar with making function calls, but you may be less comfortable with function prototyping because that&#8217;s often been hidden in the <code>include</code> files. <a href="#ch07ex02">Listing 7.2</a> shows the <code>cheers()</code> and <code>cube()</code> functions used in a program; notice the function prototypes.</p>
<p class="caption1"><a id="page_310"/><a id="ch07ex02"/><strong>Listing 7.2. <code>protos.cpp</code></strong></p><hr/>
<p class="programlisting1">// protos.cpp -- using prototypes and function calls<br/>#include &lt;iostream&gt;<br/>void cheers(int);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prototype: no return value<br/>double cube(double x);&#160;&#160;// prototype: returns a double<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cheers(5);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// function call<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Give me a number: ";<br/>&#160;&#160;&#160;&#160;double side;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; side;<br/>&#160;&#160;&#160;&#160;double volume = cube(side);&#160;&#160;&#160;&#160;// function call<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "A " &lt;&lt; side &lt;&lt;"-foot cube has a volume of ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; volume &lt;&lt; " cubic feet.\n";<br/>&#160;&#160;&#160;&#160;cheers(cube(2));&#160;&#160;&#160;&#160;// prototype protection at work<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void cheers(int n)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Cheers! ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}<br/><br/>double cube(double x)<br/>{<br/>&#160;&#160;&#160;&#160;return x * x * x;<br/>}</p><hr/>
<p>The program in <a href="#ch07ex02">Listing 7.2</a> places a <code>using</code> directive in only those functions that use the members of the <code>std</code> namespace. Here&#8217;s a sample run:</p>
<p class="programlisting">Cheers! Cheers! Cheers! Cheers! Cheers!<br/>Give me a number: <span class="EmpStrong">5</span><br/>A 5-foot cube has a volume of 125 cubic feet.<br/>Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers!</p>
<p>Note that <code>main()</code> calls the type <code>void</code> function <code>cheers()</code> by using the function name and arguments followed by a semicolon: <code>cheers(5);</code>. This is an example of a function call statement. But because <code>cube()</code> has a return value, <code>main()</code> can use it as part of an assignment statement:</p>
<p class="programlisting">double volume = cube(side);</p>
<p><a id="page_311"/>But I said earlier that you should concentrate on the prototypes. What should you know about prototypes? First, you should understand why C++ requires prototypes. Then because C++ requires prototypes, you should know the proper syntax. Finally, you should appreciate what the prototype does for you. Let&#8217;s look at these points in turn, using <a href="#ch07ex02">Listing 7.2</a> as a basis for discussion.</p>
<h5 id="ch07lev3sec1">Why Prototypes?</h5>
<p>A prototype describes the function interface to the compiler. That is, it tells the compiler what type of return value, if any, the function has, and it tells the compiler the number and type of function arguments. Consider how the prototype affects this function call from <a href="#ch07ex02">Listing 7.2</a>:</p>
<p class="programlisting">double volume = cube(side);</p>
<p>First, the prototype tells the compiler that <code>cube()</code> should have one type <code>double</code> argument. If the program fails to provide the argument, prototyping allows the compiler to catch the error. Second, when the <code>cube()</code> function finishes its calculation, it places its return value at some specified location&#8212;perhaps in a CPU register, perhaps in memory. Then the calling function, <code>main()</code> in this case, retrieves the value from that location. Because the prototype states that <code>cube()</code> is type <code>double</code>, the compiler knows how many bytes to retrieve and how to interpret them. Without that information, the compiler could only guess, and that is something compilers won&#8217;t do.</p>
<p>Still, you might wonder, why does the compiler need a prototype? Can&#8217;t it just look further in the file and see how the functions are defined? One problem with that approach is that it is not very efficient. The compiler would have to put compiling <code>main()</code> on hold while searching the rest of the file. An even more serious problem is the fact that the function might not even be in the file. C++ allows you to spread a program over several files, which you can compile independently and then combine later. In such a case, the compiler might not have access to the function code when it&#8217;s compiling <code>main()</code>. The same is true if the function is part of a library. The only way to avoid using a function prototype is to place the function definition before its first use. That is not always possible. Also the C++ programming style is to put <code>main()</code> first because it generally provides the structure for the whole program.</p>
<h5 id="ch07lev3sec2">Prototype Syntax</h5>
<p>A function prototype is a statement, so it must have a terminating semicolon. The simplest way to get a prototype is to copy the function header from the function definition and add a semicolon. That&#8217;s what the program in <a href="#ch07ex02">Listing 7.2</a> does for <code>cube()</code>:</p>
<p class="programlisting">double cube(double x); // add ; to header to get prototype</p>
<p><a id="page_312"/>However, the function prototype does not require that you provide names for the variables; a list of types is enough. The program in <a href="#ch07ex02">Listing 7.2</a> prototypes <code>cheers()</code> by using only the argument type:</p>
<p class="programlisting">void cheers(int); // okay to drop variable names in prototype</p>
<p>In general, you can either include or exclude variable names in the argument lists for prototypes. The variable names in the prototype just act as placeholders, so if you do use names, they don&#8217;t have to match the names in the function definition.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch07sb01"/>C++ Versus ANSI C Prototyping</p>
<p class="sidebarpara">ANSI C borrowed prototyping from C++, but the two languages do have some differences. The most important is that ANSI C, to preserve compatibility with classic C, made prototyping optional, whereas C++ makes prototyping mandatory. For example, consider the following function declaration:</p>
<p class="programlistingB">void say_hi();</p>
<p class="sidebarpara">In C++, leaving the parentheses empty is the same as using the keyword <code>void</code> within the parentheses. It means the function has no arguments. In ANSI C, leaving the parentheses empty means that you are declining to state what the arguments are. That is, it means you&#8217;re forgoing prototyping the argument list. The C++ equivalent for not identifying the argument list is to use an ellipsis:</p>
<p class="programlistingB">void say_bye(...);&#160;&#160;&#160;// C++ abdication of responsibility</p>
<p class="sidebarpara">Normally this use of an ellipsis is needed only for interfacing with C functions having a variable number of arguments, such as <code>printf()</code>.</p>
<hr/></div>
<h5 id="ch07lev3sec3">What Prototypes Do for You</h5>
<p>You&#8217;ve seen that prototypes help the compiler. But what do they do for you? They greatly reduce the chances of program errors. In particular, prototypes ensure the following:</p>
<p class="indenthandingB">&#8226; The compiler correctly handles the function return value.</p>
<p class="indenthandingB">&#8226; The compiler checks that you use the correct number of function arguments.</p>
<p class="indenthandingB">&#8226; The compiler checks that you use the correct type of arguments. If you don&#8217;t, it converts the arguments to the correct type, if possible.</p>
<p>We&#8217;ve already discussed how to correctly handle the return value. Let&#8217;s look now at what happens when you use the wrong number of arguments. For example, suppose you make the following call:</p>
<p class="programlisting">double z = cube();</p>
<p>A compiler that doesn&#8217;t use function prototyping lets this go by. When the function is called, it looks where the call to <code>cube()</code> should have placed a number and uses whatever value happens to be there. This is how C worked before ANSI C borrowed prototyping <a id="page_313"/>from C++. Because prototyping is optional for ANSI C, this is how some C programs still work. But in C++ prototyping is not optional, so you are guaranteed protection from that sort of error.</p>
<p>Next, suppose you provide an argument but it is the wrong type. In C, this could create weird errors. For example, if a function expects a type <code>int</code> value (assume that&#8217;s 16 bits) and you pass a <code>double</code> (assume that&#8217;s 64 bits), the function looks at just the first 16 bits of the 64 and tries to interpret them as an <code>int</code> value. However, C++ automatically converts the value you pass to the type specified in the prototype, provided that both are arithmetic types. For example, <a href="#ch07ex02">Listing 7.2</a> manages to get two type mismatches in one statement:</p>
<p class="programlisting">cheers(cube(2));</p>
<p>First, the program passes the <code>int</code> value of <code>2</code> to <code>cube()</code>, which expects type <code>double</code>. The compiler, noting that the <code>cube()</code> prototype specifies a type <code>double</code> argument, converts <code>2</code> to <code>2.0</code>, a type <code>double</code> value. Then <code>cube()</code> returns a type <code>double</code> value (<code>8.0</code>) to be used as an argument to <code>cheers()</code>. Again, the compiler checks the prototypes and notes that <code>cheers()</code> requires an <code>int</code>. It converts the return value to the integer <code>8</code>. In general, prototyping produces automatic type casts to the expected types. (Function overloading, discussed in <a href="ch08.html#ch08">Chapter 8</a>, can create ambiguous situations, however, that prevent some automatic type casts.)</p>
<p>Automatic type conversion doesn&#8217;t head off all possible errors. For example, if you pass a value of <code>8.33E27</code> to a function that expects an <code>int</code>, such a large value cannot be converted correctly to a mere <code>int</code>. Some compilers warn you of possible data loss when there is an automatic conversion from a larger type to a smaller.</p>
<p>Also prototyping results in type conversion only when it makes sense. It won&#8217;t, for example, convert an integer to a structure or pointer.</p>
<p>Prototyping takes place during compile time and is termed <em>static type checking</em>. Static type checking, as you&#8217;ve just seen, catches many errors that are much more difficult to catch during runtime.</p>
<h3 id="ch07lev1sec2">Function Arguments and Passing by Value</h3>
<p>It&#8217;s time to take a closer look at function arguments. C++ normally passes arguments <em>by value</em>. That means the numeric value of the argument is passed to the function, where it is assigned to a new variable. For example, <a href="#ch07ex02">Listing 7.2</a> has this function call:</p>
<p class="programlisting">double volume = cube(side);</p>
<p>Here <code>side</code> is a variable that, in the sample run, had the value <code>5</code>. The function header for <code>cube()</code>, recall, was this:</p>
<p class="programlisting">double cube(double x)</p>
<p>When this function is called, it creates a new type <code>double</code> variable called <code>x</code> and initializes it with the value <code>5</code>. This insulates data in <code>main()</code> from actions that take place in <code>cube()</code> because <code>cube()</code> works with a copy of <code>side</code> rather than with the original data. <a id="page_314"/>You&#8217;ll see an example of this protection soon. A variable that&#8217;s used to receive passed values is called a <em>formal argument</em> or <em>formal parameter</em>. The value passed to the function is called the <em>actual argument</em> or <em>actual parameter</em>. To simplify matters a bit, the C++ Standard uses the word <em>argument</em> by itself to denote an actual argument or parameter and the word <em>parameter</em> by itself to denote a formal argument or parameter. Using this terminology, argument passing initializes the parameter to the argument (see <a href="#ch07fig02">Figure 7.2</a>).</p>
<p class="caption"><a id="ch07fig02"/><strong>Figure 7.2. Passing by value.</strong></p>
<p class="image"><img src="graphics/07fig02.jpg" alt="Image"/></p>
<p>Variables, including parameters, declared within a function are private to the function. When a function is called, the computer allocates the memory needed for these variables. When the function terminates, the computer frees the memory that was used for those variables. (Some C++ literature refers to this allocating and freeing of memory as <em>creating and destroying variables</em>. That does make it sound much more exciting.) Such variables are called <em>local variables</em> because they are localized to the function. As mentioned previously, this helps preserve data integrity. It also means that if you declare a variable called <code>x</code> in <code>main()</code> and another variable called <code>x</code> in some other function, these are two distinct, unrelated variables, much as the Albany in California is distinct from the Albany in New York (see <a href="#ch07fig03">Figure 7.3</a>). Such variables are also termed <em>automatic variables</em> because they are allocated and deallocated automatically during program execution.</p>
<p class="caption"><a id="ch07fig03"/><strong>Figure 7.3. Local variables.</strong></p>
<p class="image"><img src="graphics/07fig03.jpg" alt="Image"/></p>
<h4 id="ch07lev2sec3">Multiple Arguments</h4>
<p>A function can have more than one argument. In the function call, you just separate the arguments with commas:</p>
<p class="programlisting">n_chars('R', 25);</p>
<p>This passes two arguments to the function <code>n_chars()</code>, which will be defined shortly.</p>
<p><a id="page_315"/>Similarly, when you define the function, you use a comma-separated list of parameter declarations in the function header:</p>
<p class="programlisting">void n_chars(char c, int n)&#160;&#160;// two arguments</p>
<p>This function header states that the function <code>n_chars()</code> takes one type <code>char</code> argument and one type <code>int</code> argument. The parameters <code>c</code> and <code>n</code> are initialized with the values passed to the function. If a function has two parameters of the same type, you have to give the type of each parameter separately. You can&#8217;t combine declarations the way you can when you declare regular variables:</p>
<p class="programlisting">void fifi(float a, float b)&#160;&#160;// declare each variable separately<br/>void fufu(float a, b)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// NOT acceptable</p>
<p>As with other functions, you just add a semicolon to get a prototype:</p>
<p class="programlisting">void n_chars(char c, int n); // prototype, style 1</p>
<p>As with single arguments, you don&#8217;t have to use the same variable names in the prototype as in the definition, and you can omit the variable names in the prototype:</p>
<p class="programlisting">void n_chars(char, int);&#160;&#160;&#160;&#160;&#160;// prototype, style 2</p>
<p><a id="page_316"/>However, providing variable names can make the prototype more understandable, particularly if two parameters are the same type. Then the names can remind you which argument is which:</p>
<p class="programlisting">double melon_density(double weight, double volume);</p>
<p><a href="#ch07ex03">Listing 7.3</a> shows an example of a function with two arguments. It also illustrates how changing the value of a formal parameter in a function has no effect on the data in the calling program.</p>
<p class="caption1"><a id="ch07ex03"/><strong>Listing 7.3. <code>twoarg.cpp</code></strong></p><hr/>
<p class="programlisting1">// twoarg.cpp -- a function with 2 arguments<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>void n_chars(char, int);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;int times;<br/>&#160;&#160;&#160;&#160;char ch;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a character: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ch;<br/>&#160;&#160;&#160;&#160;while (ch != 'q')&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// q to quit<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter an integer: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; times;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;n_chars(ch, times); // function with two arguments<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "\nEnter another character or press the"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" q-key to quit: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; ch;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The value of times is " &lt;&lt; times &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void n_chars(char c, int n) // displays c n times<br/>{<br/>&#160;&#160;&#160;&#160;while (n-- &gt; 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// continue until n reaches 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; c;<br/>}</p><hr/>
<p>The program in <a href="#ch07ex03">Listing 7.3</a> illustrates placing a <code>using</code> directive above the function definitions rather than within the functions. Here is a sample run:</p>
<p class="programlisting">Enter a character: <span class="EmpStrong">W</span><br/>Enter an integer: <span class="EmpStrong">50</span><br/><a id="page_317"/>WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW<br/>Enter another character or press the q-key to quit: <span class="EmpStrong">a</span><br/>Enter an integer: <span class="EmpStrong">20</span><br/>aaaaaaaaaaaaaaaaaaaa<br/>Enter another character or press the q-key to quit: <span class="EmpStrong">q</span><br/>The value of times is 20.<br/>Bye</p>
<h5 id="ch07lev3sec4">Program Notes</h5>
<p>The <code>main()</code> function in <a href="#ch07ex03">Listing 7.3</a> uses a <code>while</code> loop to provide repeated input (and to keep your loop skills fresh). Note that it uses <code>cin &gt;&gt; ch</code> rather than <code>cin.get(ch)</code> or <code>ch = cin.get()</code> to read a character. There&#8217;s a good reason for this. Recall that the two <code>cin.get()</code>functions read all input characters, including spaces and newlines, whereas <code>cin &gt;&gt;</code> skips spaces and newlines. When you respond to the program prompt, you have to press Enter at the end of each line, thus generating a newline character. The <code>cin &gt;&gt; ch</code> approach conveniently skips over these newlines, but the <code>cin.get()</code> siblings read the newline following each number entered as the next character to display. You can program around this nuisance, but it&#8217;s simpler to use <code>cin</code> as the program in <a href="#ch07ex03">Listing 7.3</a> does.</p>
<p>The <code>n_chars()</code> function takes two arguments: a character <code>c</code> and an integer <code>n</code>. It then uses a loop to display the character the number of times the integer specifies:</p>
<p class="programlisting">while (n-- &gt; 0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// continue until n reaches 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; c;</p>
<p>Notice that the program keeps count by decrementing the <code>n</code> variable, where <code>n</code> is the formal parameter from the argument list. This variable is assigned the value of the <code>times</code> variable in <code>main()</code>. The <code>while</code> loop then decreases <code>n</code> to <code>0</code>, but, as the sample run demonstrates, changing the value of <code>n</code> has no effect on <code>times</code>. Even if you use the name <code>n</code> instead of <code>times</code> in <code>main()</code>, the value of <code>n</code> in <code>main()</code> is unaffected by changes in the value of <code>n</code> in <code>n_chars()</code>.</p>
<h4 id="ch07lev2sec4">Another Two-Argument Function</h4>
<p>Let&#8217;s create a more ambitious function&#8212;one that performs a nontrivial calculation. Also the function illustrates the use of local variables other than the function&#8217;s formal arguments.</p>
<p>Many states in the United States now sponsor a lottery with some form of Lotto game. Lotto lets you pick a certain number of choices from a card. For example, you might get to pick six numbers from a card having 51 numbers. Then the Lotto managers pick six numbers at random. If your choice exactly matches theirs, you win a few million dollars or so. Our function will calculate the probability that you have a winning pick. (Yes, a function that successfully predicts the winning picks themselves would be more useful, but C++, although powerful, has yet to implement psychic faculties.)</p>
<p><a id="page_318"/>First, you need a formula. If you have to pick six values out of 51, mathematics says that you have one chance in <code>R</code> of winning, where the following formula gives <code>R</code>:</p>
<p class="image"><img src="graphics/318equ01.jpg" alt="Image"/></p>
<p>For six choices, the denominator is the product of the first six integers, or 6 factorial. The numerator is also the product of six consecutive numbers, this time starting with 51 and going down. More generally, if you pick <code>picks</code> values out of <code>numbers</code> numbers, the denominator is <code>picks</code> factorial and the numerator is the product of <code>picks</code> integers, starting with the value <code>numbers</code> and working down. You can use a <code>for</code> loop to make that calculation:</p>
<p class="programlisting">long double result = 1.0;<br/>for (n = numbers, p = picks; p &gt; 0; n--, p--)<br/>&#160;&#160;&#160;&#160;result = result * n / p ;</p>
<p>Rather than multiply all the numerator terms first, the loop begins by multiplying <code>1.0</code> by the first numerator term and then dividing by the first denominator term. Then in the next cycle, the loop multiplies and divides by the second numerator and denominator terms. This keeps the running product smaller than if you did all the multiplication first. For example, compare</p>
<p class="programlisting">(10 * 9) / (2 * 1)</p>
<p>with</p>
<p class="programlisting">(10 / 2) * (9 / 1)</p>
<p>The first evaluates to 90 / 2 and then to 45, whereas the second evaluates to 5 &#215; 9 and then to 45. Both give the same answer, but the first method produces a larger intermediate value (90) than does the second. The more factors you have, the bigger the difference gets. For large numbers, this strategy of alternating multiplication with division can keep the calculation from overflowing the maximum possible floating-point value.</p>
<p><a href="#ch07ex04">Listing 7.4</a> incorporates this formula into a <code>probability()</code> function. Because the number of picks and the total number of choices should be positive values, the program uses the <code>unsigned int</code> type (<code>unsigned</code>, for short) for those quantities. Multiplying several integers can produce pretty large results, so <code>lotto.cpp</code> uses the <code>long double</code> type for the function&#8217;s return value. Also terms such as 49 / 6 produce a truncation error for integer types.</p>
<div class="note"><hr/>
<p class="title"><a id="ch07note01"/>Note</p>
<p class="notepara">Some C++ implementations don&#8217;t support type <code>long double</code>. If your implementation falls into that category, try ordinary <code>double</code> instead.</p>
<hr/></div>
<p class="caption1"><a id="page_319"/><a id="ch07ex04"/><strong>Listing 7.4. <code>lotto.cpp</code></strong></p><hr/>
<p class="programlisting1">// lotto.cpp -- probability of winning<br/>#include &lt;iostream&gt;<br/>// Note: some implementations require double instead of long double<br/>long double probability(unsigned numbers, unsigned picks);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double total, choices;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the total number of choices on the game card and\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"the number of picks allowed:\n";<br/>&#160;&#160;&#160;&#160;while ((cin &gt;&gt; total &gt;&gt; choices) &#38;&#38; choices &lt;= total)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "You have one chance in ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; probability(total, choices);&#160;&#160;&#160;&#160;&#160;&#160;// compute the odds<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; " of winning.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Next two numbers (q to quit): ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "bye\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// the following function calculates the probability of picking picks<br/>// numbers correctly from numbers choices<br/>long double probability(unsigned numbers, unsigned picks)<br/>{<br/>&#160;&#160;&#160;&#160;long double result = 1.0;&#160;&#160;// here come some local variables<br/>&#160;&#160;&#160;&#160;long double n;<br/>&#160;&#160;&#160;&#160;unsigned p;<br/><br/>&#160;&#160;&#160;&#160;for (n = numbers, p = picks; p &gt; 0; n--, p--)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result = result * n / p ;<br/>&#160;&#160;&#160;&#160;return result;<br/>}</p><hr/>
<p>Here&#8217;s a sample run of the program in <a href="#ch07ex04">Listing 7.4</a>:</p>
<p class="programlisting">Enter the total number of choices on the game card and<br/>the number of picks allowed:<br/><span class="EmpStrong">49 6</span><br/>You have one chance in 1.39838e+007 of winning.<br/>Next two numbers (q to quit): <span class="EmpStrong">51 6</span><br/>You have one chance in 1.80095e+007 of winning.<br/>Next two numbers (q to quit): <span class="EmpStrong">38 6</span><br/>You have one chance in 2.76068e+006 of winning.<br/>Next two numbers (q to quit): <span class="EmpStrong">q</span><br/>bye</p>
<p><a id="page_320"/>Notice that increasing the number of choices on the game card greatly increases the odds against winning.</p>
<h5 id="ch07lev3sec5">Program Notes</h5>
<p>The <code>probability()</code> function in <a href="#ch07ex04">Listing 7.4</a> illustrates two kinds of local variables you can have in a function. First, there are the formal parameters (<code>numbers</code> and <code>picks</code>), which are declared in the function header before the opening brace. Then come the other local variables (<code>result</code>, <code>n</code>, and <code>p</code>). They are declared in between the braces bounding the function definition. The main difference between the formal parameters and the other local variables is that the formal parameters get their values from the function that calls <code>probability()</code>, whereas the other variables get values from within the function.</p>
<h3 id="ch07lev1sec3">Functions and Arrays</h3>
<p>So far the sample functions in this book have been simple, using only the basic types for arguments and return values. But functions can be the key to handling more involved types, such as arrays and structures. Let&#8217;s take a look now at how arrays and functions get along with each other.</p>
<p>Suppose you use an array to keep track of how many cookies each person has eaten at a family picnic. (Each array index corresponds to a person, and the value of the element corresponds to the number of cookies that person has eaten.) Now you want the total. That&#8217;s easy to find; you just use a loop to add all the array elements. But adding array elements is such a common task that it makes sense to design a function to do the job. Then you won&#8217;t have to write a new loop every time you have to sum an array.</p>
<p>Let&#8217;s consider what the function interface involves. Because the function calculates a sum, it should return the answer. If you keep your cookies intact, you can use a function with a type <code>int</code> return value. So that the function knows what array to sum, you want to pass the array name as an argument. And to make the function general so that it is not restricted to an array of a particular size, you pass the size of the array. The only new ingredient here is that you have to declare that one of the formal arguments is an array name. Let&#8217;s see what that and the rest of the function header look like:</p>
<p class="programlisting">int sum_arr(int arr[], int n) // arr = array name, n = size</p>
<p>This looks plausible. The brackets seem to indicate that <code>arr</code> is an array, and the fact that the brackets are empty seems to indicate that you can use the function with an array of any size. But things are not always as they seem: <code>arr</code> is not really an array; it&#8217;s a pointer! The good news is that you can write the rest of the function just as if <code>arr</code> were an array. First, let&#8217;s use an example to check that this approach works, and then let&#8217;s look into why it works.</p>
<p><a href="#ch07ex05">Listing 7.5</a> illustrates using a pointer as if it were an array name. The program initializes the array to some values and uses the <code>sum_arr()</code> function to calculate the sum. Note that the <code>sum_arr()</code> function uses <code>arr</code> as if it were an array name.</p>
<p class="caption1"><a id="page_321"/><a id="ch07ex05"/><strong>Listing 7.5. <code>arrfun1.cpp</code></strong></p><hr/>
<p class="programlisting1">// arrfun1.cpp -- functions with an array argument<br/>#include &lt;iostream&gt;<br/>const int ArSize = 8;<br/>int sum_arr(int arr[], int n);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prototype<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int cookies[ArSize] = {1,2,4,8,16,32,64,128};<br/>// some systems require preceding int with static to<br/>// enable array initialization<br/><br/>&#160;&#160;&#160;&#160;int sum = sum_arr(cookies, ArSize);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Total cookies eaten: " &lt;&lt; sum &lt;&lt;&#160;&#160;"\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// return the sum of an integer array<br/>int sum_arr(int arr[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;int total = 0;<br/><br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;total = total + arr[i];<br/>&#160;&#160;&#160;&#160;return total;<br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch07ex05">Listing 7.5</a>:</p>
<p class="programlisting">Total cookies eaten: 255</p>
<p>As you can see, the program works. Now let&#8217;s look at why it works.</p>
<h4 id="ch07lev2sec5">How Pointers Enable Array-Processing Functions</h4>
<p>The key to the program in <a href="#ch07ex05">Listing 7.5</a> is that C++, like C, in most contexts treats the name of an array as if it were a pointer. Recall from <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; that C++ interprets an array name as the address of its first element:</p>
<p class="programlisting">cookies == &#38;cookies[0]&#160;&#160;// array name is address of first element</p>
<p>(There are a few exceptions to this rule. First, the array declaration uses the array name to label the storage. Second, applying <code>sizeof</code> to an array name yields the size of the whole array, in bytes. Third, as mentioned in <a href="ch04.html#ch04">Chapter 4</a>, applying the address operator <code>&#38;</code> to an array name returns the address of the whole array; for example, <code>&#38;cookies</code> would be the address of a 32-byte block of memory if <code>int</code> is 4 bytes.)</p>
<p><a id="page_322"/><a href="#ch07ex05">Listing 7.5</a> makes the following function call:</p>
<p class="programlisting">int sum = sum_arr(cookies, ArSize);</p>
<p>Here <code>cookies</code> is the name of an array, hence by C++ rules <code>cookies</code> is the address of the array&#8217;s first element. The function passes an address. Because the array has type <code>int</code> elements, <code>cookies</code> must be type pointer-to-<code>int</code>, or <code>int *</code>. This suggests that the correct function header should be this:</p>
<p class="programlisting">int sum_arr(int * arr, int n) // arr = array name, n = size</p>
<p>Here <code>int *arr</code> has replaced <code>int arr[]</code>. It turns out that both headers are correct because in C++ the notations <code>int *arr</code> and <code>int arr[]</code> have the identical meaning when (and <em>only</em> when) used in a function header or function prototype. Both mean that <code>arr</code> is a pointer-to-<code>int</code>. However, the array notation version (<code>int arr[]</code>) symbolically reminds you that <code>arr</code> not only points to an <code>int</code>, it points to the first <code>int</code> in an array of <code>int</code>s. This book uses the array notation when the pointer is to the first element of an array, and it uses the pointer notation when the pointer is to an isolated value. Remember that the notations <code>int *arr</code> and <code>int arr[]</code> are not synonymous in any other context. For example, you can&#8217;t use the notation <code>int tip[]</code> to declare a pointer in the body of a function.</p>
<p>Given that the variable <code>arr</code> actually is a pointer, the rest of the function makes sense. As you might recall from the discussion of dynamic arrays in <a href="ch04.html#ch04">Chapter 4</a>, you can use the bracket array notation equally well with array names or with pointers to access elements of an array. Whether <code>arr</code> is a pointer or an array name, the expression <code>arr[3]</code> means the fourth element of the array. And it probably will do no harm at this point to remind you of the following two identities:</p>
<p class="programlisting">arr[i] == *(ar + i)&#160;&#160;&#160;&#160;// values in two notations<br/>&#38;arr[i] == ar + i&#160;&#160;&#160;&#160;&#160;&#160;// addresses in two notations</p>
<p>Remember that adding one to a pointer, including an array name, actually adds a value equal to the size, in bytes, of the type to which the pointer points. Pointer addition and array subscription are two equivalent ways of counting elements from the beginning of an array.</p>
<h4 id="ch07lev2sec6">The Implications of Using Arrays as Arguments</h4>
<p>Let&#8217;s look at the implications of <a href="#ch07ex05">Listing 7.5</a>. The function call <code>sum_arr(cookies, ArSize)</code> passes the address of the first element of the <code>cookies</code> array and the number of elements of the array to the <code>sum_arr()</code> function. The <code>sum_arr()</code> function initializes the <code>cookies</code> address to the pointer variable <code>arr</code> and initializes <code>ArSize</code> to the <code>int</code> variable <code>n</code>. This means <a href="#ch07ex05">Listing 7.5</a> doesn&#8217;t really pass the array contents to the function. Instead, it tells the function where the array is (the address), what kind of elements it has (the type), and how many elements it has (the <code>n</code> variable). (See <a href="#ch07fig04">Figure 7.4</a>.) Armed with this information, the function then uses the original array. If you pass an ordinary variable, the function works with a copy. But if you pass an array, the function works with the original. Actually, this difference doesn&#8217;t violate C++&#8217;s pass-by-value approach. The <code>sum_arr()</code> function still <a id="page_323"/>passes a value that&#8217;s assigned to a new variable. But that value is a single address, not the contents of an array.</p>
<p class="caption"><a id="ch07fig04"/><strong>Figure 7.4. Telling a function about an array.</strong></p>
<p class="image"><img src="graphics/07fig04.jpg" alt="Image"/></p>
<p>Is the correspondence between array names and pointers a good thing? Indeed, it is. The design decision to use array addresses as arguments saves the time and memory needed to copy an entire array. The overhead for using copies can be prohibitive if you&#8217;re working with large arrays. With copies, not only does a program need more computer memory, but it has to spend time copying large blocks of data. On the other hand, working with the original data raises the possibility of inadvertent data corruption. That&#8217;s a real problem in classic C, but ANSI C and C++&#8217;s <code>const</code> modifier provides a remedy. You&#8217;ll soon see an example. But first, let&#8217;s alter <a href="#ch07ex05">Listing 7.5</a> to illustrate some points about how array functions operate. <a href="#ch07ex06">Listing 7.6</a> demonstrates that <code>cookies</code> and <code>arr</code> have the same value. It also shows how the pointer concept makes the <code>sum_arr</code> function more versatile than it may have appeared at first. To provide a bit of variety and to show you what it looks like, the program uses the <code>std::</code> qualifier instead of the <code>using</code> directive to provide access to <code>cout</code> and <code>endl</code>.</p>
<p class="caption1"><a id="ch07ex06"/><strong>Listing 7.6. <code>arrfun2.cpp</code></strong></p><hr/>
<p class="programlisting1">// arrfun2.cpp -- functions with an array argument<br/>#include &lt;iostream&gt;<br/>const int ArSize = 8;<br/>int sum_arr(int arr[], int n);<br/>// use std:: instead of using directive<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;int cookies[ArSize] = {1,2,4,8,16,32,64,128};<br/>//&#160;&#160;some systems require preceding int with static to<br/>//&#160;&#160;enable array initialization<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; cookies &lt;&lt; " = array address, ";<br/>//&#160;&#160;some systems require a type cast: unsigned (cookies)<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; sizeof cookies &lt;&lt; " = sizeof cookies\n";<br/>&#160;&#160;&#160;&#160;int sum = sum_arr(cookies, ArSize);<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Total cookies eaten: " &lt;&lt; sum &lt;&lt;&#160;&#160;std::endl;<br/>&#160;&#160;&#160;&#160;sum = sum_arr(cookies, 3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a lie<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "First three eaters ate " &lt;&lt; sum &lt;&lt; " cookies.\n";<br/>&#160;&#160;&#160;&#160;sum = sum_arr(cookies + 4, 4);&#160;&#160;&#160;&#160;// another lie<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Last four eaters ate " &lt;&lt; sum &lt;&lt; " cookies.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// return the sum of an integer array<br/>int sum_arr(int arr[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;int total = 0;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; arr &lt;&lt; " = arr, ";<br/>// some systems require a type cast: unsigned (arr)<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; sizeof arr &lt;&lt; " = sizeof arr\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;total = total + arr[i];<br/>&#160;&#160;&#160;&#160;return total;<br/>}</p><hr/>
<p><a id="page_324"/>Here&#8217;s the output of the program in <a href="#ch07ex06">Listing 7.6</a>:</p>
<p class="programlisting">003EF9FC = array address, 32 = sizeof cookies<br/>003EF9FC = arr, 4 = sizeof arr<br/>Total cookies eaten: 255<br/>003EF9FC = arr, 4 = sizeof arr<br/>First three eaters ate 7 cookies.<br/>003EFA0C = arr, 4 = sizeof arr<br/>Last four eaters ate 240 cookies.</p>
<p>Note that the address values and the array and integer sizes will vary from system to system. Also some implementations will display the addresses in base 10 notation instead of in hexadecimal. Others will use hexadecimal digits and the <code>0x</code> hexadecimal prefix.</p>
<h5 id="ch07lev3sec6">Program Notes</h5>
<p><a href="#ch07ex06">Listing 7.6</a> illustrates some very interesting points about array functions. First, note that <code>cookies</code> and <code>arr</code> both evaluate to the same address, exactly as claimed. But <code>sizeof cookies</code> is <code>32</code>, whereas <code>sizeof arr</code> is only <code>4</code>. That&#8217;s because <code>sizeof cookies</code> is the size of the whole array, whereas <code>sizeof arr</code> is the size of the pointer variable. (This program execution takes place on a system that uses 4-byte addresses.) By the way, this is why you <a id="page_325"/>have to explicitly pass the size of the array rather than use <code>sizeof arr</code> in <code>sum_arr()</code>; the pointer by itself doesn&#8217;t reveal the size of the array.</p>
<p>Because the only way <code>sum_arr()</code> knows the number of elements in the array is through what you tell it with the second argument, you can lie to the function. For example, the second time the program uses the function, it makes this call:</p>
<p class="programlisting">sum = sum_arr(cookies, 3);</p>
<p>By telling the function that <code>cookies</code> has just three elements, you get the function to calculate the sum of the first three elements.</p>
<p>Why stop there? You can also lie about where the array starts:</p>
<p class="programlisting">sum = sum_arr(cookies + 4, 4);</p>
<p>Because <code>cookies</code> acts as the address of the first element, <code>cookies + 4</code> acts as the address of the fifth element. This statement sums the fifth, sixth, seventh, and eighth elements of the array. Note in the output how the third call to the function assigns a different address to <code>arr</code> than the first two calls did. And yes, you can use <code>&#38;cookies[4]</code> instead of <code>cookies + 4</code> as the argument; they both mean the same thing.</p>
<div class="note"><hr/>
<p class="title"><a id="ch07note02"/>Note</p>
<p class="notepara">To indicate the kind of array and the number of elements to an array-processing function, you pass the information as two separate arguments:</p>
<p class="programlistingB">void fillArray(int arr[], int size);&#160;&#160;&#160;// prototype</p>
<p class="notepara">Don&#8217;t try to pass the array size by using brackets notation:</p>
<p class="programlistingB">void fillArray(int arr[size]);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// NO -- bad prototype</p>
<hr/></div>
<h4 id="ch07lev2sec7">More Array Function Examples</h4>
<p>When you choose to use an array to represent data, you are making a design decision. But design decisions should go beyond how data is stored; they should also involve how the data is used. Often you&#8217;ll find it profitable to write specific functions to handle specific data operations. (The profits here include increased program reliability, ease of modification, and ease of debugging.) Also when you begin integrating storage properties with operations when you think about a program, you are taking an important step toward the OOP mind-set; that, too, might prove profitable in the future.</p>
<p>Let&#8217;s examine a simple case. Suppose you want to use an array to keep track of the dollar values of your real estate. (If necessary, suppose you have real estate.) You have to decide what type to use. Certainly, <code>double</code> is less restrictive in its range than <code>int</code> or <code>long</code>, and it provides enough significant digits to represent the values precisely. Next, you have to decide on the number of array elements. (With dynamic arrays created with <code>new</code>, you can put off that decision, but let&#8217;s keep things simple.) Let&#8217;s say that you have no more than five properties, so you can use an array of five <code>doubles</code>.</p>
<p>Now consider the possible operations you might want to execute with the real estate array. Two very basic ones are reading values into the array and displaying the array <a id="page_326"/>contents. Let&#8217;s add one more operation to the list: reassessing the value of the properties. For simplicity, assume that all your properties increase or decrease in value at the same rate. (Remember, this is a book on C++, not on real estate management.) Next, fit a function to each operation and then write the code accordingly. We&#8217;ll go through the steps of creating these pieces of a program next. Afterward, we&#8217;ll fit them into a complete example.</p>
<h5 id="ch07lev3sec7">Filling the Array</h5>
<p>Because a function with an array name argument accesses the original array, not a copy, you can use a function call to assign values to array elements. One argument to the function will be the name of the array to be filled. In general, a program might manage more than one person&#8217;s investments, hence more than one array, so you don&#8217;t want to build the array size into the function. Instead, you pass the array size as a second argument, as in the previous example. Also it&#8217;s possible that you might want to quit reading data before filling the array, so you want to build that feature in to the function. Because you might enter fewer than the maximum number of elements, it makes sense to have the function return the actual number of values entered. These considerations suggest the following function prototype:</p>
<p class="programlisting">int fill_array(double ar[], int limit);</p>
<p>The function takes an array name argument and an argument specifying the maximum number of items to be read, and the function returns the actual number of items read. For example, if you use this function with an array of five elements, you pass <code>5</code> as the second argument. If you then enter only three values, the function returns <code>3</code>.</p>
<p>You can use a loop to read successive values into the array, but how can you terminate the loop early? One way is to use a special value to indicate the end of input. Because no property should have a negative value, you can use a negative number to indicate the end of input. Also the function should do something about bad input, such as terminating further input. Given these considerations, you can code the function as follows:</p>
<p class="programlisting">int fill_array(double ar[], int limit)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double temp;<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; limit; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter value #" &lt;&lt; (i + 1) &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; temp;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!cin)&#160;&#160;&#160;&#160;// bad input<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.clear();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bad input; input process terminated.\n";<br/><a id="page_327"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (temp &lt; 0)&#160;&#160;&#160;&#160;&#160;// signal to terminate<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ar[i] = temp;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return i;<br/>}</p>
<p>Note that this code includes a prompt to the user. If the user enters a non-negative value, the value is assigned to the array. Otherwise, the loop terminates. If the user enters only valid values, the loop terminates after it reads <code>limit</code> values. The last thing the loop does is increment <code>i</code>, so after the loop terminates, <code>i</code> is one greater than the last array index, hence it&#8217;s equal to the number of filled elements. The function then returns that value.</p>
<h5 id="ch07lev3sec8">Showing the Array and Protecting It with <code>const</code></h5>
<p>Building a function to display the array contents is simple. You pass the name of the array and the number of filled elements to the function, which then uses a loop to display each element. But there is another consideration&#8212;guaranteeing that the display function doesn&#8217;t alter the original array. Unless the purpose of a function is to alter data passed to it, you should safeguard it from doing so. That protection comes automatically with ordinary arguments because C++ passes them by value, and the function works with a copy. But functions that use an array work with the original. After all, that&#8217;s why the <code>fill_array()</code> function is able to do its job. To keep a function from accidentally altering the contents of an array argument, you can use the keyword <code>const</code> (discussed in <a href="ch03.html#ch03">Chapter 3</a>, &#8220;<a href="ch03.html#ch03">Dealing with Data</a>&#8221;) when you declare the formal argument:</p>
<p class="programlisting">void show_array(const double ar[], int n);</p>
<p>The declaration states that the pointer <code>ar</code> points to constant data. This means that you can&#8217;t use <code>ar</code> to change the data. That is, you can use a value such as <code>ar[0]</code>, but you can&#8217;t change that value. Note that this doesn&#8217;t mean that the original array needs be constant; it just means that you can&#8217;t use <code>ar</code> in the <code>show_array()</code> function to change the data. Thus, <code>show_array()</code> treats the array as read-only data. Suppose you accidentally violate this restriction by doing something like the following in the <code>show_array()</code> function:</p>
<p class="programlisting">ar[0] += 10;</p>
<p>In this case, the compiler will put a stop to your wrongful ways. Borland C++, for example, gives an error message like this (edited slightly):</p>
<p class="programlisting">Cannot modify a const object in function<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;show_array(const double *,int)</p>
<p>Other compilers may choose to express their displeasure in different words.</p>
<p><a id="page_328"/>The message reminds you that C++ interprets the declaration <code>const double ar[]</code> to mean <code>const double *ar</code>. Thus, the declaration really says that <code>ar</code> points to a constant value. We&#8217;ll discuss this in detail when we finish with the current example. Meanwhile, here is the code for the <code>show_array()</code> function:</p>
<p class="programlisting">void show_array(const double ar[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Property #" &lt;&lt; (i + 1) &lt;&lt; ": $";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ar[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<h5 id="ch07lev3sec9">Modifying the Array</h5>
<p>The third operation for the array in this example is multiplying each element by the same revaluation factor. You need to pass three arguments to the function: the factor, the array, and the number of elements. No return value is needed, so the function can look like this:</p>
<p class="programlisting">void revalue(double r, double ar[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ar[i] *= r;<br/>}</p>
<p>Because this function is supposed to alter the array values, you don&#8217;t use <code>const</code> when you declare <code>ar</code>.</p>
<h5 id="ch07lev3sec10">Putting the Pieces Together</h5>
<p>Now that you&#8217;ve defined a data type in terms of how it&#8217;s stored (an array) and how it&#8217;s used (three functions), you can put together a program that uses the design. Because you&#8217;ve already built all the array-handling tools, you&#8217;ve greatly simplified programming <code>main()</code>. The program does check to see if the user responds to the prompt for a revaluation factor with a number. In this case, rather than stopping if the user fails to comply, the program uses a loop to ask the user to do the right thing. Most of the remaining programming work consists of having <code>main()</code> call the functions you&#8217;ve just developed. <a href="#ch07ex07">Listing 7.7</a> shows the result. It places a <code>using</code> directive in just those functions that use the <code>iostream</code> facilities.</p>
<p class="caption1"><a id="ch07ex07"/><strong>Listing 7.7. <code>arrfun3.cpp</code></strong></p><hr/>
<p class="programlisting1">// arrfun3.cpp -- array functions and const<br/>#include &lt;iostream&gt;<br/>const int Max = 5;<br/><a id="page_329"/>// function prototypes<br/>int fill_array(double ar[], int limit);<br/>void show_array(const double ar[], int n);&#160;&#160;// don't change data<br/>void revalue(double r, double ar[], int n);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double properties[Max];<br/><br/>&#160;&#160;&#160;&#160;int size = fill_array(properties, Max);<br/>&#160;&#160;&#160;&#160;show_array(properties, size);<br/>&#160;&#160;&#160;&#160;if (size &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter revaluation factor: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double factor;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (!(cin &gt;&gt; factor))&#160;&#160;&#160;&#160;// bad input<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.clear();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bad input; Please enter a number: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;revalue(factor, properties, size);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;show_array(properties, size);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>int fill_array(double ar[], int limit)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double temp;<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; limit; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter value #" &lt;&lt; (i + 1) &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; temp;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!cin)&#160;&#160;&#160;&#160;// bad input<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.clear();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bad input; input process terminated.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (temp &lt; 0)&#160;&#160;&#160;&#160;&#160;// signal to terminate<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ar[i] = temp;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return i;<br/>}<br/><br/>// the following function can use, but not alter,<br/>// the array whose address is ar<br/>void show_array(const double ar[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Property #" &lt;&lt; (i + 1) &lt;&lt; ": $";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ar[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>// multiplies each element of ar[] by r<br/>void revalue(double r, double ar[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ar[i] *= r;<br/>}</p><hr/>
<p><a id="page_330"/>Here are two sample runs of the program in <a href="#ch07ex07">Listing 7.7</a>:</p>
<p class="programlisting">Enter value #1: <span class="EmpStrong">100000</span><br/>Enter value #2: <span class="EmpStrong">80000</span><br/>Enter value #3: <span class="EmpStrong">222000</span><br/>Enter value #4: <span class="EmpStrong">240000</span><br/>Enter value #5: <span class="EmpStrong">118000</span><br/>Property #1: $100000<br/>Property #2: $80000<br/>Property #3: $222000<br/>Property #4: $240000<br/>Property #5: $118000<br/>Enter revaluation factor: <span class="EmpStrong">0.8</span><br/>Property #1: $80000<br/>Property #2: $64000<br/>Property #3: $177600<br/>Property #4: $192000<br/>Property #5: $94400<br/>Done.<br/><a id="page_331"/>Enter value #1: <span class="EmpStrong">200000</span><br/>Enter value #2: <span class="EmpStrong">84000</span><br/>Enter value #3: <span class="EmpStrong">160000</span><br/>Enter value #4: <span class="EmpStrong">-2</span><br/>Property #1: $200000<br/>Property #2: $84000<br/>Property #3: $160000<br/>Enter reevaluation factor: <span class="EmpStrong">1.20</span><br/>Property #1: $240000<br/>Property #2: $100800<br/>Property #3: $192000<br/>Done.</p>
<p>Recall that <code>fill_array()</code> prescribes that input should quit when the user enters five properties or enters a negative number, whichever comes first. The first output example illustrates reaching the five-property limit, and the second output example illustrates that entering a negative value terminates the input phase.</p>
<h5 id="ch07lev3sec11">Program Notes</h5>
<p>We&#8217;ve already discussed the important programming details related to the real estate example, so let&#8217;s reflect on the process. You began by thinking about the data type and designed appropriate functions to handle the data. Then you assembled these functions into a program. This is sometimes called <em>bottom-up programming</em> because the design process moves from the component parts to the whole. This approach is well suited to OOP, which concentrates on data representation and manipulation first. Traditional procedural programming, on the other hand, leans toward <em>top-down programming</em>, in which you develop a modular grand design first and then turn your attention to the details. Both methods are useful, and both lead to modular programs.</p>
<h5 id="ch07lev3sec12">The Usual Array Function Idiom</h5>
<p>Suppose you want a function to process an array, say, of type <code>double</code> values. If the function is intended to modify the array, the prototype might look like this:</p>
<p class="programlisting">void f_modify(double ar[], int n);</p>
<p>If the function preserves values, the prototype might look like this:</p>
<p class="programlisting">void _f_no_change(const double ar[], int n);</p>
<p>Of course, you can omit the variable names in the prototypes, and the return type might be something other than <code>void</code>. The main points are that <code>ar</code> really is a pointer to the first element of the passed array and that because the number of elements is passed as an argument, either function can be used with any size of array as long as it is an array of <code>double</code>:</p>
<p class="programlisting">double rewards[1000];<br/>double faults[50];<br/>...<br/>f_modify(rewards, 1000);<br/>f_modify(faults, 50);</p>
<p><a id="page_332"/>This idiom (pass the array name and size as arguments) works by passing two numbers&#8212;the array address and the number of elements. As you have seen, the function loses some knowledge about the original array; for example, it can&#8217;t use <code>sizeof</code> to get the size and relies on you to pass the correct number of elements.</p>
<h4 id="ch07lev2sec8">Functions Using Array Ranges</h4>
<p>As you&#8217;ve seen, C++ functions that process arrays need to be informed about the kind of data in the array, the location of the beginning of the array, and the number of elements in the array. The traditional C/C++ approach to functions that process arrays is to pass a pointer to the start of the array as one argument and to pass the size of the array as a second argument. (The pointer tells the function both where to find the array and the kind of data in it.) That gives the function the information it needs to find all the data.</p>
<p>There is another approach to giving a function the information it needs: specify a <em>range</em> of elements. This can be done by passing two pointers&#8212;one identifying the start of the array and one identifying the end of the array. The C++ Standard Template Library (STL; presented in <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library&#8221;), for example, generalizes the range approach. The STL approach uses the concept of &#8220;one past the end&#8221; to indicate an extent. That is, in the case of an array, the argument identifying the end of the array would be a pointer to the location just after the last element. For example, suppose you have this declaration:</p>
<p class="programlisting">double elbuod[20];</p>
<p>Then the two pointers <code>elbuod</code> and <code>elbuod + 20</code> define the range. First, <code>elbuod</code>, being the name of the array, points to the first element. The expression <code>elbuod + 19</code> points to the last element (that is, <code>elbuod[19]</code>), so <code>elbuod + 20</code> points to one past the end of the array. Passing a range to a function tells it which elements to process. <a href="#ch07ex08">Listing 7.8</a> modifies <a href="#ch07ex06">Listing 7.6</a> to use two pointers to specify a range.</p>
<p class="caption1"><a id="ch07ex08"/><strong>Listing 7.8. <code>arrfun4.cpp</code></strong></p><hr/>
<p class="programlisting1">// arrfun4.cpp -- functions with an array range<br/>#include &lt;iostream&gt;<br/>const int ArSize = 8;<br/>int sum_arr(const int * begin, const int * end);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int cookies[ArSize] = {1,2,4,8,16,32,64,128};<br/>//&#160;&#160;some systems require preceding int with static to<br/>//&#160;&#160;enable array initialization<br/><br/>&#160;&#160;&#160;&#160;int sum = sum_arr(cookies, cookies + ArSize);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Total cookies eaten: " &lt;&lt; sum &lt;&lt;&#160;&#160;endl;<br/>&#160;&#160;&#160;&#160;sum = sum_arr(cookies, cookies + 3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// first 3 elements<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "First three eaters ate " &lt;&lt; sum &lt;&lt; " cookies.\n";<br/>&#160;&#160;&#160;&#160;sum = sum_arr(cookies + 4, cookies + 8);&#160;&#160;&#160;&#160;// last 4 elements<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Last four eaters ate " &lt;&lt; sum &lt;&lt; " cookies.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// return the sum of an integer array<br/>int sum_arr(const int * begin, const int * end)<br/>{<br/>&#160;&#160;&#160;&#160;const int * pt;<br/>&#160;&#160;&#160;&#160;int total = 0;<br/><br/>&#160;&#160;&#160;&#160;for (pt = begin; pt != end; pt++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;total = total + *pt;<br/>&#160;&#160;&#160;&#160;return total;<br/>}</p><hr/>
<p><a id="page_333"/>Here&#8217;s the output of the program in <a href="#ch07ex08">Listing 7.8</a>:</p>
<p class="programlisting">Total cookies eaten: 255<br/>First three eaters ate 7 cookies.<br/>Last four eaters ate 240 cookies.</p>
<h5 id="ch07lev3sec13">Program Notes</h5>
<p>In <a href="#ch07ex08">Listing 7.8</a>, notice the <code>for</code> loop in the <code>sum_array()</code> function:</p>
<p class="programlisting">for (pt = begin; pt != end; pt++)<br/>&#160;&#160;&#160;&#160;total = total + *pt;</p>
<p>It sets <code>pt</code> to point to the first element to be processed (the one pointed to by <code>begin</code>) and adds <code>*pt</code> (the value of the element) to <code>total</code>. Then the loop updates <code>pt</code> by incrementing it, causing it to point to the next element. The process continues as long as <code>pt != end</code>. When <code>pt</code> finally equals <code>end</code>, it&#8217;s pointing to the location following the last element of the range, so the loop halts.</p>
<p>Second, notice how the different function calls specify different ranges within the array:</p>
<p class="programlisting">int sum = sum_arr(cookies, cookies + ArSize);<br/>...<br/>sum = sum_arr(cookies, cookies + 3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// first 3 elements<br/>...<br/>sum = sum_arr(cookies + 4, cookies + 8);&#160;&#160;&#160;&#160;// last 4 elements</p>
<p>The pointer value <code>cookies + ArSize</code> points to the location following the last element. (The array has <code>ArSize</code> elements, so <code>cookies[ArSize - 1]</code> is the last element, and its address is <code>cookies + ArSize - 1</code>.) So the range <code>cookies, cookies + ArSize</code> specifies the entire array. Similarly, <code>cookies, cookies + 3</code> specifies the first three elements, and so on.</p>
<p><a id="page_334"/>Note, by the way, that the rules for pointer subtraction imply that, in <code>sum_arr()</code>, the expression <code>end - begin</code> is an integer value equal to the number of elements in the range.</p>
<p>Also note that it&#8217;s important to pass the pointers in the correct order; the code assumes that <code>end</code> comes after <code>begin</code>.</p>
<h4 id="ch07lev2sec9">Pointers and <code>const</code></h4>
<p>Using <code>const</code> with pointers has some subtle aspects (pointers always seem to have subtle aspects), so let&#8217;s take a closer look. You can use the <code>const</code> keyword two different ways with pointers. The first way is to make a pointer point to a constant object, and that prevents you from using the pointer to change the pointed-to value. The second way is to make the pointer itself constant, and that prevents you from changing where the pointer points. Now for the details.</p>
<p>First, let&#8217;s declare a pointer <code>pt</code> that points to a constant:</p>
<p class="programlisting">int age = 39;<br/>const int * pt = &#38;age;</p>
<p>This declaration states that <code>pt</code> points to a <code>const int</code> (<code>39</code>, in this case). Therefore, you can&#8217;t use <code>pt</code> to change that value. In other words, the value <code>*pt</code> is <code>const</code> and cannot be modified:</p>
<p class="programlisting">*pt += 1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// INVALID because pt points to a const int<br/>cin &gt;&gt; *pt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// INVALID for the same reason</p>
<p>Now for a subtle point. This declaration for <code>pt</code> doesn&#8217;t necessarily mean that the value it points to is really a constant; it just means the value is a constant insofar as <code>pt</code> is concerned. For example, <code>pt</code> points to <code>age</code>, and <code>age</code> is not <code>const</code>. You can change the value of <code>age</code> directly by using the <code>age</code> variable, but you can&#8217;t change the value indirectly via the <code>pt</code> pointer:</p>
<p class="programlisting">*pt = 20;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// INVALID because pt points to a const int<br/>age = 20;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// VALID because age is not declared to be const</p>
<p>Previous examples have assigned the address of a regular variable to a regular pointer. This example assigns the address of a regular variable to a pointer-to-<code>const</code>. That leaves two other possibilities: assigning the address of a <code>const</code> variable to a pointer-to-<code>const</code> and assigning the address of a <code>const</code> to a regular pointer. Are they both possible? The first is, and the second isn&#8217;t:</p>
<p class="programlisting">const float g_earth = 9.80;<br/>const float * pe = &#38;g_earth;&#160;&#160;&#160;// VALID<br/><br/>const float g_moon = 1.63;<br/>float * pm = &#38;g_moon;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// INVALID</p>
<p>For the first case, you can use neither <code>g_earth</code> nor <code>pe</code> to change the value <code>9.80</code>. C++ doesn&#8217;t allow the second case for a simple reason: If you can assign the address of <code>g_moon</code> to <code>pm</code>, then you can cheat and use <code>pm</code> to alter the value of <code>g_moon</code>. That makes a mockery <a id="page_335"/>of <code>g_moon</code>&#8217;s <code>const</code> status, so C++ prohibits you from assigning the address of a <code>const</code> to a non-<code>const</code> pointer. (If you are really desperate, you can use a type cast to override the restriction; see <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>,&#8221; for a discussion of the <code>const_cast</code> operator.)</p>
<p>The situation becomes a bit more complex if you have pointers to pointers. As you saw earlier, assigning a non-<code>const</code> pointer to a <code>const</code> pointer is okay, provided that you&#8217;re dealing with just one level of indirection:</p>
<p class="programlisting">int age = 39;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// age++ is a valid operation<br/>int * pd = &#38;age;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// *pd = 41 is a valid operation<br/>const int * pt = pd;&#160;&#160;&#160;// *pt = 42 is an invalid operation</p>
<p>But pointer assignments that mix <code>const</code> and non-<code>const</code> in this manner are no longer safe when you go to two levels of indirection. If mixing <code>const</code> and non-<code>const</code> were allowed, you could do something like this:</p>
<p class="programlisting">const int **pp2;<br/>int *p1;<br/>const int n = 13;<br/>pp2 = &#38;p1; // not allowed, but suppose it were<br/>*pp2 = &#38;n; // valid, both const, but sets p1 to point at n<br/>*p1 = 10;&#160;&#160;// valid, but changes const n</p>
<p>Here the code assigns a non-<code>const</code> address (<code>&#38;pl</code>) to a <code>const</code> pointer (<code>pp2</code>), and that allows <code>pl</code> to be used to alter <code>const</code> data. So the rule that you can assign a non-<code>const</code> address or pointer to a <code>const</code> pointer works only if there is just one level of indirection&#8212;for example, if the pointer points to a fundamental data type.</p>
<div class="note"><hr/>
<p class="title"><a id="ch07note03"/>Note</p>
<p class="notepara">You can assign the address of either <code>const</code> data or non-<code>const</code> data to a pointer-to-<code>const</code>, provided that the data type is not itself a pointer, but you can assign the address of non-<code>const</code> data only to a non-<code>const</code> pointer.</p>
<hr/></div>
<p>Suppose you have an array of <code>const</code> data:</p>
<p class="programlisting">const int months[12] = {31,28,31,30,31,30, 31, 31,30,31,30,31};</p>
<p>The prohibition against assigning the address of a constant array means that you cannot pass the array name as an argument to a function by using a non-constant formal argument:</p>
<p class="programlisting">int sum(int arr[], int n);&#160;&#160;// should have been const int arr[]<br/>...<br/>int j = sum(months, 12);&#160;&#160;&#160;&#160;// not allowed</p>
<p>This function call attempts to assign a <code>const</code> pointer (<code>months</code>) to a non-<code>const</code> pointer (<code>arr</code>), and the compiler disallows the function call.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch07sb02"/><a id="page_336"/>Using <code>const</code> When You Can</p>
<p class="sidebarpara">There are two strong reasons to declare pointer arguments as pointers to constant data:</p>
<p class="indenthandingB">&#8226; It protects you against programming errors that inadvertently alter data.</p>
<p class="indenthandingB">&#8226; Using <code>const</code> allows a function to process both <code>const</code> and non-<code>const</code> actual arguments, whereas a function that omits <code>const</code> in the prototype can accept only non-<code>const</code> data.</p>
<p class="sidebarpara">You should declare formal pointer arguments as pointers to <code>const</code> whenever it&#8217;s appropriate to do so.</p>
<hr/></div>
<p>For yet another subtle point, consider the following declarations:</p>
<p class="programlisting">int age = 39;<br/>const int * pt = &#38;age;</p>
<p>The <code>const</code> in the second declaration only prevents you from changing the value to which <code>pt</code> points, which is <code>39</code>. It doesn&#8217;t prevent you from changing the value of <code>pt</code> itself. That is, you can assign a new address to <code>pt</code>:</p>
<p class="programlisting">int sage = 80;<br/>pt = &#38;sage; // okay to point to another location</p>
<p>But you still can&#8217;t use <code>pt</code> to change the value to which it points (now <code>80</code>).</p>
<p>The second way to use <code>const</code> makes it impossible to change the value of the pointer itself:</p>
<p class="programlisting">int sloth = 3;<br/>const int * ps = &#38;sloth;&#160;&#160;&#160;&#160;&#160;&#160;// a pointer to const int<br/>int * const finger = &#38;sloth;&#160;&#160;// a const pointer to int</p>
<p>Note that the last declaration has repositioned the keyword <code>const</code>. This form of declaration constrains <code>finger</code> to point only to <code>sloth</code>. However, it allows you to use <code>finger</code> to alter the value of <code>sloth</code>. The middle declaration does not allow you to use <code>ps</code> to alter the value of <code>sloth</code>, but it permits you to have <code>ps</code> point to another location. In short, <code>finger</code> and <code>*ps</code> are both <code>const</code>, and <code>*finger</code> and <code>ps</code> are not <code>const</code> (see <a href="#ch07fig05">Figure 7.5</a>).</p>
<p class="caption"><a id="ch07fig05"/><strong>Figure 7.5. Pointers-to-<code>const</code> and <code>const</code> pointers.</strong></p>
<p class="image"><img src="graphics/07fig05.jpg" alt="Image"/></p>
<p>If you like, you can declare a <code>const</code> pointer to a <code>const</code> object:</p>
<p class="programlisting">double trouble = 2.0E30;<br/>const double * const stick = &#38;trouble;</p>
<p>Here <code>stick</code> can point only to <code>trouble</code>, and <code>stick</code> cannot be used to change the value of <code>trouble</code>. In short, both <code>stick</code> and <code>*stick</code> are <code>const</code>.</p>
<p>Typically you use the pointer-to-<code>const</code> form to protect data when you pass pointers as function arguments. For example, recall the <code>show_array()</code> prototype from <a href="#ch07ex05">Listing 7.5</a>:</p>
<p class="programlisting">void show_array(const double ar[], int n);</p>
<p>Using <code>const</code> in this declaration means that <code>show_array()</code> cannot alter the values in any array that is passed to it. This technique works as long as there is just one level of indirection. Here, for example, the array elements are a fundamental type. But if they were pointers or pointers-to-pointers, you wouldn&#8217;t use <code>const</code>.</p>
<h3 id="ch07lev1sec4">Functions and Two-Dimensional Arrays</h3>
<p><a id="page_337"/>To write a function that has a two-dimensional array as an argument, you need to remember that the name of an array is treated as its address, so the corresponding formal parameter is a pointer, just as for one-dimensional arrays. The tricky part is declaring the pointer correctly. Suppose, for example, that you start with this code:</p>
<p class="programlisting">int data[3][4] = {{1,2,3,4}, {9,8,7,6}, {2,4,6,8}};<br/>int total = sum(data, 3);</p>
<p>What should the prototype for <code>sum()</code> look like? And why does the function pass the number of rows (<code>3</code>) as an argument and not also the number of columns (<code>4</code>)?</p>
<p>Well, <code>data</code> is the name of an array with three elements. The first element is, itself, an array of four <code>int</code> values. Thus, the type of <code>data</code> is pointer-to-array-of-four-<code>int</code>, so an appropriate prototype would be this:</p>
<p class="programlisting">int sum(int (*ar2)[4], int size);</p>
<p><a id="page_338"/>The parentheses are needed because the following declaration would declare an array of four pointers-to-<code>int</code> instead of a single pointer-to-array-of-four-<code>int</code>, and a function parameter cannot be an array:</p>
<p class="programlisting">int *ar2[4]</p>
<p>Here&#8217;s an alternative format that means exactly the same thing as this first prototype, but, perhaps, is easier to read:</p>
<p class="programlisting">int sum(int ar2[][4], int size);</p>
<p>Either prototype states that <code>ar2</code> is a pointer, not an array. Also note that the pointer type specifically says it points to an array of four <code>int</code>s. Thus, the pointer type specifies the number of columns, which is why the number of columns is not passed as a separate function argument.</p>
<p>Because the pointer type specifies the number of columns, the <code>sum()</code> function only works with arrays with four columns. But the number of rows is specified by the variable size, so <code>sum()</code> can work with a varying number of rows:</p>
<p class="programlisting">int a[100][4];<br/>int b[6][4];<br/>...<br/>int total1 = sum(a, 100);&#160;&#160;&#160;&#160;// sum all of a<br/>int total2 = sum(b, 6);&#160;&#160;&#160;&#160;&#160;&#160;// sum all of b<br/>int total3 = sum(a, 10);&#160;&#160;&#160;&#160;&#160;// sum first 10 rows of a<br/>int total4 = sum(a+10, 20);&#160;&#160;// sum next 20 rows of a</p>
<p>Given that the parameter <code>ar2</code> is a pointer to an array, how do you use it in the function definition? The simplest way is to use <code>ar2</code> as if it were the name of a two-dimensional array. Here&#8217;s a possible function definition:</p>
<p class="programlisting">int sum(int ar2[][4], int size)<br/>{<br/>&#160;&#160;&#160;&#160;int total = 0;<br/>&#160;&#160;&#160;&#160;for (int r = 0; r &lt; size; r++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int c = 0; c &lt; 4; c++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;total += ar2[r][c];<br/>&#160;&#160;&#160;&#160;return total;<br/>}</p>
<p>Again, note that the number of rows is whatever is passed to the <code>size</code> parameter, but the number of columns is fixed at four, both in the parameter declaration for <code>ar2</code> and in the inner <code>for</code> loop.</p>
<p>Here&#8217;s why you can use array notation. Because <code>ar2</code> points to the first element (element 0) of an array whose elements are array-of-four-<code>int</code>, the expression <code>ar2 + r</code> points to element number <code>r</code>. Therefore <code>ar2[r]</code> is element number <code>r</code>. That element is itself an array-of-four-<code>int</code>, so <code>ar2[r]</code> is the name of that array-of-four-<code>int</code>. Applying a subscript to an array name gives an array element, so <code>ar2[r][c]</code> is an element of the array-of-four-<code>int</code>, hence is a single <code>int</code> value. The pointer <code>ar2</code> has to be dereferenced twice to get to <a id="page_339"/>the data. The simplest way is to use brackets twice, as in <code>ar2[r][c]</code>. But it is possible, if ungainly, to use the <code>*</code> operator twice:</p>
<p class="programlisting">ar2[r][c] == *(*(ar2 + r) + c)&#160;&#160;// same thing</p>
<p>To understand this, you can work out the meaning of the subexpressions from the inside out:</p>
<p class="programlisting">ar2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to first row of an array of 4 int<br/>ar2 + r&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to row r (an array of 4 int)<br/>*(ar2 + r)&#160;&#160;&#160;&#160;&#160;&#160;&#160;// row r (an array of 4 int, hence the name of an array,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// thus a pointer to the first int in the row, i.e., ar2[r]<br/><br/>*(ar2 +r) + c&#160;&#160;&#160;&#160;// pointer int number c in row r, i.e., ar2[r] + c<br/>*(*(ar2 + r) + c // value of int number c in row r, i.e. ar2[r][c]</p>
<p>Incidentally, the code for <code>sum()</code> doesn&#8217;t use <code>const</code> in declaring the parameter <code>ar2</code> because that technique is for pointers to fundamental types, and <code>ar2</code> is a pointer to a pointer.</p>
<h3 id="ch07lev1sec5">Functions and C-Style Strings</h3>
<p>Recall that a C-style string consists of a series of characters terminated by the null character. Much of what you&#8217;ve learned about designing array functions applies to string functions, too. For example, passing a string as an argument means passing an address, and you can use <code>const</code> to protect a string argument from being altered. But there are a few special twists to strings that we&#8217;ll unravel now.</p>
<h4 id="ch07lev2sec10">Functions with C-Style String Arguments</h4>
<p>Suppose you want to pass a string as an argument to a function. You have three choices for representing a string:</p>
<p class="indenthandingB">&#8226; An array of <code>char</code></p>
<p class="indenthandingB">&#8226; A quoted string constant (also called a <em>string literal</em>)</p>
<p class="indenthandingB">&#8226; A pointer-to-<code>char</code> set to the address of a string</p>
<p>All three choices, however, are type pointer-to-<code>char</code> (more concisely, type <code>char *</code>), so you can use all three as arguments to string-processing functions:</p>
<p class="programlisting">char ghost[15] = "galloping";<br/>char * str = "galumphing";<br/>int n1 = strlen(ghost);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ghost is &#38;ghost[0]<br/>int n2 = strlen(str);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to char<br/>int n3 = strlen("gamboling");&#160;&#160;&#160;&#160;// address of string</p>
<p>Informally, you can say that you&#8217;re passing a string as an argument, but you&#8217;re really passing the address of the first character in the string. This implies that a string function prototype should use type <code>char *</code> as the type for the formal parameter representing a string.</p>
<p><a id="page_340"/>One important difference between a C-style string and a regular array is that the string has a built-in terminating character. (Recall that a <code>char</code> array containing characters but no null character is just an array and not a string.) That means you don&#8217;t have to pass the size of the string as an argument. Instead, the function can use a loop to examine each character in the string in turn until the loop reaches the terminating null character. <a href="#ch07ex09">Listing 7.9</a> illustrates that approach with a function that counts the number of times a given character appears in a string. Because the program doesn&#8217;t need to deal with negative values, it uses <code>unsigned int</code> as the type for counting.</p>
<p class="caption1"><a id="ch07ex09"/><strong>Listing 7.9. <code>strgfun.cpp</code></strong></p><hr/>
<p class="programlisting1">// strgfun.cpp -- functions with a string argument<br/>#include &lt;iostream&gt;<br/>unsigned int c_in_str(const char * str, char ch);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char mmm[15] = "minimum";&#160;&#160;&#160;&#160;// string in an array<br/>// some systems require preceding char with static to<br/>// enable array initialization<br/><br/>&#160;&#160;&#160;&#160;char *wail = "ululate";&#160;&#160;&#160;&#160;// wail points to string<br/><br/>&#160;&#160;&#160;&#160;unsigned int ms = c_in_str(mmm, 'm');<br/>&#160;&#160;&#160;&#160;unsigned int us = c_in_str(wail, 'u');<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ms &lt;&lt; " m characters in " &lt;&lt; mmm &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; us &lt;&lt; " u characters in " &lt;&lt; wail &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// this function counts the number of ch characters<br/>// in the string str<br/>unsigned int c_in_str(const char * str, char ch)<br/>{<br/>&#160;&#160;&#160;&#160;unsigned int count = 0;<br/><br/>&#160;&#160;&#160;&#160;while (*str)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// quit when *str is '\0'<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*str == ch)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// move pointer to next char<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return count;<br/>}</p><hr/>
<p><a id="page_341"/>Here&#8217;s the output of the program in <a href="#ch07ex09">Listing 7.9</a>:</p>
<p class="programlisting">3 m characters in minimum<br/>2 u characters in ululate</p>
<h5 id="ch07lev3sec14">Program Notes</h5>
<p>Because the <code>c_int_str()</code> function in <a href="#ch07ex09">Listing 7.9</a> shouldn&#8217;t alter the original string, it uses the <code>const</code> modifier when it declares the formal parameter <code>str</code>. Then if you mistakenly let the function alter part of the string, the compiler catches your error. Of course, you can use array notation instead to declare <code>str</code> in the function header:</p>
<p class="programlisting">unsigned int c_in_str(const char str[], char ch) // also okay</p>
<p>However, using pointer notation reminds you that the argument doesn&#8217;t have to be the name of an array but can be some other form of pointer.</p>
<p>The function itself demonstrates a standard way to process the characters in a string:</p>
<p class="programlisting">while (*str)<br/>{<br/>&#160;&#160;&#160;&#160;statements<br/>&#160;&#160;&#160;&#160;str++;<br/>}</p>
<p>Initially, <code>str</code> points to the first character in the string, so <code>*str</code> represents the first character itself. For example, immediately after the first function call, <code>*str</code> has the value <code>m</code>, the first character in <code>minimum</code>. As long as the character is not the null character (<code>\0</code>), <code>*str</code> is nonzero, so the loop continues. At the end of each loop, the expression <code>str++</code> increments the pointer by 1 byte so that it points to the next character in the string. Eventually, <code>str</code> points to the terminating null character, making <code>*str</code> equal to <code>0</code>, which is the numeric code for the null character. That condition terminates the loop. (Why are string-processing functions ruthless? Because they stop at nothing.)</p>
<h4 id="ch07lev2sec11">Functions That Return C-Style Strings</h4>
<p>Now suppose you want to write a function that returns a string. Well, a function can&#8217;t do that. But it can return the address of a string, and that&#8217;s more efficient. <a href="#ch07ex10">Listing 7.10</a>, for example, defines a function called <code>buildstr()</code> that returns a pointer. This function takes two arguments: a character and a number. Using <code>new</code>, the function creates a string whose length equals the number, and then it initializes each element to the character. Then it returns a pointer to the new string.</p>
<p class="caption1"><a id="ch07ex10"/><strong>Listing 7.10. <code>strgback.cpp</code></strong></p><hr/>
<p class="programlisting1">// strgback.cpp -- a function that returns a pointer to char<br/>#include &lt;iostream&gt;<br/>char * buildstr(char c, int n);&#160;&#160;&#160;&#160;&#160;// prototype<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int times;<br/>&#160;&#160;&#160;&#160;char ch;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a character: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ch;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter an integer: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; times;<br/>&#160;&#160;&#160;&#160;char *ps = buildstr(ch, times);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ps &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;delete [] ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free memory<br/>&#160;&#160;&#160;&#160;ps = buildstr('+', 20);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// reuse pointer<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ps &lt;&lt; "-DONE-" &lt;&lt; ps &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;delete [] ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// free memory<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// builds string made of n c characters<br/>char * buildstr(char c, int n)<br/>{<br/>&#160;&#160;&#160;&#160;char * pstr = new char[n + 1];<br/>&#160;&#160;&#160;&#160;pstr[n] = '\0';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// terminate string<br/>&#160;&#160;&#160;&#160;while (n-- &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pstr[n] = c;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// fill rest of string<br/>&#160;&#160;&#160;&#160;return pstr;<br/>}</p><hr/>
<p><a id="page_342"/>Here&#8217;s a sample run of the program in <a href="#ch07ex10">Listing 7.10</a>:</p>
<p class="programlisting">Enter a character: <span class="EmpStrong">V</span><br/>Enter an integer: <span class="EmpStrong">46</span><br/>VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV<br/>++++++++++++++++++++-DONE-++++++++++++++++++++</p>
<h5 id="ch07lev3sec15">Program Notes</h5>
<p>To create a string of <code>n</code> visible characters, you need storage for <code>n + 1</code> characters in order to have space for the null character. So the function in <a href="#ch07ex10">Listing 7.10</a> asks for <code>n + 1</code> bytes to hold the string. Next, it sets the final byte to the null character. Then it fills in the rest of the array from back to front. In <a href="#ch07ex10">Listing 7.10</a>, the following loop cycles <code>n</code> times as <code>n</code> decreases to <code>0</code>, filling <code>n</code> elements:</p>
<p class="programlisting">while (n-- &gt; 0)<br/>&#160;&#160;&#160;&#160;pstr[n] = c;</p>
<p>At the start of the final cycle, <code>n</code> has the value <code>1</code>. Because <code>n--</code> means use the value and then decrement it, the <code>while</code> loop test condition compares <code>1</code> to <code>0</code>, finds the test to be <code>true</code>, and continues. But after making the test, the function decrements <code>n</code> to <code>0</code>, so <code>pstr[0]</code> <a id="page_343"/>is the last element set to <code>c</code>. The reason for filling the string from back to front instead of front to back is to avoid using an additional variable. Using the other order would involve something like this:</p>
<p class="programlisting">int i = 0;<br/>while (i &lt; n)<br/>&#160;&#160;&#160;&#160;pstr[i++] = c;</p>
<p>Note that the variable <code>pstr</code> is local to the <code>buildstr</code> function, so when that function terminates, the memory used for <code>pstr</code> (but not for the string) is freed. But because the function returns the value of <code>pstr</code>, the program is able to access the new string through the <code>ps</code> pointer in <code>main()</code>.</p>
<p>The program in <a href="#ch07ex10">Listing 7.10</a> uses <code>delete</code> to free memory used for the string after the string is no longer needed. Then it reuses <code>ps</code> to point to the new block of memory obtained for the next string and frees that memory. The disadvantage to this kind of design (having a function return a pointer to memory allocated by <code>new</code>) is that it makes it the programmer&#8217;s responsibility to remember to use <code>delete</code>. In <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; you&#8217;ll see how C++ classes, by using constructors and destructors, can take care of these details for you.</p>
<h3 id="ch07lev1sec6">Functions and Structures</h3>
<p>Let&#8217;s move from arrays to structures. It&#8217;s easier to write functions for structures than for arrays. Although structure variables resemble arrays in that both can hold several data items, structure variables behave like basic, single-valued variables when it comes to functions. That is, unlike an array, a structure ties its data in to a single entity, or data object, that will be treated as a unit. Recall that you can assign one structure to another. Similarly, you can pass structures by value, just as you do with ordinary variables. In that case, the function works with a copy of the original structure. Also a function can return a structure. There&#8217;s no funny business like the name of an array being the address of its first element. The name of a structure is simply the name of the structure, and if you want its address, you have to use the <code>&#38;</code> address operator. (C++ and C both use the <code>&#38;</code> symbol to denote the address operator. C++ additionally uses this operator to identify reference variables, to be discussed in <a href="ch08.html#ch08">Chapter 8</a>.)</p>
<p>The most direct way to program by using structures is to treat them as you would treat the basic types&#8212;that is, pass them as arguments and use them, if necessary, as return values. However, there is one disadvantage to passing structures by value. If the structure is large, the space and effort involved in making a copy of a structure can increase memory requirements and slow down the system. For those reasons (and because, at first, C didn&#8217;t allow the passing of structures by value), many C programmers prefer passing the address of a structure and then using a pointer to access the structure contents. C++ provides a third alternative, called <em>passing by reference</em>, that is discussed in <a href="ch08.html#ch08">Chapter 8</a>. Let&#8217;s examine the other two choices now, beginning with passing and returning entire structures.</p>
<h4 id="ch07lev2sec12">Passing and Returning Structures</h4>
<p><a id="page_344"/>Passing structures by value makes the most sense when the structure is relatively compact, so let&#8217;s look at a couple examples along those lines. The first example deals with travel time (not to be confused with time travel). Some maps will tell you that it is 3 hours, 50 minutes, from Thunder Falls to Bingo City and 1 hour, 25 minutes, from Bingo City to Grotesquo. You can use a structure to represent such times, using one member for the hour value and a second member for the minute value. Adding two times is a little tricky because you might have to transfer some of the minutes to the hours part. For example, the two preceding times sum to 4 hours, 75 minutes, which should be converted to 5 hours, 15 minutes. Let&#8217;s develop a structure to represent a time value and then a function that takes two such structures as arguments and returns a structure that represents their sum.</p>
<p>Defining the structure is simple:</p>
<p class="programlisting">struct travel_time<br/>{<br/>&#160;&#160;&#160;&#160;int hours;<br/>&#160;&#160;&#160;&#160;int mins;<br/>};</p>
<p>Next, consider the prototype for a <code>sum()</code> function that returns the sum of two such structures. The return value should be type <code>travel_time</code>, and so should the two arguments. Thus, the prototype should look like this:</p>
<p class="programlisting">travel_time sum(travel_time t1, travel_time t2);</p>
<p>To add two times, you first add the minute members. Integer division by 60 yields the number of hours to carry over, and the modulus operation (<code>%</code>) yields the number of minutes left. <a href="#ch07ex11">Listing 7.11</a> incorporates this approach into the <code>sum()</code> function and adds a <code>show_time()</code> function to display the contents of a <code>travel_time</code> structure.</p>
<p class="caption1"><a id="ch07ex11"/><strong>Listing 7.11. <code>travel.cpp</code></strong></p><hr/>
<p class="programlisting1">// travel.cpp -- using structures with functions<br/>#include &lt;iostream&gt;<br/>struct travel_time<br/>{<br/>&#160;&#160;&#160;&#160;int hours;<br/>&#160;&#160;&#160;&#160;int mins;<br/>};<br/>const int Mins_per_hr = 60;<br/><br/>travel_time sum(travel_time t1, travel_time t2);<br/>void show_time(travel_time t);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;travel_time day1 = {5, 45};&#160;&#160;&#160;&#160;// 5 hrs, 45 min<br/>&#160;&#160;&#160;&#160;travel_time day2 = {4, 55};&#160;&#160;&#160;&#160;// 4 hrs, 55 min<br/><br/>&#160;&#160;&#160;&#160;travel_time trip = sum(day1, day2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Two-day total: ";<br/>&#160;&#160;&#160;&#160;show_time(trip);<br/><br/>&#160;&#160;&#160;&#160;travel_time day3= {4, 32};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Three-day total: ";<br/>&#160;&#160;&#160;&#160;show_time(sum(trip, day3));<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>travel_time sum(travel_time t1, travel_time t2)<br/>{<br/>&#160;&#160;&#160;&#160;travel_time total;<br/><br/>&#160;&#160;&#160;&#160;total.mins = (t1.mins + t2.mins) % Mins_per_hr;<br/>&#160;&#160;&#160;&#160;total.hours = t1.hours + t2.hours +<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(t1.mins + t2.mins) / Mins_per_hr;<br/>&#160;&#160;&#160;&#160;return total;<br/>}<br/><br/>void show_time(travel_time t)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; t.hours &lt;&lt; " hours, "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; t.mins &lt;&lt; " minutes\n";<br/>}</p><hr/>
<p><a id="page_345"/>Here <code>travel_time</code> acts just like a standard type name; you can use it to declare variables, function return types, and function argument types. Because variables such as <code>total</code> and <code>t1</code> are <code>travel_time</code> structures, you can apply the dot membership operator to them. Note that because the <code>sum()</code> function returns a <code>travel_time</code> structure, you can use it as an argument for the <code>show_time()</code> function. Because C++ functions, by default, pass arguments by value, the <code>show_time(sum(trip, day3))</code> function call first evaluates the <code>sum(trip, day3)</code> function call in order to find its return value. The <code>show_time()</code> call then passes <code>sum()</code>&#8217;s return value, not the function itself, to <code>show_time()</code>. Here&#8217;s the output of the program in <a href="#ch07ex11">Listing 7.11</a>:</p>
<p class="programlisting">Two-day total: 10 hours, 40 minutes<br/>Three-day total: 15 hours, 12 minutes</p>
<h4 id="ch07lev2sec13">Another Example of Using Functions with Structures</h4>
<p><a id="page_346"/>Much of what you learn about functions and C++ structures carries over to C++ classes, so it&#8217;s worth looking at a second example. This time let&#8217;s deal with space instead of time. In particular, this example defines two structures representing two different ways of describing positions and then develops functions to convert one form to the other and show the result. This example is a bit more mathematical than the last, but you don&#8217;t have to follow the mathematics to follow the C++.</p>
<p>Suppose you want to describe the position of a point on the screen or a location on a map relative to some origin. One way is to state the horizontal offset and the vertical offset of the point from the origin. Traditionally, mathematicians use the symbol x to represent the horizontal offset and y to represent the vertical offset (see <a href="#ch07fig06">Figure 7.6</a>). Together, x and y constitute <em>rectangular coordinates</em>. You can define a structure consisting of two coordinates to represent a position:</p>
<p class="caption"><a id="ch07fig06"/><strong>Figure 7.6. Rectangular coordinates.</strong></p>
<p class="image"><img src="graphics/07fig06.jpg" alt="Image"/></p>
<p class="programlisting">struct rect<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;double x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// horizontal distance from origin<br/>&#160;&#160;&#160;&#160;&#160;&#160;double y;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// vertical distance from origin<br/>};</p>
<p>A second way to describe the position of a point is to state how far it is from the origin and in what direction it is (for example, 40 degrees north of east). Traditionally, mathematicians have measured the angle counterclockwise from the positive horizontal <a id="page_347"/>axis (see <a href="#ch07fig07">Figure 7.7</a>). The distance and angle together constitute <em>polar coordinates</em>. You can define a second structure to represent this view of a position:</p>
<p class="programlisting">struct polar<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;double distance;&#160;&#160;&#160;// distance from origin<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;double angle;&#160;&#160;&#160;&#160;&#160;&#160;// direction from origin<br/>};</p>
<p class="caption"><a id="ch07fig07"/><strong>Figure 7.7. Polar coordinates.</strong></p>
<p class="image"><img src="graphics/07fig07.jpg" alt="Image"/></p>
<p>Let&#8217;s construct a function that displays the contents of a type <code>polar</code> structure. The math functions in the C++ library (borrowed from C) assume that angles are in radians, so you need to measure angles in that unit. But for display purposes, you can convert radian measure to degrees. This means multiplying by 180/&#960;, which is approximately 57.29577951. Here&#8217;s the function:</p>
<p class="programlisting">// show polar coordinates, converting angle to degrees<br/>void show_polar (polar dapos)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const double Rad_to_deg = 57.29577951;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "distance = " &lt;&lt; dapos.distance;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", angle = " &lt;&lt; dapos.angle * Rad_to_deg;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " degrees\n";<br/>}</p>
<p><a id="page_348"/>Notice that the formal variable is type <code>polar</code>. When you pass a <code>polar</code> structure to this function, the structure contents are copied into the <code>dapos</code> structure, and the function then uses that copy in its work. Because <code>dapos</code> is a structure, the function uses the membership (dot) operator (see <a href="ch04.html#ch04">Chapter 4</a>) to identify structure members.</p>
<p>Next, let&#8217;s try something more ambitious and write a function that converts rectangular coordinates to polar coordinates. We&#8217;ll have the function accept a <code>rect</code> structure as its argument and return a <code>polar</code> structure to the calling function. This involves using functions from the math library, so the program has to include the <code>cmath</code> header file (<code>math.h</code> on older systems). Also on some systems you have to tell the compiler to load the math library (see <a href="ch01.html#ch01">Chapter 1</a>, &#8220;<a href="ch01.html#ch01">Getting Started with C++</a>&#8221;). You can use the Pythagorean theorem to get the distance from the horizontal and vertical components:</p>
<p class="programlisting">distance = sqrt( x * x + y * y)</p>
<p>The <code>atan2()</code> function from the math library calculates the angle from the <code>x</code> and <code>y</code> values:</p>
<p class="programlisting">angle = atan2(y, x)</p>
<p>(There&#8217;s also an <code>atan()</code> function, but it doesn&#8217;t distinguish between angles 180 degrees apart. That uncertainty is no more desirable in a math function than it is in a wilderness guide.)</p>
<p>Given these formulas, you can write the function as follows:</p>
<p class="programlisting">// convert rectangular to polar coordinates<br/>polar rect_to_polar(rect xypos)&#160;&#160;&#160;// type polar<br/>{<br/>&#160;&#160;&#160;&#160;polar answer;<br/><br/>&#160;&#160;&#160;&#160;answer.distance =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sqrt( xypos.x * xypos.x + xypos.y * xypos.y);<br/>&#160;&#160;&#160;&#160;answer.angle = atan2(xypos.y, xypos.x);<br/>&#160;&#160;&#160;&#160;return answer;&#160;&#160;&#160;&#160;&#160;&#160;// returns a polar structure<br/>}</p>
<p>Now that the functions are ready, writing the rest of the program is straightforward. <a href="#ch07ex12">Listing 7.12</a> presents the result.</p>
<p class="caption1"><a id="ch07ex12"/><strong>Listing 7.12. <code>strctfun.cpp</code></strong></p><hr/>
<p class="programlisting1">// strctfun.cpp -- functions with a structure argument<br/>#include &lt;iostream&gt;<br/>#include &lt;cmath&gt;<br/><br/>// structure declarations<br/>struct polar<br/><a id="page_349"/>{<br/>&#160;&#160;&#160;&#160;double distance;&#160;&#160;&#160;&#160;&#160;&#160;// distance from origin<br/>&#160;&#160;&#160;&#160;double angle;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// direction from origin<br/>};<br/>struct rect<br/>{<br/>&#160;&#160;&#160;&#160;double x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// horizontal distance from origin<br/>&#160;&#160;&#160;&#160;double y;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// vertical distance from origin<br/>};<br/><br/>// prototypes<br/>polar rect_to_polar(rect xypos);<br/>void show_polar(polar dapos);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;rect rplace;<br/>&#160;&#160;&#160;&#160;polar pplace;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the x and y values: ";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)&#160;&#160;// slick use of cin<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pplace = rect_to_polar(rplace);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;show_polar(pplace);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Next two numbers (q to quit): ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// convert rectangular to polar coordinates<br/>polar rect_to_polar(rect xypos)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;polar answer;<br/><br/>&#160;&#160;&#160;&#160;answer.distance =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sqrt( xypos.x * xypos.x + xypos.y * xypos.y);<br/>&#160;&#160;&#160;&#160;answer.angle = atan2(xypos.y, xypos.x);<br/>&#160;&#160;&#160;&#160;return answer;&#160;&#160;&#160;&#160;&#160;&#160;// returns a polar structure<br/>}<br/><br/>// show polar coordinates, converting angle to degrees<br/>void show_polar (polar dapos)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const double Rad_to_deg = 57.29577951;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "distance = " &lt;&lt; dapos.distance;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", angle = " &lt;&lt; dapos.angle * Rad_to_deg;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " degrees\n";<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch07note04"/><a id="page_350"/>Note</p>
<p class="notepara">Some compilers require explicit instructions to search the math library. For example, older versions of g++ uses this command line:</p>
<p class="programlistingB">g++ structfun.C -lm</p>
<hr/></div>
<p>Here is a sample run of the program in <a href="#ch07ex12">Listing 7.12</a>:</p>
<p class="programlisting">Enter the x and y values: <span class="EmpStrong">30 40</span><br/>distance = 50, angle = 53.1301 degrees<br/>Next two numbers (q to quit): <span class="EmpStrong">-100 100</span><br/>distance = 141.421, angle = 135 degrees<br/>Next two numbers (q to quit): <span class="EmpStrong">q</span></p>
<h5 id="ch07lev3sec16">Program Notes</h5>
<p>We&#8217;ve already discussed the two functions in <a href="#ch07ex12">Listing 7.12</a>, so let&#8217;s review how the program uses <code>cin</code> to control a <code>while</code> loop:</p>
<p class="programlisting">while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)</p>
<p>Recall that <code>cin</code> is an object of the <code>istream</code> class. The extraction operator (<code>&gt;&gt;</code>) is designed in such a way that <code>cin &gt;&gt; rplace.x</code> also is an object of that type. As you&#8217;ll see in <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>,&#8221; class operators are implemented with functions. What really happens when you use <code>cin &gt;&gt; rplace.x</code> is that the program calls a function that returns a type <code>istream</code> value. If you apply the extraction operator to the <code>cin &gt;&gt; rplace.x</code> object (as in <code>cin &gt;&gt; rplace.x &gt;&gt; rplace.y</code>), you again get an object of the <code>istream</code> class. Thus, the entire <code>while</code> loop test expression eventually evaluates to <code>cin</code>, which, as you may recall, when used in the context of a test expression, is converted to a <code>bool</code> value of <code>true</code> or <code>false</code>, depending on whether input succeeded. In the loop in <a href="#ch07ex12">Listing 7.12</a>, for example, <code>cin</code> expects the user to enter two numbers. If, instead, the user enters <code>q</code>, as shown in the sample output, <code>cin &gt;&gt;</code> recognizes that <code>q</code> is not a number. It leaves the <code>q</code> in the input queue and returns a value that&#8217;s converted to <code>false</code>, terminating the loop.</p>
<p>Compare that approach for reading numbers to this simpler one:</p>
<p class="programlisting">for (int i = 0; i &lt; limit; i++)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter value #" &lt;&lt; (i + 1) &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; temp;<br/>&#160;&#160;&#160;&#160;if (temp &lt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;ar[i] = temp;<br/>}</p>
<p>To terminate this loop early, you enter a negative number. This restricts input to non-negative values. This restriction fits the needs of some programs, but more typically you <a id="page_351"/>would want a means of terminating a loop that doesn&#8217;t exclude certain numeric values. Using <code>cin &gt;&gt;</code> as the test condition eliminates such restrictions because it accepts all valid numeric input. You should keep this trick in mind when you need an input loop for numbers. Also, you should keep in mind that non-numeric input sets an error condition that prevents the reading of any more input. If a program needs input subsequent to the input loop, you must use <code>cin.clear()</code> to reset input, and you might then need to get rid of the offending input by reading it. <a href="#ch07ex07">Listing 7.7</a> illustrates those techniques.</p>
<h4 id="ch07lev2sec14">Passing Structure Addresses</h4>
<p>Suppose you want to save time and space by passing the address of a structure instead of passing the entire structure. This requires rewriting the functions so that they use pointers to structures. First, let&#8217;s look at how you rewrite the <code>show_polar()</code> function. You need to make three changes:</p>
<p class="indenthandingB">&#8226; When calling the function, pass it the address of the structure (<code>&#38;pplace</code>) rather than the structure itself (<code>pplace</code>).</p>
<p class="indenthandingB">&#8226; Declare the formal parameter to be a pointer-to-<code>polar</code>&#8212;that is, type <code>polar *</code>. Because the function shouldn&#8217;t modify the structure, use the <code>const</code> modifier.</p>
<p class="indenthandingB">&#8226; Because the formal parameter is a pointer instead of a structure, use the indirect membership operator (<code>-&gt;</code>) rather than the membership operator (dot).</p>
<p>After these changes are made, the function looks like this:</p>
<p class="programlisting">// show polar coordinates, converting angle to degrees<br/>void show_polar (const polar * pda)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const double Rad_to_deg = 57.29577951;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "distance = " &lt;&lt; pda-&gt;distance;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", angle = " &lt;&lt; pda-&gt;angle * Rad_to_deg;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " degrees\n";<br/>}</p>
<p>Next, let&#8217;s alter <code>rect_to_polar</code>. This is more involved because the original <code>rect_to_polar</code> function returns a structure. To take full advantage of pointer efficiency, you should use a pointer instead of a return value. The way to do this is to pass two pointers to the function. The first points to the structure to be converted, and the second points to the structure that&#8217;s to hold the conversion. Instead of <em>returning</em> a new structure, the function <em>modifies</em> an existing structure in the calling function. Hence, although the first argument is <code>const</code> pointer, the second is not <code>const</code>. Otherwise, you apply the same principles used to convert <code>show_polar()</code> to pointer arguments. <a href="#ch07ex13">Listing 7.13</a> shows the reworked program.</p>
<p class="caption1"><a id="page_352"/><a id="ch07ex13"/><strong>Listing 7.13. <code>strctptr.cpp</code></strong></p><hr/>
<p class="programlisting1">// strctptr.cpp -- functions with pointer to structure arguments<br/>#include &lt;iostream&gt;<br/>#include &lt;cmath&gt;<br/><br/>// structure templates<br/>struct polar<br/>{<br/>&#160;&#160;&#160;&#160;double distance;&#160;&#160;&#160;&#160;&#160;&#160;// distance from origin<br/>&#160;&#160;&#160;&#160;double angle;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// direction from origin<br/>};<br/>struct rect<br/>{<br/>&#160;&#160;&#160;&#160;double x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// horizontal distance from origin<br/>&#160;&#160;&#160;&#160;double y;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// vertical distance from origin<br/>};<br/><br/>// prototypes<br/>void rect_to_polar(const rect * pxy, polar * pda);<br/>void show_polar (const polar * pda);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;rect rplace;<br/>&#160;&#160;&#160;&#160;polar pplace;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the x and y values: ";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rect_to_polar(&#38;rplace, &#38;pplace);&#160;&#160;&#160;&#160;// pass addresses<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;show_polar(&#38;pplace);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pass address<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Next two numbers (q to quit): ";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// show polar coordinates, converting angle to degrees<br/>void show_polar (const polar * pda)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const double Rad_to_deg = 57.29577951;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "distance = " &lt;&lt; pda-&gt;distance;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ", angle = " &lt;&lt; pda-&gt;angle * Rad_to_deg;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " degrees\n";<br/>}<br/><br/>// convert rectangular to polar coordinates<br/>void rect_to_polar(const rect * pxy, polar * pda)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;pda-&gt;distance =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sqrt(pxy-&gt;x * pxy-&gt;x + pxy-&gt;y * pxy-&gt;y);<br/>&#160;&#160;&#160;&#160;pda-&gt;angle = atan2(pxy-&gt;y, pxy-&gt;x);<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch07note05"/><a id="page_353"/>Note</p>
<p class="notepara">Some compilers require explicit instructions to search the math library. For example, older versions of g++ use this command line:</p>
<p class="programlistingB">g++ structfun.C -lm</p>
<hr/></div>
<p>From the user&#8217;s standpoint, the program in <a href="#ch07ex13">Listing 7.13</a> behaves like that in <a href="#ch07ex12">Listing 7.12</a>. The hidden difference is that <a href="#ch07ex12">Listing 7.12</a> works with copies of structures, whereas <a href="#ch07ex13">Listing 7.13</a> uses pointers, allowing the functions to operate on the original structures.</p>
<h3 id="ch07lev1sec7">Functions and <code>string</code> Class Objects</h3>
<p>Although C-style strings and <code>string</code> class objects serve much the same purpose, a <code>string</code> class object is more closely related to a structure than to an array. For example, you can assign a structure to another structure and an object to another object. You can pass a structure as a complete entity to a function, and you can pass an object as a complete entity. If you need several strings, you can declare a one-dimensional array of <code>string</code> objects instead of a two-dimensional array of <code>char</code>.</p>
<p><a href="#ch07ex14">Listing 7.14</a> provides a short example that declares an array of string objects and passes the array to a function that displays the contents.</p>
<p class="caption1"><a id="ch07ex14"/><strong>Listing 7.14. <code>topfive.cpp</code></strong></p><hr/>
<p class="programlisting1">// topfive.cpp -- handling an array of string objects<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>using namespace std;<br/>const int SIZE = 5;<br/>void display(const string sa[], int n);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;string list[SIZE];&#160;&#160;&#160;&#160;&#160;// an array holding 5 string object<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your " &lt;&lt; SIZE &lt;&lt; " favorite astronomical sights:\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; SIZE; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i + 1 &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getline(cin,list[i]);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your list:\n";<br/>&#160;&#160;&#160;&#160;display(list, SIZE);<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void display(const string sa[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; sa[i] &lt;&lt; endl;<br/>}</p><hr/>
<p><a id="page_354"/>Here&#8217;s a sample run of the program in <a href="#ch07ex14">Listing 7.14</a>:</p>
<p class="programlisting">Enter your 5 favorite astronomical sights:<br/>1: <span class="EmpStrong">Orion Nebula</span><br/>2: <span class="EmpStrong">M13</span><br/>3: <span class="EmpStrong">Saturn</span><br/>4: <span class="EmpStrong">Jupiter</span><br/>5: <span class="EmpStrong">Moon</span><br/>Your list:<br/>1: Orion Nebula<br/>2: M13<br/>3: Saturn<br/>4: Jupiter<br/>5: Moon</p>
<p>The main point to note in this example is that, aside from the <code>getline()</code> function, this program treats <code>string</code> just as it would treat any of the built-in types, such as <code>int</code>. If you want an array of <code>string</code>, you just use the usual array-declaration format:</p>
<p class="programlisting">string list[SIZE];&#160;&#160;&#160;&#160;&#160;// an array holding 5 string object</p>
<p>Each element of the <code>list</code> array, then, is a <code>string</code> object and can be used as such:</p>
<p class="programlisting">getline(cin,list[i]);</p>
<p>Similarly, the formal argument <code>sa</code> is a pointer to a <code>string</code> object, so <code>sa[i]</code> is a <code>string</code> object and can be used accordingly:</p>
<p class="programlisting">cout &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; sa[i] &lt;&lt; endl;</p>
<h3 id="ch07lev1sec8">Functions and <code>array</code> Objects</h3>
<p><a id="page_355"/>Class objects in C++ are based on structures, so some of the same programming considerations that apply to structures also apply to classes. For example, you can pass an object by value to a function, in which case the function acts on a copy of the original object. Alternatively, you can pass a pointer to an object, which allows the function to act on the original object. Let&#8217;s look at an example using the C++11 <code>array</code> template class.</p>
<p>Suppose we have an <code>array</code> object intended to hold expense figures for each of the four seasons of the year:</p>
<p class="programlisting">std::array&lt;double, 4&gt; expenses;</p>
<p>(Recall that using the <code>array</code> class requires the <code>array</code> header file and that the name <code>array</code> is part of the <code>std</code> namespace.) If we want a function to display the contents of <code>expenses</code>, we can pass <code>expenses</code> by value:</p>
<p class="programlisting">show(expenses);</p>
<p>But if we want a function that modifies the <code>expenses</code> object, we need to pass the address of the object to the function:</p>
<p class="programlisting">fill(&#38;expenses);</p>
<p>(The next chapter discusses an alternative approach, using references.) This is the same approach that <a href="#ch07ex13">Listing 7.13</a> used for structures.</p>
<p>How can we declare these two functions? The type of <code>expenses</code> is <code>array&lt;double, 4&gt;</code>, so that&#8217;s what must appear in the prototypes:</p>
<p class="programlisting">void show(std::array&lt;double, 4&gt; da);&#160;&#160;&#160;// da an object<br/>void fill(std::array&lt;double, 4&gt; * pa); // pa a pointer to an object</p>
<p>These considerations form the core of the sample program. The program adds a few more features. First, it replaces <code>4</code> with a symbolic constant:</p>
<p class="programlisting">const int Seasons = 4;</p>
<p>Second, it adds a <code>const array</code> object containing four <code>string</code> objects representing the four seasons:</p>
<p class="programlisting">const std::array&lt;std::string, Seasons&gt; Snames =<br/>&#160;&#160;&#160;&#160;{"Spring", "Summer", "Fall", "Winter"};</p>
<p>Note that the <code>array</code> template is not limited to holding the basic data types; it can use class types too. <a href="#ch07ex15">Listing 7.15</a> presents the program in full.</p>
<p class="caption1"><a id="ch07ex15"/><strong>Listing 7.15. <code>arrobj.cpp</code></strong></p><hr/>
<p class="programlisting1">//arrobj.cpp -- functions with array objects (C++11)<br/>#include &lt;iostream&gt;<br/>#include &lt;array&gt;<br/>#include &lt;string&gt;<br/>// constant data<br/>const int Seasons = 4;<br/>const std::array&lt;std::string, Seasons&gt; Snames =<br/>&#160;&#160;&#160;&#160;{"Spring", "Summer", "Fall", "Winter"};<br/><br/>// function to modify array object<br/>void fill(std::array&lt;double, Seasons&gt; * pa);<br/>// function that uses array object without modifying it<br/>void show(std::array&lt;double, Seasons&gt; da);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;std::array&lt;double, Seasons&gt; expenses;<br/>&#160;&#160;&#160;&#160;fill(&#38;expenses);<br/>&#160;&#160;&#160;&#160;show(expenses);<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void fill(std::array&lt;double, Seasons&gt; * pa)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; Seasons; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter " &lt;&lt; Snames[i] &lt;&lt; " expenses: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; (*pa)[i];<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>void show(std::array&lt;double, Seasons&gt; da)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double total = 0.0;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nEXPENSES\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; Seasons; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; Snames[i] &lt;&lt; ": $" &lt;&lt; da[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;total += da[i];<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Total Expenses: $" &lt;&lt; total &lt;&lt; endl;<br/>}</p><hr/>
<p><a id="page_356"/>Here&#8217;s a sample run:</p>
<p class="programlisting">Enter Spring expenses: <span class="EmpStrong">212</span><br/>Enter Summer expenses: <span class="EmpStrong">256</span><br/>Enter Fall expenses: <span class="EmpStrong">208</span><br/>Enter Winter expenses: <span class="EmpStrong">244</span><br/><a id="page_357"/>EXPENSES<br/>Spring: $212<br/>Summer: $256<br/>Fall: $208<br/>Winter: $244<br/>Total: $920</p>
<h4 id="ch07lev2sec15">Program Notes</h4>
<p>Because the <code>const array</code> object <code>Snames</code> is declared above all the functions, it can be used in any of the following function definitions. Like the <code>const Seasons</code>, <code>Snames</code> is shared by the whole source code file. The program doesn&#8217;t have a <code>using</code> directive, so <code>array</code> and <code>string</code> have to be used with the <code>str::</code> qualifier. To keep the program short and focused on how functions can use objects, the <code>fill()</code> function doesn&#8217;t check for valid input.</p>
<p>Both <code>fill()</code> and <code>show()</code> have drawbacks. For <code>show()</code>, the problem is that <code>expenses</code> holds four <code>double</code> values and it&#8217;s inefficient to create a new object of that size and to copy the <code>expenses</code> values into it. The problem gets worse if we modify the program to handle expenses on a monthly basis or daily basis and expand <code>expenses</code> accordingly.</p>
<p>The <code>fill()</code> function avoids this inefficiency problem by using a pointer so that the function acts on the original object. But this comes at the cost of notation that makes the programming look more complicated:</p>
<p class="programlisting">fill(&#38;expenses);&#160;&#160;&#160;&#160;// don't forget the &#38;<br/>...<br/>cin &gt;&gt; (*pa)[i];</p>
<p>In the last statement, <code>pa</code> is a pointer to an <code>array&lt;double, 4&gt;</code> object, so <code>*pa</code> is the object, and <code>(*pa)[i]</code> is an element in the object. The parentheses are required because of operator precedence. The logic is straightforward, but results enhance opportunities for making errors.</p>
<p>Using references, as discussed in <a href="ch08.html#ch08">Chapter 8</a>, helps solve both the efficiency and the notational problems.</p>
<h3 id="ch07lev1sec9">Recursion</h3>
<p>And now for something completely different. A C++ function has the interesting characteristic that it can call itself. (Unlike C, however, C++ does not let <code>main()</code> call itself.) This ability is termed <em>recursion</em>. Recursion is an important tool in certain types of programming, such as artificial intelligence, but we&#8217;ll just take a superficial look (artificial shallowness) at how it works.</p>
<h4 id="ch07lev2sec16">Recursion with a Single Recursive Call</h4>
<p><a id="page_358"/>If a recursive function calls itself, then the newly called function calls itself, and so on, ad infinitum unless the code includes something to terminate the chain of calls. The usual method is to make the recursive call part of an <code>if</code> statement. For example, a type <code>void</code> recursive function called <code>recurs()</code> can have a form like this:</p>
<p class="programlisting">void <span class="EmpItalic">recurs</span>(<span class="EmpItalic">argumentlist</span>)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">statements1</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;if (<span class="EmpItalic">test</span>)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;recurs(<span class="EmpItalic">arguments</span>)<br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">statements2</span><br/>}</p>
<p>With luck or foresight, <em><code>test</code></em> eventually becomes <code>false</code>, and the chain of calls is broken.</p>
<p>Recursive calls produce an intriguing chain of events. As long as the <code>if</code> statement remains <code>true</code>, each call to <code>recurs()</code> executes <em><code>statements1</code></em> and then invokes a new incarnation of <code>recurs()</code> without reaching <em><code>statements2</code></em>. When the <code>if</code> statement becomes <code>false</code>, the current call then proceeds to <em><code>statements2</code></em>. Then when the current call terminates, program control returns to the previous version of <code>recurs()</code> that called it. Then, that version of <code>recurs()</code> completes executing its <em><code>statements2</code></em> section and terminates, returning control to the prior call, and so on. Thus, if <code>recurs()</code> undergoes five recursive calls, first the <em><code>statements1</code></em> section is executed five times in the order in which the functions were called, and then the <em><code>statements2</code></em> section is executed five times in the opposite order from the order in which the functions were called. After going into five levels of recursion, the program then has to back out through the same five levels. <a href="#ch07ex16">Listing 7.16</a> illustrates this behavior.</p>
<p class="caption1"><a id="ch07ex16"/><strong>Listing 7.16. <code>recur.cpp</code></strong></p><hr/>
<p class="programlisting1">// recur.cpp -- using recursion<br/>#include &lt;iostream&gt;<br/>void countdown(int n);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;countdown(4);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// call the recursive function<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void countdown(int n)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Counting down ... " &lt;&lt; n &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;if (n &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;countdown(n-1);&#160;&#160;&#160;&#160;&#160;// function calls itself<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; n &lt;&lt; ": Kaboom!\n";<br/>}</p><hr/>
<p><a id="page_359"/>Here&#8217;s the annotated output of the program in <a href="#ch07ex16">Listing 7.16</a>:</p>
<p class="programlisting">Counting down ... 4&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 1; adding levels of recursion<br/>Counting down ... 3&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 2<br/>Counting down ... 2&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 3<br/>Counting down ... 1&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 4<br/>Counting down ... 0&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 5; final recursive call<br/>0: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 5; beginning to back out<br/>1: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 4<br/>2: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 3<br/>3: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 2<br/>4: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="ent">&#8249;</span>level 1</p>
<p>Note that each recursive call creates its own set of variables, so by the time the program reaches the fifth call, it has five separate variables called <code>n</code>, each with a different value. You can verify this for yourself by modifying <a href="#ch07ex16">Listing 7.16</a> so that it displays the address of <code>n</code> as well as its value:</p>
<p class="programlisting">cout &lt;&lt; "Counting down ... " &lt;&lt; n &lt;&lt; " (n at " &lt;&lt; &#38;n &lt;&lt; ")" &lt;&lt; endl;<br/>...<br/>cout &lt;&lt; n &lt;&lt; ": Kaboom!"; &lt;&lt; "&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(n at " &lt;&lt; &#38;n &lt;&lt; ")" &lt;&lt; endl;</p>
<p>Doing so produces output like the following:</p>
<p class="programlisting">Counting down ... 4 (n at 0012FE0C)<br/>Counting down ... 3 (n at 0012FD34)<br/>Counting down ... 2 (n at 0012FC5C)<br/>Counting down ... 1 (n at 0012FB84)<br/>Counting down ... 0 (n at 0012FAAC)<br/>0: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(n at 0012FAAC)<br/>1: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(n at 0012FB84)<br/>2: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(n at 0012FC5C)<br/>3: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(n at 0012FD34)<br/>4: Kaboom!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(n at 0012FE0C)</p>
<p>Note how the <code>n</code> having the value <code>4</code> is stored at one location (memory address 0012FE0C in this example), the <code>n</code> having the value <code>3</code> is stored at a second location (memory address 0012FD34), and so on. Also note how the address of <code>n</code> for a particular level during the &#8220;Counting down&#8221; stage is the same as its address for the same level during the &#8220;Kaboom!&#8221; stage.</p>
<h4 id="ch07lev2sec17">Recursion with Multiple Recursive Calls</h4>
<p>Recursion is particularly useful for situations that call for repeatedly subdividing a task into two smaller, similar tasks. For example, consider this approach to drawing a ruler. <a id="page_360"/>Mark the two ends, locate the midpoint, and mark it. Then apply this same procedure to the left half of the ruler and then to the right half. If you want more subdivisions, apply the same procedure to each of the current subdivisions. This recursive approach is sometimes called the <em>divide-and-conquer strategy</em>. <a href="#ch07ex17">Listing 7.17</a> illustrates this approach, with the recursive function <code>subdivide()</code>. It uses a string initially filled with spaces except for a <code>|</code> character at each end. The main program uses a loop to call the <code>subdivide()</code> function six times, each time increasing the number of recursion levels and printing the resulting string. Thus, each line of output represents an additional level of recursion. To remind you that it&#8217;s an option, the program uses the <code>std::</code> qualifier instead of a <code>using</code> directive.</p>
<p class="caption1"><a id="ch07ex17"/><strong>Listing 7.17. <code>ruler.cpp</code></strong></p><hr/>
<p class="programlisting1">// ruler.cpp -- using recursion to subdivide a ruler<br/>#include &lt;iostream&gt;<br/>const int Len = 66;<br/>const int Divs = 6;<br/>void subdivide(char ar[], int low, int high, int level);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;char ruler[Len];<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 1; i &lt; Len - 2; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ruler[i] = ' ';<br/>&#160;&#160;&#160;&#160;ruler[Len - 1] = '\0';<br/>&#160;&#160;&#160;&#160;int max = Len - 2;<br/>&#160;&#160;&#160;&#160;int min = 0;<br/>&#160;&#160;&#160;&#160;ruler[min] = ruler[max] = '|';<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; ruler &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;for (i = 1; i &lt;= Divs; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;subdivide(ruler,min,max, i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; ruler &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int j = 1; j &lt; Len - 2; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ruler[j] = ' ';&#160;&#160;// reset to blank ruler<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void subdivide(char ar[], int low, int high, int level)<br/>{<br/>&#160;&#160;&#160;&#160;if (level == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return;<br/>&#160;&#160;&#160;&#160;int mid = (high + low) / 2;<br/>&#160;&#160;&#160;&#160;ar[mid] = '|';<br/>&#160;&#160;&#160;&#160;subdivide(ar, low, mid, level - 1);<br/>&#160;&#160;&#160;&#160;subdivide(ar, mid, high, level - 1);<br/>}</p><hr/>
<p><a id="page_361"/>Here is the output of the program in <a href="#ch07ex17">Listing 7.17</a>:</p>
<p class="programlisting">|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|&#160;&#160;&#160;|<br/>| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |<br/>|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||</p>
<h5 id="ch07lev3sec17">Program Notes</h5>
<p>The <code>subdivide()</code> function in <a href="#ch07ex17">Listing 7.17</a> uses the variable <code>level</code> to control the recursion level. When the function calls itself, it reduces <code>level</code> by one, and the function with a <code>level</code> of <code>0</code> terminates. Note that <code>subdivide()</code> calls itself twice, once for the left subdivision and once for the right subdivision. The original midpoint becomes the right end for one call and the left end for the other call. Notice that the number of calls grows geometrically. That is, one call generates two, which generate four calls, which generate eight, and so on. That&#8217;s why the level 6 call is able to fill in 64 elements (2<sup>6</sup> = 64). This continued doubling of the number of function calls (and hence of the number of variables stored) make this form of recursion a poor choice if many levels of recursion are required. But it is an elegant and simple choice if the necessary levels of recursion are few.</p>
<h3 id="ch07lev1sec10">Pointers to Functions</h3>
<p>No discussion of C or C++ functions would be complete without mention of pointers to functions. We&#8217;ll take a quick look at this topic and leave the full exposition of the possibilities to more advanced texts.</p>
<p>Functions, like data items, have addresses. A function&#8217;s address is the memory address at which the stored machine language code for the function begins. Normally, it&#8217;s neither important nor useful for you or the user to know that address, but it can be useful to a program. For example, it&#8217;s possible to write a function that takes the address of another function as an argument. That enables the first function to find the second function and run it. This approach is more awkward than simply having the first function call the second one directly, but it leaves open the possibility of passing different function addresses at different times. That means the first function can use different functions at different times.</p>
<h4 id="ch07lev2sec18">Function Pointer Basics</h4>
<p><a id="page_362"/>Let&#8217;s clarify this process with an example. Suppose you want to design an <code>estimate()</code> function that estimates the amount of time necessary to write a given number of lines of code, and you want different programmers to use the function. Part of the code for <code>estimate()</code> will be the same for all users, but the function will allow each programmer to provide his or her own algorithm for estimating time. The mechanism for that will be to pass to <code>estimate()</code> the address of the particular algorithm function the programmer wants to use. To implement this plan, you need to be able to do the following:</p>
<p class="indenthandingB">&#8226; Obtain the address of a function.</p>
<p class="indenthandingB">&#8226; Declare a pointer to a function.</p>
<p class="indenthandingB">&#8226; Use a pointer to a function to invoke the function.</p>
<h5 id="ch07lev3sec18">Obtaining the Address of a Function</h5>
<p>Obtaining the address of a function is simple: You just use the function name without trailing parentheses. That is, if <code>think()</code> is a function, then <code>think</code> is the address of the function. To pass a function as an argument, you pass the function name. Be sure you distinguish between passing the <em>address</em> of a function and passing the <em>return value</em> of a function:</p>
<p class="programlisting">process(think);&#160;&#160;&#160;&#160;// passes address of think() to process()<br/>thought(think());&#160;&#160;// passes return value of think() to thought()</p>
<p>The <code>process()</code> call enables the <code>process()</code> function to invoke the <code>think()</code> function from within <code>process()</code>. The <code>thought()</code> call first invokes the <code>think()</code> function and then passes the return value of <code>think()</code> to the <code>thought()</code> function.</p>
<h5 id="ch07lev3sec19">Declaring a Pointer to a Function</h5>
<p>To declare pointers to a data type, the declaration has had to specify exactly to what type the pointer points. Similarly, a pointer to a function has to specify to what type of function the pointer points. This means the declaration should identify the function&#8217;s return type and the function&#8217;s signature (its argument list). That is, the declaration should provide the same information about a function that a function prototype does. For example, suppose Pam LeCoder has written a time-estimating function with the following prototype:</p>
<p class="programlisting">double pam(int);&#160;&#160;// prototype</p>
<p>Here&#8217;s what a declaration of an appropriate pointer type looks like:</p>
<p class="programlisting">double (*pf)(int);&#160;&#160;&#160;// pf points to a function that takes<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// one int argument and that<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// returns type double</p>
<div class="note"><hr/>
<p class="title"><a id="ch07note06"/>Tip</p>
<p class="notepara">In general, to declare a pointer to a particular kind of function, you can first write a prototype for a regular function of the desired kind and then replace the function name with an expression in the form <code>(*pf)</code>. In this case, <code>pf</code> is a pointer to a function of that type.</p>
<hr/></div>
<p><a id="page_363"/>The declaration requires the parentheses around <code>*pf</code> to provide the proper operator precedence. Parentheses have a higher precedence than the <code>*</code> operator, so <code>*pf(int)</code> means <code>pf()</code> is a function that returns a pointer, whereas <code>(*pf)(int)</code> means <code>pf</code> is a pointer to a function:</p>
<p class="programlisting">double (*pf)(int); // pf points to a function that returns double<br/>double *pf(int);&#160;&#160;&#160;// pf() a function that returns a pointer-to-double</p>
<p>After you declare <code>pf</code> properly, you can assign to it the address of a matching function:</p>
<p class="programlisting">double pam(int);<br/>double (*pf)(int);<br/>pf = pam;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pf now points to the pam() function</p>
<p>Note that <code>pam()</code> has to match <code>pf</code> in both signature and return type. The compiler rejects nonmatching assignments:</p>
<p class="programlisting">double ned(double);<br/>int ted(int);<br/>double (*pf)(int);<br/>pf = ned;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invalid -- mismatched signature<br/>pf = ted;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invalid -- mismatched return types</p>
<p>Let&#8217;s return to the <code>estimate()</code> function mentioned earlier. Suppose you want to pass to it the number of lines of code to be written and the address of an estimating algorithm, such as the <code>pam()</code> function. It could have the following prototype:</p>
<p class="programlisting">void estimate(int lines, double (*pf)(int));</p>
<p>This declaration says the second argument is a pointer to a function that has an <code>int</code> argument and a <code>double</code> return value. To have <code>estimate()</code> use the <code>pam()</code> function, you pass <code>pam()</code>&#8217;s address to it:</p>
<p class="programlisting">estimate(50, pam); // function call telling estimate() to use pam()</p>
<p>Clearly, the tricky part about using pointers to functions is writing the prototypes, whereas passing the address is very simple.</p>
<h5 id="ch07lev3sec20">Using a Pointer to Invoke a Function</h5>
<p>Now we get to the final part of the technique, which is using a pointer to call the pointed-to function. The clue comes in the pointer declaration. There, recall, <code>(*pf)</code> plays the same role as a function name. Thus, all you have to do is use <code>(*pf)</code> as if it were a function name:</p>
<p class="programlisting">double pam(int);<br/>double (*pf)(int);<br/>pf = pam;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pf now points to the pam() function<br/>double x = pam(4);&#160;&#160;&#160;// call pam() using the function name<br/>double y = (*pf)(5); // call pam() using the pointer pf</p>
<p><a id="page_364"/>Actually, C++ also allows you to use <code>pf</code> as if it were a function name:</p>
<p class="programlisting">double y = pf(5);&#160;&#160;&#160;&#160;// also call pam() using the pointer pf</p>
<p>Using the first form is uglier, but it provides a strong visual reminder that the code is using a function pointer.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch07sb03"/>History Versus Logic</p>
<p class="sidebarpara">Holy syntax! How can <code>pf</code> and <code>(*pf)</code> be equivalent? One school of thought maintains that because <code>pf</code> is a pointer to a function, <code>*pf</code> is a function; hence, you should use <code>(*pf)()</code> as a function call. A second school maintains that because the name of a function is a pointer to that function, a pointer to that function should act like the name of a function; hence you should use <code>pf()</code> as a function call. C++ takes the compromise view that both forms are correct, or at least can be allowed, even though they are logically inconsistent with each other. Before you judge that compromise too harshly, reflect that the ability to hold views that are not logically self-consistent is a hallmark of the human mental process.</p>
<hr/></div>
<h4 id="ch07lev2sec19">A Function Pointer Example</h4>
<p><a href="#ch07ex18">Listing 7.18</a> demonstrates using function pointers in a program. It calls the <code>estimate()</code> function twice, once passing the <code>betsy()</code> function address and once passing the <code>pam()</code> function address. In the first case, <code>estimate()</code> uses <code>betsy()</code> to calculate the number of hours necessary, and in the second case, <code>estimate()</code> uses <code>pam()</code> for the calculation. This design facilitates future program development. When Ralph develops his own algorithm for estimating time, he doesn&#8217;t have to rewrite <code>estimate()</code>. Instead, he merely needs to supply his own <code>ralph()</code> function, making sure it has the correct signature and return type. Of course, rewriting <code>estimate()</code> isn&#8217;t a difficult task, but the same principle applies to more complex code. Also the function pointer method allows Ralph to modify the behavior of <code>estimate()</code>, even if he doesn&#8217;t have access to the source code for <code>estimate()</code>.</p>
<p class="caption1"><a id="ch07ex18"/><strong>Listing 7.18. <code>fun_ptr.cpp</code></strong></p><hr/>
<p class="programlisting1">// fun_ptr.cpp -- pointers to functions<br/>#include &lt;iostream&gt;<br/>double betsy(int);<br/>double pam(int);<br/><br/>// second argument is pointer to a type double function that<br/>// takes a type int argument<br/>void estimate(int lines, double (*pf)(int));<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int code;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "How many lines of code do you need? ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; code;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here's Betsy's estimate:\n";<br/>&#160;&#160;&#160;&#160;estimate(code, betsy);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here's Pam's estimate:\n";<br/>&#160;&#160;&#160;&#160;estimate(code, pam);<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>double betsy(int lns)<br/>{<br/>&#160;&#160;&#160;&#160;return 0.05 * lns;<br/>}<br/><br/>double pam(int lns)<br/>{<br/>&#160;&#160;&#160;&#160;return 0.03 * lns + 0.0004 * lns * lns;<br/>}<br/><br/>void estimate(int lines, double (*pf)(int))<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; lines &lt;&lt; " lines will take ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (*pf)(lines) &lt;&lt; " hour(s)\n";<br/>}</p><hr/>
<p><a id="page_365"/>Here is a sample run of the program in <a href="#ch07ex18">Listing 7.18</a>:</p>
<p class="programlisting">How many lines of code do you need? <span class="EmpStrong">30</span><br/>Here's Betsy's estimate:<br/>30 lines will take 1.5 hour(s)<br/>Here's Pam's estimate:<br/>30 lines will take 1.26 hour(s)</p>
<p>Here is a second sample run of the program:</p>
<p class="programlisting">How many lines of code do you need? <span class="EmpStrong">100</span><br/>Here's Betsy's estimate:<br/>100 lines will take 5 hour(s)<br/>Here's Pam's estimate:<br/>100 lines will take 7 hour(s)</p>
<h4 id="ch07lev2sec20">Variations on the Theme of Function Pointers</h4>
<p>With function pointers, the notation can get intimidating. Let&#8217;s look at an example that illustrates some of the challenges of function pointers and ways of dealing with them. To begin, here are prototypes for some functions that share the same signature and return type:</p>
<p class="programlisting"><a id="page_366"/>const double * f1(const double ar[], int n);<br/>const double * f2(const double [], int);<br/>const double * f3(const double *, int);</p>
<p>The signatures might look different, but they are the same. First, recall that in a function prototype parameter list <code>const double ar[]</code> and <code>const double * ar</code> have exactly the same meaning. Second, recall that in a prototype you can omit identifiers. Therefore, <code>const double ar[]</code> can be reduced to <code>const double []</code>, and <code>const double * ar</code> can be reduced to <code>const double *</code>. So all the function signatures shown previously have the same meaning. Function definitions, on the other hand, do provide identifiers, so either <code>const double ar[]</code> or <code>const double * ar</code> will serve in that context.</p>
<p>Next, suppose you wish to declare a pointer that can point to one of these three functions. The technique, you&#8217;ll recall, is if <code>pa</code> is the desired pointer, take the prototype for a target function and replace the function name with <code>(*pa)</code>:</p>
<p class="programlisting">const double * (*p1)(const double *, int);</p>
<p>This can be combined with initialization:</p>
<p class="programlisting">const double * (*p1)(const double *, int) = f1;</p>
<p>With the C++11 automatic type deduction feature, you can simplify this a bit:</p>
<p class="programlisting">auto p2 = f2;&#160;&#160;// C++11 automatic type deduction</p>
<p>Now consider the following statements:</p>
<p class="programlisting">cout &lt;&lt;&#160;&#160;(*p1)(av,3) &lt;&lt; ": " &lt;&lt; *(*p1)(av,3) &lt;&lt; endl;<br/>cout &lt;&lt; p2(av,3) &lt;&lt; ": " &lt;&lt; *p2(av,3) &lt;&lt; endl;</p>
<p>Both <code>(*p1)(av,3)</code> and <code>p2(av,3)</code>, recall, represent calling the pointed-to functions (<code>f1()</code> and <code>f2()</code>, in this case) with <code>av</code> and <code>3</code> as arguments. Therefore, what should print are the return values of these two functions. The return values are type <code>const double *</code> (that is, address of <code>double</code> values). So the first part of each <code>cout</code> expression should print the address of a <code>double</code> value. To see the actual value stored at the addresses, we need to apply the <code>*</code> operator to these addresses, and that&#8217;s what the expressions <code>*(*p1)(av,3)</code> and <code>*p2(av,3)</code> do.</p>
<p>With three functions to work with, it could be handy to have an array of function pointers. Then one can use a <code>for</code> loop to call each function, via its pointer, in turn. What would that look like? Clearly, it should look something like the declaration of a single pointer, but there should be a <code>[3]</code> somewhere to indicate an array of three pointers. The question is where. And here&#8217;s the answer (including initialization):</p>
<p class="programlistingB">const double * (*pa[3])(const double *, int) = {f1,f2,f3};</p>
<p>Why put the <code>[3]</code> there? Well, <code>pa</code> is an array of three things, and the starting point for declaring an array of three things is this: <code>pa[3]</code>. The rest of the declaration is about what kind of thing is to be placed in the array. Operator precedence ranks <code>[]</code> higher than <code>*</code>, so <code>*pa[3]</code> says <code>pa</code> is an array of three pointers. The rest of the declaration indicates what each pointer points to: a function with a signature of <code>const double *, int</code> and a return <a id="page_367"/>type of <code>const double *</code>. Hence, <code>pa</code> is an array of three pointers, each of which is a pointer to a function that takes a <code>const double *</code> and <code>int</code> as arguments and returns a <code>const double *</code>.</p>
<p>Can we use <code>auto</code> here? No. Automatic type deduction works with a single initializer value, not an initialization list. But now that we have the array <code>pa</code>, it is simple to declare a pointer of the matching type:</p>
<p class="programlisting">auto pb = pa;</p>
<p>The name of an array, as you&#8217;ll recall, is a pointer to its first element, so both <code>pa</code> and <code>pb</code> are pointers to a pointer to a function.</p>
<p>How can we use them to call a function? Both <code>pa[i]</code> and <code>pb[i]</code> represent pointers in the array, so you can use either of the function call notations with either of them:</p>
<p class="programlisting">const double * px = pa[0](av,3);<br/>const double * py = (*pb[1])(av,3);</p>
<p>And you can apply the <code>*</code> operator to get the pointed-to <code>double</code> value:</p>
<p class="programlisting">double x = *pa[0](av,3);<br/>double y = *(*pb[1])(av,3);</p>
<p>Something else you can do (and who wouldn&#8217;t want to?) is create a pointer to the whole array. Because the array name <code>pa</code> already is a pointer to a function pointer, a pointer to the array would be a pointer to a pointer to a pointer. This sounds intimidating, but because the result can be initialed with a single value, you can use <code>auto</code>:</p>
<p class="programlisting">auto pc = &#38;pa;&#160;&#160;// C++11 automatic type deduction</p>
<p>What if you prefer to do it yourself? Clearly, the declaration should resemble the declaration for <code>pa</code>, but because there is one more level of indirection, we&#8217;ll need one more <code>*</code> stuck somewhere. In particular, if we call the new pointer <code>pd</code>, we need to indicate that it is pointer, not an array name. This suggests the heart of the declaration should be <code>(*pd)[3]</code>. The parentheses bind the <code>pd</code> identifier to the <code>*</code>:</p>
<p class="programlisting">*pd[3]&#160;&#160;&#160;&#160;// an array of 3 pointers<br/>(*pd)[3]&#160;&#160;// a pointer to an array of 3 elements</p>
<p>In other words, <code>pd</code> is a pointer, and it points to an array of three things. What those things are is described by the rest of the original declaration of <code>pa</code>. This approach yields the following:</p>
<p class="programlisting">const double *(*(*pd)[3])(const double *, int) = &#38;pa;</p>
<p>To call a function, realize that if <code>pd</code> points to an array, then <code>*pd</code> is the array and <code>(*pd)[i]</code> is an array element, which is a pointer to a function. The simpler notation, then, for the function call is <code>(*pd)[i](av,3)</code>, and <code>*(*pd)[i](av,3)</code> would be the value that the returned pointer points to. Alternatively, you could use second syntax for invoking a function with a pointer and use <code>(*(*pd)[i])(av,3)</code> for the call and <code>*(*(*pd)[i])(av,3)</code> for the pointed-to <code>double</code> value.</p>
<p><a id="page_368"/>Be aware of the difference between <code>pa</code>, which as an array name is an address, and <code>&#38;pa</code>. As you&#8217;ve seen before, in most contexts <code>pa</code> is the address of the first element of the array&#8212;that is, <code>&#38;pa[0]</code>. Therefore, it is the address of a single pointer. But <code>&#38;pa</code> is the address of the entire array (that is, of a block of three pointers). Numerically, <code>pa</code> and <code>&#38;pa</code> may have the same value, but they are of different types. One practical difference is that <code>pa+1</code> is the address of the next element in the array, whereas <code>&#38;pa+1</code> is the address of the next block of 12 bytes (assuming addresses are 4 bytes) following the <code>pa</code> array. Another difference is that you dereference <code>pa</code> once to get the value of the first element and you deference <code>&#38;pa</code> twice to get the same value:</p>
<p class="programlisting">**&#38;pa == *pa == pa[0]</p>
<p><a href="#ch07ex19">Listing 7.19</a> puts this discussion to use. For illustrative purposes, the functions <code>f1()</code>, and so on, have been kept embarrassingly simple. The program shows, as comments, the C++98 alternatives to using <code>auto</code>.</p>
<p class="caption1"><a id="ch07ex19"/><strong>Listing 7.19. <code>arfupt.cpp</code></strong></p><hr/>
<p class="programlisting1">// arfupt.cpp -- an array of function pointers<br/>#include &lt;iostream&gt;<br/>// various notations, same signatures<br/>const double * f1(const double ar[], int n);<br/>const double * f2(const double [], int);<br/>const double * f3(const double *, int);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double av[3] = {1112.3, 1542.6, 2227.9};<br/><br/>&#160;&#160;&#160;&#160;// pointer to a function<br/>&#160;&#160;&#160;&#160;const double *(*p1)(const double *, int) = f1;<br/>&#160;&#160;&#160;&#160;auto p2 = f2;&#160;&#160;// C++11 automatic type deduction<br/>&#160;&#160;&#160;&#160;// pre-C++11 can use the following code instead<br/>&#160;&#160;&#160;&#160;// const double *(*p2)(const double *, int) = f2;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using pointers to functions:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " Address&#160;&#160;Value\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;&#160;&#160;(*p1)(av,3) &lt;&lt; ": " &lt;&lt; *(*p1)(av,3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; p2(av,3) &lt;&lt; ": " &lt;&lt; *p2(av,3) &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;// pa an array of pointers<br/>&#160;&#160;&#160;&#160;// auto doesn't work with list initialization<br/>&#160;&#160;&#160;&#160;const double *(*pa[3])(const double *, int) = {f1,f2,f3};<br/>&#160;&#160;&#160;&#160;// but it does work for initializing to a single value<br/>&#160;&#160;&#160;&#160;// pb a pointer to first element of pa<br/>&#160;&#160;&#160;&#160;auto pb = pa;<br/>&#160;&#160;&#160;&#160;// pre-C++11 can use the following code instead<br/><a id="page_369"/>&#160;&#160;&#160;&#160;// const double *(**pb)(const double *, int) = pa;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nUsing an array of pointers to functions:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " Address&#160;&#160;Value\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 3; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pa[i](av,3) &lt;&lt; ": " &lt;&lt; *pa[i](av,3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nUsing a pointer to a pointer to a function:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " Address&#160;&#160;Value\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 3; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pb[i](av,3) &lt;&lt; ": " &lt;&lt; *pb[i](av,3) &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;// what about a pointer to an array of function pointers<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nUsing pointers to an array of pointers:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " Address&#160;&#160;Value\n";<br/>&#160;&#160;&#160;&#160;// easy way to declare pc<br/>&#160;&#160;&#160;&#160;auto pc = &#38;pa;<br/>&#160;&#160;&#160;&#160;// pre-C++11 can use the following code instead<br/>&#160;&#160;&#160;&#160;// const double *(*(*pc)[3])(const double *, int) = &#38;pa;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (*pc)[0](av,3) &lt;&lt; ": " &lt;&lt; *(*pc)[0](av,3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;// hard way to declare pd<br/>&#160;&#160;&#160;&#160;const double *(*(*pd)[3])(const double *, int) = &#38;pa;<br/>&#160;&#160;&#160;&#160;// store return value in pdb<br/>&#160;&#160;&#160;&#160;const double * pdb = (*pd)[1](av,3);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pdb &lt;&lt; ": " &lt;&lt; *pdb &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;// alternative notation<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (*(*pd)[2])(av,3) &lt;&lt; ": " &lt;&lt; *(*(*pd)[2])(av,3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;// cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>// some rather dull functions<br/><br/>const double * f1(const double * ar, int n)<br/>{<br/>&#160;&#160;&#160;&#160;return ar;<br/>}<br/>const double * f2(const double ar[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;return ar+1;<br/>}<br/>const double * f3(const double ar[], int n)<br/>{<br/>&#160;&#160;&#160;&#160;return ar+2;<br/>}</p><hr/>
<p><a id="page_370"/>And here is the output:</p>
<p class="programlisting">Using pointers to functions:<br/>&#160;Address&#160;&#160;Value<br/>002AF9E0: 1112.3<br/>002AF9E8: 1542.6<br/><br/>Using an array of pointers to functions:<br/>&#160;Address&#160;&#160;Value<br/>002AF9E0: 1112.3<br/>002AF9E8: 1542.6<br/>002AF9F0: 2227.9<br/><br/>Using a pointer to a pointer to a function:<br/>&#160;Address&#160;&#160;Value<br/>002AF9E0: 1112.3<br/>002AF9E8: 1542.6<br/>002AF9F0: 2227.9<br/><br/>Using pointers to an array of pointers:<br/>&#160;Address&#160;&#160;Value<br/>002AF9E0: 1112.3<br/>002AF9E8: 1542.6<br/>002AF9F0: 2227.9</p>
<p>The addresses shown are the locations of the <code>double</code> values in the <code>av</code> array.</p>
<p>This example may seem esoteric, but pointers to arrays of pointers to functions are not unheard of. Indeed, the usual implementation of virtual class methods (see <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a href="ch13.html#ch13">Class Inheritance</a>&#8221;) uses this technique. Fortunately, the compiler handles the details.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch07sb04"/>Appreciating <code>auto</code></p>
<p class="sidebarpara">One of the goals of C++11 is to make C++ easier to use, letting the programmer concentrate more on design and less on details. <a href="#ch07ex19">Listing 7.19</a> surely illustrates this point:</p>
<p class="programlistingB">auto pc = &#38;pa;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C++11 automatic type deduction<br/>const double *(*(*pd)[3])(const double *, int) = &#38;pa; // C++98, do it yourself</p>
<p class="sidebarpara">The automatic type deduction feature reflects a philosophical shift in the role of the compiler. In C++98, the compiler uses its knowledge to tell you when you are wrong. In C++11, at least with this feature, it uses its knowledge to help you get the right declaration.</p>
<p class="sidebarpara">There is a potential drawback. Automatic type deduction ensures that the type of the variable matches the type of the initializer, but it still is possible that you might provide the wrong type of initializer:</p>
<p class="programlistingB">auto pc = *pa;&#160;&#160;&#160;// oops! used *pa instead of &#38;pa</p>
<p class="sidebarpara">This declaration would make <code>pc</code> match the type of <code>*pa</code>, and that would result in a compile-time error when <a href="#ch07ex19">Listing 7.19</a> later uses <code>pc</code>, assuming that it is of the same type as <code>&#38;pa</code>.</p>
<hr/></div>
<h4 id="ch07lev2sec21">Simplifying with <code>typedef</code></h4>
<p><a id="page_371"/>C++ does provide tools other than <code>auto</code> for simplifying declarations. You may recall from <a href="ch05.html#ch05">Chapter 5</a>, &#8220;<a href="ch05.html#ch05">Loops and Relational Expressions</a>,&#8221; that the <code>typedef</code> keyword allows you to create a type alias:</p>
<p class="programlisting">typedef double real; // makes real another name for double</p>
<p>The technique is to declare the alias as if it were an identifier and to insert the keyword <code>typedef</code> at the beginning. So you can do this to make <code>p_fun</code> an alias for the function pointer type used in <a href="#ch07ex19">Listing 7.19</a>:</p>
<p class="programlisting">typedef const double *(*p_fun)(const double *, int);&#160;&#160;// p_fun now a type name<br/>p_fun p1 = f1;&#160;&#160;// p1 points to the f1() function</p>
<p>You then can use this type to build elaborations:</p>
<p class="programlisting">p_fun pa[3] = {f1,f2,f3}; // pa an array of 3 function pointers<br/>p_fun (*pd)[3] = &#38;pa;&#160;&#160;&#160;&#160;&#160;// pd points to an array of 3 function pointers</p>
<p>Not only does <code>typedef</code> save you some typing, it makes writing the code less error prone, and it makes the program easier to understand.</p>
<h3 id="ch07lev1sec11">Summary</h3>
<p>Functions are the C++ programming modules. To use a function, you need to provide a definition and a prototype, and you have to use a function call. The function definition is the code that implements what the function does. The function prototype describes the function interface: how many and what kinds of values to pass to the function and what sort of return type, if any, to get from it. The function call causes the program to pass the function arguments to the function and to transfer program execution to the function code.</p>
<p>By default, C++ functions pass arguments by value. This means that the formal parameters in the function definition are new variables that are initialized to the values provided by the function call. Thus, C++ functions protect the integrity of the original data by working with copies.</p>
<p>C++ treats an array name argument as the address of the first element of the array. Technically, this is still passing by value because the pointer is a copy of the original address, but the function uses the pointer to access the contents of the original array. When you declare formal parameters for a function (and only then), the following two declarations are equivalent:</p>
<p class="programlisting"><span class="EmpItalic">typeName</span> arr[];<br/><span class="EmpItalic">typeName</span> * arr;</p>
<p>Both of these mean that <code>arr</code> is a pointer to <em><code>typeName</code></em>. When you write the function code, however, you can use <code>arr</code> as if it were an array name in order to access elements: <code>arr[i]</code>. Even when passing pointers, you can preserve the integrity of the original data by declaring the formal argument to be a pointer to a <code>const</code> type. Because passing the <a id="page_372"/>address of an array conveys no information about the size of the array, you normally pass the array size as a separate argument. Alternatively, you can pass pointers to the beginning of the array and to one position past the end to indicate a range, as do the algorithms in the STL.</p>
<p>C++ provides three ways to represent C-style strings: by using a character array, a string constant, or a pointer to a string. All are type <code>char*</code> (pointer-to-<code>char</code>), so they are passed to a function as a type <code>char*</code> argument. C++ uses the null character (<code>\0</code>) to terminate strings, and string functions test for the null character to determine the end of any string they are processing.</p>
<p>C++ also provides the <code>string</code> class to represent strings. A function can accept <code>string</code> objects as arguments and use a <code>string</code> object as a return value. The <code>string</code> class <code>size()</code> method can be used to determine the length of a stored string.</p>
<p>C++ treats structures the same as basic types, meaning that you can pass them by value and use them as function return types. However, if a structure is large, it might be more efficient to pass a pointer to the structure and let the function work with the original data. These same considerations apply to class objects.</p>
<p>A C++ function can be recursive; that is, the code for a particular function can include a call of itself.</p>
<p>The name of a C++ function acts as the address of the function. By using a function argument that is a pointer to a function, you can pass to a function the name of a second function that you want the first function to evoke.</p>
<h3 id="ch07lev1sec12">Chapter Review</h3>
<p class="question"><a id="ch07qa1q1" href="app10.html#ch07qa1a1"><strong>1.</strong></a> What are the three steps in using a function?</p>
<p class="question"><a id="ch07qa1q2" href="app10.html#ch07qa1a2"><strong>2.</strong></a> Construct function prototypes that match the following descriptions:</p>
<p class="indenthandinga"><strong>a.</strong> <code>igor()</code> takes no arguments and has no return value.</p>
<p class="indenthandinga"><strong>b.</strong> <code>tofu(</code>) takes an <code>int</code> argument and returns a <code>float</code>.</p>
<p class="indenthandinga"><strong>c.</strong> <code>mpg()</code> takes two type <code>double</code> arguments and returns a <code>double</code>.</p>
<p class="indenthandinga"><strong>d.</strong> <code>summation()</code> takes the name of a <code>long</code> array and an array size as values and returns a <code>long</code> value.</p>
<p class="indenthandinga"><strong>e.</strong> <code>doctor()</code> takes a string argument (the string is not to be modified) and returns a <code>double</code> value.</p>
<p class="indenthandinga"><strong>f.</strong> <code>ofcourse()</code> takes a <code>boss</code> structure as an argument and returns nothing.</p>
<p class="indenthandinga"><strong>g.</strong> <code>plot()</code> takes a pointer to a <code>map</code> structure as an argument and returns a string.</p>
<p class="question"><a id="page_373"/><a id="ch07qa1q3" href="app10.html#ch07qa1a3"><strong>3.</strong></a> Write a function that takes three arguments: the name of an <code>int</code> array, the array size, and an <code>int</code> value. Have the function set each element of the array to the <code>int</code> value.</p>
<p class="question"><a id="ch07qa1q4" href="app10.html#ch07qa1a4"><strong>4.</strong></a> Write a function that takes three arguments: a pointer to the first element of a range in an array, a pointer to the element following the end of a range in an array, and an <code>int</code> value. Have the function set each element of the array to the <code>int</code> value.</p>
<p class="question"><a id="ch07qa1q5" href="app10.html#ch07qa1a5"><strong>5.</strong></a> Write a function that takes a <code>double</code> array name and an array size as arguments and returns the largest value in that array. Note that this function shouldn&#8217;t alter the contents of the array.</p>
<p class="question"><a id="ch07qa1q6" href="app10.html#ch07qa1a6"><strong>6.</strong></a> Why don&#8217;t you use the <code>const</code> qualifier for function arguments that are one of the fundamental types?</p>
<p class="question"><a id="ch07qa1q7" href="app10.html#ch07qa1a7"><strong>7.</strong></a> What are the three forms a C-style string can take in a C++ program?</p>
<p class="question"><a id="ch07qa1q8" href="app10.html#ch07qa1a8"><strong>8.</strong></a> Write a function that has this prototype:</p>
<p class="programlistingB">int replace(char * str, char c1, char c2);</p>
<p>Have the function replace every occurrence of <code>c1</code> in the string <code>str</code> with <code>c2</code>, and have the function return the number of replacements it makes.</p>
<p class="question"><a id="ch07qa1q9" href="app10.html#ch07qa1a9"><strong>9.</strong></a> What does the expression <code>*"pizza"</code> mean? What about <code>"taco"[2]</code>?</p>
<p class="question1"><a id="ch07qa1q10" href="app10.html#ch07qa1a10"><strong>10.</strong></a> C++ enables you to pass a structure by value, and it lets you pass the address of a structure. If <code>glitz</code> is a structure variable, how would you pass it by value? How would you pass its address? What are the trade-offs of the two approaches?</p>
<p class="question1"><a id="ch07qa1q11" href="app10.html#ch07qa1a11"><strong>11.</strong></a> The function <code>judge()</code> has a type <code>int</code> return value. As an argument, it takes the address of a function. The function whose address is passed, in turn, takes a pointer to a <code>const char</code> as an argument and returns an <code>int</code>. Write the function prototype.</p>
<p class="question1"><a id="ch07qa1q12" href="app10.html#ch07qa1a12"><strong>12.</strong></a> Suppose we have the following structure declaration:</p>
<p class="programlistingB">struct applicant {<br/>&#160;&#160;&#160;&#160;char name[30];<br/>&#160;&#160;&#160;&#160;int credit_ratings[3];<br/>};</p>
<p class="indenthandinga"><strong>a.</strong> Write a function that takes an <code>applicant</code> structure as an argument and displays its contents.</p>
<p class="indenthandinga"><strong>b.</strong> Write a function that takes the address of an <code>applicant</code> structure as an argument and displays the contents of the pointed-to structure.</p>
<p class="question1"><a id="ch07qa1q13" href="app10.html#ch07qa1a13"><strong>13.</strong></a> Suppose the functions <code>f1()</code> and <code>f2()</code> have the following prototypes:</p>
<p class="programlistingB">void f1(applicant * a);<br/>const char * f2(const applicant * a1, const applicant * a2);</p>
<p><a id="page_374"/>Declare <code>p1</code> as a pointer that points to <code>f1</code> and <code>p2</code> as a pointer to <code>f2</code>. Declare <code>ap</code> as an array of five pointers of the same type as <code>p1</code>, and declare <code>pa</code> as a pointer to an array of ten pointers of the same type as <code>p2</code>. Use <code>typedef</code> as an aid.</p>
<h3 id="ch07lev1sec13">Programming Exercises</h3>
<p class="question"><a id="ch07qa2q1"/><strong>1.</strong> Write a program that repeatedly asks the user to enter pairs of numbers until at least one of the pair is <code>0</code>. For each pair, the program should use a function to calculate the harmonic mean of the numbers. The function should return the answer to <code>main()</code>, which should report the result. The harmonic mean of the numbers is the inverse of the average of the inverses and can be calculated as follows:</p>
<p class="indenthandingB">harmonic mean = 2.0 &#215; x &#215; y / (x + y)</p>
<p class="question"><a id="ch07qa2q2"/><strong>2.</strong> Write a program that asks the user to enter up to 10 golf scores, which are to be stored in an array. You should provide a means for the user to terminate input prior to entering 10 scores. The program should display all the scores on one line and report the average score. Handle input, display, and the average calculation with three separate array-processing functions.</p>
<p class="question"><a id="ch07qa2q3"/><strong>3.</strong> Here is a structure declaration:</p>
<p class="programlistingB">struct box<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;char maker[40];<br/>&#160;&#160;&#160;&#160;&#160;&#160;float height;<br/>&#160;&#160;&#160;&#160;&#160;&#160;float width;<br/>&#160;&#160;&#160;&#160;&#160;&#160;float length;<br/>&#160;&#160;&#160;&#160;&#160;&#160;float volume;<br/>};</p>
<p class="indenthandinga"><strong>a.</strong> Write a function that passes a <code>box</code> structure by value and that displays the value of each member.</p>
<p class="indenthandinga"><strong>b.</strong> Write a function that passes the address of a <code>box</code> structure and that sets the <code>volume</code> member to the product of the other three dimensions.</p>
<p class="indenthandinga"><strong>c.</strong> Write a simple program that uses these two functions.</p>
<p class="question"><a id="ch07qa2q4"/><strong>4.</strong> Many state lotteries use a variation of the simple lottery portrayed by <a href="#ch07ex04">Listing 7.4</a>. In these variations you choose several numbers from one set and call them the field numbers. For example, you might select five numbers from the field of 1&#8211;47). You also pick a single number (called a mega number or a power ball, etc.) from a second range, such as 1&#8211;27. To win the grand prize, you have to guess all the picks correctly. The chance of winning is the product of the probability of picking all the field numbers times the probability of picking the mega number. For instance, the <a id="page_375"/>probability of winning the example described here is the product of the probability of picking 5 out of 47 correctly times the probability of picking 1 out of 27 correctly. Modify <a href="#ch07ex04">Listing 7.4</a> to calculate the probability of winning this kind of lottery.</p>
<p class="question"><a id="ch07qa2q5"/><strong>5.</strong> Define a recursive function that takes an integer argument and returns the factorial of that argument. Recall that 3 factorial, written 3!, equals 3 &#215; 2!, and so on, with 0! defined as 1. In general, if n is greater than zero, n! = n * (n - 1)!. Test your function in a program that uses a loop to allow the user to enter various values for which the program reports the factorial.</p>
<p class="question"><a id="ch07qa2q6"/><strong>6.</strong> Write a program that uses the following functions:</p>
<p class="questionp"><code>Fill_array()</code> takes as arguments the name of an array of <code>double</code> values and an array size. It prompts the user to enter <code>double</code> values to be entered in the array. It ceases taking input when the array is full or when the user enters non-numeric input, and it returns the actual number of entries.</p>
<p class="questionp"><code>Show_array()</code> takes as arguments the name of an array of <code>double</code> values and an array size and displays the contents of the array.</p>
<p class="questionp"><code>Reverse_array()</code> takes as arguments the name of an array of <code>double</code> values and an array size and reverses the order of the values stored in the array.</p>
<p class="questionp">The program should use these functions to fill an array, show the array, reverse the array, show the array, reverse all but the first and last elements of the array, and then show the array.</p>
<p class="question"><a id="ch07qa2q7"/><strong>7.</strong> Redo <a href="#ch07ex07">Listing 7.7</a>, modifying the three array-handling functions to each use two pointer parameters to represent a range. The <code>fill_array()</code> function, instead of returning the actual number of items read, should return a pointer to the location after the last location filled; the other functions can use this pointer as the second argument to identify the end of the data.</p>
<p class="question"><a id="ch07qa2q8"/><strong>8.</strong> Redo <a href="#ch07ex15">Listing 7.15</a> without using the <code>array</code> class. Do two versions:</p>
<p class="indenthandinga"><strong>a.</strong> Use an ordinary array of <code>const char *</code> for the strings representing the season names, and use an ordinary array of <code>double</code> for the expenses.</p>
<p class="indenthandinga"><strong>b.</strong> Use an ordinary array of <code>const char *</code> for the strings representing the season names, and use a structure whose sole member is an ordinary array of <code>double</code> for the expenses. (This design is similar to the basic design of the <code>array</code> class.)</p>
<p class="question"><a id="ch07qa2q9"/><strong>9.</strong> This exercise provides practice in writing functions dealing with arrays and structures. The following is a program skeleton. Complete it by providing the described functions:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/><a id="page_376"/>const int SLEN = 30;<br/>struct student {<br/>&#160;&#160;&#160;&#160;char fullname[SLEN];<br/>&#160;&#160;&#160;&#160;char hobby[SLEN];<br/>&#160;&#160;&#160;&#160;int ooplevel;<br/>};<br/>// getinfo() has two arguments: a pointer to the first element of<br/>// an array of student structures and an int representing the<br/>// number of elements of the array. The function solicits and<br/>// stores data about students. It terminates input upon filling<br/>// the array or upon encountering a blank line for the student<br/>// name. The function returns the actual number of array elements<br/>// filled.<br/>int getinfo(student pa[], int n);<br/><br/>// display1() takes a student structure as an argument<br/>// and displays its contents<br/>void display1(student st);<br/><br/>// display2() takes the address of student structure as an<br/>// argument and displays the structure's contents<br/>void display2(const student * ps);<br/><br/>// display3() takes the address of the first element of an array<br/>// of student structures and the number of array elements as<br/>// arguments and displays the contents of the structures<br/>void display3(const student pa[], int n);<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter class size: ";<br/>&#160;&#160;&#160;&#160;&#160;int class_size;<br/>&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; class_size;<br/>&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/><br/>&#160;&#160;&#160;&#160;student * ptr_stu = new student[class_size];<br/>&#160;&#160;&#160;&#160;int entered = getinfo(ptr_stu, class_size);<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; entered; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;display1(ptr_stu[i]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;display2(&#38;ptr_stu[i]);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;display3(ptr_stu, entered);<br/>&#160;&#160;&#160;&#160;delete [] ptr_stu;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="question1"><a id="page_377"/><a id="ch07qa2q10"/><strong>10.</strong> Design a function <code>calculate()</code> that takes two type <code>double</code> values and a pointer to a function that takes two <code>double</code> arguments and returns a <code>double</code>. The <code>calculate()</code> function should also be type <code>double</code>, and it should return the value that the pointed-to function calculates, using the double arguments to <code>calculate()</code>. For example, suppose you have this definition for the <code>add()</code> function:</p>
<p class="programlistingB">double add(double x, double y)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return x + y;<br/>}</p>
<p class="questionp">Then, the function call in the following would cause <code>calculate()</code> to pass the values <code>2.5</code> and <code>10.4</code> to the <code>add()</code> function and then return the <code>add()</code> return value (<code>12.9</code>):</p>
<p class="programlistingB">double q = calculate(2.5, 10.4, add);</p>
<p class="questionp">Use these functions and at least one additional function in the <code>add()</code> mold in a program. The program should use a loop that allows the user to enter pairs of numbers. For each pair, use <code>calculate()</code> to invoke <code>add()</code> and at least one other function. If you are feeling adventurous, try creating an array of pointers to <code>add()</code>-style functions and use a loop to successively apply <code>calculate()</code> to a series of functions by using these pointers. Hint: Here&#8217;s how to declare such an array of three pointers:</p>
<p class="programlistingB">double (*pf[3])(double, double);</p>
<p class="questionp">You can initialize such an array by using the usual array initialization syntax and function names as addresses.</p>
</body>
</html>
