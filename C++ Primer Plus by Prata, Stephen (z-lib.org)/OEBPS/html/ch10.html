<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>10. Objects and Classes</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch10">10. Objects and Classes</h2>
<p><a id="page_505"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; Procedural and object-oriented programming</p>
<p class="indenthandingB">&#8226; The concept of classes</p>
<p class="indenthandingB">&#8226; How to define and implement a class</p>
<p class="indenthandingB">&#8226; Public and private class access</p>
<p class="indenthandingB">&#8226; Class data members</p>
<p class="indenthandingB">&#8226; Class methods (also called class function members)</p>
<p class="indenthandingB">&#8226; Creating and using class objects</p>
<p class="indenthandingB">&#8226; Class constructors and destructors</p>
<p class="indenthandingB">&#8226; <code>const</code> member functions</p>
<p class="indenthandingB">&#8226; The <code>this</code> pointer</p>
<p class="indenthandingB">&#8226; Creating arrays of objects</p>
<p class="indenthandingB">&#8226; Class scope</p>
<p class="indenthandingB">&#8226; Abstract data types</p>
<p>Object-oriented programming (OOP) is a particular conceptual approach to designing programs, and C++ has enhanced C with features that ease the way to applying that approach. The following are the most important OOP features:</p>
<p class="indenthandingB">&#8226; Abstraction</p>
<p class="indenthandingB">&#8226; Encapsulation and data hiding</p>
<p class="indenthandingB">&#8226; Polymorphism</p>
<p class="indenthandingB">&#8226; Inheritance</p>
<p class="indenthandingB">&#8226; Reusability of code</p>
<p><a id="page_506"/>The class is the single most important C++ enhancement for implementing these features and tying them together. This chapter begins an examination of classes. It explains abstraction, encapsulation, and data hiding, and shows how classes implement these features. It discusses how to define a class, provide a class with public and private sections, and create member functions that work with the class data. Also this chapter acquaints you with constructors and destructors, which are special member functions for creating and disposing of objects that belong to a class. Finally, you meet the <code>this</code> pointer, an important component of some class programming. The following chapters extend this discussion to operator overloading (another variety of polymorphism) and inheritance, the basis for reusing code.</p>
<h3 id="ch10lev1sec1">Procedural and Object-Oriented Programming</h3>
<p>Although in this book we have occasionally explored the OOP perspective on programming, we&#8217;ve usually stuck pretty close to the standard procedural approach of languages such as C, Pascal, and BASIC. Let&#8217;s look at an example that clarifies how the OOP outlook differs from that of procedural programming.</p>
<p>As the newest member of the Genre Giants softball team, you&#8217;ve been asked to keep the team statistics. Naturally, you turn to your computer for help. If you were a procedural programmer, you might think along these lines:</p>
<p class="indent1">Let&#8217;s see, I want to enter the name, times at bat, number of hits, batting averages (for those who don&#8217;t follow baseball or softball, the batting average is the number of hits divided by the player&#8217;s official number of times at bat; an at bat terminates when a player gets on base or makes an out, but certain events, such as getting a walk, don&#8217;t count as official times at bat), and all those other great basic statistics for each player. Wait, the computer is supposed to make life easier for me, so I want to have it figure out some of that stuff, such as the batting average. Also I want the program to report the results. How should I organize this? I guess I should do things right and use functions. Yeah, I&#8217;ll make <code>main()</code> call a function to get the input, call another function to make the calculations, and then call a third function to report the results. Hmmm, what happens when I get data from the next game? I don&#8217;t want to start from scratch again. Okay, I can add a function to update the statistics. Golly, maybe I&#8217;ll need a menu in <code>main()</code> to select between entering, calculating, updating, and showing the data. Hmmm...how am I going to represent the data? I could use an array of strings to hold the players&#8217; names, another array to hold the at bats for each player, yet another array to hold the hits, and so on. No, that&#8217;s dumb. I can design a structure to hold all the information for a single player and then use an array of those structures to represent the whole team.</p>
<p>In short, with a procedural approach, you first concentrate on the procedures you will follow and then think about how to represent the data. (So that you don&#8217;t have to keep the program running the whole season, you probably also want to be able to save data to a file and read data from a file.)</p>
<p><a id="page_507"/>Now let&#8217;s see how your perspective changes when you don your OOP hat (in an attractive polymorphic design). You begin by thinking about the data. Furthermore, you think about the data not only in terms of how to represent it, but in terms of how it&#8217;s to be used:</p>
<p class="indent1">Let&#8217;s see, what am I keeping track of? A ball player, of course. So I want an object that represents the whole player, not just her batting average or times at bat. Yeah, that&#8217;ll be my fundamental data unit, an object representing the name and statistics for a player. I&#8217;ll need some methods to handle this object. Hmmm, I guess I need a method to get basic information into this unit. The computer should calculate some of the stuff, like the batting averages&#8212;I can add methods to do calculations. And the program should do those calculations automatically, without the user having to remember to ask to have them done. Also I&#8217;ll need methods for updating and displaying the information. So the user gets three ways to interact with the data: initialization, updating, and reporting. That&#8217;s the user interface.</p>
<p>In short, with an OOP approach, you concentrate on the object as the user perceives it, thinking about the data you need to describe the object and the operations that will describe the user&#8217;s interaction with the data. After you develop a description of that interface, you move on to decide how to implement the interface and data storage. Finally, you put together a program to use your new design.</p>
<h3 id="ch10lev1sec2">Abstraction and Classes</h3>
<p>Life is full of complexities, and one way we cope with complexity is to frame simplifying abstractions. You are a collection of more than an octillion atoms. Some students of the mind would say that your mind is a collection of several semiautonomous agents. But it&#8217;s much simpler to think of yourself as a single entity. In computing, abstraction is the crucial step of representing information in terms of its interface with the user. That is, you abstract the essential operational features of a problem and express a solution in those terms. In the softball statistics example, the interface describes how the user initializes, updates, and displays the data. From abstraction, it is a short step to the user-defined type, which in C++ is a class design that implements the abstract interface.</p>
<h4 id="ch10lev2sec1">What Is a Type?</h4>
<p>Let&#8217;s think a little more about what constitutes a type. For example, what is a nerd? If you subscribe to the popular stereotype, you might think of a nerd in visual terms&#8212;thick, black-rimmed glasses, pocket protector full of pens, and so on. After a little reflection, you might conclude that a nerd is better defined operationally&#8212;for example, in terms of how he or she responds to an awkward social situation. You have a similar situation, if you don&#8217;t mind stretched analogies, with a procedural language such as C. At first, you tend to think of a data type in terms of its appearance&#8212;how it is stored in memory. A <code>char</code>, for <a id="page_508"/>example, is 1 byte of memory, and a <code>double</code> is often 8 bytes of memory. But a little reflection leads you to conclude that a data type is also defined in terms of the operations that can be performed on it. For example, the <code>int</code> type can use all the arithmetic operations. You can add, subtract, multiply, and divide integers. You can also use the modulus operator (<code>%</code>) with them.</p>
<p>On the other hand, consider pointers. A pointer might very well require the same amount of memory as an <code>int</code>. It might even be represented internally as an integer. But a pointer doesn&#8217;t allow the same operations that an integer does. You can&#8217;t, for example, multiply two pointers by each other. The concept makes no sense, so C++ doesn&#8217;t implement it. Thus, when you declare a variable as an <code>int</code> or as a pointer-to-<code>float</code>, you&#8217;re not just allocating memory&#8212;you are also establishing which operations can be performed with the variable. In short, specifying a basic type does three things:</p>
<p class="indenthandingB">&#8226; It determines how much memory is needed for a data object.</p>
<p class="indenthandingB">&#8226; It determines how the bits in memory are interpreted. (A <code>long</code> and a <code>float</code> might use the same number of bits in memory, but they are translated into numeric values differently.)</p>
<p class="indenthandingB">&#8226; It determines what operations, or methods, can be performed using the data object.</p>
<p>For built-in types, the information about operations is built in to the compiler. But when you define a user-defined type in C++, you have to provide the same kind of information yourself. In exchange for this extra work, you gain the power and flexibility to custom fit new data types to match real-world requirements.</p>
<h4 id="ch10lev2sec2">Classes in C++</h4>
<p>A <em>class</em> is a C++ vehicle for translating an abstraction to a user-defined type. It combines data representation and methods for manipulating that data into one neat package. Let&#8217;s look at a class that represents stocks.</p>
<p>First, you have to think a bit about how to represent stocks. You could take one share of stock as the basic unit and define a class to represent a share. However, that implies that you would need 100 objects to represent 100 shares, and that&#8217;s not practical. Instead, you can represent a person&#8217;s current holdings in a particular stock as a basic unit. The number of shares owned would be part of the data representation. A realistic approach would have to maintain records of such things as initial purchase price and date of purchase for tax purposes. Also it would have to manage events such as stock splits. That seems a bit ambitious for a first effort at defining a class, so you can instead take an idealized, simplified view of matters. In particular, you can limit the operations you can perform to the following:</p>
<p class="indenthandingB">&#8226; Acquire stock in a company.</p>
<p class="indenthandingB">&#8226; Buy more shares of the same stock.</p>
<p class="indenthandingB">&#8226; Sell stock.</p>
<p class="indenthandingB">&#8226; Update the per-share value of a stock.</p>
<p class="indenthandingB">&#8226; Display information about the holdings.</p>
<p><a id="page_509"/>You can use this list to define the public interface for the stock class. (And you can add additional features later if you&#8217;re interested.) To support this interface, you need to store some information. Again, you can use a simplified approach. For example, don&#8217;t worry about the U.S. practice of evaluating stocks in multiples of eighths of a dollar. (Apparently the New York Stock Exchange must have seen this simplification in a previous edition of the book because it has decided to change over to the system used here.) Here&#8217;s a list of information to store:</p>
<p class="indenthandingB">&#8226; Name of company</p>
<p class="indenthandingB">&#8226; Number of stocks owned</p>
<p class="indenthandingB">&#8226; Value of each share</p>
<p class="indenthandingB">&#8226; Total value of all shares</p>
<p>Next, you can define the class. Generally, a class specification has two parts:</p>
<p class="indenthandingB">&#8226; A <em>class declaration</em>, which describes the data component, in terms of data members, and the public interface, in terms of member functions, termed <em>methods</em></p>
<p class="indenthandingB">&#8226; The <em>class method definitions</em>, which describe how certain class member functions are implemented</p>
<p>Roughly speaking, the class declaration provides a class overview, whereas the method definitions supply the details.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch10sb01"/>What Is an Interface?</p>
<p class="sidebarpara">An <em>interface</em> is a shared framework for interactions between two systems&#8212;for instance, between a computer and a printer or between a user and a computer program. For example, the user might be you and the program might be a word processor. When you use the word processor, you don&#8217;t transfer words directly from your mind to the computer memory. Instead, you interact with the interface provided by the program. You press a key, and the computer shows you a character on the screen. You move the mouse, and the computer moves a cursor on the screen. You click the mouse accidentally, and something weird happens to the paragraph you were typing. The program interface manages the conversion of your intentions to specific information stored in the computer.</p>
<p class="sidebarpara">For classes, we speak of the public interface. In this case, the public is the program using the class, the interacting system consists of the class objects, and the interface consists of the methods provided by whoever wrote the class. The interface enables you, the programmer, to write code that interacts with class objects, and thus it enables the program to use the class objects. For example, to find the number of characters in a <code>string</code> object, you don&#8217;t open up the object to what is inside; you just use the <code>size()</code> method provided by the class creators. It turns out that the class design denies direct access to the public user. But the public is allowed to use the <code>size()</code> method. The <code>size()</code> method, then, is part of the public interface between the user and a <code>string</code> class object. Similarly, the <code>getline()</code> method is part of the <code>istream</code> class public interface; a program using <code>cin</code> doesn&#8217;t tinker directly with the innards of a <code>cin</code> object to read a line of input; instead, <code>getline()</code> does the work.</p>
<p class="sidebarpara">If you want a more personal relationship, instead of thinking of the program using a class as the public user, you can think of the person writing the program using the class as the public user. But in any case, to use a class, you need to know its public interface; to write a class, you need to create its public interface.</p>
<hr/></div>
<p><a id="page_510"/>Developing a class and a program using it requires several steps. Rather than take them all at once, let&#8217;s break up the development into smaller stages. Typically, C++ programmers place the interface, in the form of a class definition, in a header file and place the implementation, in the form of code for the class methods, in a source code file. So let&#8217;s be typical. <a href="#ch10ex01">Listing 10.1</a> presents the first stage, a tentative class declaration for a class called <code>Stock</code>. The file uses <code>#ifndef</code>, and so on, as described in <a href="ch09.html#ch09">Chapter 9</a>, &#8220;<a href="ch09.html#ch09">Memory Models and Namespaces</a>,&#8221; to protect against multiple file inclusions.</p>
<p>To help identify classes, this book follows a common, but not universal, convention of capitalizing class names. You&#8217;ll notice that <a href="#ch10ex01">Listing 10.1</a> looks like a structure declaration with a few additional wrinkles, such as member functions and public and private sections. We&#8217;ll improve on this declaration shortly (so don&#8217;t use it as a model), but first let&#8217;s see how this definition works.</p>
<p class="caption1"><a id="ch10ex01"/><strong>Listing 10.1. <code>stock00.h</code></strong></p><hr/>
<p class="programlisting1">// stock00.h -- Stock class interface<br/>// version 00<br/>#ifndef STOCK00_H_<br/>#define STOCK00_H_<br/><br/>#include &lt;string&gt;<br/><br/>class Stock&#160;&#160;// class declaration<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string company;<br/>&#160;&#160;&#160;&#160;long shares;<br/>&#160;&#160;&#160;&#160;double share_val;<br/>&#160;&#160;&#160;&#160;double total_val;<br/>&#160;&#160;&#160;&#160;void set_tot() { total_val = shares * share_val; }<br/>public:<br/>&#160;&#160;&#160;&#160;void acquire(const std::string &#38; co, long n, double pr);<br/>&#160;&#160;&#160;&#160;void buy(long num, double price);<br/>&#160;&#160;&#160;&#160;void sell(long num, double price);<br/>&#160;&#160;&#160;&#160;void update(double price);<br/>&#160;&#160;&#160;&#160;void show();<br/>};&#160;&#160;&#160;&#160;// note semicolon at the end<br/><br/>#endif</p><hr/>
<p><a id="page_511"/>You&#8217;ll get a closer look at the class details later, but first let&#8217;s examine the more general features. To begin, the C++ keyword class identifies the code in <a href="#ch10ex01">Listing 10.1</a> as defining the design of a class. (In this context the keywords class and typename are not synonymous the way they were in template parameters; typename can&#8217;t be used here.) The syntax identifies Stock as the type name for this new class. This declaration enables you to declare variables, called <em>objects</em>, or <em>instances</em>, of the Stock type. Each individual object represents a single holding. For example, the following declarations create two Stock objects called <code>sally</code> and <code>solly</code>:</p>
<p class="programlisting">Stock sally;<br/>Stock solly;</p>
<p>The <code>sally</code> object, for example, could represent Sally&#8217;s stock holdings in a particular company.</p>
<p>Next, notice that the information you decided to store appears in the form of class data members, such as <code>company</code> and <code>shares</code>. The <code>company</code> member of <code>sally</code>, for example, holds the name of the company, the <code>share</code> member holds the number of shares Sally owns, the <code>share_val</code> member holds the value of each share, and the <code>total_val</code> member holds the total value of all the shares. Similarly, the desired operations appear as class function members (or methods), such as <code>sell()</code> and <code>update()</code>. A member function can be defined in place&#8212;for example, <code>set_tot()</code>&#8212;or it can be represented by a prototype, like the other member functions in this class. The full definitions for the other member functions come later in the implementation file, but the prototypes suffice to describe the function interfaces. The binding of data and methods into a single unit is the most striking feature of the class. Because of this design, creating a <code>Stock</code> object automatically establishes the rules governing how that object can be used.</p>
<p>You&#8217;ve already seen how the <code>istream</code> and <code>ostream</code> classes have member functions, such as <code>get()</code> and <code>getline()</code>. The function prototypes in the <code>Stock</code> class declaration demonstrate how member functions are established. The <code>iostream</code> header file, for example, has a <code>getline()</code> prototype in the <code>istream</code> class declaration.</p>
<h5 id="ch10lev3sec1">Access Control</h5>
<p>Also new are the keywords <code>private</code> and <code>public</code>. These labels describe <em>access control</em> for class members. Any program that uses an object of a particular class can access the public portions directly. A program can access the private members of an object <em>only</em> by using the public member functions (or, as you&#8217;ll see in <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>,&#8221; via a friend function). For example, the only way to alter the <code>shares</code> member of the <code>Stock</code> class is to use one of the <code>Stock</code> member functions. Thus, the public member functions act as go-betweens between a program and an object&#8217;s private members; they provide the interface between object and program. This insulation of data from direct access by a program is called <em>data hiding</em>. (C++ provides a third access-control keyword, <em>protected</em>, which we&#8217;ll discuss when we cover class inheritance in <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a href="ch13.html#ch13">Class Inheritance</a>.&#8221;) (See <a href="#ch10fig01">Figure 10.1</a>.) Whereas data hiding may be an unscrupulous act in, say, a stock fund prospectus, it&#8217;s a good practice in computing because it preserves the integrity of the data.</p>
<p class="caption"><a id="page_512"/><a id="ch10fig01"/><strong>Figure 10.1. The <code>Stock</code> class.</strong></p>
<p class="image"><img src="graphics/10fig01.jpg" alt="Image"/></p>
<p>A class design attempts to separate the public interface from the specifics of the implementation. The public interface represents the abstraction component of the design. Gathering the implementation details together and separating them from the abstraction is called <em>encapsulation</em>. <em>Data hiding</em> (putting data into the private section of a class) is an instance of encapsulation, and so is hiding functional details of an implementation in the private section, as the <code>Stock</code> class does with <code>set_tot()</code>. Another example of encapsulation is the usual practice of placing class function definitions in a separate file from the class declaration.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch10sb02"/>OOP and C++</p>
<p class="sidebarpara">OOP is a programming style that you can use to some degree with any language. Certainly, you can incorporate many OOP ideas into ordinary C programs. For example, <a href="ch09.html#ch09">Chapter 9</a> provides an example (see <a href="ch09.html#ch09ex01">Listings 9.1</a>, <a href="ch09.html#ch09ex02">9.2</a>, <a href="ch09.html#ch09ex03">9.3</a>) in which a header file contains a structure prototype along with the prototypes for functions to manipulate that structure. The <code>main()</code> function simply defines variables of that structure type and uses the associated functions to handle those variables; <code>main()</code> does not directly access structure members. In essence, that example defines an abstract type that places the storage format and the function prototypes in a header file, hiding the actual data representation from <code>main()</code>.</p>
<p class="sidebarpara">C++ includes features specifically intended to implement the OOP approach, so it enables you to take the process a few steps further than you can with C. First, placing the data representation and the function prototypes into a single class declaration instead of keeping them separate unifies the description by placing everything in one class declaration. Second, making the data representation private enforces the stricture that data is accessed only by authorized functions. If in the C example <code>main()</code> directly accesses a structure member, it violates the spirit of OOP, but it doesn&#8217;t break any C language rules. However, trying to directly access, say, the <code>shares</code> member of a <code>Stock</code> object does break a C++ language rule, and the compiler will catch it.</p>
<hr/></div>
<p><a id="page_513"/>Note that data hiding not only prevents you from accessing data directly, but it also absolves you (in the roll as a user of the class) from needing to know how the data is represented. For example, the <code>show()</code> member displays, among other things, the total value of a holding. This value can be stored as part of an object, as the code in <a href="#ch10ex01">Listing 10.1</a> does, or it can be calculated when needed. From the standpoint of using the class, it makes no difference which approach is used. What you do need to know is what the different member functions accomplish; that is, you need to know what kinds of arguments a member function takes and what kind of return value it has. The principle is to separate the details of the implementation from the design of the interface. If you later find a better way to implement the data representation or the details of the member functions, you can change those details without changing the program interface, and that makes programs much easier to maintain.</p>
<h5 id="ch10lev3sec2">Member Access Control: Public or Private?</h5>
<p>You can declare class members, whether they are data items or member functions, either in the public or the private section of a class. But because one of the main precepts of OOP is to hide the data, data items normally go into the private section. The member functions that constitute the class interface go into the public section; otherwise, you can&#8217;t call those functions from a program. As the <code>Stock</code> declaration shows, you can also put member functions in the private section. You can&#8217;t call such functions directly from a program, but the public methods can use them. Typically, you use private member functions to handle implementation details that don&#8217;t form part of the public interface.</p>
<p>You don&#8217;t have to use the keyword <code>private</code> in class declarations because that is the default access control for class objects:</p>
<p class="programlisting">class World<br/>{<br/>&#160;&#160;&#160;&#160;float mass;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// private by default<br/>&#160;&#160;&#160;&#160;char name[20];&#160;&#160;&#160;&#160;&#160;&#160;&#160;// private by default<br/>public:<br/>&#160;&#160;&#160;&#160;void tellall(void);<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>However, this book explicitly uses the <code>private</code> label in order to emphasize the concept of data hiding.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch10sb03"/><a id="page_514"/>Classes and Structures</p>
<p class="sidebarpara">Class descriptions look much like structure declarations with the addition of member functions and the <code>public</code> and <code>private</code> visibility labels. In fact, C++ extends to structures the same features classes have. The only difference is that the default access type for a structure is <code>public</code>, whereas the default type for a class is <code>private</code>. C++ programmers commonly use classes to implement class descriptions while restricting structures to representing pure data objects (often called <em>plain-old data</em> structures, or <em>POD</em> structures).</p>
<hr/></div>
<h4 id="ch10lev2sec3">Implementing Class Member Functions</h4>
<p>We still have to create the second part of the class specification: providing code for those member functions represented by a prototype in the class declaration. Member function definitions are much like regular function definitions. Each has a function header and a function body. Member function definitions can have return types and arguments. But they also have two special characteristics:</p>
<p class="indenthandingB">&#8226; When you define a member function, you use the scope-resolution operator (<code>::</code>) to identify the class to which the function belongs.</p>
<p class="indenthandingB">&#8226; Class methods can access the <code>private</code> components of the class.</p>
<p>Let&#8217;s look at these points now.</p>
<p>First, the function header for a member function uses the scope-resolution operator (<code>::</code>) to indicate to which class the function belongs. For example, the header for the <code>update()</code> member function looks like this:</p>
<p class="programlisting">void Stock::update(double price)</p>
<p>This notation means you are defining the <code>update()</code> function that is a member of the <code>Stock</code> class. Not only does this identify <code>update()</code> as a member function, it means you can use the same name for a member function for a different class. For example, an <code>update()</code> function for a <code>Buffoon</code> class would have this function header:</p>
<p class="programlisting">void Buffoon::update()</p>
<p>Thus, the scope-resolution operator resolves the identity of the class to which a method definition applies. We say that the identifier <code>update()</code> has <em>class scope</em>. Other member functions of the <code>Stock</code> class can, if necessary, use the <code>update()</code> method without using the scope-resolution operator. That&#8217;s because they belong to the same class, making <code>update()</code> in scope. Using <code>update()</code> outside the class declaration and method definitions, however, requires special measures, which we&#8217;ll get to soon.</p>
<p>One way of looking at method names is that the complete name of a class method includes the class name. <code>Stock::update()</code> is called the <em>qualified name</em> of the function. A simple <code>update()</code>, on the other hand, is an abbreviation (the <em>unqualified name</em>) for the full name&#8212;one that can be used just in class scope.</p>
<p>The second special characteristic of methods is that a method can access the private members of a class. For example, the <code>show()</code> method can use code like this:</p>
<p class="programlisting"><a id="page_515"/>std::cout &lt;&lt; "Company: " &lt;&lt; company<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Shares: " &lt;&lt; shares &lt;&lt; endl<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Share Price: $" &lt;&lt; share_val<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Total Worth: $" &lt;&lt; total_val &lt;&lt; endl;</p>
<p>Here <code>company</code>, <code>shares</code>, and so on are private data members of the <code>Stock</code> class. If you try to use a nonmember function to access these data members, the compiler stops you cold in your tracks. (However, friend functions, which <a href="ch11.html#ch11">Chapter 11</a> discusses, provide an exception.)</p>
<p>With these two points in mind, we can implement the class methods as shown in <a href="#ch10ex02">Listing 10.2</a>. We&#8217;ve placed them in a separate implementation file, so the file needs to include the <code>stock00.h</code> header file so that compiler can access the class definition. To provide more namespace experience, the code uses the <code>std::</code> qualifier in some methods and <code>using</code> declarations in others.</p>
<p class="caption1"><a id="ch10ex02"/><strong>Listing 10.2. <code>stock00.cpp</code></strong></p><hr/>
<p class="programlisting1">// stock00.cpp -- implementing the Stock class<br/>// version 00<br/>#include &lt;iostream&gt;<br/>#include "stock00.h"<br/>void Stock::acquire(const std::string &#38; co, long n, double pr)<br/>{<br/>&#160;&#160;&#160;&#160;company = co;<br/>&#160;&#160;&#160;&#160;if (n &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Number of shares can't be negative; "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; company &lt;&lt; " shares set to 0.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares = 0;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares = n;<br/>&#160;&#160;&#160;&#160;share_val = pr;<br/>&#160;&#160;&#160;&#160;set_tot();<br/>}<br/><br/>void Stock::buy(long num, double price)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;if (num &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Number of shares purchased can't be negative. "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares += num;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_tot();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>void Stock::sell(long num, double price)<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;if (num &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Number of shares sold can't be negative. "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else if (num &gt; shares)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "You can't sell more than you have! "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares -= num;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_tot();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>void Stock::update(double price)<br/>{<br/>&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;set_tot();<br/>}<br/><br/>void Stock::show()<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Company: " &lt;&lt; company<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Shares: " &lt;&lt; shares &lt;&lt; '\n'<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Share Price: $" &lt;&lt; share_val<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Total Worth: $" &lt;&lt; total_val &lt;&lt; '\n';<br/>}</p><hr/>
<h5 id="ch10lev3sec3">Member Function Notes</h5>
<p><a id="page_516"/>The <code>acquire()</code> function manages the first acquisition of stock for a given company, whereas <code>buy()</code> and <code>sell()</code> manage adding to or subtracting from an existing holding. The <code>buy()</code> and <code>sell()</code> methods make sure that the number of shares bought or sold is not a negative number. Also if the user attempts to sell more shares than he or she has, the <a id="page_517"/><code>sell()</code> function terminates the transaction. The technique of making the data private and limiting access to public functions gives you control over how the data can be used; in this case, it allows you to insert these safeguards against faulty transactions.</p>
<p>Four of the member functions set or reset the <code>total_val</code> member value. Rather than write this calculation four times, the class has each function call the <code>set_tot()</code> function. Because this function is merely the means of implementing the code and not part of the public interface, the class makes <code>set_tot()</code> a private member function. (That is, <code>set_tot()</code> is a member function used by the person writing the class but not used by someone writing code that uses the class.) If the calculation were lengthy, this could save some typing and code space. Here, however, the main value is that by using a function call instead of retyping the calculation each time, you ensure that exactly the same calculation gets done. Also if you have to revise the calculation (which is not likely in this particular case), you have to revise it in just one location.</p>
<h5 id="ch10lev3sec4">Inline Methods</h5>
<p>Any function with a definition in the class declaration automatically becomes an inline function. Thus, <code>Stock::set_tot()</code> is an inline function. Class declarations often use inline functions for short member functions, and <code>set_tot()</code> qualifies on that account.</p>
<p>You can, if you like, define a member function outside the class declaration and still make it inline. To do so, you just use the <code>inline</code> qualifier when you define the function in the class implementation section:</p>
<p class="programlisting">class Stock<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;void set_tot();&#160;&#160;// definition kept separate<br/>public:<br/>&#160;&#160;&#160;&#160;...<br/>};<br/><br/>inline void Stock::set_tot()&#160;&#160;// use inline in definition<br/>{<br/>&#160;&#160;&#160;&#160;total_val = shares * share_val;<br/>}</p>
<p>The special rules for inline functions require that they be defined in each file in which they are used. The easiest way to make sure that inline definitions are available to all files in a multifile program is to include the inline definition in the same header file in which the corresponding class is defined. (Some development systems may have smart linkers that allow the inline definitions to go into a separate implementation file.)</p>
<p>Incidentally, according to the <em>rewrite rule</em>, defining a method within a class declaration is equivalent to replacing the method definition with a prototype and then rewriting the definition as an inline function immediately after the class declaration. That is, the original <a id="page_518"/>inline definition of <code>set_tot()</code> in <a href="#ch10ex01">Listing 10.1</a> is equivalent to the one just shown, with the definition following the class declaration.</p>
<h5 id="ch10lev3sec5">Which Object Does a Method Use?</h5>
<p>Now we come to one of the most important aspects of using objects: how you apply a class method to an object. Code such as this uses the <code>shares</code> member of an object:</p>
<p class="programlisting">shares += num;</p>
<p>But which object? That&#8217;s an excellent question! To answer it, first consider how you create an object. The simplest way is to declare class variables:</p>
<p class="programlistingB">Stock kate, joe;</p>
<p>This creates two objects of the <code>Stock</code> class, one named <code>kate</code> and one named <code>joe</code>.</p>
<p>Next, consider how to use a member function with one of these objects. The answer, as with structures and structure members, is to use the membership operator:</p>
<p class="programlisting">kate.show();&#160;&#160;&#160;&#160;// the kate object calls the member function<br/>joe.show();&#160;&#160;&#160;&#160;&#160;// the joe object calls the member function</p>
<p>The first call here invokes <code>show()</code> as a member of the <code>kate</code> object. This means the method interprets <code>shares</code> as <code>kate.shares</code> and <code>share_val</code> as <code>kate.share_val</code>. Similarly, the call <code>joe.show()</code> makes the <code>show()</code> method interpret <code>shares</code> and <code>share_val</code> as <code>joe.shares</code> and <code>joe.share_val</code>, respectively.</p>
<div class="note"><hr/>
<p class="title"><a id="ch10note01"/>Note</p>
<p class="notepara">When you call a member function, it uses the data members of the particular object used to invoke the member function.</p>
<hr/></div>
<p>Similarly, the function call <code>kate.sell()</code> invokes the <code>set_tot()</code> function as if it were <code>kate.set_tot()</code>, causing that function to get its data from the <code>kate</code> object.</p>
<p>Each new object you create contains storage for its own internal variables, the class members. But all objects of the same class share the same set of class methods, with just one copy of each method. Suppose, for example, that <code>kate</code> and <code>joe</code> are <code>Stock</code> objects. In that case, <code>kate.shares</code> occupies one chunk of memory, and <code>joe.shares</code> occupies a second chunk of memory. But <code>kate.show()</code> and <code>joe.show()</code> both invoke the same method&#8212;that is, both execute the same block of code. They just apply the code to different data. Calling a member function is what some OOP languages term <em>sending a message</em>. Thus, sending the same message to two different objects invokes the same method but applies it to two different objects (see <a href="#ch10fig02">Figure 10.2</a>).</p>
<p class="caption"><a id="ch10fig02"/><strong>Figure 10.2. Objects, data, and member functions.</strong></p>
<p class="image"><img src="graphics/10fig02.jpg" alt="Image"/></p>
<h4 id="ch10lev2sec4">Using Classes</h4>
<p>In this chapter you&#8217;ve seen how to define a class and its class methods. The next step is to produce a program that creates and uses objects of a class. The C++ goal is to make using classes as similar as possible to using the basic, built-in types, such as <code>int</code> and <code>char</code>. You can create a class object by declaring a class variable or using <code>new</code> to allocate an object of a <a id="page_519"/>class type. You can pass objects as arguments, return them as function return values, and assign one object to another. C++ provides facilities for initializing objects, teaching <code>cin</code> and <code>cout</code> to recognize objects, and even providing automatic type conversions between objects of similar classes. It will be a while before you can do all those things, but let&#8217;s start now with the simpler properties. Indeed, you&#8217;ve already seen how to declare a class object and call a member function. <a href="#ch10ex03">Listing 10.3</a> provides a program to use the interface and implementation files. It creates a <code>Stock</code> object named <code>fluffy_the_cat</code>. The program is simple, but it tests the features built in to the class. To compile the complete program, use the techniques for multifile programs described in <a href="ch01.html#ch01">Chapter 1</a>, &#8220;<a href="ch01.html#ch01">Getting Started with C++</a>,&#8221; and in <a href="ch09.html#ch09">Chapter 9</a>. In particular, compile it with <code>stock00.cpp</code> and have <code>stock00.h</code> present in the same directory or folder.</p>
<p class="caption1"><a id="ch10ex03"/><strong>Listing 10.3. <code>usestok0.cpp</code></strong></p><hr/>
<p class="programlisting1">// usestck0.cpp -- the client program<br/>// compile with stock00.cpp<br/>#include &lt;iostream&gt;<br/>#include "stock00.h"<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Stock fluffy_the_cat;<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.acquire("NanoSmart", 20, 12.50);<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.show();<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.buy(15, 18.125);<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.show();<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.sell(400, 20.00);<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.show();<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.buy(300000,40.125);<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.show();<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.sell(300000,0.125);<br/>&#160;&#160;&#160;&#160;fluffy_the_cat.show();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_520"/>Here is the output of the program in <a href="#ch10ex03">Listing 10.3</a>:</p>
<p class="programlisting">Company: NanoSmart&#160;&#160;Shares: 20<br/>&#160;&#160;Share Price: $12.5&#160;&#160;Total Worth: $250<br/>Company: NanoSmart&#160;&#160;Shares: 35<br/>&#160;&#160;Share Price: $18.125&#160;&#160;Total Worth: $634.375<br/>You can't sell more than you have! Transaction is aborted.<br/>Company: NanoSmart&#160;&#160;Shares: 35<br/>&#160;&#160;Share Price: $18.125&#160;&#160;Total Worth: $634.375<br/>Company: NanoSmart&#160;&#160;Shares: 300035<br/>&#160;&#160;Share Price: $40.125&#160;&#160;Total Worth: $1.20389e+007<br/>Company: NanoSmart&#160;&#160;Shares: 35<br/>&#160;&#160;Share Price: $0.125&#160;&#160;Total Worth: $4.375</p>
<p>Note that <code>main()</code> is just a vehicle for testing the design of the <code>Stock</code> class. When the <code>Stock</code> class works as you want it to, you can use it as a user-defined type in other programs. The critical point in using the new type is to understand what the member functions do; you shouldn&#8217;t have to think about the implementation details. See the following sidebar, &#8220;<a href="#ch10sb04">The Client/Server Model</a>.&#8221;</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch10sb04"/>The Client/Server Model</p>
<p class="sidebarpara">OOP programmers often discuss program design in terms of a client/server model. In this conceptualization, the <em>client</em> is a program that uses the class. The class declaration, including the class methods, constitute the <em>server</em>, which is a resource that is available to the programs that need it. The client uses the server through the publicly defined interface only. This means that the client&#8217;s only responsibility, and, by extension, the client&#8217;s programmer&#8217;s only responsibility, is to know that interface. The server&#8217;s responsibility, and, by extension, the server&#8217;s designer&#8217;s responsibility, is to see that the server reliably and accurately performs according to that interface. Any changes the server designer makes to the class design should be to details of implementation, not to the interface. This allows programmers to improve the client and the server independently of each other, without changes in the server having unforeseen repercussions on the client&#8217;s behavior.</p>
<hr/></div>
<h4 id="ch10lev2sec5">Changing the Implementation</h4>
<p><a id="page_521"/>There may be something about the program output, aside from Fluffy the Cat&#8217;s lack of financial acumen, that bothers you&#8212;the somewhat inconsistent formatting of the numbers. Here&#8217;s an opportunity to refine an implementation while keeping the interface unchanged. The <code>ostream</code> class included member functions that control formatting. Without going into much detail, you can avoid e-notation by using the <code>setf()</code> method much as we did in <a href="ch08.html#ch08ex08">Listing 8.8</a>:</p>
<p class="programlisting">std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);</p>
<p>This sets a flag in the <code>cout</code> object instructing <code>cout</code> to use fixed-point notation. Similarly, the following statement causes <code>cout</code> to show three places to the right of the decimal when using fixed-point notation:</p>
<p class="programlisting">std::cout.precision(3);</p>
<p>You&#8217;ll find more details in <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>.&#8221;</p>
<p>These tools can be used in the <code>show()</code> method to control the formatting, but there is another point to consider. When you change the implementation for a method, the changes should not affect other parts of the client program. The format changes just mentioned stay in place until changed again, so they could affect subsequent output in the client program. Therefore, the polite thing for <code>show()</code> to do is to reset the formatting information to the state that existed before <code>show()</code> was called. This can be done, as in <a href="ch08.html#ch08ex08">Listing 8.8</a>, using return values for the setting statements:</p>
<p class="programlisting">std::streamsize prec =<br/>&#160;&#160;&#160;&#160;std::cout.precision(3);&#160;&#160;// save preceding value for precision<br/>...<br/>std::cout.precision(prec);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// reset to old value<br/><br/>// store original flags<br/>std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed);<br/>...<br/>// reset to stored values<br/>std::cout.setf(orig, std::ios_base::floatfield);</p>
<p>As you may recall, <code>fmtflags</code> is a type defined in the <code>ios_base</code> class, which is defined in the <code>std</code> namespace, hence the rather long type name for <code>orig</code>. Second, <code>orig</code> holds all the flags, and the reset statement uses that information to reset information in the <code>floatfield</code> section, which includes flags for fixed-point notation and scientific notation. Third, let&#8217;s not worry too much about the details here. The main points are that the changes are confined to the implementation file and that the changes don&#8217;t affect other aspects of the program using the class.</p>
<p><a id="page_522"/>Putting this information to use, we can replace the <code>show()</code> definition in the implementation file with this:</p>
<p class="programlisting">void Stock::show()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::ios_base;<br/>&#160;&#160;&#160;&#160;// set format to #.###<br/>&#160;&#160;&#160;&#160;ios_base::fmtflags orig =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;std::streamsize prec = cout.precision(3);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Company: " &lt;&lt; company<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Shares: " &lt;&lt; shares &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;Share Price: $" &lt;&lt; share_val;<br/>&#160;&#160;&#160;&#160;// set format to #.##<br/>&#160;&#160;&#160;&#160;cout.precision(2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;Total Worth: $" &lt;&lt; total_val &lt;&lt; '\n';<br/><br/>&#160;&#160;&#160;&#160;// restore original format<br/>&#160;&#160;&#160;&#160;cout.setf(orig, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout.precision(prec);<br/>}</p>
<p>After this replacement and leaving the header file and client file unchanged, you can recompile the program. Now the output would look like this:</p>
<p class="programlisting">Company: NanoSmart&#160;&#160;Shares: 20<br/>&#160;&#160;Share Price: $12.500&#160;&#160;Total Worth: $250.00<br/>Company: NanoSmart&#160;&#160;Shares: 35<br/>&#160;&#160;Share Price: $18.125&#160;&#160;Total Worth: $634.38<br/>You can't sell more than you have! Transaction is aborted.<br/>Company: NanoSmart&#160;&#160;Shares: 35<br/>&#160;&#160;Share Price: $18.125&#160;&#160;Total Worth: $634.38<br/>Company: NanoSmart&#160;&#160;Shares: 300035<br/>&#160;&#160;Share Price: $40.125&#160;&#160;Total Worth: $12038904.38<br/>Company: NanoSmart&#160;&#160;Shares: 35<br/>&#160;&#160;Share Price: $0.125&#160;&#160;Total Worth: $4.38</p>
<h4 id="ch10lev2sec6">Reviewing Our Story to Date</h4>
<p>The first step in specifying a class design is to provide a class declaration. The class declaration is modeled after a structure declaration and can include data members and function members. The declaration has a private section, and members declared in that section can be accessed only through the member functions. The declaration also has a public section, and members declared there can be accessed directly by a program using class objects. <a id="page_523"/>Typically, data members go into the private section and member functions go into the public section, so a typical class declaration has this form:</p>
<p class="programlisting">class <span class="EmpItalic">className</span><br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">data member declarations</span><br/>public:<br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">member function prototypes</span><br/>};</p>
<p>The contents of the public section constitute the abstract part of the design, the public interface. Encapsulating data in the private section protects the integrity of the data and is called data hiding. Thus, using a class is the C++ way of making it easy to implement the OOP features abstraction, data hiding, and encapsulation.</p>
<p>The second step in specifying a class design is to implement the class member functions. You can use a complete function definition instead of a function prototype in the class declaration, but the usual practice, except with very brief functions, is to provide the function definitions separately. In that case, you need to use the scope-resolution operator to indicate to which class a member function belongs. For example, suppose the <code>Bozo</code> class has a member function called <code>Retort()</code> that returns a pointer to a <code>char</code>. The function header would look like this:</p>
<p class="programlisting">char * Bozo::Retort()</p>
<p>In other words, <code>Retort()</code> is not just a type <code>char *</code> function; it is a type <code>char *</code> function that belongs to the <code>Bozo</code> class. The full, or qualified, name of the function is <code>Bozo::Retort()</code>. The name <code>Retort()</code>, on the other hand, is an abbreviation of the qualified name, and it can be used only in certain circumstances, such as in the code for the class methods.</p>
<p>Another way of describing this situation is to say that the name <code>Retort</code> has class scope, so the scope-resolution operator is needed to qualify the name when it is used outside the class declaration and a class method.</p>
<p>To create an object, which is a particular example of a class, you use the class name as if it were a type name:</p>
<p class="programlisting">Bozo bozetta;</p>
<p>This works because a class <em>is</em> a user-defined type.</p>
<p>You invoke a class member function, or method, by using a class object. You do so by using the dot membership operator:</p>
<p class="programlisting">cout &lt;&lt; Bozetta.Retort();</p>
<p>This invokes the <code>Retort()</code> member function, and whenever the code for that function refers to a particular data member, the function uses the value that member has in the <code>bozetta</code> object.</p>
<h3 id="ch10lev1sec3">Class Constructors and Destructors</h3>
<p><a id="page_524"/>At this point, you need to do more with the <code>Stock</code> class. There are certain standard functions, called <em>constructors</em> and <em>destructors</em>, that you should normally provide for a class. Let&#8217;s talk about why they are needed and how to write them.</p>
<p>One of C++&#8217;s aims is to make using class objects similar to using standard types. However, the code provided so far in this chapter doesn&#8217;t let you initialize a <code>Stock</code> object the way you can an ordinary <code>int</code> or <code>struct</code>. That is, the usual initialization syntax doesn&#8217;t carry over for the <code>Stock</code> type</p>
<p class="programlisting">int year = 2001;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid initialization<br/>struct thing<br/>{<br/>&#160;&#160;&#160;&#160;char * pn;<br/>&#160;&#160;&#160;&#160;int m;<br/>};<br/>thing amabob = {"wodget", -23};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// valid initialization<br/>Stock hot = {"Sukie's Autos, Inc.", 200, 50.25};&#160;&#160;&#160;// NO! compile error</p>
<p>The reason you can&#8217;t initialize a <code>Stock</code> object this way is because the data parts have private access status, which means a program cannot access the data members directly. As you&#8217;ve seen, the only way a program can access the data members is through a member function. Therefore, you need to devise an appropriate member function if you&#8217;re to succeed in initializing an object. (You could initialize a class object as just shown if you made the data members public instead of private, but making the data public goes against one of the main justifications for using classes: data hiding.)</p>
<p>In general, it&#8217;s best that all objects be initialized when they are created. For example, consider the following code:</p>
<p class="programlisting">Stock gift;<br/>gift.buy(10, 24.75);</p>
<p>With the current implementation of the <code>Stock</code> class, the <code>gift</code> object has no value for the <code>company</code> member. The class design assumes that the user calls <code>acquire()</code> before calling any other member functions, but there is no way to enforce that assumption. One way around this difficulty is to have objects initialized automatically when they are created. To accomplish this, C++ provides for special member functions, called <em>class constructors</em>, especially for constructing new objects and assigning values to their data members. More precisely, C++ provides a name for these member functions and a syntax for using them, and you provide the method definition. The name is the same as the class name. For example, a possible constructor for the <code>Stock</code> class is a member function called <code>Stock()</code>. The constructor prototype and header have an interesting property: Although the constructor has no return value, it&#8217;s not declared type <code>void</code>. In fact, a constructor has no declared type.</p>
<h4 id="ch10lev2sec7">Declaring and Defining Constructors</h4>
<p><a id="page_525"/>Now you need to build a <code>Stock</code> constructor. Because a <code>Stock</code> object has three values to be provided from the outside world, you should give the constructor three arguments. (The fourth value, the <code>total_val</code> member, is calculated from <code>shares</code> and <code>share_val</code>, so you don&#8217;t have to provide it to the constructor.) Possibly, you may want to provide just the <code>company</code> member value and set the other values to zero; you can do this by using default arguments (see <a href="ch08.html#ch08">Chapter 8</a>, &#8220;<a href="ch08.html#ch08">Adventures in Functions</a>.&#8221;). Thus, the prototype would look like this:</p>
<p class="programlisting">// constructor prototype with some default arguments<br/>Stock(const string &#38; co, long n = 0, double pr = 0.0);</p>
<p>The first argument is a pointer to the string that is used to initialize the <code>company string</code> member. The <code>n</code> and <code>pr</code> arguments provide values for the <code>shares</code> and <code>share_val</code> members. Note that there is no return type. The prototype goes in the public section of the class declaration.</p>
<p>Next, here&#8217;s one possible definition for the constructor:</p>
<p class="programlisting">// constructor definition<br/>Stock::Stock(const string &#38; co, long n, double pr)<br/>{<br/>company = co;<br/><br/>&#160;&#160;&#160;&#160;if (n &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cerr &lt;&lt; "Number of shares can't be negative; "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; company &lt;&lt; " shares set to 0.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares = 0;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares = n;<br/>&#160;&#160;&#160;&#160;share_val = pr;<br/>&#160;&#160;&#160;&#160;set_tot();<br/>}</p>
<p>This is the same code that the <code>acquire()</code> function used earlier in this chapter. The difference is that in this case, a program automatically invokes the constructor when it declares an object.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch10sb05"/>Member Names and Parameter Names</p>
<p class="sidebarpara">Often those new to constructors try to use the class member names as parameter names in the constructor, as in this example:</p>
<p class="programlistingB">// NO!<br/>Stock::Stock(const string &#38; company, long shares, double share_val)<br/>{<br/>...<br/>}</p>
<p class="sidebarpara">This is wrong. The constructor arguments don&#8217;t represent the class members; they represent values that are assigned to the class members. Thus, they must have distinct names, or you end up with confusing code like this:</p>
<p class="programlistingB">shares = shares;</p>
<p class="sidebarpara">One common coding practice to help avoid such confusion is to use an <code>m_</code> prefix to identify data member names:</p>
<p class="programlistingB">class Stock<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;string m_company;<br/>&#160;&#160;&#160;&#160;long m_shares;<br/>&#160;&#160;&#160;&#160;...</p>
<p class="sidebarpara">Another common practice is to use an underbar suffix for member names:</p>
<p class="programlistingB">class Stock<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;string company_;<br/>&#160;&#160;&#160;&#160;long shares_;<br/>&#160;&#160;&#160;&#160;...</p>
<p class="sidebarpara">With either convention, you then can use <code>company</code> and <code>shares</code> as the parameter names in the public interface.</p>
<hr/></div>
<h4 id="ch10lev2sec8">Using Constructors</h4>
<p><a id="page_526"/>C++ provides two ways to initialize an object by using a constructor. The first is to call the constructor explicitly:</p>
<p class="programlisting">Stock food = Stock("World Cabbage", 250, 1.25);</p>
<p>This sets the <code>company</code> member of the <code>food</code> object to the string <code>"World Cabbage"</code>, the <code>shares</code> member to <code>250</code>, and so on.</p>
<p>The second way is to call the constructor implicitly:</p>
<p class="programlisting">Stock garment("Furry Mason", 50, 2.5);</p>
<p>This more compact form is equivalent to the following explicit call:</p>
<p class="programlisting">Stock garment = Stock("Furry Mason", 50, 2.5));</p>
<p>C++ uses a class constructor whenever you create an object of that class, even when you use <code>new</code> for dynamic memory allocation. Here&#8217;s how to use the constructor with <code>new</code>:</p>
<p class="programlisting">Stock *pstock = new Stock("Electroshock Games", 18, 19.0);</p>
<p><a id="page_527"/>This statement creates a <code>Stock</code> object, initializes it to the values provided by the arguments, and assigns the address of the object to the <code>pstock</code> pointer. In this case, the object doesn&#8217;t have a name, but you can use the pointer to manage the object. We&#8217;ll discuss pointers to objects further in <a href="ch11.html#ch11">Chapter 11</a>.</p>
<p>Constructors are used differently from the other class methods. Normally, you use an object to invoke a method:</p>
<p class="programlisting">stock1.show();&#160;&#160;// stock1 object invokes show() method</p>
<p>However, you can&#8217;t use an object to invoke a constructor because until the constructor finishes its work of making the object, there is no object. Rather than being invoked by an object, the constructor is used to create the object.</p>
<h4 id="ch10lev2sec9">Default Constructors</h4>
<p>A <em>default constructor</em> is a constructor that is used to create an object when you don&#8217;t provide explicit initialization values. That is, it&#8217;s a constructor used for declarations like this:</p>
<p class="programlisting">Stock fluffy_the_cat;&#160;&#160;// uses the default constructor</p>
<p>Hey, <a href="#ch10ex03">Listing 10.3</a> already did that! The reason this statement works is that if you fail to provide any constructors, C++ automatically supplies a default constructor. It&#8217;s an implicit version of a default constructor, and it does nothing. For the <code>Stock</code> class, the default constructor would look like this:</p>
<p class="programlisting">Stock::Stock() { }</p>
<p>The net result is that the <code>fluffy_the_cat</code> object is created with its members uninitialized, just as the following creates <code>x</code> without providing a value for <code>x</code>:</p>
<p class="programlisting">int x;</p>
<p>The fact that the default constructor has no arguments reflects the fact that no values appear in the declaration.</p>
<p>A curious fact about default constructors is that the compiler provides one only if you don&#8217;t define any constructors. After you define any constructor for a class, the responsibility for providing a default constructor for that class passes from the compiler to you. If you provide a nondefault constructor, such as <code>Stock(const string &#38; co, long n, double pr)</code>, and don&#8217;t provide your own version of a default constructor, then a declaration like this becomes an error:</p>
<p class="programlisting">Stock stock1;&#160;&#160;// not possible with current constructor</p>
<p>The reason for this behavior is that you might want to make it impossible to create uninitialized objects. If, however, you wish to create objects without explicit initialization, you must define your own default constructor. This is a constructor that takes no arguments. You can define a default constructor two ways. One is to provide default values for all the arguments to the existing constructor:</p>
<p class="programlisting">Stock(const string &#38; co = "Error", int n = 0, double pr = 0.0);</p>
<p><a id="page_528"/>The second is to use function overloading to define a second constructor, one that has no arguments:</p>
<p class="programlisting">Stock();</p>
<p>You can have only one default constructor, so be sure that you don&#8217;t do both. Actually, you should usually initialize objects in order to ensure that all members begin with known, reasonable values. Thus, a user-provided default constructor typically provides implicit initialization for all member values. For example, this is how you might define one for the <code>Stock</code> class:</p>
<p class="programlisting">Stock::Stock()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>{<br/>&#160;&#160;&#160;&#160;company = "no name";<br/>&#160;&#160;&#160;&#160;shares = 0;<br/>&#160;&#160;&#160;&#160;share_val = 0.0;<br/>&#160;&#160;&#160;&#160;total_val = 0.0;<br/>}</p>
<div class="note"><hr/>
<p class="title"><a id="ch10note02"/>Tip</p>
<p class="notepara">When you design a class, you should usually provide a default constructor that implicitly initializes all class members.</p>
<hr/></div>
<p>After you&#8217;ve used either method (no arguments or default values for all arguments) to create the default constructor, you can declare object variables without initializing them explicitly:</p>
<p class="programlisting">Stock first;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls default constructor implicitly<br/>Stock first = Stock();&#160;&#160;&#160;&#160;&#160;&#160;// calls it explicitly<br/>Stock *prelief = new Stock; // calls it implicitly</p>
<p>However, you shouldn&#8217;t be misled by the implicit form of the nondefault constructor:</p>
<p class="programlisting">Stock first("Concrete Conglomerate");&#160;&#160;&#160;&#160;&#160;&#160;// calls constructor<br/>Stock second();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// declares a function<br/>Stock third;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls default constructor</p>
<p>The first declaration here calls the nondefault constructor&#8212;that is, the one that takes arguments. The second declaration states that <code>second()</code> is a function that returns a <code>Stock</code> object. When you implicitly call the default constructor, you don&#8217;t use parentheses.</p>
<h4 id="ch10lev2sec10">Destructors</h4>
<p>When you use a constructor to create an object, the program undertakes the responsibility of tracking that object until it expires. At that time, the program automatically calls a special member function bearing the formidable title <em>destructor</em>. The destructor should clean up any debris, so it actually serves a useful purpose. For example, if your constructor uses <code>new</code> to allocate memory, the destructor should use <code>delete</code> to free that memory. The <code>Stock</code> constructor doesn&#8217;t do anything fancy like using <code>new</code>, so the <code>Stock</code> class destructor doesn&#8217;t <a id="page_529"/>really have any tasks to perform. In such a case, you can simply let the compiler generate an implicit, do-nothing destructor, which is exactly what the first version of the <code>Stock</code> class does. On the other hand, it&#8217;s certainly worth looking into how to declare and define destructors, so let&#8217;s provide one for the <code>Stock</code> class.</p>
<p>Like a constructor, a destructor has a special name: It is formed from the class name preceded by a tilde (<code>~</code>). Thus, the destructor for the <code>Stock</code> class is called <code>~Stock()</code>. Also like a constructor, a destructor can have no return value and has no declared type. Unlike a constructor, a destructor must have no arguments. Thus, the prototype for a <code>Stock</code> destructor must be this:</p>
<p class="programlisting">~Stock();</p>
<p>Because a <code>Stock</code> destructor has no vital duties, you can code it as a do-nothing function:</p>
<p class="programlisting">Stock::~Stock()<br/>{<br/>}</p>
<p>However, just so that you can see when the destructor is called, let&#8217;s code it this way:</p>
<p class="programlisting">Stock::~Stock()&#160;&#160;&#160;&#160;// class destructor<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye, " &lt;&lt; company &lt;&lt; "!\n";<br/>}</p>
<p>When should a destructor be called? The compiler handles this decision; normally your code shouldn&#8217;t explicitly call a destructor. (See the section &#8220;<a href="ch12.html#ch12lev2sec18">Looking Again at Placement <code>new</code></a>&#8221; in <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; for an exception.) If you create a static storage class object, its destructor is called automatically when the program terminates. If you create an automatic storage class object, as the examples have been doing, its destructor is called automatically when the program exits the block of code in which the object is defined. If the object is created by using <code>new</code>, it resides in heap memory, or the free store, and its destructor is called automatically when you use <code>delete</code> to free the memory. Finally, a program can create temporary objects to carry out certain operations; in that case, the program automatically calls the destructor for the object when it has finished using it.</p>
<p>Because a destructor is called automatically when a class object expires, there ought to be a destructor. If you don&#8217;t provide one, the compiler implicitly declares a default constructor and, if it detects code that leads to the destruction of an object, it provides a definition for the destructor.</p>
<h4 id="ch10lev2sec11">Improving the <code>Stock</code> Class</h4>
<p>At this point we need to incorporate the constructors and the destructor into the class and method definitions. Given the significance of adding constructors, we&#8217;ll advance the name from <code>stock00.h</code> to <code>stock10.h</code>. The class methods go into a file called <code>stock10.cpp</code>. Finally, we place the program using these resources in a third file, <code>usestok2.cpp</code>.</p>
<h5 id="ch10lev3sec6">The Header File</h5>
<p><a id="page_530"/><a href="#ch10ex04">Listing 10.4</a> shows the header file for the stock program. It adds prototypes for the constructor and destructor functions to the original class declaration. Also it dispenses with the <code>acquire()</code> function, which is no longer necessary now that the class has constructors. The file also uses the <code>#ifndef</code> technique described in <a href="ch09.html#ch09">Chapter 9</a> to protect against multiple inclusion of this file.</p>
<p class="caption1"><a id="ch10ex04"/><strong>Listing 10.4. <code>stock10.h</code></strong></p><hr/>
<p class="programlisting1">// stock10.h -- Stock class declaration with constructors, destructor added<br/>#ifndef STOCK10_H_<br/>#define STOCK01_H_<br/>#include &lt;string&gt;<br/><br/>class Stock<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string company;<br/>&#160;&#160;&#160;&#160;long shares;<br/>&#160;&#160;&#160;&#160;double share_val;<br/>&#160;&#160;&#160;&#160;double total_val;<br/>&#160;&#160;&#160;&#160;void set_tot() { total_val = shares * share_val; }<br/>public:<br/>// two constructors<br/>&#160;&#160;&#160;&#160;Stock();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>&#160;&#160;&#160;&#160;Stock(const std::string &#38; co, long n = 0, double pr = 0.0);<br/>&#160;&#160;&#160;&#160;~Stock();&#160;&#160;&#160;&#160;&#160;&#160;&#160;// noisy destructor<br/>&#160;&#160;&#160;&#160;void buy(long num, double price);<br/>&#160;&#160;&#160;&#160;void sell(long num, double price);<br/>&#160;&#160;&#160;&#160;void update(double price);<br/>&#160;&#160;&#160;&#160;void show();<br/>};<br/><br/>#endif</p><hr/>
<h5 id="ch10lev3sec7">The Implementation File</h5>
<p><a href="#ch10ex05">Listing 10.5</a> provides the method definitions for the stock program. It includes the <code>stock10.h</code> file in order to provide the class declaration. (Recall that enclosing the filename in double quotation marks instead of in brackets causes the compiler to search for it at the same location where your source files are located.) Also <a href="#ch10ex05">Listing 10.5</a> includes the <code>iostream</code> header file to provide I/O support. The listing also provides using declarations and qualified names (such as <code>std::string</code>) to provide access to various declarations in the header files. This file adds the constructor and destructor method definitions to the prior methods. To help you see when these methods are called, they each display a message. This <a id="page_531"/>is not a usual feature of constructors and destructors, but it can help you better visualize how classes use them.</p>
<p class="caption1"><a id="ch10ex05"/><strong>Listing 10.5. <code>stock10.cpp</code></strong></p><hr/>
<p class="programlisting1">// stock10.cpp -- Stock class with constructors, destructor added<br/>#include &lt;iostream&gt;<br/>#include "stock10.h"<br/><br/>// constructors (verbose versions)<br/>Stock::Stock()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Default constructor called\n";<br/>&#160;&#160;&#160;&#160;company = "no name";<br/>&#160;&#160;&#160;&#160;shares = 0;<br/>&#160;&#160;&#160;&#160;share_val = 0.0;<br/>&#160;&#160;&#160;&#160;total_val = 0.0;<br/>}<br/><br/>Stock::Stock(const std::string &#38; co, long n, double pr)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Constructor using " &lt;&lt; co &lt;&lt; " called\n";<br/>&#160;&#160;&#160;&#160;company = co;<br/><br/>&#160;&#160;&#160;&#160;if (n &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Number of shares can't be negative; "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; company &lt;&lt; " shares set to 0.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares = 0;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares = n;<br/>&#160;&#160;&#160;&#160;share_val = pr;<br/>&#160;&#160;&#160;&#160;set_tot();<br/>}<br/>// class destructor<br/>Stock::~Stock()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// verbose class destructor<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Bye, " &lt;&lt; company &lt;&lt; "!\n";<br/>}<br/><br/>// other methods<br/>void Stock::buy(long num, double price)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;if (num &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Number of shares purchased can't be negative. "<br/><a id="page_532"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares += num;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_tot();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>void Stock::sell(long num, double price)<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;if (num &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Number of shares sold can't be negative. "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else if (num &gt; shares)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "You can't sell more than you have! "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares -= num;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_tot();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>void Stock::update(double price)<br/>{<br/>&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;set_tot();<br/>}<br/><br/>void Stock::show()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::ios_base;<br/>&#160;&#160;&#160;&#160;// set format to #.###<br/>&#160;&#160;&#160;&#160;ios_base::fmtflags orig =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;std::streamsize prec = cout.precision(3);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Company: " &lt;&lt; company<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Shares: " &lt;&lt; shares &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;Share Price: $" &lt;&lt; share_val;<br/>&#160;&#160;&#160;&#160;// set format to #.##<br/>&#160;&#160;&#160;&#160;cout.precision(2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;Total Worth: $" &lt;&lt; total_val &lt;&lt; '\n';<br/><br/>&#160;&#160;&#160;&#160;// restore original format<br/>&#160;&#160;&#160;&#160;cout.setf(orig, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout.precision(prec);<br/>}</p><hr/>
<h5 id="ch10lev3sec8">A Client File</h5>
<p><a id="page_533"/><a href="#ch10ex06">Listing 10.6</a> provides a short program for testing the new methods in the stock program. Because it simply uses the <code>Stock</code> class, this listing is a client of the <code>Stock</code> class. Like <code>stock10.cpp</code>, it includes the <code>stock10.h</code> file to provide the class declaration. The program demonstrates constructors and destructors. It also uses the same formatting commands invoked by <a href="#ch10ex03">Listing 10.3</a>. To compile the complete program, you use the techniques for multifile programs described in <a href="ch01.html#ch01">Chapters 1</a> and <a href="ch09.html#ch09">9</a>.</p>
<p class="caption1"><a id="ch10ex06"/><strong>Listing 10.6. <code>usestok1.cpp</code></strong></p><hr/>
<p class="programlisting1">// usestok1.cpp -- using the Stock class<br/>// compile with stock10.cpp<br/>#include &lt;iostream&gt;<br/>#include "stock10.h"<br/><br/>int main()<br/>{<br/>&#160;&#160;{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using constructors to create new objects\n";<br/>&#160;&#160;&#160;&#160;Stock stock1("NanoSmart", 12, 20.0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// syntax 1<br/>&#160;&#160;&#160;&#160;stock1.show();<br/>&#160;&#160;&#160;&#160;Stock stock2 = Stock ("Boffo Objects", 2, 2.0); // syntax 2<br/>&#160;&#160;&#160;&#160;stock2.show();<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Assigning stock1 to stock2:\n";<br/>&#160;&#160;&#160;&#160;stock2 = stock1;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Listing stock1 and stock2:\n";<br/>&#160;&#160;&#160;&#160;stock1.show();<br/>&#160;&#160;&#160;&#160;stock2.show();<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using a constructor to reset an object\n";<br/>&#160;&#160;&#160;&#160;stock1 = Stock("Nifty Foods", 10, 50.0);&#160;&#160;&#160;&#160;// temp object<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Revised stock1:\n";<br/>&#160;&#160;&#160;&#160;stock1.show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done\n";<br/>&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_534"/>Compiling the program represented by <a href="#ch10ex04">Listings 10.4</a>, <a href="#ch10ex05">10.5</a>, and <a href="#ch10ex06">10.6</a> produces an executable program. Here&#8217;s one compiler&#8217;s output from the executable program:</p>
<p class="programlisting">Using constructors to create new objects<br/>Constructor using NanoSmart called<br/>Company: NanoSmart&#160;&#160;Shares: 12<br/>&#160;&#160;Share Price: $20.00&#160;&#160;Total Worth: $240.00<br/>Constructor using Boffo Objects called<br/>Company: Boffo Objects&#160;&#160;Shares: 2<br/>&#160;&#160;Share Price: $2.00&#160;&#160;Total Worth: $4.00<br/>Assigning stock1 to stock2:<br/>Listing stock1 and stock2:<br/>Company: NanoSmart&#160;&#160;Shares: 12<br/>&#160;&#160;Share Price: $20.00&#160;&#160;Total Worth: $240.00<br/>Company: NanoSmart&#160;&#160;Shares: 12<br/>&#160;&#160;Share Price: $20.00&#160;&#160;Total Worth: $240.00<br/>Using a constructor to reset an object<br/>Constructor using Nifty Foods called<br/>Bye, Nifty Foods!<br/>Revised stock1:<br/>Company: Nifty Foods&#160;&#160;Shares: 10<br/>&#160;&#160;Share Price: $50.00&#160;&#160;Total Worth: $500.00<br/>Done<br/>Bye, NanoSmart!<br/>Bye, Nifty Foods!</p>
<p>Some compilers may produce a program with the following initial output, which has one additional line:</p>
<p class="programlisting">Using constructors to create new objects<br/>Constructor using NanoSmart called<br/>Company: NanoSmart&#160;&#160;Shares: 12<br/>&#160;&#160;Share Price: $20.00&#160;&#160;Total Worth: $240.00<br/>Constructor using Boffo Objects called<br/>Bye, Boffo Objects!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; <span class="romanAlt">additional line</span><br/>Company: Boffo Objects&#160;&#160;Shares: 2<br/>&#160;&#160;Share Price: $2.00&#160;&#160;Total Worth: $4.00<br/>...</p>
<p>The following &#8220;<a href="#ch10lev3sec9">Program Notes</a>&#8221; section explains the <code>"Bye, Boffo Objects!"</code> line of this output.</p>
<div class="note"><hr/>
<p class="title"><a id="ch10note03"/><a id="page_535"/>Note</p>
<p class="notepara">You may have noticed that <a href="#ch10ex06">Listing 10.6</a> has an extra brace at the beginning and near the end of <code>main()</code>. Automatic variables such as <code>stock1</code> and <code>stock2</code> expire when the program exits the block that contains their definitions. Without the extra braces, that block would be the body of <code>main()</code>, so the destructors would not be called until after <code>main()</code> completed execution. In a windowing environment, this would mean that the window would close before the last two destructor calls, preventing you from seeing the last two messages. But with the braces, the last two destructor calls occur before the return statement is reached, so the messages are displayed.</p>
<hr/></div>
<h5 id="ch10lev3sec9">Program Notes</h5>
<p>In <a href="#ch10ex06">Listing 10.6</a>, the statement</p>
<p class="programlisting">Stock stock1("NanoSmart", 12, 20.0);</p>
<p>creates a <code>Stock</code> object called <code>stock1</code> and initializes its data members to the indicated values:</p>
<p class="programlisting">Constructor using NanoSmart called<br/>Company: NanoSmart&#160;&#160;Shares: 12</p>
<p>The following statement uses another syntax to create and initialize an object called <code>stock2</code>:</p>
<p class="programlisting">Stock stock2 = Stock ("Boffo Objects", 2, 2.0);</p>
<p>The C++ Standard gives a compiler a couple ways to execute this second syntax. One is to make it behave exactly like the first syntax:</p>
<p class="programlisting">Constructor using Boffo Objects called<br/>Company: Boffo Objects&#160;&#160;Shares: 2</p>
<p>The second way is to allow the call to the constructor to create a temporary object that is then copied to <code>stock2</code>. Then the temporary object is discarded. If the compiler uses this option, the destructor is called for the temporary object, producing this output instead:</p>
<p class="programlisting">Constructor using Boffo Objects called<br/>Bye, Boffo Objects!<br/>Company: Boffo Objects&#160;&#160;Shares: 2</p>
<p>The compiler that produced this output disposed of the temporary object immediately, but it&#8217;s possible that a compiler might wait longer, in which case the destructor message would be displayed later.</p>
<p>The following statement illustrates that you can assign one object to another of the same type:</p>
<p class="programlisting">stock2 = stock1;&#160;&#160;&#160;&#160;&#160;// object assignment</p>
<p>As with structure assignment, class object assignment, by default, copies the members of one object to the other. In this case, the original contents of <code>stock2</code> are overwritten.</p>
<div class="note"><hr/>
<p class="title"><a id="ch10note04"/><a id="page_536"/>Note</p>
<p class="notepara">When you assign one object to another of the same class, by default C++ copies the contents of each data member of the source object to the corresponding data member of the target object.</p>
<hr/></div>
<p>You can use the constructor for more than initializing a new object. For example, the program has this statement in <code>main()</code>:</p>
<p class="programlisting">stock1 = Stock("Nifty Foods", 10, 50.0);</p>
<p>The <code>stock1</code> object already exists. Therefore, instead of initializing <code>stock1</code>, this statement assigns new values to the object. It does so by having the constructor create a new, temporary object and then copying the contents of the new object to <code>stock1</code>. Then the program disposes of the temporary object, invoking the destructor as it does so, as illustrated by the following annotated output:</p>
<p class="programlisting">Using a constructor to reset an object<br/>Constructor using Nifty Foods called &gt;&gt; <span class="romanAlt">temporary object created</span><br/>Bye, Nifty Foods!&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&gt;&gt; <span class="romanAlt">temporary object destroyed</span><br/>Revised stock1:<br/>Company: Nifty Foods&#160;&#160;Shares: 10&#160;&#160;&#160;&#160;&#160;&gt;&gt; <span class="romanAlt">data now copied to stock1</span><br/>&#160;&#160;Share Price: $50.00&#160;&#160;Total Worth: $500.00</p>
<p>Some compilers might dispose of the temporary object later, delaying the destructor call.</p>
<p>Finally, at the end, the program displays this:</p>
<p class="programlisting">Done<br/>Bye, NanoSmart!<br/>Bye, Nifty Foods!</p>
<p>When the <code>main()</code> function terminates, its local variables (<code>stock1</code> and <code>stock2</code>) pass from your plane of existence. Because such automatic variables go on the stack, the last object created is the first deleted, and the first created is the last deleted. (Recall that <code>"NanoSmart"</code> was originally in <code>stock1</code> but was later transferred to <code>stock2</code>, and <code>stock1</code> was reset to <code>"Nifty Foods"</code>.)</p>
<p>The output points out that there is a fundamental difference between the following two statements:</p>
<p class="programlisting">Stock stock2 = Stock ("Boffo Objects", 2, 2.0);<br/>stock1 = Stock("Nifty Foods", 10, 50.0); // temporary object</p>
<p>The first of these statements invokes initialization; it creates an object with the indicated value, and it may or may not create a temporary object. The second statement invokes assignment. Using a constructor in an assignment statement in this fashion always causes the creation of a temporary object before assignment occurs.</p>
<div class="note"><hr/>
<p class="title"><a id="ch10note05"/>Tip</p>
<p class="notepara">If you can set object values either through initialization or by assignment, choose initialization. It is usually more efficient.</p>
<hr/></div>
<h5 id="ch10lev3sec10">C++11 List Initialization</h5>
<p><a id="page_537"/>With C++11, can you use the list-initialization syntax with classes? Yes, you can, providing the brace contents match the argument list of a constructor:</p>
<p class="programlisting">Stock hot_tip = {"Derivatives Plus Plus", 100, 45.0};<br/>Stock jock {"Sport Age Storage, Inc"};<br/>Stock temp {};</p>
<p>The braced lists in the first two declarations match the following constructor:</p>
<p class="programlisting">Stock::Stock(const std::string &#38; co, long n = 0, double pr = 0.0);</p>
<p>Therefore, that constructor will be used to create the two objects. For <code>jock</code>, the default values of <code>0</code> and <code>0.0</code> will be used for the second and third arguments. The third declaration matches the default constructor, so <code>temp</code> is constructed using it.</p>
<p>In addition, C++11 offers a class called <code>std::initializer_list</code> that can be used as a type for a function or method parameter. This class can represent a list of arbitrary length, providing all the entries are of the same type or can be converted to the same type. <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library,&#8221; will return to this topic.</p>
<h5 id="ch10lev3sec11"><code>const</code> Member Functions</h5>
<p>Consider the following code snippet:</p>
<p class="programlisting">const Stock land = Stock("Kludgehorn Properties");<br/>land.show();</p>
<p>With current C++, the compiler should object to the second line. Why? Because the code for <code>show()</code> fails to guarantee that it won&#8217;t modify the invoking object, which, because it is <code>const</code>, should not be altered. We&#8217;ve solved this kind of problem before by declaring a function&#8217;s argument to be a <code>const</code> reference or a pointer to <code>const</code>. But there&#8217;s a syntax problem: The <code>show()</code> method doesn&#8217;t have any arguments for <code>const</code> to qualify. Instead, the object it uses is provided implicitly by the method invocation. What is needed is a new syntax, one that says a function promises not to modify the invoking object. The C++ solution is to place the <code>const</code> keyword after the function parentheses. That is, the <code>show()</code> declaration should look like this:</p>
<p class="programlisting">void show() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// promises not to change invoking object</p>
<p>Similarly, the beginning of the function definition should look like this:</p>
<p class="programlisting">void stock::show() const&#160;&#160;&#160;// promises not to change invoking object</p>
<p>Class functions declared and defined this way are called <code>const</code> member functions. Just as you should use <code>const</code> references and pointers as formal function arguments whenever appropriate, you should make class methods <code>const</code> whenever they don&#8217;t modify the invoking object. We&#8217;ll follow this rule from here on out.</p>
<h4 id="ch10lev2sec12">Constructors and Destructors in Review</h4>
<p><a id="page_538"/>Now that we&#8217;ve gone through a few examples of constructors and destructors, you might want to pause and assimilate what has passed. To help you, here is a summary of these methods.</p>
<p>A constructor is a special class member function that&#8217;s called whenever an object of that class is created. A class constructor has the same name as its class, but through the miracle of function overloading, you can have more than one constructor with the same name, provided that each has its own signature, or argument list. Also a constructor has no declared type. Usually a constructor is used to initialize members of a class object. Your initialization should match the constructor&#8217;s argument list. For example, suppose the <code>Bozo</code> class has the following prototype for a class constructor:</p>
<p class="programlisting">Bozo(const char * fname, const char * lname);&#160;&#160;&#160;// constructor prototype</p>
<p>In this case, you can use it to initialize new objects as follows:</p>
<p class="programlisting">Bozo bozetta = bozo("Bozetta", "Biggens");&#160;&#160;&#160;// primary form<br/>Bozo fufu("Fufu", "O'Dweeb");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// short form<br/>Bozo *pc = new Bozo("Popo", "Le Peu");&#160;&#160;&#160;&#160;&#160;&#160;&#160;// dynamic object</p>
<p>If C++11 rules are in effect, you can use list initialization instead:</p>
<p class="programlisting">Bozo bozetta = {"Bozetta", "Biggens"};&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C++11<br/>Bozo fufu{"Fufu", "O'Dweeb"}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C++11;<br/>Bozo *pc = new Bozo{"Popo", "Le Peu"};&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C++11</p>
<p>If a constructor has just one argument, that constructor is invoked if you initialize an object to a value that has the same type as the constructor argument. For example, suppose you have this constructor prototype:</p>
<p class="programlisting">Bozo(int age);</p>
<p>Then you can use any of the following forms to initialize an object:</p>
<p class="programlisting">Bozo dribble = bozo(44);&#160;&#160;&#160;// primary form<br/>Bozo roon(66);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// secondary form<br/>Bozo tubby = 32;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// special form for one-argument constructors</p>
<p>Actually, the third example is a new point, not a review point, but it seemed like a nice time to tell you about it. <a href="ch11.html#ch11">Chapter 11</a> mentions a way to turn off this feature because it can lead to unpleasant surprises.</p>
<div class="note"><hr/>
<p class="title"><a id="ch10note06"/>Caution</p>
<p class="notepara">A constructor that you can use with a single argument allows you to use assignment syntax to initialize an object to a value:</p>
<p class="programlistingB">Classname object = value;</p>
<p class="notepara">This feature can cause problems, but it can be blocked, as described in <a href="ch11.html#ch11">Chapter 11</a>.</p>
<hr/></div>
<p><a id="page_539"/>A default constructor has no arguments, and it is used if you create an object without explicitly initializing it. If you fail to provide any constructors, the compiler defines a default constructor for you. Otherwise, you have to supply your own default constructor. It can have no arguments or else it must have default values for all arguments:</p>
<p class="programlisting">Bozo();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor prototype<br/>Bistro(const char * s = "Chez Zero");&#160;&#160;&#160;&#160;&#160;// default for Bistro class</p>
<p>The program uses the default constructor for uninitialized objects:</p>
<p class="programlisting">Bozo bubi;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use default<br/>Bozo *pb = new Bozo;&#160;&#160;&#160;// use default</p>
<p>Just as a program invokes a constructor when an object is created, it invokes a destructor when an object is destroyed. You can have only one destructor per class. It has no return type (not even <code>void</code>), it has no arguments, and its name is the class name preceded by a tilde. For example, the <code>Bozo</code> class destructor has the following prototype:</p>
<p class="programlisting">~Bozo();&#160;&#160;&#160;&#160;// class destructor</p>
<p>Class destructors that use <code>delete</code> become necessary when class constructors use <code>new</code>.</p>
<h3 id="ch10lev1sec4">Knowing Your Objects: The <code>this</code> Pointer</h3>
<p>You can do still more with the <code>Stock</code> class. So far each class member function has dealt with but a single object: the object that invokes it. Sometimes, however, a method might need to deal with two objects, and doing so may involve a curious C++ pointer called <code>this</code>. Let&#8217;s look at how the need for <code>this</code> can unfold.</p>
<p>Although the <code>Stock</code> class declaration displays data, it&#8217;s deficient in analytic power. For example, by looking at the <code>show()</code> output, you can tell which of your holdings has the greatest value, but the program can&#8217;t tell because it can&#8217;t access <code>total_val</code> directly. The most direct way of letting a program know about stored data is to provide methods to return values. Typically, you use inline code for this, as in the following example:</p>
<p class="programlisting">class Stock<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;double total_val;<br/>&#160;&#160;&#160;&#160;...<br/>public:<br/>&#160;&#160;&#160;&#160;double total() const { return total_val; }<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>This definition, in effect, makes <code>total_val</code> read-only memory as far as a direct program access is concerned. That is, you can use the <code>total_val()</code> method to obtain the value, but the class doesn&#8217;t provide a method for specifically resetting the value of <a id="page_540"/><code>total_val</code>. (Other methods, such as <code>buy()</code>, <code>sell()</code>, and <code>update()</code>, do modify <code>total_val</code> as a by-product of resetting the <code>shares</code> and <code>share_val</code> members.)</p>
<p>By adding this function to the class declaration, you can let a program investigate a series of stocks to find the one with the greatest value. However, you can take a different approach, one that helps you learn about the <code>this</code> pointer. The approach is to define a member function that looks at two <code>Stock</code> objects and returns a reference to the larger of the two. Attempting to implement this approach raises some interesting questions, which we&#8217;ll look into now.</p>
<p>First, how do you provide the member function with two objects to compare? Suppose, for example, that you decide to name the method <code>topval()</code>. Then the function call <code>stock1.topval()</code> accesses the data of the <code>stock1</code> object, whereas the message <code>stock2.topval()</code> accesses the data of the <code>stock2</code> object. If you want the method to compare two objects, you have to pass the second object as an argument. For efficiency, you can pass the argument by reference. That is, you can have the <code>topval()</code> method use a type <code>const Stock &#38;</code> argument.</p>
<p>Second, how do you communicate the method&#8217;s answer back to the calling program? The most direct way is to have the method return a reference to the object that has the larger total value. Thus, the comparison method should have the following prototype:</p>
<p class="programlisting">const Stock &#38; topval(const Stock &#38; s) const;</p>
<p>This function accesses one object implicitly and one object explicitly, and it returns a reference to one of those two objects. The <code>const</code> in parentheses states that the function won&#8217;t modify the explicitly accessed object, and the <code>const</code> that follows the parentheses states that the function won&#8217;t modify the implicitly accessed object. Because the function returns a reference to one of the two <code>const</code> objects, the return type also has to be a <code>const</code> reference.</p>
<p>Suppose, then, that you want to compare the <code>Stock</code> objects <code>stock1</code> and <code>stock2</code> and assign the one with the greater total value to the object <code>top</code>. You can use either of the following statements to do so:</p>
<p class="programlisting">top = stock1.topval(stock2);<br/>top = stock2.topval(stock1);</p>
<p>The first form accesses <code>stock1</code> implicitly and <code>stock2</code> explicitly, whereas the second accesses <code>stock1</code> explicitly and <code>stock2</code> implicitly (see <a href="#ch10fig03">Figure 10.3</a>). Either way, the method compares the two objects and returns a reference to the one with the higher total value.</p>
<p class="caption"><a id="ch10fig03"/><strong>Figure 10.3. Accessing two objects by using a member function.</strong></p>
<p class="image"><img src="graphics/10fig03.jpg" alt="Image"/></p>
<p>Actually, this notation is a bit confusing. It would be clearer if you could somehow use the relational operator <code>&gt;</code> to compare the two objects. You can do so with operator overloading, which <a href="ch11.html#ch11">Chapter 11</a> discusses.</p>
<p>Meanwhile, there&#8217;s still the implementation of <code>topval()</code> to attend to. It raises a slight problem. Here&#8217;s a partial implementation that highlights the problem:</p>
<p class="programlisting">const Stock &#38; Stock::topval(const Stock &#38; s) const<br/>{<br/>&#160;&#160;&#160;&#160;if (s.total_val &gt; total_val)<br/><a id="page_541"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return s;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// argument object<br/>&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ?????;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invoking object<br/>}</p>
<p>Here <code>s.total_val</code> is the total value for the object passed as an argument, and <code>total_val</code> is the total value for the object to which the message is sent. If <code>s.total_val</code> is greater than <code>total_val</code>, the function returns a reference to <code>s</code>. Otherwise, it returns a reference to the object used to evoke the method. (In OOP talk, that is the object to which the <code>topval</code> message is sent.) Here&#8217;s the problem: What do you call that object? If you make the call <code>stock1.topval(stock2)</code>, then <code>s</code> is a reference for <code>stock2</code> (that is, an alias for <code>stock2</code>), but there is no alias for <code>stock1</code>.</p>
<p>The C++ solution to this problem is to use a special pointer called <code>this</code>. The <code>this</code> pointer points to the object used to invoke a member function. (Basically, <code>this</code> is passed as a hidden argument to the method.) Thus, the function call <code>stock1.topval(stock2)</code> sets <code>this</code> to the address of the <code>stock1</code> object and makes that pointer available to the <code>topval()</code> method. Similarly, the function call <code>stock2.topval(stock1)</code> sets <code>this</code> to the address of the <code>stock2</code> object. In general, all class methods have a <code>this</code> pointer set to the address of the object that invokes the method. Indeed, <code>total_val</code> in <code>topval()</code> is just shorthand notation for <code>this-&gt;total_val</code>. (Recall from <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; that you use the <code>-&gt;</code> operator to access structure members via a pointer. The same is true for class members.) (See <a href="#ch10fig04">Figure 10.4</a>.)</p>
<p class="caption"><a id="page_542"/><a id="ch10fig04"/><strong>Figure 10.4. <code>this</code> points to the invoking object.</strong></p>
<p class="image"><img src="graphics/10fig04.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch10note07"/>Note</p>
<p class="notepara">Each member function, including constructors and destructors, has a <code>this</code> pointer. The special property of the <code>this</code> pointer is that it points to the invoking object. If a method needs to refer to the invoking object as a whole, it can use the expression <code>*this</code>. Using the <code>const</code> qualifier after the function argument parentheses qualifies <code>this</code> as being a pointer to <code>const</code>; in that case, you can&#8217;t use <code>this</code> to change the object&#8217;s value.</p>
<hr/></div>
<p>What you want to return, however, is not <code>this</code> because <code>this</code> is the address of the object. You want to return the object itself, and that is symbolized by <code>*this</code>. (Recall that applying the dereferencing operator <code>*</code> to a pointer yields the value to which the pointer points.) Now you can complete the method definition by using <code>*this</code> as an alias for the invoking object:</p>
<p class="programlisting">const Stock &#38; Stock::topval(const Stock &#38; s) const<br/>{<br/>&#160;&#160;&#160;&#160;if (s.total_val &gt; total_val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return s;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// argument object<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invoking object<br/>}</p>
<p><a id="page_543"/>The fact that the return type is a reference means that the returned object is the invoking object itself rather than a copy passed by the return mechanism. <a href="#ch10ex07">Listing 10.7</a> shows the new header file.</p>
<p class="caption1"><a id="ch10ex07"/><strong>Listing 10.7. <code>stock20.h</code></strong></p><hr/>
<p class="programlisting1">// stock20.h -- augmented version<br/>#ifndef STOCK20_H_<br/>#define STOCK20_H_<br/>#include &lt;string&gt;<br/><br/>class Stock<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string company;<br/>&#160;&#160;&#160;&#160;int shares;<br/>&#160;&#160;&#160;&#160;double share_val;<br/>&#160;&#160;&#160;&#160;double total_val;<br/>&#160;&#160;&#160;&#160;void set_tot() { total_val = shares * share_val; }<br/>public:<br/>&#160;&#160;&#160;&#160;Stock();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>&#160;&#160;&#160;&#160;Stock(const std::string &#38; co, long n = 0, double pr = 0.0);<br/>&#160;&#160;&#160;&#160;~Stock();&#160;&#160;&#160;&#160;&#160;&#160;&#160;// do-nothing destructor<br/>&#160;&#160;&#160;&#160;void buy(long num, double price);<br/>&#160;&#160;&#160;&#160;void sell(long num, double price);<br/>&#160;&#160;&#160;&#160;void update(double price);<br/>&#160;&#160;&#160;&#160;void show()const;<br/>&#160;&#160;&#160;&#160;const Stock &#38; topval(const Stock &#38; s) const;<br/>};<br/><br/>#endif</p><hr/>
<p><a href="#ch10ex08">Listing 10.8</a> presents the revised class methods file. It includes the new <code>topval()</code> method. Also now that you&#8217;ve seen how the constructors and destructor work, <a href="#ch10ex08">Listing 10.8</a> replaces them with silent versions.</p>
<p class="caption1"><a id="ch10ex08"/><strong>Listing 10.8. <code>stock20.cpp</code></strong></p><hr/>
<p class="programlisting1">// stock20.cpp -- augmented version<br/>#include &lt;iostream&gt;<br/>#include "stock20.h"<br/><br/>// constructors<br/>Stock::Stock()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>{<br/>&#160;&#160;&#160;&#160;company = "no name";<br/>&#160;&#160;&#160;&#160;shares = 0;<br/><a id="page_544"/>&#160;&#160;&#160;&#160;share_val = 0.0;<br/>&#160;&#160;&#160;&#160;total_val = 0.0;<br/>}<br/><br/>Stock::Stock(const std::string &#38; co, long n, double pr)<br/>{<br/>&#160;&#160;&#160;&#160;company = co;<br/><br/>&#160;&#160;&#160;&#160;if (n &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Number of shares can't be negative; "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; company &lt;&lt; " shares set to 0.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares = 0;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares = n;<br/>&#160;&#160;&#160;&#160;share_val = pr;<br/>&#160;&#160;&#160;&#160;set_tot();<br/>}<br/><br/>// class destructor<br/>Stock::~Stock()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// quiet class destructor<br/>{<br/>}<br/><br/>// other methods<br/>void Stock::buy(long num, double price)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;if (num &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Number of shares purchased can't be negative. "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares += num;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_tot();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>void Stock::sell(long num, double price)<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;if (num &lt; 0)<br/>&#160;&#160;&#160;&#160;{<br/><a id="page_545"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Number of shares sold can't be negative. "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else if (num &gt; shares)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "You can't sell more than you have! "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "Transaction is aborted.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shares -= num;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set_tot();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/><br/>void Stock::update(double price)<br/>{<br/>&#160;&#160;&#160;&#160;share_val = price;<br/>&#160;&#160;&#160;&#160;set_tot();<br/>}<br/><br/>void Stock::show() const<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::ios_base;<br/>&#160;&#160;&#160;&#160;// set format to #.###<br/>&#160;&#160;&#160;&#160;ios_base::fmtflags orig =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;std::streamsize prec = cout.precision(3);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Company: " &lt;&lt; company<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Shares: " &lt;&lt; shares &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;Share Price: $" &lt;&lt; share_val;<br/>&#160;&#160;&#160;&#160;// set format to #.##<br/>&#160;&#160;&#160;&#160;cout.precision(2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;Total Worth: $" &lt;&lt; total_val &lt;&lt; '\n';<br/><br/>&#160;&#160;&#160;&#160;// restore original format<br/>&#160;&#160;&#160;&#160;cout.setf(orig, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout.precision(prec);<br/>}<br/><br/>const Stock &#38; Stock::topval(const Stock &#38; s) const<br/>{<br/>&#160;&#160;&#160;&#160;if (s.total_val &gt; total_val)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return s;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>}</p><hr/>
<p><a id="page_546"/>Of course, you want to see if the <code>this</code> pointer works, and a natural place to use the new method is in a program with an array of objects, which leads us to the next topic.</p>
<h3 id="ch10lev1sec5">An Array of Objects</h3>
<p>Often, as with the <code>Stock</code> examples, you want to create several objects of the same class. You can create separate object variables, as the examples have done so far in this chapter, but it might make more sense to create an array of objects. That might sound like a major leap into the unknown, but, in fact, you declare an array of objects the same way you declare an array of any of the standard types:</p>
<p class="programlisting">Stock mystuff[4]; // creates an array of 4 Stock objects</p>
<p>Recall that a program always calls the default class constructor when it creates class objects that aren&#8217;t explicitly initialized. This declaration requires either that the class explicitly define no constructors at all, in which case the implicit do-nothing default constructor is used, or, as in this case, that an explicit default constructor be defined. Each element&#8212;<code>mystuff[0]</code>, <code>mystuff[1]</code>, and so on&#8212;is a <code>Stock</code> object and thus can be used with the <code>Stock</code> methods:</p>
<p class="programlisting">mystuff[0].update();&#160;&#160;&#160;&#160;&#160;&#160;// apply update() to 1st element<br/>mystuff[3].show();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// apply show() to 4th element<br/>const Stock * tops = mystuff[2].topval(mystuff[1]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;// compare 3rd and 2nd elements and set tops<br/>&#160;&#160;&#160;&#160;&#160;&#160;// to point at the one with a higher total value</p>
<p>You can use a constructor to initialize the array elements. In that case, you have to call the constructor for each individual element:</p>
<p class="programlisting">const int STKS = 4;<br/>Stock stocks[STKS] = {<br/>&#160;&#160;&#160;&#160;Stock("NanoSmart", 12.5, 20),<br/>&#160;&#160;&#160;&#160;Stock("Boffo Objects", 200, 2.0),<br/>&#160;&#160;&#160;&#160;Stock("Monolithic Obelisks", 130, 3.25),<br/>&#160;&#160;&#160;&#160;Stock("Fleep Enterprises", 60, 6.5)<br/>&#160;&#160;&#160;&#160;};</p>
<p>Here the code uses the standard form for initializing an array: a comma-separated list of values enclosed in braces. In this case, a call to the constructor method represents each <a id="page_547"/>value. If the class has more than one constructor, you can use different constructors for different elements:</p>
<p class="programlisting">const int STKS = 10;<br/>Stock stocks[STKS] = {<br/>&#160;&#160;&#160;&#160;Stock("NanoSmart", 12.5, 20),<br/>&#160;&#160;&#160;&#160;Stock(),<br/>&#160;&#160;&#160;&#160;Stock("Monolithic Obelisks", 130, 3.25),<br/>};</p>
<p>This initializes <code>stocks[0]</code> and <code>stocks[2]</code> using the <code>Stock(const string &#38; co, long n, double pr)</code> constructor as well as <code>stocks[1]</code> using the <code>Stock()</code> constructor. Because this declaration only partially initializes the array, the remaining seven members are initialized using the default constructor.</p>
<p><a href="#ch10ex09">Listing 10.9</a> applies these principles to a short program that initializes four array elements, displays their contents, and tests the elements to find the one with the highest total value. Because <code>topval()</code> examines just two objects at a time, the program uses a <code>for</code> loop to examine the whole array. Also it uses a pointer-to-<code>Stock</code> to keep track of which element has the highest value. This listing uses the <a href="#ch10ex07">Listing 10.7</a> header file and the <a href="#ch10ex08">Listing 10.8</a> methods file.</p>
<p class="caption1"><a id="ch10ex09"/><strong>Listing 10.9. <code>usestok2.cpp</code></strong></p><hr/>
<p class="programlisting1">// usestok2.cpp -- using the Stock class<br/>// compile with stock20.cpp<br/>#include &lt;iostream&gt;<br/>#include "stock20.h"<br/><br/>const int STKS = 4;<br/>int main()<br/>{<br/>// create an array of initialized objects<br/>&#160;&#160;&#160;&#160;Stock stocks[STKS] = {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Stock("NanoSmart", 12, 20.0),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Stock("Boffo Objects", 200, 2.0),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Stock("Monolithic Obelisks", 130, 3.25),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Stock("Fleep Enterprises", 60, 6.5)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Stock holdings:\n";<br/>&#160;&#160;&#160;&#160;int st;<br/>&#160;&#160;&#160;&#160;for (st = 0; st &lt; STKS; st++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stocks[st].show();<br/>// set pointer to first element<br/>&#160;&#160;&#160;&#160;const Stock * top = &#38;stocks[0];<br/>&#160;&#160;&#160;&#160;for (st = 1; st &lt; STKS; st++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top = &#38;top-&gt;topval(stocks[st]);<br/>// now top points to the most valuable holding<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "\nMost valuable holding:\n";<br/>&#160;&#160;&#160;&#160;top-&gt;show();<br/>&#160;&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_548"/>Here is the output from the program in <a href="#ch10ex09">Listing 10.9</a>:</p>
<p class="programlisting">Stock holdings:<br/>Company: NanoSmart&#160;&#160;Shares: 12<br/>&#160;&#160;Share Price: $20.000&#160;&#160;Total Worth: $240.00<br/>Company: Boffo Objects&#160;&#160;Shares: 200<br/>&#160;&#160;Share Price: $2.000&#160;&#160;Total Worth: $400.00<br/>Company: Monolithic Obelisks&#160;&#160;Shares: 130<br/>&#160;&#160;Share Price: $3.250&#160;&#160;Total Worth: $422.50<br/>Company: Fleep Enterprises&#160;&#160;Shares: 60<br/>&#160;&#160;Share Price: $6.500&#160;&#160;Total Worth: $390.00<br/><br/>Most valuable holding:<br/>Company: Monolithic Obelisks&#160;&#160;Shares: 130<br/>&#160;&#160;Share Price: $3.250&#160;&#160;Total Worth: $422.50</p>
<p>One thing to note about <a href="#ch10ex09">Listing 10.9</a> is that most of the work goes into designing the class. When that&#8217;s done, writing the program itself is rather simple.</p>
<p>Incidentally, knowing about the <code>this</code> pointer makes it easier to see how C++ works under the skin. For example, the original Unix implementation used a C++ front-end <code>cfront</code> that converted C++ programs to C programs. To handle method definitions, all it had to do is convert a C++ method definition like</p>
<p class="programlisting">void Stock::show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Company: " &lt;&lt; company<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Shares: " &lt;&lt; shares &lt;&lt; '\n'<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Share Price: $" &lt;&lt; share_val<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Total Worth: $" &lt;&lt; total_val &lt;&lt; '\n';<br/>}</p>
<p>to the following C-style definition:</p>
<p class="programlisting">void show(const Stock * this)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Company: " &lt;&lt; this-&gt;company<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Shares: " &lt;&lt; this-&gt;shares &lt;&lt; '\n'<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Share Price: $" &lt;&lt; this-&gt;share_val<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "&#160;&#160;Total Worth: $" &lt;&lt; this-&gt;total_val &lt;&lt; '\n';<br/>}</p>
<p><a id="page_549"/>That is, it converted a <code>Stock::</code> qualifier to a function argument that is a pointer to <code>Stock</code> and then uses the pointer to access class members.</p>
<p>Similarly, the front end converted function calls like</p>
<p class="programlisting">top.show();</p>
<p>to this:</p>
<p class="programlisting">show(&#38;top);</p>
<p>In this fashion, the <code>this</code> pointer is assigned the address of the invoking object. (The actual details might be more involved.)</p>
<h3 id="ch10lev1sec6">Class Scope</h3>
<p><a href="ch09.html#ch09">Chapter 9</a> discusses global (or file) scope and local (or block) scope. Recall that you can use a variable with global scope anywhere in the file that contains its definition, whereas a variable with local scope is local to the block that contains its definition. Function names, too, can have global scope, but they never have local scope. C++ classes introduce a new kind of scope: class scope.</p>
<p>Class scope applies to names defined in a class, such as the names of class data members and class member functions. Items that have class scope are known within the class but not outside the class. Thus, you can use the same class member names in different classes without conflict. For example, the <code>shares</code> member of the <code>Stock</code> class is distinct from the <code>shares</code> member of a <code>JobRide</code> class. Also class scope means you can&#8217;t directly access members of a class from the outside world. This is true even for public function members. That is, to invoke a public member function, you have to use an object:</p>
<p class="programlisting">Stock sleeper("Exclusive Ore", 100, 0.25);&#160;&#160;// create object<br/>sleeper.show();&#160;&#160;&#160;&#160;&#160;&#160;// use object to invoke a member function<br/>show();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// invalid -- can't call method directly</p>
<p>Similarly, you have to use the scope-resolution operator when you define member functions:</p>
<p class="programlisting">void Stock::update(double price)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>In short, within a class declaration or a member function definition you can use an unadorned member name (the unqualified name), as when <code>sell()</code> calls the <code>set_tot()</code> member function. A constructor name is recognized when it is called because its name is the same as the class name. Otherwise, you must use the direct membership operator (<code>.</code>), the indirect membership operator (<code>-&gt;</code>), or the scope-resolution operator (<code>::</code>), depending on the context, when you use a class member name. The following code fragment illustrates how identifiers with class scope can be accessed:</p>
<p class="programlisting"><a id="page_550"/>class Ik<br/>{<br/>private:<br/>&#160;&#160;&#160;int fuss;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// fuss has class scope<br/>public:<br/>&#160;&#160;&#160;Ik(int f&#160;&#160;= 9) {fuss = f; }&#160;&#160;// fuss is in scope<br/>&#160;&#160;&#160;void ViewIk() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ViewIk has class scope<br/>};<br/><br/>void Ik::ViewIk() const&#160;&#160;&#160;&#160;//Ik:: places ViewIk into Ik scope<br/>{<br/>&#160;&#160;&#160;cout &lt;&lt; fuss &lt;&lt; endl;&#160;&#160;&#160;// fuss in scope within class methods<br/>}<br/>...<br/>int main()<br/>{<br/>&#160;&#160;&#160;Ik * pik = new Ik;<br/>&#160;&#160;&#160;Ik ee = Ik(8); // constructor in scope because has class name<br/>&#160;&#160;&#160;ee.ViewIk();&#160;&#160;&#160;// class object brings ViewIk into scope<br/>&#160;&#160;&#160;pik-&gt;ViewIk(); // pointer-to-Ik brings ViewIk into scope<br/>...</p>
<h4 id="ch10lev2sec13">Class Scope Constants</h4>
<p>Sometimes it would be nice to have symbolic constants with class scope. For example, a class declaration might use the literal <code>30</code> to specify an array size. Because the constant is the same for all objects, it would be nice to create a single constant shared by all objects. You might think the following would be a solution:</p>
<p class="programlisting">class Bakery<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;const int Months = 12;&#160;&#160;&#160;&#160;// declare a constant? FAILS<br/>&#160;&#160;&#160;&#160;double costs[Months];<br/>&#160;&#160;&#160;&#160;...</p>
<p>But this won&#8217;t work because declaring a class describes what an object looks like but doesn&#8217;t create an object. Hence, until you create an object, there&#8217;s no place to store a value. (Actually, C++11 provides for member initialization, but not in a way that would make the preceding array declaration work; <a href="ch12.html#ch12">Chapter 12</a> returns to this topic.) There are, however, a couple ways to achieve essentially the same desired effect.</p>
<p>First, you can declare an enumeration within a class. An enumeration given in a class declaration has class scope, so you can use enumerations to provide class scope symbolic names for integer constants. That is, you can start off the <code>Bakery</code> declaration this way:</p>
<p class="programlisting"><a id="page_551"/>class Bakery<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {Months = 12};<br/>&#160;&#160;&#160;&#160;double costs[Months];<br/>&#160;&#160;&#160;&#160;...</p>
<p>Note that declaring an enumeration in this fashion does not create a class data member. That is, each individual object does not carry an enumeration in it. Rather, <code>Len</code> is just a symbolic name that the compiler replaces with <code>30</code> when it encounters it in code in class scope.</p>
<p>Because the <code>Bakery</code> class uses the enumeration merely to create a symbolic constant, with no intent of creating variables of the enumeration type, you needn&#8217;t provide an enumeration tag. Incidentally, for many implementations, the <code>ios_base</code> class does something similar in its public section; that&#8217;s the source of identifiers such as <code>ios_base::fixed</code>. Here <code>fixed</code> is typically an enumerator defined in the <code>ios_base</code> class.</p>
<p>C++ has a second way of defining a constant within a class&#8212;using the keyword <code>static</code>:</p>
<p class="programlisting">class Bakery<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;static const int Months = 12;<br/>&#160;&#160;&#160;&#160;double costs[Months];<br/>&#160;&#160;&#160;&#160;...</p>
<p>This creates a single constant called <code>Months</code> that is stored with other static variables rather than in an object. Thus, there is only one <code>Months</code> constant shared by all <code>Bakery</code> objects. <a href="ch12.html#ch12">Chapter 12</a> looks further into static class members. In C++98 you can use this technique only for declaring static constants with integral and enumeration values. Thus, C++98 doesn&#8217;t allow you to store a <code>double</code> constant this way. C++11 removes that restriction.</p>
<h4 id="ch10lev2sec14">Scoped Enumerations (C++11)</h4>
<p>Traditional enumerations have some problems. One is that enumerators from two different <code>enum</code> definitions can conflict. Suppose you were working on a project involving eggs and T-shirts. You might try something like this:</p>
<p class="programlisting">enum egg {Small, Medium, Large, Jumbo};<br/>enum t_shirt {Small, Medium, Large, Xlarge};</p>
<p>This won&#8217;t fly because the <code>egg Small</code> and the <code>t_shirt Small</code> would both be in the same scope, and the names conflict. C++11 provides a new form of enumeration that avoids this problem by having class scope for its enumerators. The declarations for this form look like this:</p>
<p class="programlisting">enum class egg {Small, Medium, Large, Jumbo};<br/>enum class t_shirt {Small, Medium, Large, Xlarge};</p>
<p><a id="page_552"/>Alternatively, you can use the keyword <code>struct</code> instead of <code>class</code>. In either case, you now need to use the <code>enum</code> name to qualify the enumerator:</p>
<p class="programlisting">egg choice = egg::Large;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// the Large enumerator of the egg enum<br/>t_shirt Floyd = t_shirt::Large; // the Large enumerator of the t_shirt enum</p>
<p>Now that the enumerators have class scope, enumerators from different <code>enum</code> definitions no longer have potential name conflicts, and your egg-and-T-shirt project can proceed.</p>
<p>C++11 also tightens up type security for scoped enumerations. Regular enumerations get converted to integer types automatically in some situations, such as assignment to an <code>int</code> variable or being used in a comparison expression, but scoped enumerations have no implicit conversions to integer types:</p>
<p class="programlisting">enum egg_old {Small, Medium, Large, Jumbo};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// unscoped<br/>enum class t_shirt {Small, Medium, Large, Xlarge}; // scoped<br/>egg_old one = Medium;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// unscoped<br/>t_shirt rolf = t_shirt::Large;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// scoped<br/>int king = one;&#160;&#160;&#160;&#160;&#160;&#160;// implicit type conversion for unscoped<br/>int ring = rolf;&#160;&#160;&#160;&#160;&#160;// not allowed, no implicit type conversion<br/>if (king &lt; Jumbo)&#160;&#160;&#160;&#160;// allowed<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Jumbo converted to int before comparison.\n";<br/>if (king &lt; t_shirt::Medium)&#160;&#160;&#160;// not allowed<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Not allowed: &lt; not defined for scoped enum.\n";</p>
<p>But you can do an explicit type conversion if you feel you have to:</p>
<p class="programlisting">int Frodo = int(t_shirt::Small); // Frodo set to 0</p>
<p>Enumerations are represented by some underlying integer type, and under C98 that choice was implementation-dependent. Thus, a structure containing an enumeration might be of different sizes on different systems. C++11 removes that dependency for scoped enumerations. By default, the underlying type for C++11 scoped enumerations is <code>int</code>. Furthermore, there&#8217;s a syntax for indicating a different choice:</p>
<p class="programlisting">// underlying type for pizza is short<br/>enum class : short pizza {Small, Medium, Large, XLarge};</p>
<p>The <code>: short</code> specifies the underlying type to be <code>short</code>. The underlying type has to be an integer type. Under C++11, you also can use this syntax to indicate the underlying type for an unscoped enumeration, but if you don&#8217;t choose the type, the choice the compiler makes is implementation-dependent.</p>
<h3 id="ch10lev1sec7">Abstract Data Types</h3>
<p>The <code>Stock</code> class is pretty specific. Often, however, programmers define classes to represent more general concepts. For example, using classes is a good way to implement what computer scientists describe as <em>abstract data types</em> (ADTs). As the name suggests, an ADT describes a data type in a general fashion without bringing in language or implementation details. Consider, for example, the stack. By using the stack, you can store data so that <a id="page_553"/>data is always added to or deleted from the top of the stack. For example, C++ programs use a stack to manage automatic variables. As new automatic variables are generated, they are added to the top of the stack. When they expire, they are removed from the stack.</p>
<p>Let&#8217;s look at the properties of a stack in a general, abstract way. First, a stack holds several items. (That property makes it a <em>container</em>, an even more general abstraction.) Next, a stack is characterized by the operations you can perform on it:</p>
<p class="indenthandingB">&#8226; You can create an empty stack.</p>
<p class="indenthandingB">&#8226; You can add an item to the top of a stack (that is, you can <em>push</em> an item).</p>
<p class="indenthandingB">&#8226; You can remove an item from the top (that is, you can <em>pop</em> an item).</p>
<p class="indenthandingB">&#8226; You can check whether the stack is full.</p>
<p class="indenthandingB">&#8226; You can check whether the stack is empty.</p>
<p>You can match this description with a class declaration in which the public member functions provide an interface that represents the stack operations. The private data members take care of storing the stack data. The class concept is a nice match to the ADT approach.</p>
<p>The private section has to commit itself to how to hold the data. For example, you can use an ordinary array, a dynamically allocated array, or some more advanced data structure, such as a linked list. However, the public interface should hide the exact representation. Instead, it should be expressed in general terms, such as creating a stack, pushing an item, and so on. <a href="#ch10ex10">Listing 10.10</a> shows one approach. It assumes that the <code>bool</code> type has been implemented. If it hasn&#8217;t been implemented on your system, you can use <code>int</code>, <code>0</code>, and <code>1</code> rather than <code>bool</code>, <code>false</code>, and <code>true</code>.</p>
<p class="caption1"><a id="ch10ex10"/><strong>Listing 10.10. <code>stack.h</code></strong></p><hr/>
<p class="programlisting1">// stack.h -- class definition for the stack ADT<br/>#ifndef STACK_H_<br/>#define STACK_H_<br/><br/>typedef unsigned long Item;<br/><br/>class Stack<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {MAX = 10};&#160;&#160;&#160;&#160;// constant specific to class<br/>&#160;&#160;&#160;&#160;Item items[MAX];&#160;&#160;&#160;&#160;// holds stack items<br/>&#160;&#160;&#160;&#160;int top;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// index for top stack item<br/>public:<br/>&#160;&#160;&#160;&#160;Stack();<br/>&#160;&#160;&#160;&#160;bool isempty() const;<br/>&#160;&#160;&#160;&#160;bool isfull() const;<br/>&#160;&#160;&#160;&#160;// push() returns false if stack already is full, true otherwise<br/>&#160;&#160;&#160;&#160;bool push(const Item &#38; item);&#160;&#160;&#160;// add item to stack<br/>&#160;&#160;&#160;&#160;// pop() returns false if stack already is empty, true otherwise<br/>&#160;&#160;&#160;&#160;bool pop(Item &#38; item);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pop top into item<br/>};<br/>#endif</p><hr/>
<p><a id="page_554"/>In the example in <a href="#ch10ex10">Listing 10.10</a>, the private section shows that the stack is implemented by using an array, but the public section doesn&#8217;t reveal that fact. Thus, you can replace the array with, say, a dynamic array without changing the class interface. This means changing the stack implementation doesn&#8217;t require that you recode programs that use the stack. You just recompile the stack code and link it with existing program code.</p>
<p>The interface is redundant in that <code>pop()</code> and <code>push()</code> return information about the stack status (full or empty) instead of being type <code>void</code>. This provides the programmer with a couple options as to how to handle exceeding the stack limit or emptying the stack. He or she can use <code>isempty()</code> and <code>isfull()</code> to check before attempting to modify the stack, or else use the return value of <code>push()</code> and <code>pop()</code> to determine whether the operation is successful.</p>
<p>Rather than define the stack in terms of some particular type, the class describes it in terms of a general <code>Item</code> type. In this case, the header file uses <code>typedef</code> to make <code>Item</code> the same as <code>unsigned long</code>. If you want, say, a stack of <code>double</code>s or of a structure type, you can change the <code>typedef</code> and leave the class declaration and method definitions unaltered. Class templates (see <a href="ch14.html#ch14">Chapter 14</a>, &#8220;<a href="ch14.html#ch14">Reusing Code in C++</a>&#8221;) provide a more powerful method for isolating from the class design the type of data stored.</p>
<p>Next, you need to implement the class methods. <a href="#ch10ex11">Listing 10.11</a> shows one possibility.</p>
<p class="caption1"><a id="ch10ex11"/><strong>Listing 10.11. <code>stack.cpp</code></strong></p><hr/>
<p class="programlisting1">// stack.cpp -- Stack member functions<br/>#include "stack.h"<br/>Stack::Stack()&#160;&#160;&#160;&#160;// create an empty stack<br/>{<br/>&#160;&#160;&#160;&#160;top = 0;<br/>}<br/><br/>bool Stack::isempty() const<br/>{<br/>&#160;&#160;&#160;&#160;return top == 0;<br/>}<br/><br/>bool Stack::isfull() const<br/>{<br/>&#160;&#160;&#160;&#160;return top == MAX;<br/>}<br/><br/>bool Stack::push(const Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (top &lt; MAX)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;items[top++] = item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/><br/>bool Stack::pop(Item &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (top &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;item = items[--top];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}</p><hr/>
<p><a id="page_555"/>The default constructor guarantees that all stacks are created empty. The code for <code>pop()</code> and <code>push()</code> guarantees that the top of the stack is managed properly. Guarantees like this are one of the things that make OOP reliable. Suppose that, instead, you create a separate array to represent the stack and an independent variable to represent the index of the top. In that case, it is your responsibility to get the code right each time you create a new stack. Without the protection that private data offers, there&#8217;s always the possibility of making some program blunder that alters data unintentionally.</p>
<p>Let&#8217;s test this stack. <a href="#ch10ex12">Listing 10.12</a> models the life of a clerk who processes purchase orders from the top of his in-basket, using the LIFO (last-in, first-out) approach of a stack.</p>
<p class="caption1"><a id="ch10ex12"/><strong>Listing 10.12. <code>stacker.cpp</code></strong></p><hr/>
<p class="programlisting1">// stacker.cpp -- testing the Stack class<br/>#include &lt;iostream&gt;<br/>#include &lt;cctype&gt;&#160;&#160;// or ctype.h<br/>#include "stack.h"<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;Stack st; // create an empty stack<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;unsigned long po;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter A to add a purchase order,\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "P to process a PO, or Q to quit.\n";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; ch &#38;&#38; toupper(ch) != 'Q')<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!isalpha(ch))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; '\a';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch(ch)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'A':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'a': cout &lt;&lt; "Enter a PO number to add: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; po;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (st.isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "stack already full\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.push(po);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'P':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'p': if (st.isempty())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "stack already empty\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.pop(po);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "PO #" &lt;&lt; po &lt;&lt; " popped\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter A to add a purchase order,\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "P to process a PO, or Q to quit.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_556"/>The little <code>while</code> loop in <a href="#ch10ex12">Listing 10.12</a> that gets rid of the rest of the line isn&#8217;t absolutely necessary at this point, but it will come in handy in a modification of this program in <a href="ch14.html#ch14">Chapter 14</a>. Here&#8217;s a sample run:</p>
<p class="programlisting">Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">A</span><br/>Enter a PO number to add: <span class="EmpStrong">17885</span><br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">P</span><br/>PO #17885 popped<br/>Please enter A to add a purchase order,<br/><a id="page_557"/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">A</span><br/>Enter a PO number to add: <span class="EmpStrong">17965</span><br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">A</span><br/>Enter a PO number to add: <span class="EmpStrong">18002</span><br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">P</span><br/>PO #18002 popped<br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">P</span><br/>PO #17965 popped<br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">P</span><br/>stack already empty<br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">Q</span><br/>Bye</p>
<h3 id="ch10lev1sec8">Summary</h3>
<p>OOP emphasizes how a program represents data. The first step toward solving a programming problem by using the OOP approach is to describe the data in terms of its interface with the program, specifying how the data is used. Next, you need to design a class that implements the interface. Typically, private data members store the information, whereas public member functions, also called methods, provide the only access to the data. The class combines data and methods into one unit, and the private aspect accomplishes data hiding.</p>
<p>Usually, you separate a class declaration into two parts, typically kept in separate files. The class declaration proper goes into a header file, with the methods represented by function prototypes. The source code that defines the member functions goes into a methods file. This approach separates the description of the interface from the details of the implementation. In principle, you need to know only the public class interface to use the class. Of course, you can look at the implementation (unless it&#8217;s been supplied to you in compiled form only), but your program shouldn&#8217;t rely on details of the implementation, such as knowing that a particular value is stored as an <code>int</code>. As long as a program and a class communicate only through methods defining the interface, you are free to improve either part separately without worrying about unforeseen interactions.</p>
<p><a id="page_558"/>A class is a user-defined type, and an object is an instance of a class. This means an object is a variable of that type or the equivalent of a variable, such as memory allocated by <code>new</code> according to the class specification. C++ tries to make user-defined types as similar as possible to standard types, so you can declare objects, pointers to objects, and arrays of objects. You can pass objects as arguments, return them as function return values, and assign one object to another of the same type. If you provide a constructor method, you can initialize objects when they are created. If you provide a destructor method, the program executes that method when the object expires.</p>
<p>Each object holds its own copies of the data portion of a class declaration, but they share the class methods. If <code>mr_object</code> is the name of a particular object and <code>try_me()</code> is a member function, you invoke the member function by using the dot membership operator: <code>mr_object.try_me()</code>. OOP terminology describes this function call as sending a <code>try_me</code> message to the <code>mr_object</code> object. Any reference to class data members in the <code>try_me()</code> method then applies to the data members of the <code>mr_object</code> object. Similarly, the function call <code>i_object.try_me()</code> accesses the data members of the <code>i_object</code> object.</p>
<p>If you want a member function to act on more than one object, you can pass additional objects to the method as arguments. If a method needs to refer explicitly to the object that evoked it, it can use the <code>this</code> pointer. The <code>this</code> pointer is set to the address of the evoking object, so <code>*this</code> is an alias for the object itself.</p>
<p>Classes are well matched to describing ADTs. The public member function interface provides the services described by an ADT, and the class&#8217;s private section and the code for the class methods provide an implementation that is hidden from clients of the class.</p>
<h3 id="ch10lev1sec9">Chapter Review</h3>
<p class="question"><a id="ch10qa1q1" href="app10.html#ch10qa1a1"><strong>1.</strong></a> What is a class?</p>
<p class="question"><a id="ch10qa1q2" href="app10.html#ch10qa1a2"><strong>2.</strong></a> How does a class accomplish abstraction, encapsulation, and data hiding?</p>
<p class="question"><a id="ch10qa1q3" href="app10.html#ch10qa1a3"><strong>3.</strong></a> What is the relationship between an object and a class?</p>
<p class="question"><a id="ch10qa1q4" href="app10.html#ch10qa1a4"><strong>4.</strong></a> In what way, aside from being functions, are class function members different from class data members?</p>
<p class="question"><a id="ch10qa1q5" href="app10.html#ch10qa1a5"><strong>5.</strong></a> Define a class to represent a bank account. Data members should include the depositor&#8217;s name, the account number (use a string), and the balance. Member functions should allow the following:</p>
<p class="indenthandingNB">&#8226; Creating an object and initializing it.</p>
<p class="indenthandingNB">&#8226; Displaying the depositor&#8217;s name, account number, and balance</p>
<p class="indenthandingNB">&#8226; Depositing an amount of money given by an argument</p>
<p class="indenthandingNB">&#8226; Withdrawing an amount of money given by an argument</p>
<p class="questionp">Just show the class declaration, not the method implementations. (Programming Exercise 1 provides you with an opportunity to write the implementation.)</p>
<p class="question"><a id="page_559"/><a id="ch10qa1q6" href="app10.html#ch10qa1a6"><strong>6.</strong></a> When are class constructors called? When are class destructors called?</p>
<p class="question"><a id="ch10qa1q7" href="app10.html#ch10qa1a7"><strong>7.</strong></a> Provide code for a constructor for the bank account class from Chapter Review Question 5.</p>
<p class="question"><a id="ch10qa1q8" href="app10.html#ch10qa1a8"><strong>8.</strong></a> What is a default constructor? What is the advantage of having one?</p>
<p class="question"><a id="ch10qa1q9" href="app10.html#ch10qa1a9"><strong>9.</strong></a> Modify the <code>Stock</code> class definition (the version in <code>stock20.h</code>) so that it has member functions that return the values of the individual data members. Note: A member that returns the company name should not provide a weapon for altering the array. That is, it can&#8217;t simply return a <code>string</code> reference. It could return a <code>const</code> reference.</p>
<p class="question1"><a id="ch10qa1q10" href="app10.html#ch10qa1a10"><strong>10.</strong></a> What are <code>this</code> and <code>*this</code>?</p>
<h3 id="ch10lev1sec10">Programming Exercises</h3>
<p class="question"><a id="ch10qa2q1"/><strong>1.</strong> Provide method definitions for the class described in Chapter Review Question 5 and write a short program that illustrates all the features.</p>
<p class="question"><a id="ch10qa2q2"/><strong>2.</strong> Here is a rather simple class definition:</p>
<p class="programlistingB">class Person {<br/>private:<br/>&#160;&#160;&#160;&#160;static const LIMIT = 25;<br/>&#160;&#160;&#160;&#160;string lname;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Person's last name<br/>&#160;&#160;&#160;&#160;char fname[LIMIT];&#160;&#160;// Person's first name<br/>public:<br/>&#160;&#160;&#160;&#160;Person() {lname = ""; fname[0] = '\0';&#160;&#160;} // #1<br/>&#160;&#160;&#160;&#160;Person(const string &#38; ln, const char * fn = "Heyyou");&#160;&#160;&#160;// #2<br/>// the following methods display lname and fname<br/>&#160;&#160;&#160;&#160;void Show() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// firstname lastname format<br/>&#160;&#160;&#160;&#160;void FormalShow() const;&#160;&#160;// lastname, firstname format<br/>};</p>
<p class="questionp">(It uses both a <code>string</code> object and a character array so that you can compare how the two forms are used.) Write a program that completes the implementation by providing code for the undefined methods. The program in which you use the class should also use the three possible constructor calls (no arguments, one argument, and two arguments) and the two display methods. Here&#8217;s an example that uses the constructors and methods:</p>
<p class="programlistingB">Person one;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use default constructor<br/>Person two("Smythecraft");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use #2 with one default argument<br/>Person three("Dimwiddy", "Sam");&#160;&#160;// use #2, no defaults<br/>one.Show();<br/>cout &lt;&lt; endl;<br/>one.FormalShow();<br/>// etc. for two and three</p>
<p class="question"><a id="ch10qa2q3"/><strong>3.</strong> Do Programming Exercise 1 from <a href="ch09.html#ch09">Chapter 9</a> but replace the code shown there with an appropriate <code>golf</code> class declaration. Replace <code>setgolf(golf &#38;, const char*, int)</code> <a id="page_560"/>with a constructor with the appropriate argument for providing initial values. Retain the interactive version of <code>setgolf()</code> but implement it by using the constructor. (For example, for the code for <code>setgolf()</code>, obtain the data, pass the data to the constructor to create a temporary object, and assign the temporary object to the invoking object, which is <code>*this</code>.)</p>
<p class="question"><a id="ch10qa2q4"/><strong>4.</strong> Do Programming Exercise 4 from <a href="ch09.html#ch09">Chapter 9</a> but convert the <code>Sales</code> structure and its associated functions to a class and its methods. Replace the <code>setSales(Sales &#38;, double [], int)</code> function with a constructor. Implement the interactive <code>setSales(Sales &#38;)</code> method by using the constructor. Keep the class within the namespace <code>SALES</code>.</p>
<p class="question"><a id="ch10qa2q5"/><strong>5.</strong> Consider the following structure declaration:</p>
<p class="programlistingB">struct customer {<br/>&#160;&#160;&#160;&#160;char fullname[35];<br/>&#160;&#160;&#160;&#160;double payment;<br/>};</p>
<p class="questionp">Write a program that adds and removes customer structures from a stack, represented by a <code>Stack</code> class declaration. Each time a customer is removed, his or her payment should be added to a running total, and the running total should be reported. Note: You should be able to use the <code>Stack</code> class unaltered; just change the <code>typedef</code> declaration so that <code>Item</code> is type <code>customer</code> instead of <code>unsigned long</code>.</p>
<p class="question"><a id="ch10qa2q6"/><strong>6.</strong> Here&#8217;s a class declaration:</p>
<p class="programlistingB">class Move<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double x;<br/>&#160;&#160;&#160;&#160;double y;<br/>public:<br/>&#160;&#160;&#160;&#160;Move(double a = 0, double b = 0);&#160;&#160;&#160;// sets x, y to a, b<br/>&#160;&#160;&#160;&#160;showmove() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// shows current x, y values<br/>&#160;&#160;&#160;&#160;Move add(const Move &#38; m) const;<br/>// this function adds x of m to x of invoking object to get new x,<br/>// adds y of m to y of invoking object to get new y, creates a new<br/>// move object initialized to new x, y values and returns it<br/>&#160;&#160;&#160;&#160;reset(double a = 0, double b = 0);&#160;&#160;// resets x,y to a, b<br/>};</p>
<p class="questionp">Create member function definitions and a program that exercises the class.</p>
<p class="question"><a id="page_561"/><a id="ch10qa2q7"/><strong>7.</strong> A Betelgeusean plorg has these properties:</p>
<p class="questionp"><strong>Data</strong></p>
<p class="questionp">A plorg has a name with no more than 19 letters.</p>
<p class="questionp">A plorg has a contentment index (CI), which is an integer.</p>
<p class="questionp"><strong>Operations</strong></p>
<p class="questionp">A new plorg starts out with a name and a CI of 50.</p>
<p class="questionp">A plorg&#8217;s CI can change.</p>
<p class="questionp">A plorg can report its name and CI.</p>
<p class="questionp">The default plorg has the name <code>"Plorga"</code>.</p>
<p class="questionp">Write a <code>Plorg</code> class declaration (including data members and member function prototypes) that represents a plorg. Write the function definitions for the member functions. Write a short program that demonstrates all the features of the <code>Plorg</code> class.</p>
<p class="question"><a id="ch10qa2q8"/><strong>8.</strong> You can describe a simple list as follows:</p>
<p class="indenthandingNB">&#8226; The simple list can hold zero or more items of some particular type.</p>
<p class="indenthandingNB">&#8226; You can create an empty list.</p>
<p class="indenthandingNB">&#8226; You can add items to the list.</p>
<p class="indenthandingNB">&#8226; You can determine whether the list is empty.</p>
<p class="indenthandingNB">&#8226; You can determine whether the list is full.</p>
<p class="indenthandingNB">&#8226; You can visit each item in the list and perform some action on it.</p>
<p>As you can see, this list really is simple; it doesn&#8217;t allow insertion or deletion, for example.</p>
<p class="indenthanding">Design a <code>List</code> class to represent this abstract type. You should provide a <code>list.h</code> header file with the class declaration and a <code>list.cpp</code> file with the class method implementations. You should also create a short program that utilizes your design.</p>
<p class="indenthanding">The main reason for keeping the list specification simple is to simplify this programming exercise. You can implement the list as an array or, if you&#8217;re familiar with the data type, as a linked list. But the public interface should not depend on your choice. That is, the public interface should not have array indices, pointers to nodes, and so on. It should be expressed in the general concepts of creating a list, adding <a id="page_562"/>an item to the list, and so on. The usual way to handle visiting each item and performing an action is to use a function that takes a function pointer as an argument:</p>
<p class="programlistingB">void visit(void (*pf)(Item &#38;));</p>
<p class="indenthanding">Here <code>pf</code> points to a function (not a member function) that takes a reference to <code>Item</code> argument, where <code>Item</code> is the type for items in the list. The <code>visit()</code> function applies this function to each item in the list. You can use the <code>Stack</code> class as a general guide.</p>
</body>
</html>
