<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5. Loops and Relational Expressions</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch05">5. Loops and Relational Expressions</h2>
<p><a id="page_195"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; The <code>for</code> loop</p>
<p class="indenthandingB">&#8226; Expressions and statements</p>
<p class="indenthandingB">&#8226; The increment and decrement operators: <code>++</code> and <code>--</code></p>
<p class="indenthandingB">&#8226; Combination assignment operators</p>
<p class="indenthandingB">&#8226; Compound statements (blocks)</p>
<p class="indenthandingB">&#8226; The comma operator</p>
<p class="indenthandingB">&#8226; Relational operators: <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>&lt;=</code>, <code>&lt;</code>, and <code>!=</code></p>
<p class="indenthandingB">&#8226; The <code>while</code> loop</p>
<p class="indenthandingB">&#8226; The <code>typedef</code> facility</p>
<p class="indenthandingB">&#8226; The <code>do while</code> loop</p>
<p class="indenthandingB">&#8226; The <code>get()</code> character input method</p>
<p class="indenthandingB">&#8226; The end-of-file condition</p>
<p class="indenthandingB">&#8226; Nested loops and two-dimensional arrays</p>
<p>Computers do more than store data. They analyze, consolidate, rearrange, extract, modify, extrapolate, synthesize, and otherwise manipulate data. Sometimes they even distort and trash data, but we&#8217;ll try to steer clear of that kind of behavior. To perform their manipulative miracles, programs need tools for performing repetitive actions and for making decisions. Of course, C++ provides such tools. Indeed, it uses the same <code>for</code> loops, <code>while</code> loops, <code>do while</code> loops, <code>if</code> statements, and <code>switch</code> statements that regular C employs, so if you know C, you can zip through this chapter and <a href="ch06.html#ch06">Chapter 6</a>, &#8220;<a href="ch06.html#ch06">Branching Statements and Logical Operators</a>.&#8221; (But don&#8217;t zip too fast&#8212;you don&#8217;t want to miss how <code>cin</code> handles character input!) These various program control statements often use relational expressions and logical expressions to govern their behavior. This chapter discusses <a id="page_196"/>loops and relational expressions, and <a href="ch06.html#ch06">Chapter 6</a> follows up with branching statements and logical expressions.</p>
<h3 id="ch05lev1sec1">Introducing <code>for</code> Loops</h3>
<p>Circumstances often call on a program to perform repetitive tasks, such as adding together the elements of an array one by one or printing some paean to productivity 20 times. The C++ <code>for</code> loop makes such tasks easy to do. Let&#8217;s look at a loop in <a href="#ch05ex01">Listing 5.1</a>, see what it does, and then discuss how it works.</p>
<p class="caption1"><a id="ch05ex01"/><strong>Listing 5.1. <code>forloop.cpp</code></strong></p><hr/>
<p class="programlisting1">// forloop.cpp -- introducing the for loop<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int i;&#160;&#160;// create a counter<br/>//&#160;&#160;&#160;initialize; test ; update<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; 5; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "C++ knows loops.\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "C++ knows when to stop.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output from the program in <a href="#ch05ex01">Listing 5.1</a>:</p>
<p class="programlisting">C++ knows loops.<br/>C++ knows loops.<br/>C++ knows loops.<br/>C++ knows loops.<br/>C++ knows loops.<br/>C++ knows when to stop.</p>
<p>This loop begins by setting the integer <code>i</code> to 0:</p>
<p class="programlisting">i = 0</p>
<p>This is the <em>loop initialization</em> part of the loop. Then in the <em>loop test</em>, the program tests whether <code>i</code> is less than 5:</p>
<p class="programlisting">i &lt; 5</p>
<p>If it is, the program executes the following statement, which is termed the <em>loop body</em>:</p>
<p class="programlisting">cout &lt;&lt; "C++ knows loops.\n";</p>
<p>Then the program uses the <em>loop update</em> part of the loop to increase <code>i</code> by 1:</p>
<p class="programlisting">i++</p>
<p><a id="page_197"/>The <em>loop update</em> part of the loop uses the <code>++</code> operator, called the <em>increment operator</em>. It increments the value of its operand by 1. (The increment operator is not restricted to <code>for</code> loops. For example, you can use <code>i++;</code> instead of <code>i = i + 1;</code> as a statement in a program.) Incrementing <code>i</code> completes the first cycle of the loop.</p>
<p>Next, the loop begins a new cycle by comparing the new <code>i</code> value with 5. Because the new value (1) is also less than 5, the loop prints another line and then finishes by incrementing <code>i</code> again. That sets the stage for a fresh cycle of testing, executing a statement, and updating the value of <code>i</code>. The process continues until the loop updates <code>i</code> to 5. Then the next test fails, and the program moves on to the next statement after the loop.</p>
<h4 id="ch05lev2sec1">Parts of a <code>for</code> Loop</h4>
<p>A <code>for</code> loop provides a step-by-step recipe for performing repeated actions. Let&#8217;s take a more detailed look at how it&#8217;s set up. The usual parts of a <code>for</code> loop handle these steps:</p>
<p class="indenthandingN"><strong>1.</strong> Setting a value initially</p>
<p class="indenthandingN"><strong>2.</strong> Performing a test to see whether the loop should continue</p>
<p class="indenthandingN"><strong>3.</strong> Executing the loop actions</p>
<p class="indenthandingN"><strong>4.</strong> Updating value(s) used for the test</p>
<p>The C++ loop design positions these elements so that you can spot them at a glance. The initialization, test, and update actions constitute a three-part control section enclosed in parentheses. Each part is an expression, and semicolons separate the expressions from each other. The statement following the control section is called the <em>body</em> of the loop, and it is executed as long as the test expression remains true:</p>
<p class="programlisting">for (<span class="EmpItalic">initialization</span>; <span class="EmpItalic">test-expression</span>; <span class="EmpItalic">update-expression</span>)<br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">body</span></p>
<p>C++ syntax counts a complete <code>for</code> statement as a single statement, even though it can incorporate one or more statements in the body portion. (Having more than one statement requires using a compound statement, or block, as discussed later in this chapter.)</p>
<p>The loop performs initialization just once. Typically, programs use this expression to set a variable to a starting value and then use the variable to count loop cycles.</p>
<p><em><code>test-expression</code></em> determines whether the loop body gets executed. Typically, this expression is a relational expression&#8212;that is, one that compares two values. Our example compares the value of <code>i</code> to 5, checking whether <code>i</code> is less than 5. If the comparison is true, the program executes the loop body. Actually, C++ doesn&#8217;t limit <em><code>test-expression</code></em> to true/false comparisons. You can use any expression, and C++ will type cast it to type <code>bool</code>. Thus, an expression with a value of 0 is converted to the <code>bool</code> value <code>false</code>, and the loop terminates. If the expression evaluates to nonzero, it is type cast to the <code>bool</code> value <code>true</code>, and the loop continues. <a href="#ch05ex02">Listing 5.2</a> demonstrates this by using the expression <code>i</code> as the test condition. (In the update section, <code>i--</code> is similar to <code>i++</code> except that it decreases the value of <code>i</code> by 1 each time it&#8217;s used.)</p>
<p class="caption1"><a id="page_198"/><a id="ch05ex02"/><strong>Listing 5.2. <code>num_test.cpp</code></strong></p><hr/>
<p class="programlisting1">// num_test.cpp -- use numeric test in for loop<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the starting countdown value: ";<br/>&#160;&#160;&#160;&#160;int limit;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; limit;<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = limit; i; i--)&#160;&#160;&#160;&#160;&#160;// quits when i is 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done now that i = " &lt;&lt; i &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output from the program in <a href="#ch05ex02">Listing 5.2</a>:</p>
<p class="programlisting">Enter the starting countdown value: <span class="EmpStrong">4</span><br/>i = 4<br/>i = 3<br/>i = 2<br/>i = 1<br/>Done now that i = 0</p>
<p>Note that the loop terminates when <code>i</code> reaches 0.</p>
<p>How do relational expressions, such as <code>i &lt; 5</code>, fit into this framework of terminating a loop with a 0 value? Before the <code>bool</code> type was introduced, relational expressions evaluated to 1 if true and 0 if false. Thus, the value of the expression <code>3 &lt; 5</code> was <code>1</code>, and the value of <code>5 &lt; 5</code> was <code>0</code>. Now that C++ has added the <code>bool</code> type, however, relational expressions evaluate to the <code>bool</code> literals <code>true</code> and <code>false</code> instead of <code>1</code> and <code>0</code>. This change doesn&#8217;t lead to incompatibilities, however, because a C++ program converts <code>true</code> and <code>false</code> to <code>1</code> and <code>0</code> where integer values are expected, and it converts <code>0</code> to <code>false</code> and nonzero to <code>true</code> where <code>bool</code> values are expected.</p>
<p>The <code>for</code> loop is an <em>entry-condition</em> loop. This means the test expression is evaluated <em>before</em> each loop cycle. The loop never executes the loop body when the test expression is false. For example, suppose you rerun the program in <a href="#ch05ex02">Listing 5.2</a> but give 0 as a starting value. Because the test condition fails the very first time it&#8217;s evaluated, the loop body never gets executed:</p>
<p class="programlisting">Enter the starting countdown value: <span class="EmpStrong">0</span><br/>Done now that i = 0</p>
<p>This look-before-you-loop attitude can help keep a program out of trouble.</p>
<p><em><code>update-expression</code></em> is evaluated at the end of the loop, after the body has been executed. Typically, it&#8217;s used to increase or decrease the value of the variable keeping track of <a id="page_199"/>the number of loop cycles. However, it can be any valid C++ expression, as can the other control expressions. This makes the <code>for</code> loop capable of much more than simply counting from 0 to 5, the way the first loop example does. You&#8217;ll see some examples of this later.</p>
<p>The <code>for</code> loop body consists of a single statement, but you&#8217;ll soon learn how to stretch that rule. <a href="#ch05fig01">Figure 5.1</a> summarizes the <code>for</code> loop design.</p>
<p class="caption"><a id="ch05fig01"/><strong>Figure 5.1. The design of <code>for</code> loops.</strong></p>
<p class="image"><img src="graphics/05fig01.jpg" alt="Image"/></p>
<p>A <code>for</code> statement looks something like a function call because it uses a name followed by paired parentheses. However, <code>for</code>&#8217;s status as a C++ keyword prevents the compiler from thinking <code>for</code> is a function. It also prevents you from naming a function <code>for</code>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note01"/>Tip</p>
<p class="notepara">Common C++ style is to place a space between <code>for</code> and the following parenthesis and to omit space between a function name and the following parenthesis:</p>
<p class="programlistingB">for (i = 6; i &lt; 10; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;smart_function(i);</p>
<p class="notepara"><a id="page_200"/>Other control statements, such as <code>if</code> and <code>while</code>, are treated similarly to <code>for</code>. This serves to visually reinforce the distinction between a control statement and a function call. Also common practice is to indent the body of a <code>for</code> statement to make it stand out visually.</p>
<hr/></div>
<h5 id="ch05lev3sec1">Expressions and Statements</h5>
<p>A <code>for</code> control section uses three expressions. Within its self-imposed limits of syntax, C++ is a very expressive language. Any value or any valid combination of values and operators constitute an expression. For example, <code>10</code> is an expression with the value 10 (no surprise), and <code>28 * 20</code> is an expression with the value 560. In C++ every expression has a value. Often the value is obvious. For example, the following expression is formed from two values and the addition operator, and it has the value 49:</p>
<p class="programlisting">22 + 27</p>
<p>Sometimes the value is less obvious. For example, the following is an expression because it&#8217;s formed from two values and the assignment operator:</p>
<p class="programlisting">x = 20</p>
<p>C++ defines the value of an assignment expression to be the value of the member on the left, so the expression has the value 20. The fact that assignment expressions have values permits statements such as the following:</p>
<p class="programlisting">maids = (cooks = 4) + 3;</p>
<p>The expression <code>cooks = 4</code> has the value 4, so <code>maids</code> is assigned the value 7. However, just because C++ permits this behavior doesn&#8217;t mean you should encourage it. But the same rule that makes this peculiar statement possible also makes the following useful statement possible:</p>
<p class="programlisting">x = y = z = 0;</p>
<p>This is a fast way to set several variables to the same value. The precedence table (see <a href="app04.html#app04">Appendix D</a>, &#8220;<a href="app04.html#app04">Operator Precedence</a>&#8221;) reveals that assignment associates right-to-left, so first <code>0</code> is assigned to <code>z</code>, and then <code>z = 0</code> is assigned to <code>y</code>, and so on.</p>
<p>Finally, as mentioned previously, relational expressions such as <code>x &lt; y</code> evaluate to the <code>bool</code> values <code>true</code> or <code>false</code>. The short program in <a href="#ch05ex03">Listing 5.3</a> illustrates some points about expression values. The <code>&lt;&lt;</code> operator has higher precedence than the operators used in the expressions, so the code uses parentheses to enforce the correct order.</p>
<p class="caption1"><a id="ch05ex03"/><strong>Listing 5.3. <code>express.cpp</code></strong></p><hr/>
<p class="programlisting1">// express.cpp -- values of expressions<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int x;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The expression x = 100 has the value ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (x = 100) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Now x = " &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The expression x &lt; 3 has the value ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (x &lt; 3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The expression x &gt; 3 has the value ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (x &gt; 3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::boolalpha);&#160;&#160;&#160;//a newer C++ feature<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The expression x &lt; 3 has the value ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (x &lt; 3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The expression x &gt; 3 has the value ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (x &gt; 3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_201"/>Here is the output from the program in <a href="#ch05ex03">Listing 5.3</a>:</p>
<p class="programlisting">The expression x = 100 has the value 100<br/>Now x = 100<br/>The expression x &lt; 3 has the value 0<br/>The expression x &gt; 3 has the value 1<br/>The expression x &lt; 3 has the value false<br/>The expression x &gt; 3 has the value true</p>
<p>Normally, <code>cout</code> converts <code>bool</code> values to <code>int</code> before displaying them, but the <code>cout.setf(ios::boolalpha)</code> function call sets a flag that instructs <code>cout</code> to display the words <code>true</code> and <code>false</code> instead of <code>1</code> and <code>0</code>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note02"/>Note</p>
<p class="notepara">A C++ expression is a value or a combination of values and operators, and every C++ expression has a value.</p>
<hr/></div>
<p>To evaluate the expression <code>x = 100</code>, C++ must assign the value <code>100</code> to <code>x</code>. When the very act of evaluating an expression changes the value of data in memory, we say the evaluation has a <em>side effect</em>. Thus, evaluating an assignment expression has the side effect of changing the assignee&#8217;s value. You might think of assignment as the intended effect, but from the standpoint of how C++ is constructed, evaluating the expression is the primary effect. Not all expressions have side effects. For example, evaluating <code>x + 15</code> calculates a new value, but it doesn&#8217;t change the value of <code>x</code>. But evaluating <code>++x + 15</code> does have a side effect because it involves incrementing <code>x</code>.</p>
<p>From expression to statement is a short step; you just add a semicolon. Thus, the following is an expression:</p>
<p class="programlisting">age = 100</p>
<p>Whereas the following is a statement:</p>
<p class="programlisting">age = 100;</p>
<p><a id="page_202"/>More particularly, it is an <em>expression statement</em>. Any expression can become a statement if you add a semicolon, but the result might not make programming sense. For example, if <code>rodents</code> is a variable, then the following is a valid C++ statement:</p>
<p class="programlisting">rodents + 6;&#160;&#160;&#160;&#160;&#160;// valid, but useless, statement</p>
<p>The compiler allows it, but the statement doesn&#8217;t accomplish anything useful. The program merely calculates the sum, does nothing with it, and goes on to the next statement. (A smart compiler might even skip the statement.)</p>
<h5 id="ch05lev3sec2">Nonexpressions and Statements</h5>
<p>Some concepts, such as knowing the structure of a <code>for</code> loop, are crucial to understanding C++. But there are also relatively minor aspects of syntax that can suddenly bedevil you just when you think you understand the language. We&#8217;ll look at a couple of them now.</p>
<p>Although it is true that adding a semicolon to any expression makes it a statement, the reverse is not true. That is, removing a semicolon from a statement does not necessarily convert it to an expression. Of the kinds of statements we&#8217;ve used so far, return statements, declaration statements, and <code>for</code> statements don&#8217;t fit the <em>statement = expression + semicolon</em> mold. For example, this is a statement:</p>
<p class="programlisting">int toad;</p>
<p>But the fragment <code>int toad</code> is not an expression and does not have a value. This makes code such as the following invalid:</p>
<p class="programlisting">eggs = int toad * 1000;&#160;&#160;&#160;// invalid, not an expression<br/>cin &gt;&gt; int toad;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// can't combine declaration with cin</p>
<p>Similarly, you can&#8217;t assign a <code>for</code> loop to a variable. In the following example, the <code>for</code> loop is not an expression, so it has no value and you can&#8217;t assign it:</p>
<p class="programlisting">int fx = for (i = 0; i&lt; 4; i++)<br/>&#160;&#160;&#160;&#160;&#160;cout &gt;&gt; i;&#160;&#160;&#160;// not possible</p>
<h5 id="ch05lev3sec3">Bending the Rules</h5>
<p>C++ adds a feature to C loops that requires some artful adjustments to the <code>for</code> loop syntax. This was the original syntax:</p>
<p class="programlisting">for (<span class="EmpItalic">expression</span>; <span class="EmpItalic">expression</span>; <span class="EmpItalic">expression</span>)<br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">statement</span></p>
<p>In particular, the control section of a <code>for</code> structure consisted of three expressions, as defined earlier in this chapter, separated by semicolons. C++ loops allow you do to things like the following, however:</p>
<p class="programlisting">for (int i = 0; i &lt; 5; i++)</p>
<p>That is, you can declare a variable in the initialization area of a <code>for</code> loop. This can be convenient, but it doesn&#8217;t fit the original syntax because a declaration is not an expression. This once outlaw behavior was originally accommodated by defining a new kind of <a id="page_203"/>expression, the <em>declaration-statement expression</em>, which was a declaration stripped of the semicolon, and which could appear only in a <code>for</code> statement. That adjustment has been dropped, however. Instead, the syntax for the <code>for</code> statement has been modified to the following:</p>
<p class="programlisting">for (<span class="EmpItalic">for-init-statement condition</span>; <span class="EmpItalic">expression</span>)<br/>&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">statement</span></p>
<p>At first glance, this looks odd because there is just one semicolon instead of two. But that&#8217;s okay because <em><code>for-init-statement</code></em> is identified as a statement, and a statement has its own semicolon. As for <em><code>for-init-statement</code></em>, it&#8217;s identified as either an expression-statement or a declaration. This syntax rule replaces an expression followed by a semicolon with a statement, which has its own semicolon. What this boils down to is that C++ programmers want to be able to declare and initialize a variable in a <code>for</code> loop initialization, and they&#8217;ll do whatever is necessary to C++ syntax and to the English language to make it possible.</p>
<p>There&#8217;s a practical aspect to declaring a variable in <em><code>for-init-statement</code></em> that you should know about. Such a variable exists only within the <code>for</code> statement. That is, after the program leaves the loop, the variable is eliminated:</p>
<p class="programlisting">for (int i = 0; i &lt; 5; i++)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "C++ knows loops.\n";<br/>cout &lt;&lt; i &lt;&lt; endl;&#160;&#160;// oops! i no longer defined</p>
<p>Another thing you should know is that some older C++ implementations follow an earlier rule and treat the preceding loop as if <code>i</code> were declared <em>before</em> the loop, thus making it available after the loop terminates.</p>
<h4 id="ch05lev2sec2">Back to the <code>for</code> Loop</h4>
<p>Let&#8217;s be a bit more ambitious with loops. <a href="#ch05ex04">Listing 5.4</a> uses a loop to calculate and store the first 16 factorials. Factorials, which are handy for computing odds, are calculated the following way. Zero factorial, written as 0!, is defined to be 1. Then, 1! is 1 * 0!, or 1. Next, 2! is 2 * 1!, or 2. Then, 3! is 3 * 2!, or 6, and so on, with the factorial of each integer being the product of that integer with the preceding factorial. (One of the late pianist-comedian Victor Borge&#8217;s best-known monologues featured phonetic punctuation, in which the exclamation mark is pronounced something like phffft pptz, with a moist accent. However, in this case, &#8220;!&#8221; is pronounced &#8220;factorial.&#8221;) The program uses one loop to calculate the values of successive factorials, storing them in an array. Then it uses a second loop to display the results. Also the program introduces the use of external declarations for values.</p>
<p class="caption1"><a id="ch05ex04"/><strong>Listing 5.4. <code>formore.cpp</code></strong></p><hr/>
<p class="programlisting1">// formore.cpp -- more looping with for<br/>#include &lt;iostream&gt;<br/>const int ArSize = 16;&#160;&#160;&#160;&#160;&#160;&#160;// example of external declaration<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;long long factorials[ArSize];<br/>&#160;&#160;&#160;&#160;factorials[1] = factorials[0] = 1LL;<br/>&#160;&#160;&#160;&#160;for (int i = 2; i &lt; ArSize; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;factorials[i] = i * factorials[i-1];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; ArSize; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; i &lt;&lt; "! = " &lt;&lt; factorials[i] &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_204"/>Here is the output from the program in <a href="#ch05ex04">Listing 5.4</a>:</p>
<p class="programlisting">0! = 1<br/>1! = 1<br/>2! = 2<br/>3! = 6<br/>4! = 24<br/>5! = 120<br/>6! = 720<br/>7! = 5040<br/>8! = 40320<br/>9! = 362880<br/>10! = 3628800<br/>11! = 39916800<br/>12! = 479001600<br/>13! = 6227020800<br/>14! = 87178291200<br/>15! = 1307674368000</p>
<p>Factorials get big fast!</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note03"/>Note</p>
<p class="notepara">This listing uses the <code>long long</code> type. If your system doesn&#8217;t have that type available, you can use <code>double</code>. However, the integer format gives a nicer visual representation of how the numbers grow larger.</p>
<hr/></div>
<h5 id="ch05lev3sec4">Program Notes</h5>
<p>The program in <a href="#ch05ex04">Listing 5.4</a> creates an array to hold the factorial values. Element 0 is 0!, element 1 is 1!, and so on. Because the first two factorials equal 1, the program sets the first two elements of the <code>factorials</code> array to 1.0. (Remember, the first element of an array has an index value of 0.) After that, the program uses a loop to set each factorial to the product of the index with the previous factorial. The loop illustrates that you can use the loop counter as a variable in the body of the loop.</p>
<p>The program in <a href="#ch05ex04">Listing 5.4</a> demonstrates how the <code>for</code> loop works hand-in-hand with arrays by providing a convenient means to access each array member in turn. Also <code>formore.cpp</code> uses <code>const</code> to create a symbolic representation (<code>ArSize</code>) for the array size. Then it uses <code>ArSize</code> wherever the array size comes into play, such as in the array <a id="page_205"/>definition and in the limits for the loops handling the array. Now, if you wish to extend the program to, say, 20 factorials, you just have to set <code>ArSize</code> to 20 in the program and recompile. By using a symbolic constant, you avoid having to change every occurrence of 16 to 20 individually.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note04"/>Tip</p>
<p class="notepara">It&#8217;s usually a good idea to define a <code>const</code> value to represent the number of elements in an array. You can use the <code>const</code> value in the array declaration and in all other references to the array size, such as in a <code>for</code> loop.</p>
<hr/></div>
<p>The limit <code>expression i &lt; ArSize</code> reflects the fact that subscripts for an array with <code>ArSize</code> elements run from <code>0</code> to <code>ArSize - 1</code>, so the array index should stop one short of <code>ArSize</code>. You could use the test <code>i &lt;= ArSize - 1</code> instead, but it looks awkward in comparison.</p>
<p>Note that the program declares the <code>const int</code> variable <code>ArSize</code> outside the body of <code>main()</code>. As the end of <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; mentions, this makes <code>ArSize</code> external data. The two consequences of declaring <code>ArSize</code> in this fashion are that <code>ArSize</code> exists for the duration of the program and that all functions in the program file can use it. In this particular case, the program has just one function, so declaring <code>ArSize</code> externally has little practical effect. But multifunction programs often benefit from sharing external constants, so we&#8217;ll practice using them next.</p>
<p>Also this example reminds us that we can use <code>std::</code> instead of a <code>using</code> directive to make selected standard names available.</p>
<h4 id="ch05lev2sec3">Changing the Step Size</h4>
<p>So far the loop examples in this chapter have increased or decreased the loop counter by one in each cycle. You can change that by changing the update expression. The program in <a href="#ch05ex05">Listing 5.5</a>, for example, increases the loop counter by a user-selected step size. Rather than use <code>i++</code> as the update expression, it uses the expression <code>i = i + by</code>, where <code>by</code> is the user-selected step size.</p>
<p class="caption1"><a id="ch05ex05"/><strong>Listing 5.5. <code>bigstep.cpp</code></strong></p><hr/>
<p class="programlisting1">// bigstep.cpp -- count as directed<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/><br/>&#160;&#160;&#160;&#160;using std::cout;&#160;&#160;&#160;// a using declaration<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter an integer: ";<br/>&#160;&#160;&#160;&#160;int by;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; by;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Counting by " &lt;&lt; by &lt;&lt; "s:\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 100; i = i + by)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_206"/>Here is a sample run of the program in <a href="#ch05ex05">Listing 5.5</a>:</p>
<p class="programlisting">Enter an integer: <span class="EmpStrong">17</span><br/>Counting by 17s:<br/>0<br/>17<br/>34<br/>51<br/>68<br/>85</p>
<p>When <code>i</code> reaches the value 102, the loop quits. The main point here is that the update expression can be any valid expression. For example, if you want to square <code>i</code> and add <code>10</code> in each cycle, you can use <code>i = i * i + 10</code>.</p>
<p>Another point to note is that it often is a better idea to test for inequality than equality. For example, the test <code>i == 100</code> would have failed in this case because <code>i</code> skips over the value <code>100</code>.</p>
<p>Finally, this example illustrates the use of <code>using</code> declarations instead of a <code>using</code> directive.</p>
<h4 id="ch05lev2sec4">Inside Strings with the <code>for</code> Loop</h4>
<p>The <code>for</code> loop provides a direct way to access each character in a string in turn. For example, <a href="#ch05ex06">Listing 5.6</a> enables you to enter a string and then displays the string character-by-character, in reverse order. You could use either a <code>string</code> class object or an array of <code>char</code> in this example because both allow you to use array notation to access individual characters in a string; <a href="#ch05ex06">Listing 5.6</a> uses a <code>string</code> class object. The <code>string</code> class <code>size()</code> method yields the number of characters in the string; the loop uses that value in its initializing expression to set <code>i</code> to the index of the last character in the string, not counting the null character. To count backward, the program uses the decrement operator (<code>--</code>) to decrease the array subscript by one in each loop. Also <a href="#ch05ex06">Listing 5.6</a> uses the greater-than-or-equal-to relational operator (<code>&gt;=</code>) to test whether the loop has reached the first element. We&#8217;ll summarize all the relational operators soon.</p>
<p class="caption1"><a id="ch05ex06"/><strong>Listing 5.6. <code>forstr1.cpp</code></strong></p><hr/>
<p class="programlisting1">// forstr1.cpp -- using for with a string<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a word: ";<br/>&#160;&#160;&#160;&#160;string word;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; word;<br/><br/>&#160;&#160;&#160;&#160;// display letters in reverse order<br/>&#160;&#160;&#160;&#160;for (int i = word.size() - 1; i &gt;= 0; i--)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; word[i];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nBye.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_207"/>Here is a sample run of the program in <a href="#ch05ex06">Listing 5.6</a>:</p>
<p class="programlisting">Enter a word: <span class="EmpStrong">animal</span><br/>lamina<br/>Bye.</p>
<p>Yes, the program succeeds in printing <code>animal</code> backward; choosing <code>animal</code> as a test word more clearly illustrates the effect of this program than choosing, say, a palindrome such as <code>rotator</code>, <code>redder,</code> or <code>stats</code>.</p>
<h4 id="ch05lev2sec5">The Increment (<code>++</code>) and Decrement (<code>--</code>) Operators</h4>
<p>C++ features several operators that are frequently used in loops; let&#8217;s take a little time to examine them now. You&#8217;ve already seen two: the increment operator (<code>++</code>), which inspired the name C++, and the decrement operator (<code>--</code>). These operators perform two exceedingly common loop operations: increasing and decreasing a loop counter by one. However, there&#8217;s more to their story than you&#8217;ve seen to this point. Each operator comes in two varieties. The <em>prefix</em> version comes before the operand, as in <code>++x</code>. The <em>postfix</em> version comes after the operand, as in <code>x++</code>. The two versions have the same effect on the operand, but they differ in terms of when they take place. It&#8217;s like getting paid for mowing the lawn in advance or afterward; both methods have the same final effect on your wallet, but they differ in when the money gets added. <a href="#ch05ex07">Listing 5.7</a> demonstrates this difference for the increment operator.</p>
<p class="caption1"><a id="ch05ex07"/><strong>Listing 5.7. <code>plus_one.cpp</code></strong></p><hr/>
<p class="programlisting1">// plus_one.cpp -- the increment operator<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/><br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;int a = 20;<br/>&#160;&#160;&#160;&#160;int b = 20;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a&#160;&#160;&#160;= " &lt;&lt; a &lt;&lt; ":&#160;&#160;&#160;b = " &lt;&lt; b &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a++ = " &lt;&lt; a++ &lt;&lt; ": ++b = " &lt;&lt; ++b &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "a&#160;&#160;&#160;= " &lt;&lt; a &lt;&lt; ":&#160;&#160;&#160;b = " &lt;&lt; b &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_208"/>Here is the output from the program in <a href="#ch05ex07">Listing 5.7</a>:</p>
<p class="programlisting">a&#160;&#160;&#160;&#160;&#160;= 20:&#160;&#160;&#160;b = 20<br/>a++&#160;&#160;&#160;= 20: ++b = 21<br/>a&#160;&#160;&#160;&#160;&#160;= 21:&#160;&#160;&#160;b = 21</p>
<p>Roughly speaking, the notation <code>a++</code> means &#8220;use the current value of <code>a</code> in evaluating an expression, and then increment the value of <code>a</code>.&#8221; Similarly, the notation <code>++b</code> means &#8220;first increment the value of <code>b</code> and then use the new value in evaluating the expression.&#8221; For example, we have the following relationships:</p>
<p class="programlisting">int x = 5;<br/>int y = ++x;&#160;&#160;&#160;&#160;&#160;&#160;// change x, then assign to y<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// y is 6, x is 6<br/><br/>int z = 5;<br/>int y = z++;&#160;&#160;&#160;&#160;&#160;&#160;// assign to y, then change z<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// y is 5, z is 6</p>
<p>Using the increment and decrement operators is a concise, convenient way to handle the common task of increasing or decreasing values by one.</p>
<p>The increment and decrement operators are nifty little operators, but don&#8217;t get carried away and increment or decrement the same value more than once in the same statement. The problem is that the use-then-change and change-then-use rules can become ambiguous. That is, a statement such as the following can produce quite different results on different systems:</p>
<p class="programlisting">x = 2 * x++ * (3 - ++x);&#160;&#160;&#160;&#160;// don't do it except as an experiment</p>
<p>C++ does not define correct behavior for this sort of statement.</p>
<h4 id="ch05lev2sec6">Side Effects and Sequence Points</h4>
<p>Let&#8217;s take a closer look at what C++ does and doesn&#8217;t say about when increment operators take effect. First, recall that a <em>side effect</em> is an effect that occurs when evaluating an expression modifies something, such as a value stored in a variable. A <em>sequence point</em> is a point in program execution at which all side effects are guaranteed to be evaluated before going on to the next step. In C++ the semicolon in a statement marks a sequence point. That means all changes made by assignment operators, increment operators, and decrement operators in a statement must take place before a program proceeds to the next statement. Some operators that we&#8217;ll discuss in later chapters have sequence points. Also the end of any full expression is a sequence point.</p>
<p><a id="page_209"/>What&#8217;s a full expression? It&#8217;s an expression that&#8217;s not a subexpression of a larger expression. Examples of full expressions include an expression portion of an expression statement and an expression that serves as a test condition for a <code>while</code> loop.</p>
<p>Sequence points help clarify when postfix incrementation takes place. Consider, for instance, the following code:</p>
<p class="programlisting">while (guests++ &lt; 10)<br/>&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; guests &lt;&lt; endl;</p>
<p>(The <code>while</code> loop, discussed later this chapter, works like a <code>for</code> loop that has just a test expression.) Sometimes C++ newcomers assume that &#8220;use the value, then increment it&#8221; means, in this context, to increment <code>guests</code> after it&#8217;s used in the <code>cout</code> statement. However, the <code>guests++ &lt; 10</code> expression is a full expression because it is a <code>while</code> loop test condition, so the end of this expression is a sequence point. Therefore, C++ guarantees that the side effect (incrementing <code>guests</code>) takes place before the program moves on to <code>cout</code>. Using the postfix form, however, guarantees that <code>guests</code> will be incremented after the comparison to <code>10</code> is made.</p>
<p>Now consider this statement:</p>
<p class="programlisting">y = (4 + x++) + (6 + x++);</p>
<p>The expression <code>4 + x++</code> is not a full expression, so C++ does not guarantee that <code>x</code> will be incremented immediately after the subexpression <code>4 + x++</code> is evaluated. Here the full expression is the entire assignment statement, and the semicolon marks the sequence point, so all that C++ guarantees is that <code>x</code> will have been incremented twice by the time the program moves to the following statement. C++ does not specify whether <code>x</code> is incremented after each subexpression is evaluated or only after all the expressions have been evaluated, which is why you should avoid statements of this kind.</p>
<p>C++11 documentation has dropped the term &#8220;sequence point&#8221; because the concept doesn&#8217;t carry over well when discussing multiple threads of execution. Instead, descriptions are framed in terms of sequencing, with some events being described as being sequenced before other events. This descriptive approach isn&#8217;t intended to change the rules; the goal is to provide language that can more clearly handle multithreaded programming.</p>
<h4 id="ch05lev2sec7">Prefixing Versus Postfixing</h4>
<p>Clearly, whether you use the prefix or postfix form makes a difference if the value is used for some purpose, such as a function argument or assigning to a variable. But what if the value of an increment or decrement expression isn&#8217;t used? For example, are</p>
<p class="programlisting">x++;</p>
<p>and</p>
<p class="programlisting">++x;</p>
<p>different from one another? Or are</p>
<p class="programlisting">for (n = lim; n &gt; 0; --n)<br/><a id="page_210"/>&#160;&#160;&#160;&#160;...;</p>
<p>and</p>
<p class="programlisting">for (n = lim; n &gt; 0; n--)<br/>&#160;&#160;&#160;&#160;...;</p>
<p>different from one another?</p>
<p>Logically, whether the prefix or postfix forms are used makes no difference in these two situations. The values of the expressions aren&#8217;t used, so the only effects are the side effects. Here the expressions using the operators are full expressions, so the side effects of incrementing <code>x</code> and decrementing <code>n</code> are guaranteed to be performed by the time the program moves on to the next step; the prefix form and postfix form lead to the same final result.</p>
<p>However, although the choice between prefix and postfix forms has no effect on the program&#8217;s behavior, it is possible for the choice to have a small effect on execution speed. For built-in types and modern compilers, this seems to be a non issue. But C++ lets you define these operators for classes. In that case, the user defines a prefix function that works by incrementing a value and then returning it. But the postfix version works by first stashing a copy of the value, incrementing the value, and then returning the stashed copy. Thus, for classes, the prefix version is a bit more efficient than the postfix version.</p>
<p>In short, for built-in types, it most likely makes no difference which form you use. For user-defined types having user-defined increment and decrement operators, the prefix form is more efficient.</p>
<h4 id="ch05lev2sec8">The Increment/Decrement Operators and Pointers</h4>
<p>You can use increment operators with pointers as well as with basic variables. Recall that adding an increment operator to a pointer increases its value by the number of bytes in the type it points to. The same rule holds for incrementing and decrementing pointers:</p>
<p class="programlisting">double arr[5] = {21.1, 32.8, 23.4, 45.2, 37.4};<br/>double *pt = arr;&#160;&#160;// pt points to arr[0], i.e. to 21.1<br/>++pt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pt points to arr[1], i.e. to 32.8</p>
<p>You can also use these operators to change the quantity a pointer points to by using them in conjunction with the <code>*</code> operator. Applying both <code>*</code> and <code>++</code> to a pointer raises the questions of what gets dereferenced and what gets incremented. Those actions are determined by the placement and precedence of the operators. The prefix increment, prefix decrement, and dereferencing operators all have the same precedence and associate from right to left. The postfix increment and decrement operators both have the same precedence, which is higher than the prefix precedence. These two operators associate from left to right.</p>
<p>The right-to-left association rule for prefix operators implies that <code>*++pt</code> means first apply <code>++</code> to <code>pt</code> (because the <code>++</code> is to the right of the <code>*</code>) and then apply <code>*</code> to the new value of <code>pt</code>:</p>
<p class="programlisting">double x = *++pt;&#160;&#160;// increment pointer, take the value; i.e., arr[2], or 23.4</p>
<p><a id="page_211"/>On the other hand, <code>++*pt</code> means obtain the value that <code>pt</code> points to and then increment that value:</p>
<p class="programlisting">++*pt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// increment the pointed to value; i.e., change 23.4 to 24.4</p>
<p>Here, <code>pt</code> remains pointing to <code>arr[2]</code>.</p>
<p>Next, consider this combination:</p>
<p class="programlisting">(*pt)++;&#160;&#160;&#160;&#160;&#160;// increment pointed-to value</p>
<p>The parentheses indicate that first the pointer is dereferenced, yielding <code>24.4</code>. Then the <code>++</code> operator increments that value to <code>25.4</code>; <code>pt</code> remains pointing at <code>arr[2]</code>.</p>
<p>Finally, consider this combination:</p>
<p class="programlisting">x = *pt++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// dereference original location, then increment pointer</p>
<p>The higher precedence of the postfix <code>++</code> operator means the <code>++</code> operator operates on <code>pt</code>, not on <code>*pt</code>, so the pointer is incremented. But the fact that the postfix operator is used means that the address that gets dereferenced is the original address, <code>&#38;arr[2]</code>, not the new address. Thus, the value of <code>*pt++</code> is <code>arr[2]</code>, or <code>25.4</code>, but the value of <code>pt</code> after the statement completes is the address of <code>arr[3]</code>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note05"/>Note</p>
<p class="notepara">Incrementing and decrementing pointers follow pointer arithmetic rules. Thus, if <code>pt</code> points to the first member of an array, <code>++pt</code> changes <code>pt</code> so that it points to the second member.</p>
<hr/></div>
<h4 id="ch05lev2sec9">Combination Assignment Operators</h4>
<p><a href="#ch05ex05">Listing 5.5</a> uses the following expression to update a loop counter:</p>
<p class="programlisting">i = i + by</p>
<p>C++ has a combined addition and assignment operator that accomplishes the same result more concisely:</p>
<p class="programlisting">i += by</p>
<p>The <code>+=</code> operator adds the values of its two operands and assigns the result to the operand on the left. This implies that the left operand must be something to which you can assign a value, such as a variable, an array element, a structure member, or data you identify by dereferencing a pointer:</p>
<p class="programlisting">int k = 5;<br/>k += 3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok, k set to 8<br/>int *pa = new int[10];&#160;&#160;&#160;// pa points to pa[0]<br/>pa[4] = 12;<br/>pa[4] += 6;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok, pa[4] set to 18<br/>*(pa + 4) += 7;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok, pa[4] set to 25<br/>pa += 2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok, pa points to the former pa[2]<br/>34 += 10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// quite wrong</p>
<p><a id="page_212"/>Each arithmetic operator has a corresponding assignment operator, as summarized in <a href="#ch05table01">Table 5.1</a>. Each operator works analogously to <code>+=</code>. Thus, for example, the following statement replaces the current value of <code>k</code> with a value 10 times greater:</p>
<p class="programlisting">k *= 10;</p>
<p class="caption"><a id="ch05table01"/><strong>Table 5.1. Combined Assignment Operators</strong></p>
<p class="image"><img src="graphics/05tab01.jpg" alt="Image"/></p>
<h4 id="ch05lev2sec10">Compound Statements, or Blocks</h4>
<p>The format, or syntax, for writing a C++ <code>for</code> statement might seem restrictive to you because the body of the loop must be a single statement. That&#8217;s awkward if you want the loop body to contain several statements. Fortunately, C++ provides a syntax loophole through which you may stuff as many statements as you like into a loop body. The trick is to use paired braces to construct a <em>compound statement</em>, or <em>block</em>. The block consists of paired braces and the statements they enclose and, for the purposes of syntax, counts as a single statement. For example, the program in <a href="#ch05ex08">Listing 5.8</a> uses braces to combine three separate statements into a single block. This enables the body of the loop to prompt the user, read input, and do a calculation. The program calculates the running sum of the numbers you enter, and this provides a natural occasion for using the <code>+=</code> operator.</p>
<p class="caption1"><a id="ch05ex08"/><strong>Listing 5.8. <code>block.cpp</code></strong></p><hr/>
<p class="programlisting1">// block.cpp -- use a block statement<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The Amazing Accounto will sum and average ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "five numbers for you.\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter five values:\n";<br/>&#160;&#160;&#160;&#160;double number;<br/>&#160;&#160;&#160;&#160;double sum = 0.0;<br/>&#160;&#160;&#160;&#160;for (int i = 1; i &lt;= 5; i++)<br/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// block starts here<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Value " &lt;&lt; i &lt;&lt; ": ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; number;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum += number;<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// block ends here<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Five exquisite choices indeed! ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "They sum to " &lt;&lt; sum &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "and average to " &lt;&lt; sum / 5 &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The Amazing Accounto bids you adieu!\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_213"/>Here is a sample run of the program in <a href="#ch05ex08">Listing 5.8</a>:</p>
<p class="programlisting">The Amazing Accounto will sum and average five numbers for you.<br/>Please enter five values:<br/>Value 1: <span class="EmpStrong">1942</span><br/>Value 2: <span class="EmpStrong">1948</span><br/>Value 3: <span class="EmpStrong">1957</span><br/>Value 4: <span class="EmpStrong">1974</span><br/>Value 5: <span class="EmpStrong">1980</span><br/>Five exquisite choices indeed! They sum to 9801<br/>and average to 1960.2.<br/>The Amazing Accounto bids you adieu!</p>
<p>Suppose you leave in the indentation but omit the braces:</p>
<p class="programlisting">for (int i = 1; i &lt;= 5; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Value " &lt;&lt; i &lt;&lt; ": ";&#160;&#160;&#160;&#160;&#160;&#160;// loop ends here<br/>&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; number;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// after the loop<br/>&#160;&#160;&#160;&#160;&#160;&#160;sum += number;<br/>cout &lt;&lt; "Five exquisite choices indeed! ";</p>
<p>The compiler ignores indentation, so only the first statement would be in the loop. Thus, the loop would print the five prompts and do nothing more. After the loop completes, the program moves to the following lines, reading and summing just one number.</p>
<p>Compound statements have another interesting property. If you define a new variable inside a block, the variable persists only as long as the program is executing statements within the block. When execution leaves the block, the variable is deallocated. That means the variable is known only within the block:</p>
<p class="programlisting">#include&#160;&#160;&lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int x = 20;<br/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// block starts<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int y = 100;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;&#160;&#160;// ok<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; y &lt;&lt; endl;&#160;&#160;// ok<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// block ends<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;// ok<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; y &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;// invalid, won't compile<br/>&#160;&#160;&#160;&#160;return 0;</p>
<p><a id="page_214"/>Note that a variable defined in an outer block is still defined in the inner block.</p>
<p>What happens if you declare a variable in a block that has the same name as one outside the block? The new variable hides the old one from its point of appearance until the end of the block. Then the old one becomes visible again, as in this example:</p>
<p class="programlisting">#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;int x = 20;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// original x<br/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// block starts<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;&#160;&#160;// use original x<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int x = 100;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// new x<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;&#160;&#160;// use new x<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// block ends<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;// use original x<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<h4 id="ch05lev2sec11">More Syntax Tricks&#8212;The Comma Operator</h4>
<p>As you have seen, a block enables you to sneak two or more statements into a place where C++ syntax allows just one statement. The comma operator does the same for expressions, enabling you to sneak two expressions into a place where C++ syntax allows only one expression. For example, suppose you have a loop in which one variable increases by one each cycle and a second variable decreases by one each cycle. Doing both in the update part of a <code>for</code> loop control section would be convenient, but the loop syntax allows just one expression there. The solution is to use the comma operator to combine the two expressions into one:</p>
<p class="programlisting">++j, --i&#160;&#160;&#160;// two expressions count as one for syntax purposes</p>
<p>The comma is not always a comma operator. For example, the comma in this declaration serves to separate adjacent names in a list of variables:</p>
<p class="programlisting">int i, j;&#160;&#160;// comma is a separator here, not an operator</p>
<p><a href="#ch05ex09">Listing 5.9</a> uses the comma operator twice in a program that reverses the contents of a <code>string</code> class object. (You could also write the program by using an array of <code>char</code>, but the length of the word would be limited by your choice of array size.) Note that <a href="#ch05ex06">Listing 5.6</a> displays the contents of an array in reverse order, but <a href="#ch05ex09">Listing 5.9</a> actually moves characters around in the array. The program in <a href="#ch05ex09">Listing 5.9</a> also uses a block to group several statements into one.</p>
<p class="caption1"><a id="page_215"/><a id="ch05ex09"/><strong>Listing 5.9. <code>forstr2.cpp</code></strong></p><hr/>
<p class="programlisting1">// forstr2.cpp -- reversing an array<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a word: ";<br/>&#160;&#160;&#160;&#160;string word;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; word;<br/><br/>&#160;&#160;&#160;&#160;// physically modify string object<br/>&#160;&#160;&#160;&#160;char temp;<br/>&#160;&#160;&#160;&#160;int i, j;<br/>&#160;&#160;&#160;&#160;for (j = 0, i = word.size() - 1; j &lt; i; --i, ++j)<br/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start block<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp = word[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;word[i] = word[j];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;word[j] = temp;<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// end block<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; word &lt;&lt; "\nDone\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch05ex09">Listing 5.9</a>:</p>
<p class="programlisting">Enter a word: <span class="EmpStrong">stressed</span><br/>desserts<br/>Done</p>
<p>By the way, the <code>string</code> class offers more concise ways to reverse a string, but we&#8217;ll leave those for <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library.&#8221;</p>
<h5 id="ch05lev3sec5">Program Notes</h5>
<p>Look at the <code>for</code> control section of the program in <a href="#ch05ex09">Listing 5.9</a>. First, it uses the comma operator to squeeze two initializations into one expression for the first part of the control section. Then it uses the comma operator again to combine two updates into a single expression for the last part of the control section.</p>
<p>Next, look at the body. The program uses braces to combine several statements into a single unit. In the body, the program reverses the word by switching the first element of the array with the last element. Then it increments <code>j</code> and decrements <code>i</code> so that they now refer to the next-to-the-first element and the next-to-the-last element. After this is done, the program swaps those elements. Note that the test condition <code>j&lt;i</code> makes the loop stop when it reaches the center of the array. If it were to continue past that point, it would begin swapping the switched elements back to their original positions (see <a href="#ch05fig02">Figure 5.2</a>).</p>
<p class="caption"><a id="page_216"/><a id="ch05fig02"/><strong>Figure 5.2. Reversing a string.</strong></p>
<p class="image"><img src="graphics/05fig02.jpg" alt="Image"/></p>
<p>Another thing to note is the location for declaring the variables <code>temp</code>, <code>i</code>, and <code>j</code>. The code declares <code>i</code> and <code>j</code> before the loop because you can&#8217;t combine two declarations with a comma operator. That&#8217;s because declarations already use the comma for another purpose&#8212;separating items in a list. You can use a single declaration-statement expression to create and initialize two variables, but it&#8217;s a bit confusing visually:</p>
<p class="programlisting">int j = 0, i = word.size() - 1;</p>
<p>In this case the comma is just a list separator, not the comma operator, so the expression declares and initializes both <code>j</code> and <code>i</code>. However, it looks as if it declares only <code>j</code>.</p>
<p>Incidentally, you can declare <code>temp</code> inside the <code>for</code> loop:</p>
<p class="programlisting">int temp = word[i];</p>
<p>This may result in <code>temp</code> being allocated and deallocated in each loop cycle. This might be a bit slower than declaring <code>temp</code> once before the loop. On the other hand, after the loop is finished, <code>temp</code> is discarded if it&#8217;s declared inside the loop.</p>
<h5 id="ch05lev3sec6">Comma Operator Tidbits</h5>
<p>By far the most common use for the comma operator is to fit two or more expressions into a single <code>for</code> loop expression. But C++ does provide the operator with two additional properties. First, it guarantees that the first expression is evaluated before the second <a id="page_217"/>expression. (In other words, the comma operator is a sequence point.) Expressions such as the following are safe:</p>
<p class="programlisting">i = 20, j = 2 * i&#160;&#160;&#160;&#160;&#160;&#160;// i set to 20, then j set to 40</p>
<p>Second, C++ states that the value of a comma expression is the value of the second part of the expression. The value of the preceding expression, for example, is 40 because that is the value of <code>j = 2 * i</code>.</p>
<p>The comma operator has the lowest precedence of any operator. For example, this statement:</p>
<p class="programlisting">cata = 17,240;</p>
<p>gets read as this:</p>
<p class="programlisting">(cats = 17), 240;</p>
<p>That is, <code>cats</code> is set to <code>17</code>, and <code>240</code> does nothing. But because parentheses have high precedence, the following results in <code>cats</code> being set to <code>240</code>, the value of the expression on the right of the comma:</p>
<p class="programlisting">cats = (17,240);</p>
<h4 id="ch05lev2sec12">Relational Expressions</h4>
<p>Computers are more than relentless number crunchers. They have the capability to compare values, and this capability is the foundation of computer decision making. In C++ relational operators embody this ability. C++ provides six relational operators to compare numbers. Because characters are represented by their ASCII codes, you can use these operators with characters, too. They don&#8217;t work with C-style strings, but they do work with <code>string</code> class objects. Each relational expression reduces to the <code>bool</code> value <code>true</code> if the comparison is true and to the <code>bool</code> value <code>false</code> if the comparison is false, so these operators are well suited for use in a loop test expression. (Older implementations evaluate true relational expressions to <code>1</code> and false relational expressions to <code>0</code>.) <a href="#ch05table02">Table 5.2</a> summarizes these operators.</p>
<p class="caption"><a id="ch05table02"/><strong>Table 5.2. Relational Operators</strong></p>
<p class="image"><img src="graphics/05tab02.jpg" alt="Image"/></p>
<p><a id="page_218"/>The six relational operators exhaust the comparisons C++ enables you to make for numbers. If you want to compare two values to see which is the more beautiful or the luckier, you must look elsewhere.</p>
<p>Here are some sample tests:</p>
<p class="programlisting">for (x = 20; x &gt; 5; x--) // continue while x is greater than 5<br/>for (x = 1; y != x; ++x) // continue while y is not equal to x<br/>for (cin &gt;&gt; x; x == 0; cin &gt;&gt; x))&#160;&#160;&#160;&#160;// continue while x is 0</p>
<p>The relational operators have a lower precedence than the arithmetic operators. That means this expression:</p>
<p class="programlisting">x + 3 &gt; y - 2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Expression 1</p>
<p>corresponds to this:</p>
<p class="programlisting">(x + 3) &gt; (y - 2)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Expression 2</p>
<p>and not to the following:</p>
<p class="programlisting">x + (3 &gt; y) - 2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Expression 3</p>
<p>Because the expression <code>(3 &gt; y)</code> is either <code>1</code> or <code>0</code> after the <code>bool</code> value is promoted to <code>int</code>, Expressions 2 and 3 are both valid. But most of us would want Expression 1 to mean Expression 2, and that is what C++ does.</p>
<h4 id="ch05lev2sec13">Assignment, Comparison, and a Mistake You&#8217;ll Probably Make</h4>
<p>Don&#8217;t confuse testing the is-equal-to operator (<code>==</code>) with the assignment operator (<code>=</code>). This expression asks the musical question &#8220;Is <code>musicians</code> equal to 4?&#8221;:</p>
<p class="programlistingB">musicians == 4&#160;&#160;&#160;&#160;// comparison</p>
<p>The expression has the value <code>true</code> or <code>false</code>. This expression assigns the value <code>4</code> to <code>musicians</code>:</p>
<p class="programlisting">musicians = 4&#160;&#160;&#160;&#160;&#160;// assignment</p>
<p>The whole expression, in this case, has the value <code>4</code> because that&#8217;s the value of the left side.</p>
<p>The flexible design of the <code>for</code> loop creates an interesting opportunity for error. If you accidentally drop an equals sign (<code>=</code>) from the <code>==</code> operator and use an assignment expression instead of a relational expression for the test part of a <code>for</code> loop, you still produce valid code. That&#8217;s because you can use any valid C++ expression for a <code>for</code> loop test condition. Remember that nonzero values test as <code>true</code>, and zero tests as <code>false</code>. An expression that assigns <code>4</code> to <code>musicians</code> has the value <code>4</code> and is treated as <code>true</code>. If you come from a language, such as Pascal or BASIC, that uses <code>=</code> to test for equality, you might be particularly prone to this slip.</p>
<p><a href="#ch05ex10">Listing 5.10</a> shows a situation in which you can make this sort of error. The program attempts to examine an array of quiz scores and stops when it reaches the first score that&#8217;s not 20. It shows a loop that correctly uses comparison and then one that mistakenly uses assignment in the test condition. The program also has another egregious design error that <a id="page_219"/>you&#8217;ll see how to fix later. (You learn from your mistakes, and <a href="#ch05ex10">Listing 5.10</a> is happy to help in that respect.)</p>
<p class="caption1"><a id="ch05ex10"/><strong>Listing 5.10. <code>equal.cpp</code></strong></p><hr/>
<p class="programlisting1">// equal.cpp -- equality vs assignment<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int quizscores[10] =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ 20, 20, 20, 20, 20, 19, 20, 18, 20, 20};<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Doing it right:\n";<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; quizscores[i] == 20; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "quiz " &lt;&lt; i &lt;&lt; " is a 20\n";<br/>// Warning: you may prefer reading about this program<br/>// to actually running it.<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Doing it dangerously wrong:\n";<br/>&#160;&#160;&#160;&#160;for (i = 0; quizscores[i] = 20; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "quiz " &lt;&lt; i &lt;&lt; " is a 20\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Because the program in <a href="#ch05ex10">Listing 5.10</a> has a serious problem, you might prefer reading about it to actually running it. Here is some sample output from the program:</p>
<p class="programlisting">Doing it right:<br/>quiz 0 is a 20<br/>quiz 1 is a 20<br/>quiz 2 is a 20<br/>quiz 3 is a 20<br/>quiz 4 is a 20<br/>Doing it dangerously wrong:<br/>quiz 0 is a 20<br/>quiz 1 is a 20<br/>quiz 2 is a 20<br/>quiz 3 is a 20<br/>quiz 4 is a 20<br/>quiz 5 is a 20<br/>quiz 6 is a 20<br/>quiz 7 is a 20<br/>quiz 8 is a 20<br/>quiz 9 is a 20<br/>quiz 10 is a 20<br/><a id="page_220"/>quiz 11 is a 20<br/>quiz 12 is a 20<br/>quiz 13 is a 20<br/>...</p>
<p>The first loop correctly halts after displaying the first five quiz scores. But the second starts by displaying the whole array. Worse than that, it says every value is 20. And worse still, it doesn&#8217;t stop at the end of the array! And worst of all, the program can (although not necessarily) freeze other applications running at the time and require a computer reboot.</p>
<p>Where things go wrong, of course, is with the following test expression:</p>
<p class="programlisting">quizscores[i] = 20</p>
<p>First, simply because it assigns a nonzero value to the array element, the expression is always nonzero, hence always true. Second, because the expression assigns values to the array elements, it actually changes the data. Third, because the test expression remains true, the program continues changing data beyond the end of the array. It just keeps putting more and more 20s into memory! This is not good.</p>
<p>The difficulty with this kind of error is that the code is syntactically correct, so the compiler won&#8217;t tag it as an error. (However, years and years of C and C++ programmers making this error has eventually led many compilers to issue a warning, asking if that&#8217;s what you really meant to do.)</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note06"/>Caution</p>
<p class="notepara">Don&#8217;t use <code>=</code> to compare for equality; use <code>==</code>.</p>
<hr/></div>
<p>Like C, C++ grants you more freedom than most programming languages. This comes at the cost of requiring greater responsibility on your part. Nothing but your own good planning prevents a program from going beyond the bounds of a standard C++ array. However, with C++ classes, you can design a protected array type that prevents this sort of nonsense. <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a href="ch13.html#ch13">Class Inheritance</a>,&#8221; provides an example. For now, you should build the protection into your programs when you need it. For example, the loop in <a href="#ch05ex10">Listing 5.10</a> should include a test that keeps it from going past the last member. That&#8217;s true even for the &#8220;good&#8221; loop. If all the scores were 20s, the &#8220;good&#8221; loop, too, would exceed the array bounds. In short, the loop needs to test the values of the array and the array index. <a href="ch06.html#ch06">Chapter 6</a> shows how to use logical operators to combine two such tests into a single condition.</p>
<h4 id="ch05lev2sec14">Comparing C-Style Strings</h4>
<p>Suppose you want to see if a string in a character array is the word <code>mate</code>. If <code>word</code> is the array name, the following test might not do what you think it should do:</p>
<p class="programlisting">word == "mate"</p>
<p>Remember that the name of an array is a synonym for its address. Similarly, a quoted string constant is a synonym for its address. Thus, the preceding relational expression <a id="page_221"/>doesn&#8217;t test whether the strings are the same; it checks whether they are stored at the same address. The answer to that is no, even if the two strings have the same characters.</p>
<p>Because C++ handles C-style strings as addresses, you get little satisfaction if you try to use the relational operators to compare strings. Instead, you can go to the C-style string library and use the <code>strcmp()</code> function to compare strings. This function takes two string addresses as arguments. That means the arguments can be pointers, string constants, or character array names. If the two strings are identical, the function returns the value <code>0</code>. If the first string precedes the second alphabetically, <code>strcmp()</code> returns a negative value, and if the first string follows the second alphabetically, <code>strcmp()</code> returns a positive value. Actually, &#8220;in the system collating sequence&#8221; is more accurate than &#8220;alphabetically.&#8221; This means that characters are compared according to the system code for characters. For example, in ASCII code, uppercase letters have smaller codes than the lowercase letters, so uppercase precedes lowercase in the collating sequence. Therefore, the string <code>"Zoo"</code> precedes the string <code>"aviary"</code>. The fact that comparisons are based on code values also means that uppercase and lowercase letters differ, so the string <code>"FOO"</code> is different from the string <code>"foo"</code>.</p>
<p>In some languages, such as BASIC and standard Pascal, strings stored in differently sized arrays are necessarily unequal to each other. But C-style strings are defined by the terminating null character, not by the size of the containing array. This means that two strings can be identical even if they are contained in differently sized arrays:</p>
<p class="programlisting">char big[80] = "Daffy";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// 5 letters plus \0<br/>char little[6] = "Daffy";&#160;&#160;&#160;&#160;&#160;&#160;&#160;// 5 letters plus \0</p>
<p>By the way, although you can&#8217;t use relational operators to compare strings, you can use them to compare characters because characters are actually integer types. Therefore, the following is valid code, at least for the ASCII and Unicode character sets, for displaying the characters of the alphabet:</p>
<p class="programlisting">for (ch = 'a'; ch &lt;= 'z'; ch++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;</p>
<p>The program in <a href="#ch05ex11">Listing 5.11</a> uses <code>strcmp()</code> in the test condition of a <code>for</code> loop. The program displays a word, changes its first letter, displays the word again, and keeps going until <code>strcmp()</code> determines that <code>word</code> is the same as the string <code>"mate"</code>. Note that the listing includes the <code>cstring</code> file because it provides a function prototype for <code>strcmp()</code>.</p>
<p class="caption1"><a id="ch05ex11"/><strong>Listing 5.11. <code>compstr1.cpp</code></strong></p><hr/>
<p class="programlisting1">// compstr1.cpp -- comparing strings using arrays<br/>#include &lt;iostream&gt;<br/>#include &lt;cstring&gt;&#160;&#160;&#160;&#160;&#160;// prototype for strcmp()<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char word[5] = "?ate";<br/><br/>&#160;&#160;&#160;&#160;for (char ch = 'a'; strcmp(word, "mate"); ch++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; word &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;word[0] = ch;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After loop ends, word is " &lt;&lt; word &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_222"/>Here is the output for the program in <a href="#ch05ex11">Listing 5.11</a>:</p>
<p class="programlisting">?ate<br/>aate<br/>bate<br/>cate<br/>date<br/>eate<br/>fate<br/>gate<br/>hate<br/>iate<br/>jate<br/>kate<br/>late<br/>After loop ends, word is mate</p>
<h5 id="ch05lev3sec7">Program Notes</h5>
<p>The program in <a href="#ch05ex11">Listing 5.11</a> has some interesting points. One, of course, is the test. You want the loop to continue as long as <code>word</code> is not <code>mate</code>. That is, you want the test to continue as long as <code>strcmp()</code> says the two strings are not the same. The most obvious test for that is this:</p>
<p class="programlisting">strcmp(word, "mate") != 0&#160;&#160;&#160;&#160;// strings are not the same</p>
<p>This statement has the value <code>1</code> (<code>true</code>) if the strings are unequal and the value <code>0</code> (<code>false</code>) if they are equal. But what about <code>strcmp(word, "mate")</code> by itself? It has a nonzero value (<code>true</code>) if the strings are unequal and the value <code>0</code> (<code>false</code>) if the strings are equal. In essence, the function returns <code>true</code> if the strings are different and <code>false</code> if they are the same. You can use just the function instead of the whole relational expression. This produces the same behavior and involves less typing. Also it&#8217;s the way C and C++ programmers have traditionally used <code>strcmp()</code>.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch05sb01"/>Testing for Equality or Order</p>
<p class="sidebarpara">You can use <code>strcmp()</code> to test C-style strings for equality or order. The following expression is true if <code>str1</code> and <code>str2</code> are identical:</p>
<p class="programlistingB">strcmp(str1,str2) == 0</p>
<p class="sidebarpara">The expressions</p>
<p class="programlistingB">strcmp(str1, str2) != 0</p>
<p class="sidebarpara">and</p>
<p class="programlistingB">strcmp(str1, str2)</p>
<p class="sidebarpara">are true if <code>str1</code> and <code>str2</code> are not identical. The following expression is true if <code>str1</code> precedes <code>str2</code>:</p>
<p class="programlistingB">strcmp(str1,str2) &lt; 0</p>
<p class="sidebarpara">And the following expression is true if <code>str1</code> follows <code>str2</code>:</p>
<p class="programlistingB">strcmp(str1, str2) &gt; 0</p>
<p class="sidebarpara">Thus, the <code>strcmp()</code> function can play the role of the <code>==</code>, <code>!=</code>, <code>&lt;</code>, and <code>&gt;</code> operators, depending on how you set up a test condition.</p>
<hr/></div>
<p><a id="page_223"/>Next, <code>compstr1.cpp</code> uses the increment operator to march the variable <code>ch</code> through the alphabet:</p>
<p class="programlisting">ch++</p>
<p>You can use the increment and decrement operators with character variables because type <code>char</code> really is an integer type, so the operation actually changes the integer code stored in the variable. Also note that using an array index makes it simple to change individual characters in a string:</p>
<p class="programlisting">word[0] = ch;</p>
<h4 id="ch05lev2sec15">Comparing <code>string</code> Class Strings</h4>
<p>Life is a bit simpler if you use <code>string</code> class strings instead of C-style strings because the class design allows you to use relational operators to make the comparisons. This is possible because one can define class functions that &#8220;overload,&#8221; or redefine, operators. <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; discusses how to incorporate this feature into class designs, but from a practical standpoint, all you need to know now is that you can use the relational operators with <code>string</code> class objects. <a href="#ch05ex12">Listing 5.12</a> revises <a href="#ch05ex11">Listing 5.11</a> to use a <code>string</code> object instead of an array of <code>char</code>.</p>
<p class="caption1"><a id="ch05ex12"/><strong>Listing 5.12. <code>compstr2.cpp</code></strong></p><hr/>
<p class="programlisting1">// compstr2.cpp -- comparing strings using arrays<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;&#160;&#160;&#160;&#160;&#160;// string class<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;string word = "?ate";<br/><br/>&#160;&#160;&#160;&#160;for (char ch = 'a'; word != "mate"; ch++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; word &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;word[0] = ch;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After loop ends, word is " &lt;&lt; word &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_224"/>The output from the program in <a href="#ch05ex12">Listing 5.12</a> is the same as that for the program in <a href="#ch05ex11">Listing 5.11</a>.</p>
<h5 id="ch05lev3sec8">Program Notes</h5>
<p>In <a href="#ch05ex12">Listing 5.12</a>, the following test condition uses a relational operator with a <code>string</code> object on the left and a C-style string on the right:</p>
<p class="programlisting">word != "mate"</p>
<p>The way the <code>string</code> class overloads the <code>!=</code> operator allows you to use it as long as at least one of the operands is a <code>string</code> object; the remaining operand can be either a <code>string</code> object or a C-style string.</p>
<p>The <code>string</code> class design allows you to use a <code>string</code> object as a single entity, as in the relational test expression, or as an aggregate object for which you can use array notation to extract individual characters.</p>
<p>As you can see, you can achieve the same results with C-style strings as with <code>string</code> objects, but programming with <code>string</code> objects is simpler and more intuitive.</p>
<p>Finally, unlike most of the <code>for</code> loops you have seen to this point, the last two loops aren&#8217;t counting loops. That is, they don&#8217;t execute a block of statements a specified number of times. Instead, each of these loops watches for a particular circumstance (<code>word</code> being <code>"mate"</code>) to signal that it&#8217;s time to stop. More typically, C++ programs use <code>while</code> loops for this second kind of test, so let&#8217;s examine that form next.</p>
<h3 id="ch05lev1sec2">The <code>while</code> Loop</h3>
<p>The <code>while</code> loop is a <code>for</code> loop stripped of the initialization and update parts; it has just a test condition and a body:</p>
<p class="programlisting">while (<span class="EmpItalic">test-condition</span>)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">body</span></p>
<p>First, a program evaluates the parenthesized <em><code>test-condition</code></em> expression. If the expression evaluates to <code>true</code>, the program executes the statement(s) in the body. As with a <code>for</code> loop, the body consists of a single statement or a block defined by paired braces. After it finishes with the body, the program returns to the test condition and re-evaluates it. If the condition is nonzero, the program executes the body again. This cycle of testing and execution continues until the test condition evaluates to <code>false</code> (see <a href="#ch05fig03">Figure 5.3</a>). Clearly, if <a id="page_225"/>you want the loop to terminate eventually, something within the loop body must do something to affect the <em><code>test-condition</code></em> expression. For example, the loop can increment a variable used in the test condition or read a new value from keyboard input. Like the <code>for</code> loop, the <code>while</code> loop is an entry-condition loop. Thus, if <em><code>test-condition</code></em> evaluates to <code>false</code> at the beginning, the program never executes the body of the loop.</p>
<p class="caption"><a id="ch05fig03"/><strong>Figure 5.3. The structure of <code>while</code> loops.</strong></p>
<p class="image"><img src="graphics/05fig03.jpg" alt="Image"/></p>
<p><a href="#ch05ex13">Listing 5.13</a> puts a <code>while</code> loop to work. The loop cycles through each character in a string and displays the character and its ASCII code. The loop quits when it reaches the null character. This technique of stepping through a string character-by-character until reaching the null character is a standard C++ method for processing C-style strings. Because a string contains its own termination marker, programs often don&#8217;t need explicit information about how long a string is.</p>
<p class="caption1"><a id="ch05ex13"/><strong>Listing 5.13. <code>while.cpp</code></strong></p><hr/>
<p class="programlisting1">// while.cpp -- introducing the while loop<br/>#include &lt;iostream&gt;<br/>const int ArSize = 20;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char name[ArSize];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your first name, please: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; name;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here is your name, verticalized and ASCIIized:\n";<br/>&#160;&#160;&#160;&#160;int i = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start at beginning of string<br/>&#160;&#160;&#160;&#160;while (name[i] != '\0')&#160;&#160;&#160;&#160;&#160;// process to end of string<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; name[i] &lt;&lt; ": " &lt;&lt; int(name[i]) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// don't forget this step<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_226"/>Here is a sample run of the program in <a href="#ch05ex13">Listing 5.13</a>:</p>
<p class="programlisting">Your first name, please: <span class="EmpStrong">Muffy</span><br/>Here is your name, verticalized and ASCIIized:<br/>M: 77<br/>u: 117<br/>f: 102<br/>f: 102<br/>y: 121</p>
<p>(No, verticalized and ASCIIized are not real words or even good would-be words. But they do add an endearing technoid tone to the output.)</p>
<h4 id="ch05lev2sec16">Program Notes</h4>
<p>The <code>while</code> condition in <a href="#ch05ex13">Listing 5.13</a> looks like this:</p>
<p class="programlisting">while (name[i] != '\0')</p>
<p>It tests whether a particular character in the array is the null character. For this test to eventually succeed, the loop body needs to change the value of <code>i</code>. It does so by incrementing <code>i</code> at the end of the loop body. Omitting this step keeps the loop stuck on the same array element, printing the character and its code until you manage to kill the program. Getting such an infinite loop is one of the most common problems with loops. Often you can cause it when you forget to update some value within the loop body.</p>
<p>You can rewrite the <code>while</code> line this way:</p>
<p class="programlisting">while (name[i])</p>
<p>With this change, the program works just as it did before. That&#8217;s because when <code>name[i]</code> is an ordinary character, its value is the character code, which is nonzero, or <code>true</code>. But when <code>name[i]</code> is the null character, its character-code value is <code>0</code>, or <code>false</code>. This notation is more concise (and more commonly used) but less clear than what <a href="#ch05ex13">Listing 5.13</a> uses. Dumb compilers might produce faster code for the second version, but smart compilers produce the same code for both.</p>
<p><a id="page_227"/>To print the ASCII code for a character, the program uses a type cast to convert <code>name[i]</code> to an integer type. Then <code>cout</code> prints the value as an integer rather than interpret it as a character code.</p>
<p>Unlike a C-style string, a <code>string</code> class object doesn&#8217;t use a null character to identify the end of a string, so you can&#8217;t convert <a href="#ch05ex13">Listing 5.13</a> to a <code>string</code> class version merely by replacing the array of <code>char</code> with a <code>string</code> object. <a href="ch16.html#ch16">Chapter 16</a> discusses techniques you can use with a <code>string</code> object to identify the last character.</p>
<h4 id="ch05lev2sec17"><code>for</code> Versus <code>while</code></h4>
<p>In C++ the <code>for</code> and <code>while</code> loops are essentially equivalent. For example, the <code>for</code> loop</p>
<p class="programlisting">for (<span class="EmpItalic">init-expression</span>; <span class="EmpItalic">test-expression</span>; <span class="EmpItalic">update-expression</span>)<br/>{<br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">statement</span>(s)<br/>}</p>
<p>could be rewritten this way:</p>
<p class="programlisting"><span class="EmpItalic">init-expression</span>;<br/>while (<span class="EmpItalic">test-expression</span>)<br/>{<br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">statement(s)</span><br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">update-expression</span>;<br/>}</p>
<p>Similarly, the <code>while</code> loop</p>
<p class="programlisting">while (<span class="EmpItalic">test-expression</span>)<br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">body</span></p>
<p>could be rewritten this way:</p>
<p class="programlisting">for ( ;<span class="EmpItalic">test-expression</span>;)<br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">body</span></p>
<p>This <code>for</code> loop requires three expressions (or, more technically, one statement followed by two expressions), but they can be empty expressions (or statements). Only the two semicolons are mandatory. Incidentally, a missing test expression in a <code>for</code> loop is construed as true, so this loop runs forever:</p>
<p class="programlisting">for ( ; ; )<br/>&#160;&#160;&#160;&#160;<span class="EmpItalic">body</span></p>
<p>Because <code>for</code> loops and <code>while</code> loops are nearly equivalent, the one you use is largely a matter of style. There are three differences. One, as just mentioned, is that an omitted test condition in a <code>for</code> loop is interpreted as <code>true</code>. The second is that you can use the initializing statement in a <code>for</code> loop to declare a variable that is local to the loop; you can&#8217;t do that with a <code>while</code> loop. Finally, there is a slight difference if the body includes a <code>continue</code> statement, which is discussed in <a href="ch06.html#ch06">Chapter 6</a>. Typically, programmers use <code>for</code> loops for <a id="page_228"/>counting loops because the <code>for</code> loop format enables you to place all the relevant information&#8212;initial value, terminating value, and method of updating the counter&#8212;in one place. Programmers most often use <code>while</code> loops when they don&#8217;t know in advance precisely how many times a loop will execute.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note07"/>Tip</p>
<p class="notepara">Keep in mind the following guidelines when you design a loop:</p>
<p class="indenthandingB">&#8226; Identify the condition that terminates loop execution.</p>
<p class="indenthandingB">&#8226; Initialize that condition before the first test.</p>
<p class="indenthandingB">&#8226; Update the condition in each loop cycle before the condition is tested again.</p>
<p class="notepara">One nice thing about <code>for</code> loops is that their structure provides a place to implement these three guidelines, thus helping you to remember to do so. But these guidelines apply to a <code>while</code> loop, too.</p>
<hr/></div>
<div class="sidebar"><hr/>
<p class="title"><a id="ch05sb02"/>Bad Punctuation</p>
<p class="sidebarpara">Both <code>for</code> loops and <code>while</code> loops have bodies that consist of a single statement following the parenthesized expressions. As you&#8217;ve seen, that single statement can be a block, which can contain several statements. Keep in mind that braces, not indentation, define a block. Consider the following loop, for example:</p>
<p class="programlistingB">i = 0;<br/>while (name[i] != '\0')<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; name[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;i++;<br/>cout &lt;&lt; "Done\n";</p>
<p class="sidebarpara">The indentation tells you that the program author intended the <code>i++;</code> statement to be part of the loop body. The absence of braces, however, tells the compiler that the body consists solely of the first <code>cout</code> statement. Thus, the loop keeps printing the first character of the array indefinitely. The program never reaches the <code>i++;</code> statement because it is outside the loop.</p>
<p class="sidebarpara">The following example shows another potential pitfall:</p>
<p class="programlistingB">i = 0;<br/>while (name[i] != '\0');&#160;&#160;&#160;&#160;// problem semicolon<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; name[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;i++;<br/>}<br/>cout &lt;&lt; "Done\n";</p>
<p class="sidebarpara">This time the code gets the braces right, but it also inserts an extra semicolon. Remember, a semicolon terminates a statement, so this semicolon terminates the <code>while</code> loop. In other words, the body of the loop is a <em>null statement</em>&#8212;that is, nothing followed by a semicolon. All the material in braces now comes <em>after</em> the loop and is never reached. Instead, the loop cycles, doing nothing forever. Beware the straggling semicolon.</p>
<hr/></div>
<h4 id="ch05lev2sec18">Just a Moment&#8212;Building a Time-Delay Loop</h4>
<p><a id="page_229"/>Sometimes it&#8217;s useful to build a time delay into a program. For example, you might have encountered programs that flash a message onscreen and then go on to something else before you can read the message. You end up being afraid that you&#8217;ve missed irretrievable information of vital importance. It would be much nicer if the program paused 5 seconds before moving on. The <code>while</code> loop is handy for producing this effect. A technique from the early days of personal computers was to make the computer count for a while to use up time:</p>
<p class="programlisting">long wait = 0;<br/>while (wait &lt; 10000)<br/>&#160;&#160;&#160;&#160;wait++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// counting silently</p>
<p>The problem with this approach is that you have to change the counting limit when you change computer processor speed. Several games written for the original IBM PC, for example, became unmanageably fast when run on its faster successors. And these days a compiler might even deduce that it can just set to <code>wait</code> to <code>1000</code> and skip the loop. A better approach is to let the system clock do the timing for you.</p>
<p>The ANSI C and the C++ libraries have a function to help you do this. The function is called <code>clock()</code>, and it returns the system time elapsed since a program started execution. There are a couple complications, though. First, <code>clock()</code> doesn&#8217;t necessarily return the time in seconds. Second, the function&#8217;s return type might be <code>long</code> on some systems, <code>unsigned long</code> on others, and perhaps some other type on others.</p>
<p>But the <code>ctime</code> header file (<code>time.h</code> on less current implementations) provides solutions to these problems. First, it defines a symbolic constant, <code>CLOCKS_PER_SEC</code>, that equals the number of system time units per second. So dividing the system time by this value yields seconds. Or you can multiply seconds by <code>CLOCKS_PER_SEC</code> to get time in the system units. Second, <code>ctime</code> establishes <code>clock_t</code> as an alias for the <code>clock()</code> return type. (See the sidebar &#8220;<a href="#ch05sb03">Type Aliases</a>,&#8221; later in this chapter.) This means you can declare a variable as type <code>clock_t</code>, and the compiler converts it to <code>long</code> or <code>unsigned int</code> or whatever is the proper type for your system.</p>
<p><a href="#ch05ex14">Listing 5.14</a> shows how to use <code>clock()</code> and the <code>ctime</code> header to create a time-delay loop.</p>
<p class="caption1"><a id="ch05ex14"/><strong>Listing 5.14. <code>waiting.cpp</code></strong></p><hr/>
<p class="programlisting1">// waiting.cpp -- using clock() in a time-delay loop<br/>#include &lt;iostream&gt;<br/>#include &lt;ctime&gt; // describes clock() function, clock_t type<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the delay time, in seconds: ";<br/>&#160;&#160;&#160;&#160;float secs;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; secs;<br/>&#160;&#160;&#160;&#160;clock_t delay = secs * CLOCKS_PER_SEC;&#160;&#160;// convert to clock ticks<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "starting\a\n";<br/>&#160;&#160;&#160;&#160;clock_t start = clock();<br/>&#160;&#160;&#160;&#160;while (clock() - start &lt; delay )&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// wait until time elapses<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// note the semicolon<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "done \a\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_230"/>By calculating the delay time in system units instead of in seconds, the program in <a href="#ch05ex14">Listing 5.14</a> avoids having to convert system time to seconds in each loop cycle.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch05sb03"/>Type Aliases</p>
<p class="sidebarpara">C++ has two ways to establish a new name as an alias for a type. One is to use the preprocessor:</p>
<p class="programlistingB">#define BYTE char // preprocessor replaces BYTE with char</p>
<p class="sidebarpara">The preprocessor then replaces all occurrences of <code>BYTE</code> with <code>char</code> when you compile a program, thus making <code>BYTE</code> an alias for <code>char</code>.</p>
<p class="sidebarpara">The second method is to use the C++ (and C) keyword <code>typedef</code> to create an alias. For example, to make <code>byte</code> an alias for <code>char</code>, you use this:</p>
<p class="programlistingB">typedef char byte;&#160;&#160;&#160;// makes byte an alias for char</p>
<p class="sidebarpara">Here&#8217;s the general form:</p>
<p class="programlistingB">typedef <span class="EmpItalic">typeName aliasName</span>;</p>
<p class="sidebarpara">In other words, if you want <code>aliasName</code> to be an alias for a particular type, you declare <code>aliasName</code> as if it were a variable of that type and then prefix the declaration with the <code>typedef</code> keyword. For example, to make <code>byte_pointer</code> an alias for pointer-to-<code>char</code>, you could declare <code>byte_pointer</code> as a pointer-to-<code>char</code> and then stick <code>typedef</code> in front:</p>
<p class="programlistingB">typedef char * byte_pointer; // pointer to char type</p>
<p class="sidebarpara">You could try something similar with <code>#define</code>, but that wouldn&#8217;t work if you declared a list of variables. For example, consider the following:</p>
<p class="programlistingB">#define FLOAT_POINTER float *<br/>FLOAT_POINTER pa, pb;</p>
<p class="sidebarpara">Preprocessor substitution converts the declaration to this:</p>
<p class="programlistingB">float * pa, pb;&#160;&#160;// pa a pointer to float, pb just a float</p>
<p class="sidebarpara">The <code>typedef</code> approach doesn&#8217;t have that problem. Its ability to handle more complex type aliases makes using <code>typedef</code> a better choice than <code>#define</code>&#8212;and sometimes it is the only choice.</p>
<p class="sidebarpara">Notice that <code>typedef</code> doesn&#8217;t create a new type. It just creates a new name for an old type. If you make <code>word</code> an alias for <code>int</code>, <code>cout</code> treats a type <code>word</code> value as the <code>int</code> it really is.</p>
<hr/></div>
<h3 id="ch05lev1sec3">The <code>do while</code> Loop</h3>
<p><a id="page_231"/>You&#8217;ve now seen the <code>for</code> loop and the <code>while</code> loop. The third C++ loop is the <code>do while</code>. It&#8217;s different from the other two because it&#8217;s an <em>exit-condition</em> loop. That means this devil-may-care loop first executes the body of the loop and only then evaluates the test expression to see whether it should continue looping. If the condition evaluates to <code>false</code>, the loop terminates; otherwise, a new cycle of execution and testing begins. Such a loop always executes at least once because its program flow must pass through the body of the loop before reaching the test. Here&#8217;s the syntax for the <code>do while</code> loop:</p>
<p class="programlisting">do<br/>&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpItalic">body</span><br/>while (test-expression);</p>
<p>The <em><code>body</code></em> portion can be a single statement or a brace-delimited statement block. <a href="#ch05fig04">Figure 5.4</a> summarizes the program flow for <code>do while</code> loops.</p>
<p class="caption"><a id="ch05fig04"/><strong>Figure 5.4. The structure of <code>do while</code> loops.</strong></p>
<p class="image"><img src="graphics/05fig04.jpg" alt="Image"/></p>
<p>Usually, an entry-condition loop is a better choice than an exit-condition loop because the entry-condition loop checks before looping. For example, suppose <a href="#ch05ex13">Listing 5.13</a> used <a id="page_232"/><code>do while</code> instead of <code>while</code>. In that case, the loop would print the null character and its code before finding that it had already reached the end of the string. But sometimes a <code>do while</code> test does make sense. For example, if you&#8217;re requesting user input, the program has to obtain the input before testing it. <a href="#ch05ex15">Listing 5.15</a> shows how to use <code>do while</code> in such a situation.</p>
<p class="caption1"><a id="ch05ex15"/><strong>Listing 5.15. <code>dowhile.cpp</code></strong></p><hr/>
<p class="programlisting1">// dowhile.cpp -- exit-condition loop<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int n;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter numbers in the range 1-10 to find ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "my favorite number\n";<br/>&#160;&#160;&#160;&#160;do<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; n;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// execute body<br/>&#160;&#160;&#160;&#160;} while (n != 7);&#160;&#160;&#160;// then test<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Yes, 7 is my favorite.\n" ;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s a sample run of the program in <a href="#ch05ex15">Listing 5.15</a>:</p>
<p class="programlisting">Enter numbers in the range 1-10 to find my favorite number<br/><span class="EmpStrong">9</span><br/><span class="EmpStrong">4</span><br/><span class="EmpStrong">7</span><br/>Yes, 7 is my favorite.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch05sb04"/>Strange <code>for</code> loops</p>
<p class="sidebarpara">It&#8217;s not terribly common, but you may occasionally see code that resembles the following:</p>
<p class="programlistingB">int I = 0;<br/>for(;;)&#160;&#160;// sometimes called a "forever loop"<br/>{<br/>&#160;&#160;&#160;&#160;I++;<br/>&#160;&#160;&#160;&#160;// do something ...<br/>&#160;&#160;&#160;&#160;if (30 &gt;= I) break;&#160;&#160;&#160;&#160;// if statement and break (Chapter 6)<br/>}</p>
<p class="sidebarpara">Or here is another variation:</p>
<p class="programlistingB">int I = 0;<br/>for(;;I++)<br/>{<br/>&#160;&#160;&#160;&#160;if (30 &gt;= I) break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// do something ...<br/>&#160;}</p>
<p class="sidebarpara">The code relies on the fact that an empty test condition in a <code>for</code> loop is treated as being true. Neither of these examples is easy to read, and neither should be used as a general model of writing a loop. The functionality of the first example can be more clearly expressed in a <code>do while</code> loop:</p>
<p class="programlistingB">int I = 0;<br/>do {<br/>&#160;&#160;&#160;&#160;I++;<br/>&#160;&#160;&#160;&#160;// do something;<br/>while (30 &gt; I);</p>
<p class="sidebarpara">Similarly, the second example can be expressed more clearly as a <code>while</code> loop:</p>
<p class="programlistingB">while (I &lt; 30)<br/>{<br/>&#160;&#160;&#160;&#160;// do something<br/>&#160;&#160;&#160;&#160;I++;<br/>}</p>
<p class="sidebarpara">In general, writing clear, easily understood code is a more useful goal than demonstrating the ability to exploit obscure features of the language.</p>
<hr/></div>
<h3 id="ch05lev1sec4">The Range-Based <code>for</code> Loop (C++11)</h3>
<p><a id="page_233"/>The C++11 adds a new form of loop called the <em>range-based</em> <code>for</code> loop. It simplifies one common loop task&#8212;that of doing something with each element of an array, or, more generally, of one of the container classes, such as <code>vector</code> or <code>array</code>. Here is an example:</p>
<p class="programlisting">double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};<br/>for (double x : prices)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; std::endl;</p>
<p>Here <code>x</code> initially represents the first member of the <code>prices</code> array. After displaying the first element, the loop then cycles <code>x</code> to represent the remaining elements of the array in turn, so this code would print all five members, one per line. In short, this loop displays every value included in the range of the array.</p>
<p>To modify array values, you need a different syntax for the loop variable:</p>
<p class="programlisting">for (double &#38;x : prices)<br/>&#160;&#160;&#160;&#160;x = x * 0.80;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//20% off sale</p>
<p>The <code>&#38;</code> symbol identifies <code>x</code> as a reference variable, a topic we&#8217;ll discuss in <a href="ch08.html#ch08">Chapter 8</a>, &#8220;<a href="ch08.html#ch08">Adventures in Functions</a>.&#8221; The significance here is that this form of declaration allows the subsequent code to modify the array contents, whereas the first form doesn&#8217;t.</p>
<p>The range-based <code>for</code> loop also can be used with initialization lists:</p>
<p class="programlisting">for (int x : {3, 5, 2, 8, 6})<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; x &lt;&lt; " ";<br/>cout &lt;&lt; '\n';</p>
<p><a id="page_234"/>However, this loop likely will be used most often with the various template container classes discussed in <a href="ch16.html#ch16">Chapter 16</a>.</p>
<h3 id="ch05lev1sec5">Loops and Text Input</h3>
<p>Now that you&#8217;ve seen how loops work, let&#8217;s look at one of the most common and important tasks assigned to loops: reading text character-by-character from a file or from the keyboard. For example, you might want to write a program that counts the number of characters, lines, and words in the input. Traditionally, C++, like C, uses the <code>while</code> loop for this sort of task. We&#8217;ll next investigate how that is done. If you already know C, don&#8217;t skim through the following sections too fast. Although the C++ <code>while</code> loop is the same as C&#8217;s, C++&#8217;s I/O facilities are different. This can give the C++ loop a somewhat different look from the C loop. In fact, the <code>cin</code> object supports three distinct modes of single-character input, each with a different user interface. Let&#8217;s look at how to use these choices with <code>while</code> loops.</p>
<h4 id="ch05lev2sec19">Using Unadorned <code>cin</code> for Input</h4>
<p>If a program is going to use a loop to read text input from the keyboard, it has to have some way of knowing when to stop. How can it know when to stop? One way is to choose some special character, sometimes called a <em>sentinel character</em>, to act as a stop sign. For example, <a href="#ch05ex16">Listing 5.16</a> stops reading input when the program encounters a <code>#</code> character. The program counts the number of characters it reads and then echoes them. That is, it redisplays the characters that have been read. (Pressing a keyboard key doesn&#8217;t automatically place a character onscreen; programs have to do that drudge work by echoing the input character. Typically, the operating system handles that task. In this case, both the operating system and the test program echo the input.) When it is finished, the program reports the total number of characters processed. <a href="#ch05ex16">Listing 5.16</a> shows the program.</p>
<p class="caption1"><a id="ch05ex16"/><strong>Listing 5.16. <code>textin1.cpp</code></strong></p><hr/>
<p class="programlisting1">// textin1.cpp -- reading chars with a while loop<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;int count = 0;&#160;&#160;&#160;&#160;&#160;&#160;// use basic input<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter characters; enter # to quit:\n";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// get a character<br/>&#160;&#160;&#160;&#160;while (ch != '#')&#160;&#160;&#160;// test the character<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;&#160;&#160;&#160;&#160;&#160;// echo the character<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++count;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// count the character<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; ch;&#160;&#160;&#160;&#160;&#160;&#160;// get the next character<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; count &lt;&lt; " characters read\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_235"/>Here&#8217;s a sample run of the program in <a href="#ch05ex16">Listing 5.16</a>:</p>
<p class="programlisting">Enter characters; enter # to quit:<br/><span class="EmpStrong">see ken run#really fast</span><br/>seekenrun<br/>9 characters read</p>
<p>Apparently, Ken runs so fast that he obliterates space itself&#8212;or at least the space characters in the input.</p>
<h5 id="ch05lev3sec9">Program Notes</h5>
<p>Note the structure of the program in <a href="#ch05ex16">Listing 5.16</a>. The program reads the first input character before it reaches the loop. That way, the first character can be tested when the program reaches the loop statement. This is important because the first character might be <code>#</code>. Because <code>textin1.cpp</code> uses an entry-condition loop, the program correctly skips the entire loop in that case. And because the variable <code>count</code> was previously set to <code>0</code>, <code>count</code> has the correct value.</p>
<p>Suppose the first character read is not a <code>#</code>. In that case, the program enters the loop, displays the character, increments the count, and reads the next character. This last step is vital. Without it, the loop repeatedly processes the first input character forever. With the last step, the program advances to the next character.</p>
<p>Note that the loop design follows the guidelines mentioned earlier. The condition that terminates the loop is if the last character read is <code>#</code>. That condition is initialized by reading a character before the loop starts. The condition is updated by reading a new character at the end of the loop.</p>
<p>This all sounds reasonable. So why does the program omit the spaces on output? Blame <code>cin</code>. When reading type <code>char</code> values, just as when reading other basic types, <code>cin</code> skips over spaces and newline characters. The spaces in the input are not echoed, so they are not counted.</p>
<p>To further complicate things, the input to <code>cin</code> is buffered. That means the characters you type don&#8217;t get sent to the program until you press Enter. This is why you are able to type characters after the <code>#</code> when running the program in <a href="#ch05ex16">Listing 5.16</a>. After you press Enter, the whole sequence of characters is sent to the program, but the program quits processing the input after it reaches the <code>#</code> character.</p>
<h4 id="ch05lev2sec20"><code>cin.get(char)</code> to the Rescue</h4>
<p>Usually, programs that read input character-by-character need to examine every character, including spaces, tabs, and newlines. The <code>istream</code> class (defined in <code>iostream</code>), to which <code>cin</code> belongs, includes member functions that meet this need. In particular, the member function <code>cin.get(ch)</code> reads the next character, even if it is a space, from the input and <a id="page_236"/>assigns it to the variable <code>ch</code>. By replacing <code>cin&gt;&gt;ch</code> with this function call, you can fix <a href="#ch05ex16">Listing 5.16</a>. <a href="#ch05ex17">Listing 5.17</a> shows the result.</p>
<p class="caption1"><a id="ch05ex17"/><strong>Listing 5.17. <code>textin2.cpp</code></strong></p><hr/>
<p class="programlisting1">// textin2.cpp -- using cin.get(char)<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;int count = 0;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter characters; enter # to quit:\n";<br/>&#160;&#160;&#160;&#160;cin.get(ch);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use the cin.get(ch) function<br/>&#160;&#160;&#160;&#160;while (ch != '#')<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++count;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(ch);&#160;&#160;&#160;&#160;// use it again<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; count &lt;&lt; " characters read\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch05ex17">Listing 5.17</a>:</p>
<p class="programlisting">Enter characters; enter # to quit:<br/><span class="EmpStrong">Did you use a #2 pencil?</span><br/>Did you use a<br/>14 characters read</p>
<p>Now the program echoes and counts every character, including the spaces. Input is still buffered, so it is still possible to type more input than what eventually reaches the program.</p>
<p>If you are familiar with C, this program may strike you as terribly wrong. The <code>cin.get(ch)</code> call places a value in the <code>ch</code> variable, which means it alters the value of the variable. In C you must pass the address of a variable to a function if you want to change the value of that variable. But the call to <code>cin.get()</code> in <a href="#ch05ex17">Listing 5.17</a> passes <code>ch</code>, not <code>&#38;ch</code>. In C, code like this won&#8217;t work. In C++ it can work, provided that the function declares the argument as a <em>reference</em>. The reference type is something that C++ added to C. The <code>iostream</code> header file declares the argument to <code>cin.get(ch)</code> as a reference type, so this function can alter the value of its argument. You&#8217;ll learn the details in <a href="ch08.html#ch08">Chapter 8</a>. Meanwhile, the C mavens among you can relax; ordinarily, argument passing in C++ works just as it does in C. For <code>cin.get(ch)</code>, however, it doesn&#8217;t.</p>
<h4 id="ch05lev2sec21">Which <code>cin.get()</code> Should You Use?</h4>
<p><a id="page_237"/><a href="ch04.html#ch04ex05">Listing 4.5</a> in <a href="ch04.html#ch04">Chapter 4</a> uses this code:</p>
<p class="programlisting">char name[ArSize];<br/>...<br/>cout &lt;&lt; "Enter your name:\n";<br/>cin.get(name, ArSize).get();</p>
<p>The last line is equivalent to two consecutive function calls:</p>
<p class="programlisting">cin.get(name, ArSize);<br/>cin.get();</p>
<p>One version of <code>cin.get()</code> takes two arguments: the array name, which is the address of the string (technically, type <code>char*</code>), and <code>ArSize</code>, which is an integer of type <code>int</code>. (Recall that the name of an array is the address of its first element, so the name of a character array is type <code>char*</code>.) Then the program uses <code>cin.get()</code> with no arguments. And most recently, we&#8217;ve used <code>cin.get()</code> this way:</p>
<p class="programlisting">char ch;<br/>cin.get(ch);</p>
<p>This time <code>cin.get()</code> has one argument, and it is type <code>char</code>.</p>
<p>Once again it is time for those of you familiar with C to get excited or confused. In C if a function takes a pointer-to-<code>char</code> and an <code>int</code> as arguments, you can&#8217;t successfully use the same function with a single argument of a different type. But you can do so in C++ because the language supports an OOP feature called <em>function overloading</em>. Function overloading allows you to create different functions that have the same name, provided that they have different argument lists. If, for example, you use <code>cin.get(name, ArSize)</code> in C++, the compiler finds the version of <code>cin.get()</code> that uses a <code>char*</code> and an <code>int</code> as arguments. But if you use <code>cin.get(ch)</code>, the compiler fetches the version that uses a single type <code>char</code> argument. And if the code provides no arguments, the compiler uses the version of <code>cin.get()</code> that takes no arguments.</p>
<p>Function overloading enables you to use the same name for related functions that perform the same basic task in different ways or for different types. This is another topic awaiting you in <a href="ch08.html#ch08">Chapter 8</a>. Meanwhile, you can get accustomed to function overloading by using the <code>get()</code> examples that come with the <code>istream</code> class. To distinguish between the different function versions, we&#8217;ll include the argument list when referring to them. Thus, <code>cin.get()</code> means the version that takes no arguments, and <code>cin.get(char)</code> means the version that takes one argument.</p>
<h4 id="ch05lev2sec22">The End-of-File Condition</h4>
<p>As <a href="#ch05ex17">Listing 5.17</a> shows, using a symbol such as <code>#</code> to signal the end of input is not always satisfactory because such a symbol might be part of legitimate input. The same is true of other arbitrarily chosen symbols, such as <code>@</code> and <code>%</code>. If the input comes from a file, you can employ a much more powerful technique&#8212;detecting the end-of-file (EOF). C++ input <a id="page_238"/>facilities cooperate with the operating system to detect when input reaches the end of a file and report that information back to a program.</p>
<p>At first glance, reading information from files seems to have little to do with <code>cin</code> and keyboard input, but there are two connections. First, many operating systems, including Unix, Linux, and the Windows Command Prompt mode, support <em>redirection</em>, which enables you to substitute a file for keyboard input. For example, suppose in Windows you have an executable program called <code>gofish.exe</code> and a text file called <code>fishtale</code>. In that case, you can give this command line in the command prompt mode:</p>
<p class="programlisting">gofish &lt;fishtale</p>
<p>This causes the program to take input from the <code>fishtale</code> file instead of from the keyboard. The <code>&lt;</code> symbol is the redirection operator for both Unix and the Windows Command Prompt mode.</p>
<p>Second, many operating systems allow you to simulate the EOF condition from the keyboard. In Unix you do so by pressing Ctrl+D at the beginning of a line. In the Windows Command Prompt mode, you press Ctrl+Z and then press Enter anywhere on the line. Some implementations of C++ support similar behavior even though the underlying operating system doesn&#8217;t. The EOF concept for keyboard entry is actually a legacy of command-line environments. However, Symantec C++ for the Mac imitates Unix and recognizes Ctrl+D as a simulated EOF. Metrowerks Codewarrior recognizes Ctrl+Z in the Macintosh and Windows environments. Microsoft Visual C++, Borland C++ 5.5, and GNU C++ for the PC recognize Ctrl+Z when it&#8217;s the first character on a line, but they require a subsequent Enter. In short, many PC programming environment recognize Ctrl+Z as a simulated EOF, but the exact details (anywhere on a line versus first character on a line, Enter key required or not required) vary.</p>
<p>If your programming environment can test for the EOF, you can use a program similar to <a href="#ch05ex17">Listing 5.17</a> with redirected files and you can use it for keyboard input in which you simulate the EOF. That sounds useful, so let&#8217;s see how it&#8217;s done.</p>
<p>When <code>cin</code> detects the EOF, it sets two bits (the <em>eofbit</em> and the <em>failbit</em>) to <code>1</code>. You can use a member function named <code>eof()</code> to see whether the eofbit has been set; the call <code>cin.eof()</code> returns the <code>bool</code> value <code>true</code> if the EOF has been detected and <code>false</code> otherwise. Similarly, the <code>fail()</code> member function returns <code>true</code> if either the eofbit or the failbit has been set to <code>1</code> and <code>false</code> otherwise. Note that the <code>eof()</code> and <code>fail()</code> methods report the result of the most recent attempt to read; that is, they report on the past rather than look ahead. So a <code>cin.eof()</code> or <code>cin.fail()</code> test should always follow an attempt to read. The design of <a href="#ch05ex18">Listing 5.18</a> reflects this fact. It uses <code>fail()</code> instead of <code>eof()</code> because the former method appears to work with a broader range of implementations.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note08"/>Note</p>
<p class="notepara">Some systems do not support simulated EOF from the keyboard. Other systems support it imperfectly. If you have been using <code>cin.get()</code> to freeze the screen until you can read it, that won&#8217;t work here because detecting the EOF turns off further attempts to read input. <a id="page_239"/>However, you can use a timing loop like that in <a href="#ch05ex14">Listing 5.14</a> to keep the screen visible for a while. Or you can use <code>cin.clear(),</code> as mentioned in <a href="ch06.html#ch06">Chapters 6</a> and <a href="ch17.html#ch17">17</a>, to reset the input stream.</p>
<hr/></div>
<p class="caption1"><a id="ch05ex18"/><strong>Listing 5.18. <code>textin3.cpp</code></strong></p><hr/>
<p class="programlisting1">// textin3.cpp -- reading chars to end of file<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;int count = 0;<br/>&#160;&#160;&#160;&#160;cin.get(ch);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// attempt to read a char<br/>&#160;&#160;&#160;&#160;while (cin.fail() == false)&#160;&#160;// test for EOF<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;&#160;&#160;&#160;&#160;&#160;// echo character<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++count;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(ch);&#160;&#160;&#160;&#160;// attempt to read another char<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; count &lt;&lt; " characters read\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is sample output from the program in <a href="#ch05ex18">Listing 5.18</a>:</p>
<p class="programlisting"><span class="EmpStrong">The green bird sings in the winter.&lt;ENTER&gt;</span><br/>The green bird sings in the winter.<br/><span class="EmpStrong">Yes, but the crow flies in the dawn.&lt;ENTER&gt;</span><br/>Yes, but the crow flies in the dawn.<br/><span class="EmpStrong">&lt;CTRL&gt;+&lt;Z&gt;&lt;ENTER&gt;</span><br/>73 characters read</p>
<p>Because I ran the program on a Windows 7 system, I pressed Ctrl+Z and then Enter to simulate the EOF condition. Unix and Linux users would press Ctrl+D instead. Note that in Unix and Unix-like systems, including Linux and Cygwin, Ctrl+Z suspends execution of the program; the <code>fg</code> command lets execution resume.</p>
<p>By using redirection, you can use the program in <a href="#ch05ex18">Listing 5.18</a> to display a text file and report how many characters it has. This time, we have a program read, echo, and count characters from a two-line file on a Unix system (the <code>$</code> is a Unix prompt):</p>
<p class="programlisting">$ textin3 &lt; stuff<br/>I am a Unix file. I am proud<br/>to be a Unix file.<br/>48 characters read<br/>$</p>
<h5 id="ch05lev3sec10">EOF Ends Input</h5>
<p><a id="page_240"/>Remember that when a <code>cin</code> method detects the EOF, it sets a flag in the <code>cin</code> object, indicating the EOF condition. When this flag is set, <code>cin</code> does not read anymore input, and further calls to <code>cin</code> have no effect. For file input, this makes sense because you shouldn&#8217;t read past the end of a file. For keyboard input, however, you might use a simulated EOF to terminate a loop but then want to read more input later. The <code>cin.clear()</code> method clears the EOF flag and lets input proceed again. <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>,&#8221; discusses this further. Keep in mind, however, that in some systems, typing Ctrl+Z effectively terminates both input and output beyond the powers of <code>cin.clear()</code> to restore them.</p>
<h5 id="ch05lev3sec11">Common Idioms for Character Input</h5>
<p>The following is the essential design of a loop intended to read text a character at a time until EOF:</p>
<p class="programlisting">cin.get(ch);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// attempt to read a char<br/>while (cin.fail() == false)&#160;&#160;// test for EOF<br/>{<br/>&#160;&#160;&#160;&#160;...&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// do stuff<br/>&#160;&#160;&#160;&#160;cin.get(ch);&#160;&#160;&#160;&#160;// attempt to read another char<br/>}</p>
<p>There are some shortcuts you can take with this code. <a href="ch06.html#ch06">Chapter 6</a> introduces the <code>!</code> operator, which toggles <code>true</code> to <code>false</code> and vice versa. You can use it to rewrite the <code>while</code> test to look like this:</p>
<p class="programlisting">while (!cin.fail())&#160;&#160;&#160;&#160;// while input has not failed</p>
<p>The return value for the <code>cin.get(char)</code> method is <code>cin</code>, an object. However, the <code>istream</code> class provides a function that can convert an <code>istream</code> object such as <code>cin</code> to a <code>bool</code> value; this conversion function is called when <code>cin</code> occurs in a location where a <code>bool</code> is expected, such as in the test condition of a <code>while</code> loop. Furthermore, the <code>bool</code> value for the conversion is <code>true</code> if the last attempted read was successful and <code>false</code> otherwise. This means you can rewrite the <code>while</code> test to look like this:</p>
<p class="programlisting">while (cin)&#160;&#160;&#160;&#160;// while input is successful</p>
<p>This is a bit more general than using <code>!cin.fail()</code> or <code>!cin.eof()</code> because it detects other possible causes of failure, such as disk failure.</p>
<p>Finally, because the return value of <code>cin.get(char)</code> is <code>cin</code>, you can condense the loop to this format:</p>
<p class="programlisting">while (cin.get(ch))&#160;&#160;// while input is successful<br/>{<br/>&#160;&#160;&#160;&#160;...&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// do stuff<br/>}</p>
<p>Here, <code>cin.get(char)</code> is called once in the test condition instead of twice&#8212;once before the loop and once at the end of the loop. To evaluate the loop test, the program <a id="page_241"/>first has to execute the call to <code>cin.get(ch)</code>, which, if successful, places a value into <code>ch</code>. Then the program obtains the return value from the function call, which is <code>cin</code>. Then it applies the <code>bool</code> conversion to <code>cin</code>, which yields <code>true</code> if input worked and <code>false</code> otherwise. The three guidelines (identifying the termination condition, initializing the condition, and updating the condition) are all compressed into one loop test condition.</p>
<h4 id="ch05lev2sec23">Yet Another Version of <code>cin.get()</code></h4>
<p>Nostalgic C users might yearn for C&#8217;s character I/O functions, <code>getchar()</code> and <code>putchar()</code>. They are available in C++ if you want them. You just use the <code>stdio.h</code> header file as you would in C (or use the more current <code>cstdio</code>). Or you can use member functions from the <code>istream</code> and <code>ostream</code> classes that work in much the same way. Let&#8217;s look at that approach next.</p>
<p>The <code>cin.get()</code> member function with no arguments returns the next character from the input. That is, you use it in this way:</p>
<p class="programlisting">ch = cin.get();</p>
<p>(Recall that <code>cin.get(ch)</code> returns an object, not the character read.) This function works much the same as C&#8217;s <code>getchar()</code>, returning the character code as a type <code>int</code> value. Similarly, you can use the <code>cout.put()</code> function (see <a href="ch03.html#ch03">Chapter 3</a>, &#8220;<a href="ch03.html#ch03">Dealing with Data</a>&#8221;) to display the character:</p>
<p class="programlisting">cout.put(ch);</p>
<p>It works much like C&#8217;s <code>putchar()</code>, except that its argument should be type <code>char</code> instead of type <code>int</code>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note09"/>Note</p>
<p class="notepara">Originally, the <code>put()</code> member had the single prototype <code>put(char)</code>. You could pass to it an <code>int</code> argument, which would then be type cast to <code>char</code>. The Standard also calls for a single prototype. However, some C++ implementations provide three prototypes: <code>put(char)</code>, <code>put(signed char)</code>, and <code>put(unsigned char)</code>. Using <code>put()</code> with an <code>int</code> argument in these implementations generates an error message because there is more than one choice for converting the <code>int</code>. An explicit type cast, such as <code>cin.put(char(ch))</code>, works for <code>int</code> types.</p>
<hr/></div>
<p>To use <code>cin.get()</code> successfully, you need to know how it handles the EOF condition. When the function reaches the EOF, there are no more characters to be returned. Instead, <code>cin.get()</code> returns a special value, represented by the symbolic constant <code>EOF</code>. This constant is defined in the <code>iostream</code> header file. The <code>EOF</code> value must be different from any valid character value so that the program won&#8217;t confuse <code>EOF</code> with a regular character. Typically, <code>EOF</code> is defined as the value <code>-1</code> because no character has an ASCII code of <code>-1</code>, but you don&#8217;t need to know the actual value. You can just use <code>EOF</code> in a program. For example, the heart of <a href="#ch05ex18">Listing 5.18</a> looks like this:</p>
<p class="programlisting"><a id="page_242"/>char ch;<br/>cin.get(ch);<br/>while (cin.fail() == false)&#160;&#160;// test for EOF<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;++count;<br/>&#160;&#160;&#160;&#160;cin.get(ch);<br/>}</p>
<p>You can use <code>int ch</code>, replace <code>cin.get(char)</code> with <code>cin.get()</code>, replace <code>cout</code> with <code>cout.put()</code>, and replace the <code>cin.fail()</code> test with a test for <code>EOF</code>:</p>
<p class="programlisting">int ch;&#160;&#160;&#160;&#160;&#160;&#160;/// for compatibility with EOF value<br/>ch = cin.get();<br/>while (ch != EOF)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout.put(ch);&#160;&#160;&#160;// cout.put(char(ch)) for some implementations<br/>&#160;&#160;&#160;&#160;&#160;&#160;++count;<br/>&#160;&#160;&#160;&#160;&#160;&#160;ch = cin.get();<br/>}</p>
<p>If <code>ch</code> is a character, the loop displays it. If <code>ch</code> is <code>EOF</code>, the loop terminates.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note10"/>Tip</p>
<p class="notepara">You should realize that <code>EOF</code> does not represent a character in the input. Instead, it&#8217;s a signal that there are no more characters.</p>
<hr/></div>
<p>There&#8217;s a subtle but important point about using <code>cin.get()</code> beyond the changes made so far. Because <code>EOF</code> represents a value outside the valid character codes, it&#8217;s possible that it might not be compatible with the <code>char</code> type. For example, on some systems type <code>char</code> is unsigned, so a <code>char</code> variable could never have the usual <code>EOF</code> value of <code>-1</code>. For this reason, if you use <code>cin.get()</code> (with no argument) and test for <code>EOF</code>, you must assign the return value to type <code>int</code> instead of to type <code>char</code>. Also if you make <code>ch</code> type <code>int</code> instead of type <code>char</code>, you might have to do a type cast to <code>char</code> when displaying <code>ch</code>.</p>
<p><a href="#ch05ex19">Listing 5.19</a> incorporates the <code>cin.get()</code> approach into a new version of <a href="#ch05ex18">Listing 5.18</a>. It also condenses the code by combining character input with the <code>while</code> loop test.</p>
<p class="caption1"><a id="ch05ex19"/><strong>Listing 5.19. <code>textin4.cpp</code></strong></p><hr/>
<p class="programlisting1">// textin4.cpp -- reading chars with cin.get()<br/>#include &lt;iostream&gt;<br/>int main(void)<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;int ch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// should be int, not char<br/>&#160;&#160;&#160;&#160;int count = 0;<br/><br/>&#160;&#160;&#160;&#160;while ((ch = cin.get()) != EOF) // test for end-of-file<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.put(char(ch));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++count;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; count &lt;&lt; " characters read\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch05note11"/><a id="page_243"/>Note</p>
<p class="notepara">Some systems either do not support simulated EOF from the keyboard or support it imperfectly, and that may prevent the example in <a href="#ch05ex19">Listing 5.19</a> from running as described. If you have been using <code>cin.get()</code> to freeze the screen until you can read it, that won&#8217;t work here because detecting the EOF turns off further attempts to read input. However, you can use a timing loop like that in <a href="#ch05ex14">Listing 5.14</a> to keep the screen visible for a while. Or you can use <code>cin.clear(),</code> as described in <a href="ch17.html#ch17">Chapter 17</a>, to reset the input stream.</p>
<hr/></div>
<p>Here&#8217;s a sample run of the program in <a href="#ch05ex19">Listing 5.19</a>:</p>
<p class="programlisting"><span class="EmpStrong">The sullen mackerel sulks in the shadowy shallows.&lt;ENTER&gt;</span><br/>The sullen mackerel sulks in the shadowy shallows.<br/><span class="EmpStrong">Yes, but the blue bird of happiness harbors secrets.&lt;ENTER&gt;</span><br/>Yes, but the blue bird of happiness harbors secrets.<br/><span class="EmpStrong">&lt;CTRL&gt;+&lt;Z&gt;&lt;ENTER&gt;</span><br/>104 characters read</p>
<p>Let&#8217;s analyze the loop condition:</p>
<p class="programlisting">while ((ch = cin.get()) != EOF)</p>
<p>The parentheses that enclose the subexpression <code>ch = cin.get()</code> cause the program to evaluate that expression first. To do the evaluation, the program first has to call the <code>cin.get()</code> function. Next, it assigns the function return value to <code>ch</code>. Because the value of an assignment statement is the value of the left operand, the whole subexpression reduces to the value of <code>ch</code>. If this value is <code>EOF</code>, the loop terminates; otherwise, it continues. The test condition needs all the parentheses. Suppose you leave some parentheses out:</p>
<p class="programlisting">while (ch = cin.get() != EOF)</p>
<p>The <code>!=</code> operator has higher precedence than <code>=</code>, so first the program compares <code>cin.get()</code>&#8217;s return value to <code>EOF</code>. A comparison produces a <code>false</code> or <code>true</code> result; that <code>bool</code> value is converted to <code>0</code> or <code>1</code>, and that&#8217;s the value that gets assigned to <code>ch</code>.</p>
<p>Using <code>cin.get(ch)</code> (with an argument) for input, on the other hand, doesn&#8217;t create any type problems. Remember that the <code>cin.get(char)</code> function doesn&#8217;t assign a special value to <code>ch</code> at the EOF. In fact, it doesn&#8217;t assign anything to <code>ch</code> in that case. <code>ch</code> is never called on to hold a non-<code>char</code> value. <a href="#ch05table03">Table 5.3</a> summarizes the differences between <code>cin.get(char)</code> and <code>cin.get()</code>.</p>
<p class="caption"><a id="page_244"/><a id="ch05table03"/><strong>Table 5.3. <code>cin.get(ch)</code> Versus <code>cin.get()</code></strong></p>
<p class="image"><img src="graphics/05tab03.jpg" alt="Image"/></p>
<p>So which should you use, <code>cin.get()</code> or <code>cin.get(char)</code>? The form with the character argument is integrated more fully into the object approach because its return value is an <code>istream</code> object. This means, for example, that you can chain uses. For example, the following code means read the next input character into <code>ch1</code> and the following input character into <code>ch2</code>:</p>
<p class="programlisting">cin.get(ch1).get(ch2);</p>
<p>This works because the function call <code>cin.get(ch1)</code> returns the <code>cin</code> object, which then acts as the object to which <code>get(ch2)</code> is attached.</p>
<p>Probably the main use for the <code>get()</code> form is to let you make quick-and-dirty conversions from the <code>getchar()</code> and <code>putchar()</code> functions of <code>stdio.h</code> to the <code>cin.get()</code> and <code>cout.put()</code> methods of <code>iostream</code>. You just replace one header file with the other and globally replace <code>getchar()</code> and <code>putchar()</code> with their act-alike method equivalents. (If the old code uses a type <code>int</code> variable for input, you have to make further adjustments if your implementation has multiple prototypes for <code>put()</code>.)</p>
<h3 id="ch05lev1sec6">Nested Loops and Two-Dimensional Arrays</h3>
<p>Earlier in this chapter you saw that the <code>for</code> loop is a natural tool for processing arrays. Now let&#8217;s go a step further and look at how a <code>for</code> loop within a <code>for</code> loop (nested loops) serves to handle two-dimensional arrays.</p>
<p>First, let&#8217;s examine what a two-dimensional array is. The arrays used so far in this chapter are termed <em>one-dimensional arrays</em> because you can visualize each array as a single row of data. You can visualize a two-dimensional array as being more like a table, having both rows and columns of data. You can use a two-dimensional array, for example, to represent quarterly sales figures for six separate districts, with one row of data for each district. Or you can use a two-dimensional array to represent the position of RoboDork on a computerized game board.</p>
<p>C++ doesn&#8217;t provide a special two-dimensional array type. Instead, you create an array for which each element is itself an array. For example, suppose you want to store maximum temperature data for five cities over a 4-year period. In that case, you can declare an array as follows:</p>
<p class="programlisting">int maxtemps[4][5];</p>
<p><a id="page_245"/>This declaration means that <code>maxtemps</code> is an array with four elements. Each of these elements is an array of five integers (see <a href="#ch05fig05">Figure 5.5</a>). You can think of the <code>maxtemps</code> array as representing four rows of five temperature values each.</p>
<p class="caption"><a id="ch05fig05"/><strong>Figure 5.5. An array of arrays.</strong></p>
<p class="image"><img src="graphics/05fig05.jpg" alt="Image"/></p>
<p>The expression <code>maxtemps[0]</code> is the first element of the <code>maxtemps</code> array; hence <code>maxtemps[0]</code> is itself an array of five <code>int</code>s. The first element of the <code>maxtemps[0]</code> array is <code>maxtemps[0][0]</code>, and this element is a single <code>int</code>. Thus, you need to use two subscripts to access the <code>int</code> elements. You can think of the first subscript as representing the row and the second subscript as representing the column (see <a href="#ch05fig06">Figure 5.6</a>).</p>
<p class="caption"><a id="ch05fig06"/><strong>Figure 5.6. Accessing array elements with subscripts.</strong></p>
<p class="image"><img src="graphics/05fig06.jpg" alt="Image"/></p>
<p><a id="page_246"/>Suppose you want to print all the array contents. In that case, you can use one <code>for</code> loop to change rows and a second, nested, <code>for</code> loop to change columns:</p>
<p class="programlisting">for (int row = 0; row &lt; 4; row++)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;for (int col = 0; col &lt; 5; ++col)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; maxtemps[row][col] &lt;&lt; "\t";<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}</p>
<p>For each value of <code>row</code>, the inner <code>for</code> loop cycles through all the <code>col</code> values. This example prints a tab character (<code>\t</code> in C++ escape character notation) after each value and a newline character after each complete row.</p>
<h4 id="ch05lev2sec24">Initializing a Two-Dimensional Array</h4>
<p>When you create a two-dimensional array, you have the option of initializing each element. The technique is based on that for initializing a one-dimensional array. Remember that you do this by providing a comma-separated list of values enclosed in braces:</p>
<p class="programlisting">// initializing a one-dimensional array<br/>int btus[5] = { 23, 26, 24, 31, 28};</p>
<p>For a two-dimensional array, each element is itself an array, so you can initialize each element by using a form like that in the previous code example. Thus, the initialization consists of a comma-separated series of one-dimensional initializations, all enclosed in a set of braces:</p>
<p class="programlisting">int maxtemps[4][5] =&#160;&#160;&#160;// 2-D array<br/>{<br/>&#160;&#160;&#160;&#160;{96, 100, 87, 101, 105},&#160;&#160;&#160;// values for maxtemps[0]<br/>&#160;&#160;&#160;&#160;{96, 98, 91, 107, 104},&#160;&#160;&#160;&#160;// values for maxtemps[1]<br/>&#160;&#160;&#160;&#160;{97, 101, 93, 108, 107},&#160;&#160;&#160;// values for maxtemps[2]<br/>&#160;&#160;&#160;&#160;{98, 103, 95, 109, 108}&#160;&#160;&#160;&#160;// values for maxtemps[3]<br/>};</p>
<p>You can visualize maxtemps as four rows of five numbers each. The term <code>{94, 98, 87, 103, 101}</code> initializes the first row, represented by <code>maxtemps[0]</code>. As a matter of style, placing each row of data on its own line, if possible, makes the data easier to read.</p>
<h4 id="ch05lev2sec25">Using a Two-Dimensional Array</h4>
<p><a href="#ch05ex20">Listing 5.20</a> incorporates an initialized two-dimensional array and a nested loop into a program. This time the program reverses the order of the loops, placing the column loop (city index) on the outside and the row loop (year index) on the inside. Also it uses a <a id="page_247"/>common C++ practice of initializing an array of pointers to a set of string constants. That is, <code>cities</code> is declared as an array of pointers-to-<code>char</code>. That makes each element, such as <code>cities[0]</code>, a pointer-to-<code>char</code> that can be initialized to the address of a string. The program initializes <code>cities[0]</code> to the address of the <code>"Gribble City"</code> string, and so on. Thus, this array of pointers behaves like an array of strings.</p>
<p class="caption1"><a id="ch05ex20"/><strong>Listing 5.20. <code>nested.cpp</code></strong></p><hr/>
<p class="programlisting1">// nested.cpp -- nested loops and 2-D array<br/>#include &lt;iostream&gt;<br/>const int Cities = 5;<br/>const int Years = 4;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;const char * cities[Cities] =&#160;&#160;&#160;// array of pointers<br/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// to 5 strings<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Gribble City",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Gribbletown",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"New Gribble",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"San Gribble",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"Gribble Vista"<br/>&#160;&#160;&#160;&#160;};<br/><br/>&#160;&#160;&#160;&#160;int maxtemps[Years][Cities] =&#160;&#160;&#160;// 2-D array<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{96, 100, 87, 101, 105},&#160;&#160;&#160;// values for maxtemps[0]<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{96, 98, 91, 107, 104},&#160;&#160;&#160;&#160;// values for maxtemps[1]<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{97, 101, 93, 108, 107},&#160;&#160;&#160;// values for maxtemps[2]<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{98, 103, 95, 109, 108}&#160;&#160;&#160;&#160;// values for maxtemps[3]<br/>&#160;&#160;&#160;&#160;};<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Maximum temperatures for 2008 - 2011\n\n";<br/>&#160;&#160;&#160;&#160;for (int city = 0; city &lt; Cities; ++city)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; cities[city] &lt;&lt; ":\t";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int year = 0; year &lt; Years; ++year)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; maxtemps[year][city] &lt;&lt; "\t";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_248"/>Here is the output for the program in <a href="#ch05ex20">Listing 5.20</a>:</p>
<p class="programlisting">Maximum temperatures for 2008 - 2011<br/><br/><br/>Gribble City:&#160;&#160;&#160;96&#160;&#160;&#160;&#160;&#160;&#160;96&#160;&#160;&#160;&#160;&#160;&#160;97&#160;&#160;&#160;&#160;&#160;&#160;98<br/>Gribbletown:&#160;&#160;&#160;&#160;100&#160;&#160;&#160;&#160;&#160;98&#160;&#160;&#160;&#160;&#160;&#160;101&#160;&#160;&#160;&#160;&#160;103<br/>New Gribble:&#160;&#160;&#160;&#160;87&#160;&#160;&#160;&#160;&#160;&#160;91&#160;&#160;&#160;&#160;&#160;&#160;93&#160;&#160;&#160;&#160;&#160;&#160;95<br/>San Gribble:&#160;&#160;&#160;&#160;101&#160;&#160;&#160;&#160;&#160;107&#160;&#160;&#160;&#160;&#160;108&#160;&#160;&#160;&#160;&#160;109<br/>Gribble Vista:&#160;&#160;105&#160;&#160;&#160;&#160;&#160;104&#160;&#160;&#160;&#160;&#160;107&#160;&#160;&#160;&#160;&#160;108</p>
<p>Using tabs in the output spaces the data more regularly than using spaces would. However, different tab settings can cause the output to vary in appearance from one system to another. <a href="ch17.html#ch17">Chapter 17</a> presents more precise, but more complex, methods for formatting output.</p>
<p>More awkwardly, you could use an array of arrays of <code>char</code> instead of an array of pointers for the string data. The declaration would look like this:</p>
<p class="programlisting">char cities[Cities][25] =&#160;&#160;&#160;// array of 5 arrays of 25 char<br/>{<br/>&#160;&#160;&#160;&#160;"Gribble City",<br/>&#160;&#160;&#160;&#160;"Gribbletown",<br/>&#160;&#160;&#160;&#160;"New Gribble",<br/>&#160;&#160;&#160;&#160;"San Gribble",<br/>&#160;&#160;&#160;&#160;"Gribble Vista"<br/>};</p>
<p>This approach limits each of the five strings to a maximum of 24 characters. The array of pointers stores the addresses of the five string literals, but the array of <code>char</code> arrays copies each of the five string literals to the corresponding five arrays of 25 <code>char</code>. Thus, the array of pointers is much more economical in terms of space. However, if you intended to modify any of the strings, the two-dimensional array would be a better choice. Oddly enough, both choices use the same initialization list and the same <code>for</code> loop code to display the strings.</p>
<p>Also you could use an array of <code>string</code> class objects instead of an array of pointers for the string data. The declaration would look like this:</p>
<p class="programlisting">const string cities[Cities] =&#160;&#160;&#160;// array of 5 strings<br/>{<br/>&#160;&#160;&#160;&#160;"Gribble City",<br/>&#160;&#160;&#160;&#160;"Gribbletown",<br/>&#160;&#160;&#160;&#160;"New Gribble",<br/>&#160;&#160;&#160;&#160;"San Gribble",<br/>&#160;&#160;&#160;&#160;"Gribble Vista"<br/>};</p>
<p><a id="page_249"/>If you intended for the strings to be modifiable, you would omit the <code>const</code> qualifier. This form uses the same initializer list and the same <code>for</code> loop display code as the other two forms. If you want modifiable strings, the automatic sizing feature of the <code>string</code> class makes this approach more convenient to use than the two-dimensional array approach.</p>
<h3 id="ch05lev1sec7">Summary</h3>
<p>C++ offers three varieties of loops: <code>for</code> loops, <code>while</code> loops, and <code>do while</code> loops. A loop cycles through the same set of instructions repetitively, as long as the loop test condition evaluates to <code>true</code> or nonzero and the loop terminates execution when the test condition evaluates to <code>false</code> or zero. The <code>for</code> loop and the <code>while</code> loop are entry-condition loops, meaning that they examine the test condition before executing the statements in the body of the loop. The <code>do while</code> loop is an exit-condition loop, meaning that it examines the test condition after executing the statements in the body of the loop.</p>
<p>The syntax for each loop calls for the loop body to consist of a single statement. However, that statement can be a compound statement, or block, formed by enclosing several statements within paired curly braces.</p>
<p>Relational expressions, which compare two values, are often used as loop test conditions. Relational expressions are formed by using one of the six relational operators: <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>&gt;=</code>, <code>&gt;</code>, or <code>!=</code>. Relational expressions evaluate to the type <code>bool</code> values <code>true</code> and <code>false</code>.</p>
<p>Many programs read text input or text files character-by-character. The <code>istream</code> class provides several ways to do this. If <code>ch</code> is a type <code>char</code> variable, the following statement reads the next input character into <code>ch</code>:</p>
<p class="programlisting">cin &gt;&gt; ch;</p>
<p>However, it skips over spaces, newlines, and tabs. The following member function call reads the next input character, regardless of its value, and places it in <code>ch</code>:</p>
<p class="programlisting">cin.get(ch);</p>
<p>The member function call <code>cin.get()</code> returns the next input character, including spaces, newlines, and tabs, so it can be used as follows:</p>
<p class="programlisting">ch = cin.get();</p>
<p>The <code>cin.get(char)</code> member function call reports encountering the EOF condition by returning a value with the <code>bool</code> conversion of <code>false</code>, whereas the <code>cin.get()</code> member function call reports the EOF by returning the value <code>EOF</code>, which is defined in the <code>iostream</code> file.</p>
<p>A nested loop is a loop within a loop. Nested loops provide a natural way to process two-dimensional arrays.</p>
<h3 id="ch05lev1sec8">Chapter Review</h3>
<p class="question"><a id="page_250"/><a id="ch05qa1q1" href="app10.html#ch05qa1a1"><strong>1.</strong></a> What&#8217;s the difference between an entry-condition loop and an exit-condition loop? Which kind is each of the C++ loops?</p>
<p class="question"><a id="ch05qa1q2" href="app10.html#ch05qa1a2"><strong>2.</strong></a> What would the following code fragment print if it were part of a valid program?</p>
<p class="programlistingB">int i;<br/>for (i = 0; i &lt; 5; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i;<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;</p>
<p class="question"><a id="ch05qa1q3" href="app10.html#ch05qa1a3"><strong>3.</strong></a> What would the following code fragment print if it were part of a valid program?</p>
<p class="programlistingB">int j;<br/>for (j = 0; j &lt; 11; j += 3)<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; j;<br/>cout &lt;&lt; endl &lt;&lt; j &lt;&lt; endl;</p>
<p class="question"><a id="ch05qa1q4" href="app10.html#ch05qa1a4"><strong>4.</strong></a> What would the following code fragment print if it were part of a valid program?</p>
<p class="programlistingB">int j = 5;<br/>while ( ++j &lt; 9)<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; j++ &lt;&lt; endl;</p>
<p class="question"><a id="ch05qa1q5" href="app10.html#ch05qa1a5"><strong>5.</strong></a> What would the following code fragment print if it were part of a valid program?</p>
<p class="programlistingB">int k = 8;<br/>do<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt;" k = " &lt;&lt; k &lt;&lt; endl;<br/>while (k++ &lt; 5);</p>
<p class="question"><a id="ch05qa1q6" href="app10.html#ch05qa1a6"><strong>6.</strong></a> Write a <code>for</code> loop that prints the values 1 2 4 8 16 32 64 by increasing the value of a counting variable by a factor of two in each cycle.</p>
<p class="question"><a id="ch05qa1q7" href="app10.html#ch05qa1a7"><strong>7.</strong></a> How do you make a loop body include more than one statement?</p>
<p class="question"><a id="ch05qa1q8" href="app10.html#ch05qa1a8"><strong>8.</strong></a> Is the following statement valid? If not, why not? If so, what does it do?</p>
<p class="programlistingB">int x = (1,024);</p>
<p class="questionp">What about the following?</p>
<p class="programlistingB">int y;<br/>y = 1,024;</p>
<p class="question"><a id="ch05qa1q9" href="app10.html#ch05qa1a9"><strong>9.</strong></a> How does <code>cin&gt;&gt;ch</code> differ from <code>cin.get(ch)</code> and <code>ch=cin.get()</code> in how it views input?</p>
<h3 id="ch05lev1sec9">Programming Exercises</h3>
<p class="question"><a id="page_251"/><a id="ch05qa2q1"/><strong>1.</strong> Write a program that requests the user to enter two integers. The program should then calculate and report the sum of all the integers between and including the two integers. At this point, assume that the smaller integer is entered first. For example, if the user enters <strong><code>2</code></strong> and <strong><code>9</code></strong>, the program should report that the sum of all the integers from 2 through 9 is 44.</p>
<p class="question"><a id="ch05qa2q2"/><strong>2.</strong> Redo <a href="#ch05ex04">Listing 5.4</a> using a type <code>array</code> object instead of a built-in array and type <code>long double</code> instead of <code>long long</code>. Find the value of 100!</p>
<p class="question"><a id="ch05qa2q3"/><strong>3.</strong> Write a program that asks the user to type in numbers. After each entry, the program should report the cumulative sum of the entries to date. The program should terminate when the user enters <strong><code>0</code></strong>.</p>
<p class="question"><a id="ch05qa2q4"/><strong>4.</strong> Daphne invests $100 at 10% simple interest. That is, every year, the investment earns 10% of the original investment, or $10 each and every year:</p>
<p class="questionp">interest = 0.10 &#215; original balance</p>
<p class="questionp">At the same time, Cleo invests $100 at 5% compound interest. That is, interest is 5% of the current balance, including previous additions of interest:</p>
<p class="questionp">interest = 0.05 &#215; current balance</p>
<p class="questionp">Cleo earns 5% of $100 the first year, giving her $105. The next year she earns 5% of $105, or $5.25, and so on. Write a program that finds how many years it takes for the value of Cleo&#8217;s investment to exceed the value of Daphne&#8217;s investment and then displays the value of both investments at that time.</p>
<p class="question"><a id="ch05qa2q5"/><strong>5.</strong> You sell the book <em>C++ for Fools</em>. Write a program that has you enter a year&#8217;s worth of monthly sales (in terms of number of books, not of money). The program should use a loop to prompt you by month, using an array of <code>char *</code> (or an array of <code>string</code> objects, if you prefer) initialized to the month strings and storing the input data in an array of <code>int</code>. Then, the program should find the sum of the array contents and report the total sales for the year.</p>
<p class="question"><a id="ch05qa2q6"/><strong>6.</strong> Do Programming Exercise 5 but use a two-dimensional array to store input for 3 years of monthly sales. Report the total sales for each individual year and for the combined years.</p>
<p class="question"><a id="ch05qa2q7"/><strong>7.</strong> Design a structure called <code>car</code> that holds the following information about an automobile: its make, as a string in a character array or in a <code>string</code> object, and the year it was built, as an integer. Write a program that asks the user how many cars to catalog. The program should then use <code>new</code> to create a dynamic array of that many <code>car</code> structures. Next, it should prompt the user to input the make (which might consist of more than one word) and year information for each structure. Note that this requires some care because it alternates reading strings with numeric data (see <a href="ch04.html#ch04">Chapter 4</a>). <a id="page_252"/>Finally, it should display the contents of each structure. A sample run should look something like the following:</p>
<p class="programlistingB">How many cars do you wish to catalog? <span class="EmpStrong">2</span><br/>Car #1:<br/>Please enter the make: <span class="EmpStrong">Hudson Hornet</span><br/>Please enter the year made: <span class="EmpStrong">1952</span><br/>Car #2:<br/>Please enter the make: <span class="EmpStrong">Kaiser</span><br/>Please enter the year made: <span class="EmpStrong">1951</span><br/>Here is your collection:<br/>1952 Hudson Hornet<br/>1951 Kaiser</p>
<p class="question"><a id="ch05qa2q8"/><strong>8.</strong> Write a program that uses an array of <code>char</code> and a loop to read one word at a time until the word <code>done</code> is entered. The program should then report the number of words entered (not counting <code>done</code>). A sample run could look like this:</p>
<p class="programlistingB">Enter words (to stop, type the word done):<br/><span class="EmpStrong">anteater birthday category dumpster</span><br/><span class="EmpStrong">envy finagle geometry done for sure</span><br/>You entered a total of 7 words.</p>
<p class="questionp">You should include the <code>cstring</code> header file and use the <code>strcmp()</code> function to make the comparison test.</p>
<p class="question"><a id="ch05qa2q9"/><strong>9.</strong> Write a program that matches the description of the program in Programming Exercise 8, but use a <code>string</code> class object instead of an array. Include the <code>string</code> header file and use a relational operator to make the comparison test.</p>
<p class="question1"><a id="ch05qa2q10"/><strong>10.</strong> Write a program using nested loops that asks the user to enter a value for the number of rows to display. It should then display that many rows of asterisks, with one asterisk in the first row, two in the second row, and so on. For each row, the asterisks are preceded by the number of periods needed to make all the rows display a total number of characters equal to the number of rows. A sample run would look like this:</p>
<p class="programlistingB">Enter number of rows: <span class="EmpStrong">5</span><br/>....*<br/>...**<br/>..***<br/>.****<br/>*****</p>
</body>
</html>
