<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>18. Visiting with the New C++ Standard</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch18">18. Visiting with the New C++ Standard</h2>
<p><a id="page_1153"/>In this chapter you&#8217;ll review C++11 features previously covered and then learn about the following:</p>
<p class="indenthandingB">&#8226; Move semantics and rvalue references</p>
<p class="indenthandingB">&#8226; Lambda expressions</p>
<p class="indenthandingB">&#8226; The <code>function</code> wrapper template</p>
<p class="indenthandingB">&#8226; Variadic templates</p>
<p>This chapter concentrates on the new C++11 changes to the C++ language. The book already has covered several C++11 features, and we&#8217;ll begin by reviewing them. Then we&#8217;ll look at some additional features in some detail. Next, we&#8217;ll identify some of the C++11 additions that are beyond the scope of this book. (Given that the C++11 draft is over 80% longer than C++98, we won&#8217;t cover everything.) Finally, we&#8217;ll briefly examine the BOOST library.</p>
<h3 id="ch18lev1sec1">C++11 Features Revisited</h3>
<p>By now you may have lost track of the many C++11 changes we already have encountered. This section reviews them briefly.</p>
<h4 id="ch18lev2sec1">New Types</h4>
<p>C++11 adds the <code>long long</code> and <code>unsigned long long</code> types to support 64-bit integers (or wider) and the <code>char16_t</code> and <code>char32_t</code> types to support 16-bit and 32-bit character representations, respectively. It also adds the &#8220;raw&#8221; string. <a href="ch03.html#ch03">Chapter 3</a>, &#8220;<a href="ch03.html#ch03">Dealing with Data</a>,&#8221; discusses these additions.</p>
<h4 id="ch18lev2sec2">Uniform Initialization</h4>
<p><a id="page_1154"/>C++11 extends the applicability of the brace-enclosed list (<em>list-initialization</em>) so that it can be used with all built-in types and with user-defined types (that is, class objects). The list can be used either with or without the <code>=</code> sign:</p>
<p class="programlisting">int x = {5};<br/>double y {2.75};<br/>short quar[5] {4,5,2,76,1};</p>
<p>Also the list-initialization syntax can be used in <code>new</code> expressions:</p>
<p class="programlisting">int * ar = new int [4] {2,4,6,7};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// C++11</p>
<p>With class objects, a braced list can be used instead of a parenthesized list to invoke a constructor:</p>
<p class="programlisting">class Stump<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int roots;<br/>&#160;&#160;&#160;&#160;double weight;<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;Stump(int r, double w) : roots(r), weight(w) {}<br/>};<br/>Stump s1(3,15.6);&#160;&#160;&#160;&#160;&#160;&#160;// old style<br/>Stump s2{5, 43.4};&#160;&#160;&#160;&#160;&#160;// C++11<br/>Stump s3 = {4, 32.1};&#160;&#160;// C++11</p>
<p>However, if a class has a constructor whose argument is a <code>std::initializer_list</code> template, then only that constructor can use the list-initialization form. Various aspects of list-initialization were discussed in <a href="ch03.html#ch03">Chapters 3</a>, <a href="ch04.html#ch04">4</a>, <a href="ch09.html#ch09">9</a>, <a href="ch10.html#ch10">10</a>, and <a href="ch16.html#ch16">16</a>.</p>
<h5 id="ch18lev3sec1">Narrowing</h5>
<p>The initialization-list syntax provides protection against narrowing&#8212;that is, against assigning a numeric value to a numeric type not capable of holding that value. Ordinary initialization allows you to do things that may or may not make sense:</p>
<p class="programlisting">char c1 = 1.57e27;&#160;&#160;&#160;// double-to-char, undefined behavior<br/>char c2 = 459585821; // int-to-char, undefined behavior</p>
<p>If you use initialization-list syntax, however, the compiler disallows type conversions that attempt to store values in a type &#8220;narrower&#8221; than the value:</p>
<p class="programlisting">char c1 {1.57e27};&#160;&#160;&#160;&#160;// double-to-char, compile-time error<br/>char c2 = {459585821};// int-to-char,out of range, compile-time error</p>
<p>However, conversions to wider types are allowed. Also a conversion to a narrower type is allowed if the value is within the range allowed by the type:</p>
<p class="programlisting"><a id="page_1155"/>char c1 {66};&#160;&#160;&#160;&#160;&#160;// int-to-char, in range, allowed<br/>double c2 = {66}; // int-to-double, allowed</p>
<h5 id="ch18lev3sec2"><code>std::initializer_list</code></h5>
<p>C++11 provides an <code>initializer_list</code> template class (discussed in <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library&#8221;) that can be used as a constructor argument. If a class has such a constructor, the brace syntax can be used only with that constructor. The items in the list should all be of the same type or else be convertible to the same type. The STL containers provide constructors with <code>initializer_list</code> arguments:</p>
<p class="programlisting">vector&lt;int&gt; a1(10);&#160;&#160;&#160;&#160;// uninitialized vector with 10 elements<br/>vector&lt;int&gt; a2{10};&#160;&#160;&#160;&#160;// initializer-list, a2 has 1 element set to 10<br/>vector&lt;int&gt; a3{4,6,1}; // 3 elements set to 4,6,1</p>
<p>The <code>initializer_list</code> header file provides support for this template class. The class has <code>begin()</code> and <code>end()</code> member functions specifying the range of the list. You can use an <code>initializer_list</code> argument for regular functions as well as for constructors:</p>
<p class="programlisting">#include &lt;initializer_list&gt;<br/>double sum(std::initializer_list&lt;double&gt; il);<br/>int main()<br/>{<br/>&#160;&#160;&#160;double total = sum({2.5,3.1,4});&#160;&#160;// 4 converted to 4.0<br/>...<br/>}<br/>double sum(std::initializer_list&lt;double&gt; il)<br/>{<br/>&#160;&#160;&#160;&#160;double tot = 0;<br/>&#160;&#160;&#160;&#160;for (auto p = il.begin(); p !=il.end(); p++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tot += *p;<br/>&#160;&#160;&#160;&#160;return tot;<br/>}</p>
<h4 id="ch18lev2sec3">Declarations</h4>
<p>C++11 implements several features that simplify declarations, particularly for situations arising when templates are used.</p>
<h5 id="ch18lev3sec3"><code>auto</code></h5>
<p>C++11 strips the keyword <code>auto</code> of its former meaning as a storage class specifier (<a href="ch09.html#ch09">Chapter 9</a>, &#8220;<a href="ch09.html#ch09">Memory Models and Namespaces</a>&#8221;) and puts it to use (<a href="ch03.html#ch03">Chapter 3</a>) to implement automatic type deduction, provided that an explicit initializer is given. The compiler sets the type of the variable to the type of the initialization value:</p>
<p class="programlisting">auto maton = 112;&#160;&#160;// maton is type int<br/>auto pt = &#38;maton;&#160;&#160;// pt is type int *<br/>double fm(double, int);<br/>auto pf = fm;&#160;&#160;&#160;&#160;&#160;&#160;// pf is type double (*)(double,int)</p>
<p><a id="page_1156"/>The <code>auto</code> keyword can simplify template declarations too. For example, if <code>il</code> is an object of type <code>std::initializer_list&lt;double&gt;</code>, you can replace</p>
<p class="programlisting">for (std::initializer_list&lt;double&gt;::iterator p = il.begin();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p !=il.end(); p++)</p>
<p>with this:</p>
<p class="programlisting">for (auto p = il.begin(); p !=il.end(); p++)</p>
<h5 id="ch18lev3sec4"><code>decltype</code></h5>
<p>The <code>decltype</code> keyword creates a variable of the type indicated by an expression. The following statement means &#8220;make <code>y</code> the same type as <code>x</code>,&#8221; where <code>x</code> is an expression:</p>
<p class="programlisting">decltype(x) y;</p>
<p>Here are a couple of examples:</p>
<p class="programlisting">double x;<br/>int n;<br/>decltype(x*n) q; // q same type as x*n, i.e., double<br/>decltype(&#38;x) pd; // pd same as &#38;x, i.e., double *</p>
<p>This is particularly useful in template definitions, when the type may not be determined until a specific instantiation is made:</p>
<p class="programlisting">template&lt;typename T, typename U)<br/>void ef(T t, U u)<br/>{<br/>&#160;&#160;&#160;&#160;decltype(T*U) tu;<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>Here, <code>tu</code> is of whatever type results from the operation <code>T*U</code>, assuming that operation is defined. For example, if <code>T</code> is <code>char</code> and <code>U</code> is <code>short</code>, <code>tu</code> would be of type <code>int</code> because of the automatic integer promotions that take place in integer arithmetic.</p>
<p>The workings of <code>decltype</code> are more complicated than those of <code>auto</code>, and the resulting types can be references and can be <code>const</code>-qualified, depending on the expressions used. Here are some more examples:</p>
<p class="programlisting">int j = 3;<br/>int &#38;k = j<br/>const int &#38;n = j;<br/>decltype(n) i1;&#160;&#160;&#160;&#160;&#160;&#160;// i1 type const int &#38;<br/>decltype(j) i2;&#160;&#160;&#160;&#160;&#160;&#160;// i2 type int<br/>decltype((j)) i3;&#160;&#160;&#160;&#160;// i3 type int &#38;<br/>decltype(k + 1) i4;&#160;&#160;// i4 type int</p>
<p>See <a href="ch08.html#ch08">Chapter 8</a>, &#8220;<a href="ch08.html#ch08">Adventures in Functions</a>,&#8221; for the rules that lead to these results.</p>
<h5 id="ch18lev3sec5">Trailing Return Type</h5>
<p><a id="page_1157"/>C++11 introduces a new syntax for declaring functions, one in which the return type comes after the function name and parameter list instead of before them:</p>
<p class="programlisting">double f1(double, int);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// traditional syntax<br/>auto f2(double, int) -&gt; double;&#160;&#160;// new syntax, return type is double</p>
<p>The new syntax may look like a step backwards in readability for the usual function declarations, but it does make it possible to use <code>decltype</code> to specify template function return types:</p>
<p class="programlisting">template&lt;typename T, typename U)<br/>auto eff(T t, U u) -&gt; decltype(T*U)<br/>{<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>The problem that&#8217;s addressed here is that <code>T</code> and <code>U</code> are not in scope before the compiler reads the <code>eff</code> parameter list, so any use of <code>decltype</code> has to come after the parameter list. The new syntax makes that possible.</p>
<h5 id="ch18lev3sec6">Template Aliases: <code>using =</code></h5>
<p>It&#8217;s handy to be able to create aliases for long or complex type identifiers. C++ already had <code>typedef</code> for that purpose:</p>
<p class="programlisting">typedef std::vector&lt;std::string&gt;::iterator itType;</p>
<p>C++11 provides a second syntax (discussed in <a href="ch14.html#ch14">Chapter 14</a>, &#8220;<a href="ch14.html#ch14">Reusing Code in C++</a>&#8221;) for creating aliases:</p>
<p class="programlisting">using itType = std::vector&lt;std::string&gt;::iterator;</p>
<p>The difference is that the new syntax also can be used for partial template specializations, whereas <code>typedef</code> can&#8217;t:</p>
<p class="programlisting">template&lt;typename T&gt;<br/>&#160;&#160;using arr12 = std::array&lt;T,12&gt;;&#160;&#160;// template for multiple aliases</p>
<p>This statement specializes the <code>array&lt;T,int&gt;</code> template by setting the <code>int</code> parameter to <code>12</code>. For instance, consider these declarations:</p>
<p class="programlisting">std::array&lt;double, 12&gt; a1;<br/>std::array&lt;std::string, 12&gt; a2;</p>
<p>They can be replaced with the following:</p>
<p class="programlisting">arr12&lt;double&gt; a1;<br/>arr12(std::string&gt; a2;</p>
<h4 id="ch18lev2sec4"><code>nullptr</code></h4>
<p><a id="page_1158"/>The null pointer is a pointer guaranteed not to point to valid data. Traditionally, C++ has represented this pointer in source code with <code>0</code>, although the internal representation could be different. This raises some problems because it makes <code>0</code> both a pointer constant and an integer constant. As discussed in <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; C++11 introduces the keyword <code>nullptr</code> to represent the null pointer; it is a pointer type and not convertible to an integer type. For backward compatibility, C++ still allows the use of <code>0</code>, and the expression <code>nullptr == 0</code> evaluates as <code>true</code>, but using <code>nullptr</code> instead of <code>0</code> provides better type safety. For example, the value <code>0</code> could be passed to a function accepting an <code>int</code> argument, but the compiler will identify an attempt to pass <code>nullptr</code> to such a function as an error. So, for clarity and added safety, use <code>nullptr</code> if your compiler accepts it.</p>
<h4 id="ch18lev2sec5">Smart Pointers</h4>
<p>A program that uses <code>new</code> to allocate memory from the heap (or free store) should use <code>delete</code> to free that memory when it no longer is needed. Earlier, C++ introduced the <code>auto_ptr</code> smart pointer to help automate the process. Subsequent programming experience, particularly with the STL, indicated that something more sophisticated was needed. Guided by the experience of programmers and by solutions provided by the BOOST library, C++11 deprecates <code>auto_ptr</code> and introduces three new smart pointer types: <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>. <a href="ch16.html#ch16">Chapter 16</a> discusses the first two.</p>
<p>All the new smart pointers have been designed to work with STL containers and with move semantics.</p>
<h4 id="ch18lev2sec6">Exception Specification Changes</h4>
<p>C++ provides a syntax for specifying what exceptions, if any, a function may throw (refer to <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>&#8221;):</p>
<p class="programlisting">void f501(int) throw(bad_dog);&#160;&#160;&#160;&#160;// can throw type bad_dog exception<br/>void f733(long long) throw();&#160;&#160;&#160;&#160;&#160;// doesn't throw an exception</p>
<p>As with <code>auto_ptr</code>, the collective experience of the C++ programming community is that, in practice, exception specifications didn&#8217;t work as well as intended. Thus, the C++11 standard deprecates exception specifications. However, the standards committee felt that there is some value in documenting that a function does not throw an exception, and it added the keyword <code>noexcept</code> for this purpose:</p>
<p class="programlisting">void f875(short, short) noexcept; // doesn't throw an exception</p>
<h4 id="ch18lev2sec7">Scoped Enumerations</h4>
<p>Traditional C++ enumerations provide a way to create named constants. However, they come with a rather low level of type checking. Also the scope for enumeration names is the scope that encloses the enumeration definition, which means that two enumerations <a id="page_1159"/>defined in the same scope must not have enumeration members with the same name. Finally, enumerations may not be completely portable because different implementations may choose to use different underlying types. C++11 introduces a variant of enumerations that addresses these problems. The new form is indicated by using <code>class</code> or <code>struct</code> in the definition:</p>
<p class="programlisting">enum Old1 {yes, no, maybe};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// traditional form<br/>enum class New1 {never, sometimes, often, always}; // new form<br/>enum struct New2 {never, lever, sever};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// new form</p>
<p>The new forms avoid name conflicts by requiring explicit scoping. Thus, you would use <code>New1::never</code> and <code>New2::never</code> to identify those particular enumerations. <a href="ch10.html#ch10">Chapter 10</a>, &#8220;<a href="ch10.html#ch10">Objects and Classes</a>,&#8221; provides more details.</p>
<h4 id="ch18lev2sec8">Class Changes</h4>
<p>C++11 makes several changes to simplify and expand class design. These include ways to allow constructors to call one another and to be inherited, better ways to control method access, and move constructors and assignment operators, all of which will be covered in this chapter. Meanwhile, let&#8217;s review the changes that have been discussed previously.</p>
<h5 id="ch18lev3sec7"><code>explicit</code> Conversion Operators</h5>
<p>One of the exciting aspects in the early days of C++ was the ease with which automatic conversions for classes could be established. One of the realizations that grew as programming experience accumulated was that automatic type conversions could lead to problems in the form of unexpected conversions. C++ then addressed one aspect of the problem by introducing the keyword <code>explicit</code> to suppress automatic conversions invoked by one-argument constructors:</p>
<p class="programlisting">class Plebe<br/>{<br/>&#160;&#160;&#160;&#160;Plebe(int);&#160;&#160;&#160;// automatic int-to-plebe conversion<br/>&#160;&#160;&#160;&#160;explicit Plebe(double);&#160;&#160;// requires explicit use<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>...<br/>Plebe a, b;<br/>a = 5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// implicit conversion, call Plebe(5)<br/>b = 0.5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed<br/>b = Plebe(0.5);&#160;&#160;// explicit conversion</p>
<p>C++11 extends the use of <code>explicit</code> (discussed in <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>&#8221;) so that conversion functions can be treated similarly:</p>
<p class="programlisting">class Plebe<br/>{<br/>...<br/>// conversion functions<br/><a id="page_1160"/>&#160;&#160;&#160;&#160;operator int() const;<br/>&#160;&#160;&#160;&#160;explicit operator double() const;<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>...<br/>Plebe a, b;<br/>int n = a;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// int-to-Plebe automatic conversion<br/>double x = b;&#160;&#160;&#160;&#160;// not allowed<br/>x = double(b);&#160;&#160;&#160;// explicit conversion, allowed</p>
<h5 id="ch18lev3sec8">Member In-Class Initialization</h5>
<p>Many first-time users of C++ have wondered why they can&#8217;t initialize members simply by providing values in the class definition. Now they (and you) can. The syntax looks like this:</p>
<p class="programlisting">class Session<br/>{<br/>&#160;&#160;&#160;&#160;int mem1 = 10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// in-class initialization<br/>&#160;&#160;&#160;&#160;double mem2 {1966.54}; // in-class initialization<br/>&#160;&#160;&#160;&#160;short mem3;<br/>public:<br/>&#160;&#160;&#160;&#160;Session(){}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #1<br/>&#160;&#160;&#160;&#160;Session(short s) : mem3(s) {}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #2<br/>&#160;&#160;&#160;&#160;Session(int n, double d, short s) : mem1(n), mem2(d), mem3(s) {} // #3<br/>...<br/>};</p>
<p>You can use the equal sign or the brace forms of initialization, but not the parenthesized version. The result is the same as if you provided the first two constructors with member initialization list entries for <code>mem1</code> and <code>mem2</code>:</p>
<p class="programlisting">Session() : mem1(10), mem2(1966.54) {}<br/>Session(short s) : mem1(10), mem2(1966.54), mem3(s) {}</p>
<p>Note how using in-class initialization avoids having to duplicate code in the constructors, thus reducing work and the number of opportunities for error and boredom for the programmer.</p>
<p>These default values are overridden by a constructor that supplies values in the member initialization list, so the third constructor overrides the in-class member initialization.</p>
<h4 id="ch18lev2sec9">Template and STL Changes</h4>
<p>C++11 makes several changes extending the usability of templates in general and the Standard Template Library in particular. Some are in the library itself; others relate to ease of use. In this chapter we&#8217;ve already mentioned template aliases and the STL-friendly smart pointers.</p>
<h5 id="ch18lev3sec9">Range-based <code>for</code> Loop</h5>
<p><a id="page_1161"/>The range-based <code>for</code> loop (discussed in <a href="ch05.html#ch05">Chapter 5</a>, &#8220;<a href="ch05.html#ch05">Loops and Relational Expressions</a>,&#8221; and <a href="ch16.html#ch16">Chapter 16</a>) simplifies writing loops for built-in arrays and for classes, such as <code>std::string</code> and the STL containers, that have <code>begin()</code> and <code>end()</code> methods identifying a range. The loop applies the indicated action to each element in the array or container:</p>
<p class="programlisting">double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};<br/>for (double x : prices)<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; x &lt;&lt; std::endl;</p>
<p>Here, <code>x</code> takes on the value of each element in <code>prices</code> in turn. The type of <code>x</code> should match the type of the array element. An easier and safer way of doing this is to use <code>auto</code> to declare <code>x</code>; the compiler will deduce the type from the information in the <code>prices</code> declaration:</p>
<p class="programlisting">double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};<br/>for (auto x : prices)<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; x &lt;&lt; std::endl;</p>
<p>If your intent is to have the loop modify elements of the array or container, use a reference type:</p>
<p class="programlisting">std::vector&lt;int&gt; vi(6);<br/>for (auto &#38; x: vi)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use a reference if loop alters contents<br/>&#160;&#160;&#160;&#160;x = std::rand();</p>
<h5 id="ch18lev3sec10">New STL Containers</h5>
<p>C++11 adds <code>forward_list</code>, <code>unordered_map</code>, <code>unordered_multimap</code>, <code>unordered_set</code>, and <code>unordered_multiset</code> to its collection of STL containers (see <a href="ch16.html#ch16">Chapter 16</a>). The <code>forward_list</code> container is a singly linked list that can be traversed in just one direction; it&#8217;s simpler and more economical of space than the doubly linked <code>list</code> container. The other four containers support implementing hash tables.</p>
<p>C++11 also adds the <code>array</code> template (discussed in <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; and <a href="ch16.html#ch16">Chapter 16</a>), for which one specifies an element type and a fixed number of elements:</p>
<p class="programlisting">std::array&lt;int,360&gt; ar;&#160;&#160;// array of 360 ints</p>
<p>This template class does not satisfy all the usual template requirements. For example, because the size is fixed, you can&#8217;t use any method, such as <code>put_back()</code>, that changes the size of a container. But <code>array</code> does have the <code>begin()</code> and <code>end()</code> methods, which allow you to use many of the range-based STL algorithms with array objects.</p>
<h5 id="ch18lev3sec11">New STL Methods</h5>
<p>C++11 adds <code>cbegin()</code> and <code>cend()</code> to the list of STL methods. Like <code>begin()</code> and <code>end()</code>, the new methods return iterators to the first element and to one past the last element of a container, thus specifying a range encompassing all the elements. In addition, the new <a id="page_1162"/>methods treat the elements as if they were <code>const</code>. Similarly, <code>crbegin()</code> and <code>crend()</code> are <code>const</code> versions of <code>rbegin()</code> and <code>rend()</code>.</p>
<p>More significantly, STL containers now have move constructors and move assignment operators in addition to the traditional copy constructors and regular assignment operators. This chapter describes move semantics later.</p>
<h5 id="ch18lev3sec12"><code>valarray</code> Upgrade</h5>
<p>The <code>valarray</code> template was developed independently of the STL, and its original design precluded using range-based STL algorithms with <code>valarray</code> objects. C++11 adds two functions, <code>begin()</code> and <code>end()</code>, that each take a <code>valarray</code> argument. They return iterators to the first and one past the last element of a <code>valarray</code> object, allowing one to use range-based STL algorithms (see <a href="ch16.html#ch16">Chapter 16</a>).</p>
<h5 id="ch18lev3sec13"><code>export</code> Departs</h5>
<p>C++98 introduced the <code>export</code> keyword in the hopes of creating a way to separate template definitions into interface files containing the prototypes and template declarations and implementation files containing the template function and methods definitions. This proved to be impractical, and C++11 ends that roll for export. However, the Standard retains <code>export</code> as a keyword for possible future use.</p>
<h5 id="ch18lev3sec14">Angle Brackets</h5>
<p>To avoid confusion with the <code>&gt;&gt;</code> operator, C++ required a space between the brackets in nested template declarations:</p>
<p class="programlisting">std::vector&lt;std::list&lt;int&gt; &gt; vl; // &gt;&gt; not ok</p>
<p>C++11 removes that requirement:</p>
<p class="programlisting">std::vector&lt;std::list&lt;int&gt;&gt; vl; //&#160;&#160;&gt;&gt; ok in C++11</p>
<h4 id="ch18lev2sec10">The rvalue Reference</h4>
<p>The traditional C++ reference, now called an <em>lvalue reference</em>, binds an identifier to an lvalue. An lvalue is an expression, such as a variable name or a dereferenced pointer, that represents data for which the program can obtain an address. Originally, an lvalue was one that could appear on the left side of an assignment statement, but the advent of the <code>const</code> modifier allowed for constructs that cannot be assigned to but which are still addressable:</p>
<p class="programlisting">int n;<br/>int * pt = new int;<br/>const int b = 101;&#160;&#160;// can't assign to b, but &#38;b is valid<br/>int &#38; rn = n;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// n identifies datum at address &#38;n<br/>int &#38; rt = *pt;&#160;&#160;&#160;&#160;&#160;// *pt identifies datum at address pt<br/>const int &#38; rb = b; // b identifies const datum at address &#38;b</p>
<p>C++11 adds the rvalue reference (discussed in <a href="ch08.html#ch08">Chapter 8</a>), indicated by using <code>&#38;&#38;,</code> that can bind to rvalues&#8212;that is, values that can appear on the right-hand side of an <a id="page_1163"/>assignment expression but for which one cannot apply the address operator. Examples include literal constants (aside from C-style strings, which evaluate as addresses), expressions such as <code>x+y</code>, and function return values, providing the function does not return a reference:</p>
<p class="programlisting">int x = 10;<br/>int y = 23;<br/>int &#38;&#38; r1 = 13;<br/>int &#38;&#38; r2 = x + y;<br/>double &#38;&#38; r3 = std::sqrt(2.0);</p>
<p>Note that what <code>r2</code> really binds to is the value to which <code>x + y</code> evaluates at that time. That is, <code>r2</code> binds to the value <code>23</code>, and <code>r2</code> is unaffected by subsequent changes to <code>x</code> or <code>y</code>.</p>
<p>Interestingly, binding an rvalue to an rvalue reference results in the value being stored in a location whose address can be taken. That is, although you can&#8217;t apply the <code>&#38;</code> operator to <code>13</code>, you can apply it to <code>r1</code>. This binding of the data to particular addresses is what makes it possible to access the data through the rvalue references.</p>
<p><a href="#ch18ex01">Listing 18.1</a> provides a short example illustrating some of these points about rvalue references.</p>
<p class="caption1"><a id="ch18ex01"/><strong>Listing 18.1. <code>rvref.cpp</code></strong></p><hr/>
<p class="programlisting1">// rvref.cpp -- simple uses of rvalue references<br/>#include &lt;iostream&gt;<br/><br/>inline double f(double tf) {return 5.0*(tf-32.0)/9.0;};<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;double tc = 21.5;<br/>&#160;&#160;&#160;&#160;double &#38;&#38; rd1 = 7.07;<br/>&#160;&#160;&#160;&#160;double &#38;&#38; rd2 = 1.8 * tc + 32.0;<br/>&#160;&#160;&#160;&#160;double &#38;&#38; rd3 = f(rd2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " tc value and address: " &lt;&lt; tc &lt;&lt;", " &lt;&lt; &#38;tc &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "rd1 value and address: " &lt;&lt; rd1 &lt;&lt;", " &lt;&lt; &#38;rd1 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "rd2 value and address: " &lt;&lt; rd2 &lt;&lt;", " &lt;&lt; &#38;rd2 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "rd3 value and address: " &lt;&lt; rd3 &lt;&lt;", " &lt;&lt; &#38;rd3 &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample output:</p>
<p class="programlisting">&#160;tc value and address: 21.5, 002FF744<br/>rd1 value and address: 7.07, 002FF728<br/>rd2 value and address: 70.7, 002FF70C<br/>rd3 value and address: 21.5, 002FF6F0</p>
<p><a id="page_1164"/>One of the main reasons for introducing the rvalue reference is to implement move semantics, the next topic in this chapter.</p>
<h3 id="ch18lev1sec2">Move Semantics and the Rvalue Reference</h3>
<p>Now let&#8217;s move on to topics we haven&#8217;t yet discussed. C++11 enables a technique called <em>move semantics</em>. This raises some questions, such as what are move semantics, how does C++11 enable them, and why do we need them? We&#8217;ll begin with the last question.</p>
<h4 id="ch18lev2sec11">The Need for Move Semantics</h4>
<p>Let&#8217;s look into the copying process as it worked prior to C++11. Suppose we start with something like this:</p>
<p class="programlisting">vector&lt;string&gt; vstr;<br/>// build up a vector of 20,000 strings, each of 1000 characters<br/>...<br/>vector&lt;string&gt; vstr_copy1(vstr);&#160;&#160;// make vstr_copy1 a copy of vstr</p>
<p>Both the <code>vector</code> class and the <code>string</code> class use dynamic memory allocation, so they will have copy constructors defined that use some version of <code>new</code>. To initialize the <code>vstr_copy1</code> object, the <code>vector&lt;string&gt;</code> copy constructor will use <code>new</code> to allocate memory for 20,000 <code>string</code> objects, and each <code>string</code> object, in turn, will call the <code>string</code> copy constructor, which will use <code>new</code> to allocate memory for 1000 characters. Then all 20,000,000 characters will be copied from the memory controlled by <code>vstr</code> to the memory controlled by <code>vstr_copy1</code>. That&#8217;s a lot of work, but if it&#8217;s got to be done, then it&#8217;s got to be done.</p>
<p>But does it &#8220;got to be done?&#8221; There are times when the answer is no. For instance, suppose we have a function that returns a <code>vector&lt;string&gt;</code> object:</p>
<p class="programlisting">vector&lt;string&gt; allcaps(const vector&lt;string&gt; &#38; vs)<br/>{<br/>&#160;&#160;&#160;&#160;vector&lt;string&gt; temp;<br/>// code that stores an all-uppercase version of vs in temp<br/>&#160;&#160;&#160;&#160;return temp;<br/>}</p>
<p>Next, suppose we use it this way:</p>
<p class="programlisting">vector&lt;string&gt; vstr;<br/>// build up a vector of 20,000 strings, each of 1000 characters<br/>vector&lt;string&gt; vstr_copy1(vstr);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #1<br/>vector&lt;string&gt; vstr_copy2(allcaps(vstr));&#160;&#160;&#160;&#160;&#160;// #2</p>
<p>Superficially, statements #1 and #2 are similar; each uses an existing object to initialize a new <code>vector&lt;string&gt;</code> object. If we take this code at face value, <code>allcaps()</code> creates a <code>temp</code> object managing 20,000,000 characters, the <code>vector</code> and <code>string</code> copy constructors go through the effort of creating a 20,000,000-character duplicate, then the program <a id="page_1165"/>deletes the temporary object returned by <code>allcaps()</code>. (A really uninspired compiler could even copy <code>temp</code> to a temporary return object, delete <code>temp</code>, and then delete the return object.) The main point is that a lot of effort is wasted here. Because the temporary object is deleted, wouldn&#8217;t it be better if the compiler could just transfer ownership of the data to <code>vstr_copy2</code>? That is, instead of copying 20,000,000 characters to a new location and then deleting the old location, just leave the characters in place and attach the <code>vstr_copy2</code> label to them. This would be similar to what happens when you move a file from one directory to another: The actual file stays where it is on the hard drive, and just the bookkeeping is altered. Such an approach is called <em>move semantics</em>. Somewhat paradoxically, move semantics actually avoids moving the primary data; it just adjusts the bookkeeping.</p>
<p>To implement move semantics, we need a way to let the compiler know when it needs to do a real copy and when it doesn&#8217;t. Here&#8217;s where the rvalue reference comes into play. We can define two constructors. One, the regular copy constructor, can use the usual <code>const</code> lvalue reference as a parameter. This reference will bind to lvalue arguments, such as <code>vstr</code> in statement #1. The other, called a <em>move constructor</em>, can use an rvalue reference, and it can bind to rvalue arguments, such as the return value of <code>allcaps(vstr)</code> in statement #2. The copy constructor can do the usual deep copy, while the move constructor can just adjust the bookkeeping. A move constructor may alter its argument in the process of transferring ownership to a new object, and this implies that an rvalue reference parameter should not be <code>const</code>.</p>
<h4 id="ch18lev2sec12">A Move Example</h4>
<p>Let&#8217;s look at an example to see how move semantics and rvalue references work. <a href="#ch18ex02">Listing 18.2</a> defines and uses the <code>Useless</code> class, which incorporates dynamic memory allocation, a regular copy constructor, and a move constructor, which uses move semantics and an rvalue reference. In order to illustrate the processes involved, the constructors and destructor are unusually verbose, and the class uses a state variable to keep track of the number of objects. Also some important methods, such as the assignment operator, are omitted. (Despite these omissions, the <code>Useless</code> class should not be confused with the eco-friendly <code>Use_Less</code> class.)</p>
<p class="caption1"><a id="ch18ex02"/><strong>Listing 18.2. <code>useless.cpp</code></strong></p><hr/>
<p class="programlisting1">// useless.cpp -- an otherwise useless class with move semantics<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>// interface<br/>class Useless<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int n;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// number of elements<br/>&#160;&#160;&#160;&#160;char * pc;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to data<br/>&#160;&#160;&#160;&#160;static int ct;&#160;&#160;// number of objects<br/><a id="page_1166"/>&#160;&#160;&#160;&#160;void ShowObject() const;<br/>public:<br/>&#160;&#160;&#160;&#160;Useless();<br/>&#160;&#160;&#160;&#160;explicit Useless(int k);<br/>&#160;&#160;&#160;&#160;Useless(int k, char ch);<br/>&#160;&#160;&#160;&#160;Useless(const Useless &#38; f); // regular copy constructor<br/>&#160;&#160;&#160;&#160;Useless(Useless &#38;&#38; f);&#160;&#160;&#160;&#160;&#160;&#160;// move constructor<br/>&#160;&#160;&#160;&#160;~Useless();<br/>&#160;&#160;&#160;&#160;Useless operator+(const Useless &#38; f)const;<br/>// need operator=() in copy and move versions<br/>&#160;&#160;&#160;&#160;void ShowData() const;<br/>};<br/><br/>// implementation<br/>int Useless::ct = 0;<br/><br/>Useless::Useless()<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;n = 0;<br/>&#160;&#160;&#160;&#160;pc = nullptr;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "default constructor called; number of objects: " &lt;&lt; ct &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;ShowObject();<br/>}<br/><br/>Useless::Useless(int k) : n(k)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "int constructor called; number of objects: " &lt;&lt; ct &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>&#160;&#160;&#160;&#160;ShowObject();<br/>}<br/><br/>Useless::Useless(int k, char ch) : n(k)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "int, char constructor called; number of objects: " &lt;&lt; ct<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pc[i] = ch;<br/>&#160;&#160;&#160;&#160;ShowObject();<br/>}<br/><br/>Useless::Useless(const Useless &#38; f): n(f.n)<br/>{<br/><a id="page_1167"/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "copy const called; number of objects: " &lt;&lt; ct &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pc[i] = f.pc[i];<br/>&#160;&#160;&#160;&#160;ShowObject();<br/>}<br/><br/>Useless::Useless(Useless &#38;&#38; f): n(f.n)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "move constructor called; number of objects: " &lt;&lt; ct &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;pc = f.pc;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// steal address<br/>&#160;&#160;&#160;&#160;f.pc = nullptr;&#160;&#160;// give old object nothing in return<br/>&#160;&#160;&#160;&#160;f.n = 0;<br/>&#160;&#160;&#160;&#160;ShowObject();<br/>}<br/><br/>Useless::~Useless()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "destructor called; objects left: " &lt;&lt; --ct &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "deleted object:\n";<br/>&#160;&#160;&#160;&#160;ShowObject();<br/>&#160;&#160;&#160;&#160;delete [] pc;<br/>}<br/><br/>Useless Useless::operator+(const Useless &#38; f)const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Entering operator+()\n";<br/>&#160;&#160;&#160;&#160;Useless temp = Useless(n + f.n);<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp.pc[i] = pc[i];<br/>&#160;&#160;&#160;&#160;for (int i = n; i &lt; temp.n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp.pc[i] = f.pc[i - n];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "temp object:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Leaving operator+()\n";<br/>&#160;&#160;&#160;&#160;return temp;<br/>}<br/><br/>void Useless::ShowObject() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Number of elements: " &lt;&lt; n;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " Data address: " &lt;&lt; (void *) pc &lt;&lt; endl;<br/>}<br/><br/>void Useless::ShowData() const<br/>{<br/>&#160;&#160;&#160;&#160;if (n == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "(object empty)";<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pc[i];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>}<br/><br/>// application<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Useless one(10, 'x');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Useless two = one;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls copy constructor<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Useless three(20, 'o');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Useless four (one + three);&#160;&#160;// calls operator+(), move constructor<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "object one: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;one.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "object two: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;two.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "object three: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;three.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "object four: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;four.ShowData();<br/>&#160;&#160;&#160;&#160;}<br/>}</p><hr/>
<p><a id="page_1168"/>The crucial definitions are those of the two copy/move constructors. First, shorn of the output statements, here is the copy constructor:</p>
<p class="programlisting">Useless::Useless(const Useless &#38; f): n(f.n)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pc[i] = f.pc[i];<br/>}</p>
<p>It does the usual deep copy, and it is the constructor that&#8217;s used by the following statement:</p>
<p class="programlisting">Useless two = one;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// calls copy constructor</p>
<p>The reference <code>f</code> refers to the lvalue object <code>one</code>.</p>
<p><a id="page_1169"/>Next, again shorn of the output statements, here is the move constructor:</p>
<p class="programlisting">Useless::Useless(Useless &#38;&#38; f): n(f.n)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;pc = f.pc;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// steal address<br/>&#160;&#160;&#160;&#160;f.pc = nullptr;&#160;&#160;// give old object nothing in return<br/>&#160;&#160;&#160;&#160;f.n = 0;<br/>}</p>
<p>It takes ownership of the existing data by setting <code>pc</code> to point to the data. At this time, both <code>pc</code> and <code>f.pc</code> point to the same data. This would be awkward when the destructors are called, because a program shouldn&#8217;t call <code>delete []</code> twice for the same address. To avoid this problem, the constructor then sets the original pointer to the null pointer because it is not an error to apply <code>delete []</code> to the null pointer. This appropriation of ownership often is termed <em>pilfering</em>. The code also sets the element count in the original object to 0. This isn&#8217;t necessary, but it makes the output for our example look more self-consistent. Note that the changes to the <code>f</code> object require not using <code>const</code> in the parameter declaration.</p>
<p>It is this constructor that is used in the following statement:</p>
<p class="programlisting">Useless four (one + three);&#160;&#160;// calls move constructor</p>
<p>The expression <code>one + three</code> invokes <code>Useless::operator+()</code>, and the rvalue reference <code>f</code> binds to the rvalue temporary object returned by the method.</p>
<p>Here&#8217;s the output when the program was compiled with Microsoft Visual C++ 2010:</p>
<p class="programlisting">int, char constructor called; number of objects: 1<br/>Number of elements: 10 Data address: 006F4B68<br/>copy const called; number of objects: 2<br/>Number of elements: 10 Data address: 006F4BB0<br/>int, char constructor called; number of objects: 3<br/>Number of elements: 20 Data address: 006F4BF8<br/>Entering operator+()<br/>int constructor called; number of objects: 4<br/>Number of elements: 30 Data address: 006F4C48<br/>temp object:<br/>Leaving operator+()<br/>move constructor called; number of objects: 5<br/>Number of elements: 30 Data address: 006F4C48<br/>destructor called; objects left: 4<br/>deleted object:<br/>Number of elements: 0 Data address: 00000000<br/>object one: xxxxxxxxxx<br/>object two: xxxxxxxxxx<br/>object three: oooooooooooooooooooo<br/>object four: xxxxxxxxxxoooooooooooooooooooo<br/>destructor called; objects left: 3<br/><a id="page_1170"/>deleted object:<br/>Number of elements: 30 Data address: 006F4C48<br/>destructor called; objects left: 2<br/>deleted object:<br/>Number of elements: 20 Data address: 006F4BF8<br/>destructor called; objects left: 1<br/>deleted object:<br/>Number of elements: 10 Data address: 006F4BB0<br/>destructor called; objects left: 0<br/>deleted object:<br/>Number of elements: 10 Data address: 006F4B68</p>
<p>Note that object <code>two</code> is a separate copy of object <code>one</code>: Both display the same data output, but the data addresses (<code>006F4B68</code> and <code>006F4BB0</code>) are different. On the other hand, the data address (<code>006F4C48</code>) of the object created in the <code>Useless::operator+()</code> method is the same as the data address stored in the <code>four</code> object, which was constructed by the move copy constructor. Also note how the destructor was called for the temporary object after the <code>four</code> object was constructed. You can tell that is the temporary object that was deleted because the size and the data address both show as 0.</p>
<p>Compiling the same program (but replacing <code>nullptr</code> with <code>0</code>) with g++ 4.5.0 with the <code>&#8211;std=c++11</code> flag leads to an interestingly different output:</p>
<p class="programlisting">int, char constructor called; number of objects: 1<br/>Number of elements: 10 Data address: 0xa50338<br/>copy const called; number of objects: 2<br/>Number of elements: 10 Data address: 0xa50348<br/>int, char constructor called; number of objects: 3<br/>Number of elements: 20 Data address: 0xa50358<br/>Entering operator+()<br/>int constructor called; number of objects: 4<br/>Number of elements: 30 Data address: 0xa50370<br/>temp object:<br/>Leaving operator+()<br/>object one: xxxxxxxxxx<br/>object two: xxxxxxxxxx<br/>object three: oooooooooooooooooooo<br/>object four: xxxxxxxxxxoooooooooooooooooooo<br/>destructor called; objects left: 3<br/>deleted object:<br/>Number of elements: 30 Data address: 0xa50370<br/>destructor called; objects left: 2<br/>deleted object:<br/>Number of elements: 20 Data address: 0xa50358<br/>destructor called; objects left: 1<br/>deleted object:<br/>Number of elements: 10 Data address: 0xa50348<br/><a id="page_1171"/>destructor called; objects left: 0<br/>deleted object:<br/>Number of elements: 10 Data address: 0xa50338</p>
<p>Note that the move constructor is not called and that only four objects were created. The compiler did not call any of our constructors to construct the <code>four</code> object; instead, it deduced that the <code>four</code> object should be the beneficiary of the work done by <code>operator+()</code> and transferred the name <code>four</code> to the object created in <code>operator+()</code>. In general, compilers are empowered to make their own optimizations if the result is the same that would have been obtained by going through all the steps. Even if you omit the move constructor from the code and compile with g++, you get the same behavior.</p>
<h4 id="ch18lev2sec13">Move Constructor Observations</h4>
<p>Although using an rvalue reference enables move semantics, it doesn&#8217;t magically make it happen. There are two steps to enablement. The first step is that the rvalue reference allows the compiler to identify when move semantics can be used:</p>
<p class="programlisting">Useless two = one;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// matches Useless::Useless(const Useless &#38;)<br/>Useless four (one + three); // matches Useless::Useless(Useless &#38;&#38;)</p>
<p>The object <code>one</code> is an lvalue, so it matches the lvalue reference, and the expression <code>one + three</code> is an rvalue, so it matches the rvalue reference. Thus, the rvalue reference directs initialization for object <code>four</code> to the move constructor. The second step in enabling move semantics is coding the move constructor so that it provides the behavior we want.</p>
<p>In short, the presence of one constructor with an lvalue reference and a second constructor with an rvalue reference sorts possible initializations into two groups. Objects initialized with an lvalue object use the copy constructor, and objects initialized with an rvalue object use the move constructor. The code writer then can endow these constructors with different behaviors.</p>
<p>This raises the question of what happened before rvalue references were part of the language. If there is no move constructor and the compiler doesn&#8217;t optimize away the need for the copy constructor, what should happen? Under C++98, the following statement would invoke the copy constructor:</p>
<p class="programlistingB">Useless four (one + three);</p>
<p>But an lvalue reference doesn&#8217;t bind to an rvalue. So what happens? As you may recall from <a href="ch08.html#ch08">Chapter 8</a>, a <code>const</code> reference parameter will bind to a temporary variable or object if the actual argument is an rvalue:</p>
<p class="programlisting">int twice(const &#38; rx) {return 2 * rx;}<br/>...<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;int m = 6;<br/>&#160;&#160;&#160;&#160;// below, rx refers to m<br/>&#160;&#160;&#160;&#160;int n = twice(m);<br/><a id="page_1172"/>&#160;&#160;&#160;&#160;// below, rx refers to a temporary variable initialized to 21<br/>&#160;&#160;&#160;&#160;int k = twice(21);<br/>...</p>
<p>So in the <code>Useless</code> case, the formal parameter <code>f</code> will be initialized to a temporary object that&#8217;s initialized to the return value of <code>operator+()</code>. Here is an excerpt from the result of using an older compiler with <a href="#ch18ex02">Listing 18.2</a> and omitting the move constructor:</p>
<p class="programlisting">...<br/>Entering operator+()<br/>int constructor called; number of objects: 4<br/>Number of elements: 30 Data address: 01C337C4<br/>temp object:<br/>Leaving operator+()<br/>copy const called; number of objects: 5<br/>Number of elements: 30 Data address: 01C337E8<br/>destructor called; objects left: 4<br/>deleted object:<br/>Number of elements: 30 Data address: 01C337C4<br/>copy const called; number of objects: 5<br/>Number of elements: 30 Data address: 01C337C4<br/>destructor called; objects left: 4<br/>deleted object:<br/>Number of elements: 30 Data address: 01C337E8<br/>...</p>
<p>First, within the <code>Useless::operator+()</code> method, a constructor creates <code>temp</code>, allocating storage for 30 elements at location <code>01C337C4</code>. Then the copy constructor creates a temporary copy to which <code>f</code> will refer, copying the information to location <code>01C337E8</code>. Next, <code>temp</code>, which uses location <code>01C337C4</code>, gets deleted. Then a new object, <code>four</code>, is constructed, reusing the recently freed memory at <code>01C337C4</code>. Then the temporary argument object, which used location <code>01C337E8</code>, gets deleted. So three complete objects were constructed, and two of them were destroyed. This is the sort of extra work that move semantics are meant to eliminate.</p>
<p>As the g++ example shows, an optimizing compiler might eliminate extra copying on its own, but using an rvalue reference lets the programmer dictate move semantics when appropriate.</p>
<h4 id="ch18lev2sec14">Assignment</h4>
<p>The same considerations that make move semantics appropriate for constructors make them appropriate for assignment. Here, for example, is how you could code the copy assignment and the move assignment operators for the <code>Useless</code> class:</p>
<p class="programlisting">Useless &#38; Useless::operator=(const Useless &#38; f)&#160;&#160;// copy assignment<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;f)<br/><a id="page_1173"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;delete [] pc;<br/>&#160;&#160;&#160;&#160;n = f.n;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pc[i] = f.pc[i];<br/>&#160;&#160;&#160;&#160;return *this;<br/>}<br/><br/>Useless &#38; Useless::operator=(Useless &#38;&#38; f)&#160;&#160;&#160;&#160;&#160;&#160;&#160;// move assignment<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;f)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;delete [] pc;<br/>&#160;&#160;&#160;&#160;n = f.n;<br/>&#160;&#160;&#160;&#160;pc = f.pc;<br/>&#160;&#160;&#160;&#160;f.n = 0;<br/>&#160;&#160;&#160;&#160;f.pc = nullptr;<br/>&#160;&#160;&#160;&#160;return *this;<br/>}</p>
<p>The copy assignment operator follows the usual pattern given in <a href="ch12.html#ch12">Chapter 12</a>. The move assignment operator deletes the original data in the target and pilfers the source object. It&#8217;s important that only one pointer points to the data, so the method resets the pointer in the source object to the null pointer.</p>
<p>As with the move constructor, the move assignment operator parameter is not a <code>const</code> reference because the method alters the source object.</p>
<h4 id="ch18lev2sec15">Forcing a Move</h4>
<p>Move constructors and move assignment operators work with rvalues. What if you want to use them with lvalues? For instance, a program could analyze an array of some sort of candidate objects, select one object for further use, and discard the array. It would be convenient if you could use a move constructor or a move assignment operator to preserve the selected object. However, suppose you tried the following:</p>
<p class="programlisting">Useless choices[10];<br/>Useless best;<br/>int pick;<br/>... // select one object,&#160;&#160;set pick to index<br/>best = choices[pick];</p>
<p>The <code>choices[pick]</code> object is an lvalue, so the assignment statement will use the copy assignment operator, not the move assignment operator. But if you could make <code>choices[pick]</code> look like an rvalue, then the move assignment operator would be used. This can be done by using the <code>static_cast&lt;&gt;</code> operator to cast the object to type <code>Useless &#38;&#38;</code>. C++11 provides a simpler way to do this&#8212;use the <code>std::move()</code> function, <a id="page_1174"/>which is declared in the <code>utility</code> header file. <a href="#ch18ex03">Listing 18.3</a> illustrates this technique. It adds verbose versions of the assignment operators to the <code>Useless</code> class while silencing the previously verbose constructors and destructor.</p>
<p class="caption1"><a id="ch18ex03"/><strong>Listing 18.3. <code>stdmove.cpp</code></strong></p><hr/>
<p class="programlisting1">// stdmove.cpp -- using std::move()<br/>#include &lt;iostream&gt;<br/>#include &lt;utility&gt;<br/><br/>// interface<br/>class Useless<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int n;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// number of elements<br/>&#160;&#160;&#160;&#160;char * pc;&#160;&#160;&#160;&#160;&#160;&#160;// pointer to data<br/>&#160;&#160;&#160;&#160;static int ct;&#160;&#160;// number of objects<br/>&#160;&#160;&#160;&#160;void ShowObject() const;<br/>public:<br/>&#160;&#160;&#160;&#160;Useless();<br/>&#160;&#160;&#160;&#160;explicit Useless(int k);<br/>&#160;&#160;&#160;&#160;Useless(int k, char ch);<br/>&#160;&#160;&#160;&#160;Useless(const Useless &#38; f); // regular copy constructor<br/>&#160;&#160;&#160;&#160;Useless(Useless &#38;&#38; f);&#160;&#160;&#160;&#160;&#160;&#160;// move constructor<br/>&#160;&#160;&#160;&#160;~Useless();<br/>&#160;&#160;&#160;&#160;Useless operator+(const Useless &#38; f)const;<br/>&#160;&#160;&#160;&#160;Useless &#38; operator=(const Useless &#38; f); // copy assignment<br/>&#160;&#160;&#160;&#160;Useless &#38; operator=(Useless &#38;&#38; f);&#160;&#160;&#160;&#160;&#160;&#160;// move assignment<br/>&#160;&#160;&#160;&#160;void ShowData() const;<br/>};<br/><br/>// implementation<br/>int Useless::ct = 0;<br/><br/>Useless::Useless()<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;n = 0;<br/>&#160;&#160;&#160;&#160;pc = nullptr;<br/>&#160;}<br/><br/>Useless::Useless(int k) : n(k)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>}<br/><br/><a id="page_1175"/>Useless::Useless(int k, char ch) : n(k)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pc[i] = ch;<br/>}<br/><br/>Useless::Useless(const Useless &#38; f): n(f.n)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pc[i] = f.pc[i];<br/>}<br/><br/>Useless::Useless(Useless &#38;&#38; f): n(f.n)<br/>{<br/>&#160;&#160;&#160;&#160;++ct;<br/>&#160;&#160;&#160;&#160;pc = f.pc;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// steal address<br/>&#160;&#160;&#160;&#160;f.pc = nullptr;&#160;&#160;// give old object nothing in return<br/>&#160;&#160;&#160;&#160;f.n = 0;<br/>}<br/><br/>Useless::~Useless()<br/>{<br/>&#160;&#160;&#160;&#160;delete [] pc;<br/>}<br/><br/>Useless &#38; Useless::operator=(const Useless &#38; f)&#160;&#160;// copy assignment<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "copy assignment operator called:\n";<br/>&#160;&#160;&#160;&#160;if (this == &#38;f)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;delete [] pc;<br/>&#160;&#160;&#160;&#160;n = f.n;<br/>&#160;&#160;&#160;&#160;pc = new char[n];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pc[i] = f.pc[i];<br/>&#160;&#160;&#160;&#160;return *this;<br/>}<br/><br/>Useless &#38; Useless::operator=(Useless &#38;&#38; f)&#160;&#160;&#160;&#160;&#160;&#160;&#160;// move assignment<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "move assignment operator called:\n";<br/>&#160;&#160;&#160;&#160;if (this == &#38;f)<br/><a id="page_1176"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;delete [] pc;<br/>&#160;&#160;&#160;&#160;n = f.n;<br/>&#160;&#160;&#160;&#160;pc = f.pc;<br/>&#160;&#160;&#160;&#160;f.n = 0;<br/>&#160;&#160;&#160;&#160;f.pc = nullptr;<br/>&#160;&#160;&#160;&#160;return *this;<br/>}<br/><br/>Useless Useless::operator+(const Useless &#38; f)const<br/>{<br/>&#160;&#160;&#160;&#160;Useless temp = Useless(n + f.n);<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp.pc[i] = pc[i];<br/>&#160;&#160;&#160;&#160;for (int i = n; i &lt; temp.n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp.pc[i] = f.pc[i - n];<br/>&#160;&#160;&#160;&#160;return temp;<br/>}<br/><br/>void Useless::ShowObject() const<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Number of elements: " &lt;&lt; n;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; " Data address: " &lt;&lt; (void *) pc &lt;&lt; std::endl;<br/>}<br/><br/>void Useless::ShowData() const<br/>{<br/>&#160;&#160;&#160;&#160;if (n == 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "(object empty)";<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; pc[i];<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; std::endl;<br/>}<br/><br/>// application<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Useless one(10, 'x');<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Useless two = one +one;&#160;&#160;&#160;// calls move constructor<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "object one: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;one.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "object two: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;two.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Useless three, four;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "three = one\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;three = one;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// automatic copy assignment<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "now object three = ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;three.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "and object one = ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;one.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "four = one + two\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;four = one + two;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// automatic move assignment<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "now object four = ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;four.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "four = move(one)\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;four = std::move(one);&#160;&#160;&#160;&#160;// forced move assignment<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "now object four = ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;four.ShowData();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "and object one = ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;one.ShowData();<br/>&#160;&#160;&#160;&#160;}<br/>}</p><hr/>
<p><a id="page_1177"/>Here is a sample run:</p>
<p class="programlisting">object one: xxxxxxxxxx<br/>object two: xxxxxxxxxxxxxxxxxxxx<br/>three = one<br/>copy assignment operator called:<br/>now object three = xxxxxxxxxx<br/>and object one = xxxxxxxxxx<br/>four = one + two<br/>move assignment operator called:<br/>now object four = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br/>four = move(one)<br/>move assignment operator called:<br/>now object four = xxxxxxxxxx<br/>and object one = (object empty)</p>
<p>As you can see, assigning <code>one</code> to <code>three</code> invokes copy assignment, but assigning <code>move(one)</code> to <code>four</code> invokes move assignment.</p>
<p>You should realize that the <code>std::move()</code> function doesn&#8217;t necessarily produce a move operation. Suppose, for instance, that <code>Chunk</code> is a class with private data and that we have the following code:</p>
<p class="programlisting">Chunk one;<br/>...<br/>Chunk two;<br/>two = std::move(one);&#160;&#160;// move semantics?</p>
<p><a id="page_1178"/>The expression <code>std::move(one)</code> is an rvalue, so the assignment statement will invoke the move assignment operator for <code>Chunk</code>, providing that one has been defined. But if the <code>Chunk</code> class doesn&#8217;t define a move assignment operator, the compiler will use the copy assignment operator. And if that also isn&#8217;t defined, then assignment isn&#8217;t allowed at all.</p>
<p>The main benefit rvalue references bring to most programmers is not the opportunity to write code using them. Rather, it is the opportunity to use library code that utilizes rvalue references to implement move semantics. For example, the STL classes now have copy constructors, move constructors, copy assignment operators, and move assignment operators.</p>
<h3 id="ch18lev1sec3">New Class Features</h3>
<p>C++11 adds several features to classes in addition to those already mentioned in this chapter&#8212;that is, explicit conversion operators and in-class member initialization.</p>
<h4 id="ch18lev2sec16">Special Member Functions</h4>
<p>C++11 adds two more <em>special member functions</em> (the move constructor and the move assignment operator) to four previous ones (the default constructor, the copy constructor, the copy assignment operator, and the destructor). These are member functions that the compiler provides automatically, subject to a variety of conditions.</p>
<p>The default constructor, recall, is a constructor that can be called with no arguments. The compiler provides one if you fail to define any constructors for the class. This default version of a default constructor is termed the <em>defaulted</em> default constructor. The defaulted default constructor leaves members of the built-in types uninitialized, and it invokes the default constructors for members that are class objects.</p>
<p>Also the compiler provides a defaulted copy constructor if you don&#8217;t provide one and if your code requires its use, and it now provides a defaulted move constructor if you don&#8217;t provide one and if your code requires its use. If the class name is <code>Someclass</code>, these two defaulted constructors have the following prototypes:</p>
<p class="programlisting">Someclass::Someclass(const Someclass &#38;);&#160;&#160;// defaulted copy constructor<br/>Someclass::Someclass(Someclass &#38;&#38;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// defaulted move constructor</p>
<p>In similar circumstances, the compiler provides a defaulted copy assignment operator and a defaulted move assignment operator with the following prototypes:</p>
<p class="programlisting">Someclass &#38; Someclass::operator(const Someclass &#38;);&#160;&#160;// defaulted copy assignment<br/>Someclass &#38; Someclass::operator(Someclass &#38;&#38;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// defaulted move assignment</p>
<p>Finally, the compiler provides a destructor if you don&#8217;t.</p>
<p>There are various exceptions to this description. If you do provide a destructor or a copy constructor or a copy assignment operator, the compiler does not automatically provide a move constructor or a move assignment operator. If you do provide a move constructor or a move assignment operator, the compiler does not automatically provide a copy constructor or a copy assignment operator.</p>
<p><a id="page_1179"/>Also the defaulted move constructor and defaulted move assignment operator work similarly to their copy counterparts, doing memberwise initialization and copying for built-in types. For members that are class objects, constructors and assignment operators for those classes are used as if the parameters were rvalues. This, in turn, invokes move constructors and assignment operators, if defined, and copy constructors and assignment operators otherwise, if defined.</p>
<h4 id="ch18lev2sec17">Defaulted and Deleted Methods</h4>
<p>C++11 provides more control over which methods are used. Suppose that you wish to use a defaulted function that, due to circumstances, isn&#8217;t created automatically. For example, if you provide a move constructor, then the default constructor, the copy constructor, and the copy assignment operator are not provided. In that case, you can use the keyword <code>default</code> to explicitly declare the defaulted versions of these methods:</p>
<p class="programlisting">class Someclass<br/>{<br/>public:<br/>&#160;&#160;&#160;Someclass(Someclass &#38;&#38;);<br/>&#160;&#160;&#160;Someclass() = default;&#160;&#160;&#160;&#160;&#160;&#160;// use compiler-generated default constructor<br/>&#160;&#160;&#160;Someclass(const Someclass &#38;) = default;<br/>&#160;&#160;&#160;Someclass &#38; operator=(const Someclass &#38;) = default;<br/>...<br/>};</p>
<p>The compiler provides the same constructor that it would have provided automatically had you not provided the move constructor.</p>
<p>The <code>delete</code> keyword, on the other hand, can be used to prevent the compiler from using a particular method. For example, to prevent an object from being copied, you can disable the copy constructor and copy assignment operator:</p>
<p class="programlisting">class Someclass<br/>{<br/>public:<br/>&#160;&#160;&#160;Someclass() = default;&#160;&#160;&#160;&#160;&#160;&#160;// use compiler-generated default constructor<br/>// disable copy constructor and copy assignment operator:<br/>&#160;&#160;&#160;Someclass(const Someclass &#38;) = delete;<br/>&#160;&#160;&#160;Someclass &#38; operator=(const Someclass &#38;) = delete;<br/>// use compiler-generated move constructor and move assignment operator:<br/>&#160;&#160;&#160;Someclass(Someclass &#38;&#38;) = default;<br/>&#160;&#160;&#160;Someclass &#38; operator=(Someclass &#38;&#38;) = default;<br/>&#160;&#160;&#160;Someclass &#38; operator+(const Someclass &#38;) const;<br/>...<br/>};</p>
<p><a id="page_1180"/>You may recall (from <a href="ch12.html#ch12">Chapter 12</a>) that you can disable copying by placing the copy constructor and assignment operator in the <code>private</code> section of a class. But using <code>delete</code> is a less devious and more easily understood way to accomplish that end.</p>
<p>What is the effect of disabling copy methods while enabling move methods? Recall that an rvalue reference, such as used by move operations, binds only to rvalue expressions. This implies the following:</p>
<p class="programlisting">Someclass one;<br/>Someclass two;<br/>Someclass three(one);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// not allowed, one an lvalue<br/>Someclass four(one + two);&#160;&#160;// allowed, expression is an rvalue</p>
<p>Only the six special member functions can be defaulted, but you can use <code>delete</code> with any member function. One possible use is to disable certain conversions. Suppose, for example, that the <code>Someclass</code> class has a method with a type <code>double</code> parameter:</p>
<p class="programlisting">class Someclass<br/>{<br/>public:<br/>...<br/>&#160;&#160;&#160;&#160;void redo(double);<br/>...<br/>};</p>
<p>Then suppose we have the following code:</p>
<p class="programlisting">Someclass sc;<br/>sc.redo(5);</p>
<p>The <code>int</code> value <code>5</code> will be promoted to <code>5.0</code>, and the <code>redo()</code> method will execute.</p>
<p>Now suppose the <code>Someclass</code> definition is modified thusly:</p>
<p class="programlisting">class Someclass<br/>{<br/>public:<br/>...<br/>&#160;&#160;&#160;&#160;void redo(double);<br/>&#160;&#160;&#160;&#160;void redo(int) = delete;<br/>...<br/>};</p>
<p>In this case, the method call <code>sc.redo(5)</code> matches the <code>redo(int)</code> prototype. The compiler will detect that fact and also detect that <code>redo(int)</code> is deleted, and it will then flag the call as a compile-time error. This illustrates an important fact about deleted functions. They do exist as far as function look-up is concerned, but to use them is an error.</p>
<h4 id="ch18lev2sec18">Delegating Constructors</h4>
<p>If you provide a class with several constructors, you may find yourself writing the same code over and over. That is, some of the constructors may require you to duplicate code <a id="page_1181"/>already present in other constructors. To make coding simpler and more reliable, C++11 allows to you use a constructor as part of the definition of another constructor. This process is termed <em>delegation</em> because one constructor temporarily delegates responsibility to another constructor to work on the object it is constructing. Delegation uses a variant of the member initialization list syntax:</p>
<p class="programlisting">class Notes {<br/>&#160;&#160;&#160;&#160;int k;<br/>&#160;&#160;&#160;&#160;double x;<br/>&#160;&#160;&#160;&#160;std::string st;<br/>public:<br/>&#160;&#160;&#160;&#160;Notes();<br/>&#160;&#160;&#160;&#160;Notes(int);<br/>&#160;&#160;&#160;&#160;Notes(int, double);<br/>&#160;&#160;&#160;&#160;Notes(int, double, std::string);<br/>};<br/>Notes::Notes(int kk, double xx, std::string stt) : k(kk),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x(xx), st(stt) {/*do stuff*/}<br/>Notes::Notes() : Notes(0, 0.01, "Oh") {/* do other stuff*/}<br/>Notes::Notes(int kk) : Notes(kk, 0.01, "Ah") {/* do yet other stuff*/ }<br/>Notes::Notes( int kk, double xx ) : Notes(kk, xx, "Uh") {/* ditto*/ }</p>
<p>The default constructor, for example, uses the first constructor in the list to initialize the data members and to also do whatever the body of that constructor requests. Then it finishes up doing whatever its own body requests.</p>
<h4 id="ch18lev2sec19">Inheriting Constructors</h4>
<p>In another move to simplify coding, C++11 provides a mechanism for derived classes to inherit constructors from the base class. C++98 already had a syntax for making functions from a namespace available:</p>
<p class="programlisting">namespace Box<br/>{<br/>&#160;&#160;&#160;&#160;int fn(int) { ... }<br/>&#160;&#160;&#160;&#160;int fn(double) { ... }<br/>&#160;&#160;&#160;&#160;int fn(const char *) { ... }<br/>}<br/>using Box::fn;</p>
<p>This makes all the overloaded <code>fn</code> functions available. The same technique works for making nonspecial member functions of a base class available to a derived class. For example, consider the following code:</p>
<p class="programlisting">class C1<br/>{<br/>...<br/>public:<br/>...<br/><a id="page_1182"/>&#160;&#160;&#160;&#160;int fn(int j) { ... }<br/>&#160;&#160;&#160;&#160;double fn(double w) { ... }<br/>&#160;&#160;&#160;&#160;void fn(const char * s) { ... }<br/>};<br/>class C2 : public C1<br/>{<br/>...<br/>public:<br/>...<br/>&#160;&#160;&#160;&#160;using C1::fn;<br/>&#160;&#160;&#160;&#160;double fn(double) { ... };<br/>};<br/>...<br/>C2 c2;<br/>int k = c2.fn(3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// uses C1::fn(int)<br/>double z = c2.fn(2.4);&#160;&#160;// uses C2::fn(double)</p>
<p>The <code>using</code> declaration in <code>C2</code> makes the three <code>fn()</code> methods in <code>C1</code> available to a <code>C2</code> object. However, the <code>fn(double)</code> method defined in <code>C2</code> is chosen over the one from <code>C1</code>.</p>
<p>C++11 brings the same technique to constructors. All the constructors of the base class, other than the default, copy, and move constructors, are brought in as possible constructors for the derived class, but the ones that have function signatures matching derived class constructors aren&#8217;t used:</p>
<p class="programlisting">class BS<br/>{<br/>&#160;&#160;&#160;&#160;int q;<br/>&#160;&#160;&#160;&#160;double w;<br/>public:<br/>&#160;&#160;&#160;&#160;BS() : q(0), w(0) {}<br/>&#160;&#160;&#160;&#160;BS(int k) : q(k), w(100) {}<br/>&#160;&#160;&#160;&#160;BS(double x) : q(-1), w(x) {}<br/>&#160;&#160;&#160;&#160;B0(int k, double x) : q(k), w(x) {}<br/>&#160;&#160;&#160;&#160;void Show() const {std::cout &lt;&lt; q &lt;&lt;", " &lt;&lt; w &lt;&lt; '\n';}<br/>};<br/><br/>class DR : public BS<br/>{<br/>&#160;&#160;&#160;&#160;short j;<br/>public:<br/>&#160;&#160;&#160;&#160;using BS::BS;<br/>&#160;&#160;&#160;&#160;DR() : j(-100) {}&#160;&#160;&#160;&#160;&#160;&#160;// DR needs its own default constructor<br/>&#160;&#160;&#160;&#160;DR(double x) : BS(2*x), j(int(x)) {}<br/>&#160;&#160;&#160;&#160;DR(int i) : j(-2), BS(i, 0.5* i) {}<br/>&#160;&#160;&#160;&#160;void Show() const {std::cout &lt;&lt; j &lt;&lt; ", "; BS::Show();}<br/>};<br/>int main()<br/><a id="page_1183"/>{<br/>&#160;&#160;&#160;&#160;DR o1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use DR()<br/>&#160;&#160;&#160;&#160;DR o2(18.81);&#160;&#160;&#160;// use DR(double) instead of BS(double)<br/>&#160;&#160;&#160;&#160;DR o3(10, 1.8); // use BS(int, double)<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>Because there is no <code>DR(int, double)</code> constructor, the inherited <code>BS(int, double)</code> is used for <code>03</code>. Note that an inherited base-class constructor only initializes base-class members. If you need to initialize derived class members too, you can use the member list initialization syntax instead of inheritance:</p>
<p class="programlisting">&#160;&#160;&#160;&#160;DR(int i, int k, double x) : j(i), BS(k,x) {}</p>
<h4 id="ch18lev2sec20">Managing Virtual Methods: <code>override</code> and <code>final</code></h4>
<p>Virtual methods are an important component of implementing polymorphic class hierarchies, in which a base class reference or pointer can invoke the particular method appropriate to the type of object referred to. Virtual methods do pose some programming pitfalls. For instance, suppose the base class declares a particular virtual method, and you decide to provide a different version for a derived class. This is called <em>overriding</em> the old version. But, as discussed in <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a href="ch13.html#ch13">Class Inheritance</a>,&#8221; if you mismatch the function signature, you hide rather than override the old version:</p>
<p class="programlisting">class Action<br/>{<br/>&#160;&#160;&#160;&#160;int a;<br/>public:<br/>&#160;&#160;&#160;&#160;Action(int i = 0) : a(i) {}<br/>&#160;&#160;&#160;&#160;int val() const {return a;};<br/>&#160;&#160;&#160;&#160;virtual void f(char ch) const { std::cout &lt;&lt; val() &lt;&lt; ch &lt;&lt; "\n";}<br/>};<br/>class Bingo : public Action<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;Bingo(int i = 0) : Action(i) {}<br/>&#160;&#160;&#160;&#160;virtual void f(char * ch) const { std::cout &lt;&lt; val() &lt;&lt; ch&#160;&#160;&lt;&lt; "!\n"; }<br/>};</p>
<p>Because class <code>Bingo</code> uses <code>f(char * ch)</code> instead of <code>f(char ch)</code>, <code>f(char ch)</code> is hidden to a <code>Bingo</code> object. This prevents a program from using code like the following:</p>
<p class="programlisting">Bingo b(10);<br/>b.f('@');&#160;&#160;// works for Action object, fails for Bingo object</p>
<p>With C++11, you can use the virtual specifier <code>override</code> to indicate that you intend to override a virtual function. Place it after the parameter list. If your declaration does not match a base method, the compiler objects. Thus, the following version of <code>Bingo::f()</code> would generate a compile-time error message:</p>
<p class="programlisting"><a id="page_1184"/>virtual void f(char * ch) const override { std::cout &lt;&lt; val()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ch&#160;&#160;&lt;&lt; "!\n"; }</p>
<p>For example, Microsoft Visual C++ 2010 has this to say:</p>
<p class="programlisting">method with override specifier 'override' did not override any<br/>base class methods</p>
<p>The specifier <code>final</code> addresses a different issue. You may find that you want to prohibit derived classes from overriding a particular virtual method. To do so, place <code>final</code> after the parameter list. For example, the following code would prevent classes based on <code>Action</code> to redefine the <code>f()</code> function:</p>
<p class="programlisting">virtual void f(char ch) const final { std::cout &lt;&lt; val() &lt;&lt; ch &lt;&lt; "\n";}</p>
<p>The specifiers <code>override</code> and <code>final</code> do not quite have the status of keywords. Instead, they are labeled &#8220;identifiers with special meaning.&#8221; This means that the compiler uses the context in which they appear to decide if they have a special meaning. In other contexts, they can be used as ordinary identifiers (for example, as variable names or enumerations).</p>
<h3 id="ch18lev1sec4">Lambda Functions</h3>
<p>When you see the term <em>lambda functions</em> (a.k.a. <em>lambda expressions</em> or, simply, <em>lambdas</em>), you may suspect that this is not one of the C++11 additions intended to help the novice programmer. You will have your suspicions seemingly confirmed when you see how lambda functions actually look&#8212;here&#8217;s an example:</p>
<p class="programlisting">[&#38;count](int x){count += (x % 13 == 0);}</p>
<p>But they aren&#8217;t as arcane as they may look, and they do provide a useful service, particularly with STL algorithms using function predicates.</p>
<h4 id="ch18lev2sec21">The How of Function Pointers, Functors, and Lambdas</h4>
<p>Let&#8217;s look at an example using three approaches for passing information to an STL algorithm: function pointers, functors, and lambdas. (For convenience, we&#8217;ll refer to these three forms as <em>function objects</em> so that we won&#8217;t have to keep repeating &#8220;function pointer or functor or lambda.&#8221;) Suppose you wish to generate a list of random integers and determine how many of them are divisible by 3 and how many are divisible by 13. If necessary, imagine that this is a quest you find absolutely fascinating.</p>
<p>Generating the list is pretty straightforward. One option is to use a <code>vector&lt;int&gt;</code> array to hold the numbers and use the STL <code>generate()</code> algorithm to stock the array with random numbers:</p>
<p class="programlisting">#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cmath&gt;<br/>...<br/>std::vector&lt;int&gt; numbers(1000);<br/>std::generate(vector.begin(), vector.end(), std::rand);</p>
<p><a id="page_1185"/>The <code>generate()</code> function takes a range, specified by the first two arguments, and sets each element to the value returned by the third argument, which is a function object that takes no arguments. In this case, the function object is a pointer to the standard <code>rand()</code> function.</p>
<p>With the help of the <code>count_if(</code>) algorithm, it&#8217;s easy to count the number of elements divisible by 3. The first two arguments should specify the range, just as for <code>generate()</code>. The third argument should be a function object that returns <code>true</code> or <code>false</code>. The <code>count_if()</code> function then counts all the elements for which the function object returns <code>true</code>. To find elements divisible by 3, you can use this function definition:</p>
<p class="programlisting">bool f3(int x) {return x % 3 == 0;}</p>
<p>Similarly, you can use the following function definition for finding elements divisible by 13:</p>
<p class="programlisting">bool f13(int x) {return x % 13 == 0;}</p>
<p>With these definitions in place, you can count elements as follows:</p>
<p class="programlisting">int count3 = std::count_if(numbers.begin(), numbers.end(), f3);<br/>cout &lt;&lt; "Count of numbers divisible by 3: " &lt;&lt; count3 &lt;&lt; '\n';<br/>int count13 = std::count_if(numbers.begin(), numbers.end(), f13);<br/>cout &lt;&lt; "Count of numbers divisible by 13: " &lt;&lt; count13 &lt;&lt; "\n\n";</p>
<p>Next, let&#8217;s review how to accomplish the same task using a functor. A functor, as you&#8217;ll recall from <a href="ch16.html#ch16">Chapter 16</a>, is a class object than can be used as if it were a function name, thanks to the class defining <code>operator()()</code> as a class method. One advantage of the functor in our example is that you can use the same functor for both counting tasks. Here&#8217;s one possible definition:</p>
<p class="programlisting">class f_mod<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int dv;<br/>public:<br/>&#160;&#160;&#160;&#160;f_mod(int d = 1) : dv(d) {}<br/>&#160;&#160;&#160;&#160;bool operator()(int x) {return x % dv == 0;}<br/>};</p>
<p>Recall how this works. You can use the constructor to create an <code>f_mod</code> object storing a particular integer value:</p>
<p class="programlisting">f_mod obj(3);&#160;&#160;// f_mod.dv set to 3</p>
<p>This object can use the <code>operator()</code> method to return a <code>bool</code> value:</p>
<p class="programlisting">bool is_div_by_3 = obj(7); // same as obj.operator()(7)</p>
<p><a id="page_1186"/>The constructor itself can be used as an argument to functions such as <code>count_if()</code>:</p>
<p class="programlisting">count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));</p>
<p>The argument <code>f_mod(3)</code> creates an object storing the value <code>3</code>, and <code>count_if()</code> uses the created object to call the <code>operator()()</code> method, setting the parameter <code>x</code> equal to an element of <code>numbers</code>. To count how many numbers are divisible by <code>13</code> instead of <code>3</code>, use <code>f_mod(13)</code> as the third argument.</p>
<p>Finally, let&#8217;s examine the lambda approach. The name comes from <em>lambda calculus</em>, a mathematical system for defining and applying functions. The system enables one to use anonymous functions&#8212;that is, it allows one to dispense with function names. In the C++11 context, you can use an anonymous function definition (a lambda) as an argument to functions expecting a function pointer or functor. The lambda corresponding to the <code>f3()</code> function is this:</p>
<p class="programlisting">[](int x) {return x % 3 == 0;}</p>
<p>It looks much like the definition of <code>f3()</code>:</p>
<p class="programlisting">bool f3(int x) {return x % 3 == 0;}</p>
<p>The two differences are that the function name is replaced with <code>[]</code> (how anonymous is that!) and that there is no declared return type. Instead, the return type is the type that <code>decltype</code> would deduce from the return value, which would be <code>bool</code> in this case. If the lambda doesn&#8217;t have a return statement, the type is deduced to be <code>void</code>. In our example, you would use this lambda as follows:</p>
<p class="programlisting">count3 = std::count_if(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int x){return x % 3 == 0;});</p>
<p>That is, you use the entire lambda expression as you would use a pointer or a functor constructor.</p>
<p>The automatic type deduction for lambdas works only if the body consists of a single return statement. Otherwise, you need to use the new trailing-return-value syntax:</p>
<p class="programlisting">[](double x)-&gt;double{int y = x; return x &#8211; y;}&#160;&#160;// return type is double</p>
<p><a href="#ch18ex04">Listing 18.4</a> illustrates the points just discussed.</p>
<p class="caption1"><a id="ch18ex04"/><strong>Listing 18.4. <code>lambda0.cpp</code></strong></p><hr/>
<p class="programlisting1">// lambda0.cpp -- using lambda expressions<br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cmath&gt;<br/>#include &lt;ctime&gt;<br/>const long Size1 = 39L;<br/>const long Size2 = 100*Size1;<br/>const long Size3 = 100*Size2;<br/><br/><a id="page_1187"/>bool f3(int x) {return x % 3 == 0;}<br/>bool f13(int x) {return x % 13 == 0;}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;std::vector&lt;int&gt; numbers(Size1);<br/><br/>&#160;&#160;&#160;&#160;std::srand(std::time(0));<br/>&#160;&#160;&#160;&#160;std::generate(numbers.begin(), numbers.end(), std::rand);<br/><br/>// using function pointers<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sample size = " &lt;&lt; Size1 &lt;&lt; '\n';<br/><br/>&#160;&#160;&#160;&#160;int count3 = std::count_if(numbers.begin(), numbers.end(), f3);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 3: " &lt;&lt; count3 &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;int count13 = std::count_if(numbers.begin(), numbers.end(), f13);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 13: " &lt;&lt; count13 &lt;&lt; "\n\n";<br/><br/>// increase number of numbers<br/>&#160;&#160;&#160;&#160;numbers.resize(Size2);<br/>&#160;&#160;&#160;&#160;std::generate(numbers.begin(), numbers.end(), std::rand);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sample size = " &lt;&lt; Size2 &lt;&lt; '\n';<br/>// using a functor<br/>&#160;&#160;&#160;&#160;class f_mod<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int dv;<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;f_mod(int d = 1) : dv(d) {}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bool operator()(int x) {return x % dv == 0;}<br/>&#160;&#160;&#160;&#160;};<br/><br/>&#160;&#160;&#160;&#160;count3 = std::count_if(numbers.begin(), numbers.end(), f_mod(3));<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 3: " &lt;&lt; count3 &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;count13 = std::count_if(numbers.begin(), numbers.end(), f_mod(13));<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 13: " &lt;&lt; count13 &lt;&lt; "\n\n";<br/><br/>// increase number of numbers again<br/>&#160;&#160;&#160;&#160;numbers.resize(Size3);<br/>&#160;&#160;&#160;&#160;std::generate(numbers.begin(), numbers.end(), std::rand);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sample size = " &lt;&lt; Size3 &lt;&lt; '\n';<br/>// using lambdas<br/>&#160;&#160;&#160;&#160;count3 = std::count_if(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int x){return x % 3 == 0;});<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 3: " &lt;&lt; count3 &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;count13 = std::count_if(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int x){return x % 13 == 0;});<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 13: " &lt;&lt; count13 &lt;&lt; '\n';<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1188"/>Here is a sample output:</p>
<p class="programlisting">Sample size = 39<br/>Count of numbers divisible by 3: 15<br/>Count of numbers divisible by 13: 6<br/><br/>Sample size = 3900<br/>Count of numbers divisible by 3: 1305<br/>Count of numbers divisible by 13: 302<br/><br/>Sample size = 390000<br/>Count of numbers divisible by 3: 130241</p>
<p><code>Count of numbers divisible by 13: 29860</code></p>
<p>The output illustrates that one should not rely on statistics based on small samples.</p>
<h4 id="ch18lev2sec22">The Why of Lambdas</h4>
<p>You may be wondering what need, other than the flowering of geekly expressionism, the lambda serves. Let&#8217;s examine this question in terms of four qualities: proximity, brevity, efficiency, and capability.</p>
<p>Many programmers feel that it is useful to locate definitions close to where they are used. That way, you don&#8217;t have to scan through pages of source code to find, say, what the third argument to a <code>count_if(</code>) function call accomplishes. Also if you need to modify the code, all the components are close at hand. And if you cut and paste the code for use elsewhere, again all the components are at hand. From this standpoint, lambdas are ideal because the definition is at the point of usage. Functions are worst because functions cannot be defined inside other functions, so the definition will be located possibly quite far from the point of usage. Functors can be pretty good because a class, including a functor class, can be defined inside a function, so the definition can be located close to the point of use.</p>
<p>In terms of brevity, the functor code is more verbose than the equivalent function or lambda code. Functions and lambdas are approximately equally brief. One apparent exception would be if you had to use a lambda twice:</p>
<p class="programlisting">count1 = std::count_if(n1.begin(), n1.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int x){return x % 3 == 0;});<br/>count2 = std::count_if(n2.begin(), n2.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int x){return x % 3 == 0;});</p>
<p><a id="page_1189"/>But you don&#8217;t actually have to write out the lambda twice. Essentially, you can create a name for the anonymous lambda and then use the name twice:</p>
<p class="programlisting">auto mod3 = [](int x){return x % 3 == 0;}&#160;&#160;// mod3 a name for the lambda<br/>count1 = std::count_if(n1.begin(), n1.end(), mod3);<br/>count2 = std::count_if(n2.begin(), n2.end(), mod3);</p>
<p>You even can use this no-longer-anonymous lambda as an ordinary function:</p>
<p class="programlisting">bool result = mod3(z); // result is true if z % 3 == 0</p>
<p>Unlike an ordinary function, however, a named lambda can be defined inside a function. The actual type for <code>mod3</code> will be some implementation-dependent type that the compiler uses to keep track of lambdas.</p>
<p>The relative efficiencies of the three approaches boils down to what the compiler chooses to inline. Here, the function pointer approach is handicapped by the fact that compilers traditionally don&#8217;t inline a function that has its address taken because the concept of a function address implies a non-inline function. With functors and lambdas, there is no apparent contradiction with inlining.</p>
<p>Finally, lambdas have some additional capabilities. In particular, a lambda can access by name any automatic variable in scope. Variables to be used are <em>captured</em> by having their names listed within the brackets. If just the name is used, as in <code>[z]</code>, the variable is accessed by value. If the name is preceded by an <code>&#38;</code>, as in <code>[&#38;count]</code>, the variable is accessed by reference. Using <code>[&#38;]</code> provides access to all the automatic variables by reference, and <code>[=]</code> provides access to all the automatic variables by value. You also can mix and match. For instance, <code>[ted, &#38;ed]</code> would provide access to <code>ted</code> by value and <code>ed</code> by reference, <code>[&#38;, ted]</code> would provide access to <code>ted</code> by value and to all other automatic variables by reference, and <code>[=, &#38;ed]</code> would provide access by reference to <code>ed</code> and by value to the remaining automatic variables. In <a href="#ch18ex04">Listing 18.4</a>, you can replace</p>
<p class="programlisting">int count13;<br/>...<br/>count13 = std::count_if(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int x){return x % 13 == 0;});</p>
<p>with this:</p>
<p class="programlisting">int count13 = 0;<br/>std::for_each(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;[&#38;count13](int x){count13 += x % 13 == 0;});</p>
<p>The <code>[&#38;count13]</code> allows the lambda to use <code>count13</code> in its code. Because <code>count13</code> is captured by reference, any changes to <code>count13</code> in the lambda are changes to the original <code>count13</code>. The expression <code>x % 13 == 0</code> evaluates to <code>true</code> if <code>x</code> is divisible by <code>13</code>, and <code>true</code> converts to <code>1</code> when added to <code>count13</code>. Similarly, <code>false</code> converts to <code>0</code>. Thus, after <code>for_each()</code> applies the lambda expression to each element of <code>numbers</code>, <code>count13</code> counts the number of elements divisible by 13.</p>
<p><a id="page_1190"/>You can use this technique to count elements divisible by 3 and elements divisible by 13 using a single lambda expression:</p>
<p class="programlisting">int count3 = 0;<br/>int count13 = 0;<br/>std::for_each(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;[&#38;](int x){count3 += x % 3 == 0; count13 += x % 13 == 0;});</p>
<p>This time, <code>[&#38;]</code> makes all the automatic variables, including <code>count3</code> and <code>count13</code>, available to the lambda expression.</p>
<p><a href="#ch18ex05">Listing 18.5</a> puts these techniques to use.</p>
<p class="caption1"><a id="ch18ex05"/><strong>Listing 18.5. <code>lambda1.cpp</code></strong></p><hr/>
<p class="programlisting1">// lambda1.cpp -- use captured variables<br/>#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cmath&gt;<br/>#include &lt;ctime&gt;<br/>const long Size = 390000L;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;std::vector&lt;int&gt; numbers(Size);<br/><br/>&#160;&#160;&#160;&#160;std::srand(std::time(0));<br/>&#160;&#160;&#160;&#160;std::generate(numbers.begin(), numbers.end(), std::rand);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sample size = " &lt;&lt; Size &lt;&lt; '\n';<br/>// using lambdas<br/>&#160;&#160;&#160;&#160;int count3 = std::count_if(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int x){return x % 3 == 0;});<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 3: " &lt;&lt; count3 &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;int count13 = 0;<br/>&#160;&#160;&#160;&#160;std::for_each(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&#38;count13](int x){count13 += x % 13 == 0;});<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 13: " &lt;&lt; count13 &lt;&lt; '\n';<br/>// using a single lambda<br/>&#160;&#160;&#160;&#160;count3 = count13 = 0;<br/>&#160;&#160;&#160;&#160;std::for_each(numbers.begin(), numbers.end(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&#38;](int x){count3 += x % 3 == 0; count13 += x % 13 == 0;});<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 3: " &lt;&lt; count3 &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Count of numbers divisible by 13: " &lt;&lt; count13 &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1191"/>Here is a sample output:</p>
<p class="programlisting">Sample size = 390000<br/>Count of numbers divisible by 3: 130274<br/>Count of numbers divisible by 13: 30009<br/>Count of numbers divisible by 3: 130274<br/>Count of numbers divisible by 13: 30009</p>
<p>It&#8217;s reassuring that both approaches (two separate lambdas and a single lambda) in this program led to the same answers.</p>
<p>The main motivation for adding lambdas to C++ was to enable using a function-like expression as an argument to a function expecting a function pointer or functor as an argument. So the typical lambda would be a test expression or comparison expression that could be written as a single return statement. That keeps the lambda short and easy to understand and enables automatic deduction of the return value. However, it is likely that a subset of the ingenious C++ programming community will develop other uses.</p>
<h3 id="ch18lev1sec5">Wrappers</h3>
<p>C++ provides several <em>wrappers</em> or <em>adapters</em>. These are objects used to provide a more uniform or more appropriate interface for other programming elements. For example, <a href="ch16.html#ch16">Chapter 16</a> described <code>bind1st</code> and <code>bind2nd</code>, which adapt functions with two parameters to match up with STL algorithms that expect functions with one parameter to be supplied as an argument. C++11 provides additional wrappers. They include the <code>bind</code> template, which provides a more flexible alternative to <code>bind1st</code> and <code>bind2nd</code>, the <code>mem_fn</code> template, which allows a member function to pass as a regular function, the <code>reference_wrappe</code>r template allows you to create an object that acts like reference but which can be copied, and the <code>function</code> wrapper, which provides a way to handle several function-like forms uniformly.</p>
<p>Let&#8217;s look more closely at one example of wrapper, the <code>function</code> wrapper, and at the problem it addresses.</p>
<h4 id="ch18lev2sec23">The <code>function</code> Wrapper and Template Inefficiencies</h4>
<p>Consider the following line of code:</p>
<p class="programlisting">answer = ef(q);</p>
<p>What is <code>ef</code>? It could be the name of a function. It could be a pointer to a function. It could be a function object. It could be a name assigned to a lambda expression. These all are examples of <em>callable types</em>. The abundance of callable types can lead to template inefficiencies. To see this, let&#8217;s examine a simple case.</p>
<p>First, let&#8217;s define some templates in a header file, as shown in <a href="#ch18ex06">Listing 18.6</a>.</p>
<p class="caption1"><a id="page_1192"/><a id="ch18ex06"/><strong>Listing 18.6. <code>somedefs.h</code></strong></p><hr/>
<p class="programlisting1">// somedefs.h<br/>#include &lt;iostream&gt;<br/><br/>template &lt;typename T, typename F&gt;<br/>T use_f(T v, F f)<br/>{<br/>&#160;&#160;&#160;&#160;static int count = 0;<br/>&#160;&#160;&#160;&#160;count++;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "&#160;&#160;use_f count = " &lt;&lt; count<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ", &#38;count = " &lt;&lt; &#38;count &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;return f(v);<br/>}<br/><br/>class Fp<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double z_;<br/>public:<br/>&#160;&#160;&#160;&#160;Fp(double z = 1.0) : z_(z) {}<br/>&#160;&#160;&#160;&#160;double operator()(double p) { return z_*p; }<br/>};<br/><br/>class Fq<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double z_;<br/>public:<br/>&#160;&#160;&#160;&#160;Fq(double z = 1.0) : z_(z) {}<br/>&#160;&#160;&#160;&#160;double operator()(double q) { return z_+ q; }<br/>};</p><hr/>
<p>The <code>use_f()</code> template uses the parameter f to represent a callable type:</p>
<p class="programlisting">return f(v);</p>
<p>Next the program in <a href="#ch18ex07">Listing 18.7</a> calls the <code>use_f()</code> template function six times.</p>
<p class="caption1"><a id="ch18ex07"/><strong>Listing 18.7. <code>callable.cpp</code></strong></p><hr/>
<p class="programlisting1">// callable.cpp -- callable types and templates<br/>#include "somedefs.h"<br/>#include &lt;iostream&gt;<br/><br/>double dub(double x) {return 2.0*x;}<br/>double square(double x) {return x*x;}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;double y = 1.21;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Function pointer dub:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, dub) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Function pointer square:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, square) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Function object Fp:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, Fp(5.0)) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Function object Fq:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, Fq(5.0)) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Lambda expression 1:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, [](double u) {return u*u;}) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Lambda expression 2:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, [](double u) {return u+u/2.0;}) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1193"/>The template parameter <code>T</code> is set to type <code>double</code> for each call. What about template parameter <code>F</code>? Each time the actual argument is something that takes a type <code>double</code> argument and returns a type <code>double</code> value, so it might seem that <code>F</code> would be the same type for all six calls to <code>use_f()</code> and that the template would be instantiated just once. But as the following sample output shows, that belief is na&#239;ve:</p>
<p class="programlisting">Function pointer dub:<br/>&#160;&#160;use_f count = 1, &#38;count = 0x402028<br/>&#160;&#160;2.42<br/>Function pointer square:<br/>&#160;&#160;use_f count = 2, &#38;count = 0x402028<br/>&#160;&#160;1.1<br/>Function object Fp:<br/>&#160;&#160;use_f count = 1, &#38;count = 0x402020<br/>&#160;&#160;6.05<br/>Function object Fq:<br/>&#160;&#160;use_f count = 1, &#38;count = 0x402024<br/>&#160;&#160;6.21<br/>Lambda expression 1:<br/>&#160;&#160;use_f count = 1, &#38;count = 0x405020<br/>&#160;&#160;1.4641<br/>Lambda expression 2:<br/>&#160;&#160;use_f count = 1, &#38;count = 0x40501c<br/>&#160;&#160;1.815</p>
<p><a id="page_1194"/>The template function <code>use_f()</code> has a static member <code>count</code>, and we can use its address to see how many instantiations are made. There are five distinct addresses, so there must have been five distinct instantiations of the <code>use_f()</code> template.</p>
<p>To see what is happening, consider how the compiler determines the type for the <code>F</code> template parameter. First, look at this call:</p>
<p class="programlisting">use_f(y, dub);</p>
<p>Here <code>dub</code> is the name of a function that takes a <code>double</code> argument and returns a <code>double</code> value. The name of a function is a pointer, hence the parameter <code>F</code> becomes type <code>double (*)(double)</code>, a pointer to a function with a <code>double</code> argument and a <code>double</code> return value.</p>
<p>The next call is this:</p>
<p class="programlisting">use_f(y, square);</p>
<p>Again, the second argument is type <code>double (*)(double)</code>, so this call uses the same instantiation of <code>use_f()</code> as the first call.</p>
<p>The next two calls to <code>use_f()</code> have objects as second arguments, so <code>F</code> becomes type <code>Fp</code> and <code>Fq</code> respectively, so we get two new instantiations for these values of <code>F</code>. Finally, the last two calls set <code>F</code> to whatever types the compiler uses for lambda expressions.</p>
<h4 id="ch18lev2sec24">Fixing the Problem</h4>
<p>The function wrapper lets you rewrite the program so that it uses just one instantiation of <code>use_f()</code> instead of five. Note that the function pointers, function objects, and lambda expressions in <a href="#ch18ex07">Listing 18.7</a> share a common behavior&#8212;each takes one type <code>double</code> argument and each returns a type <code>double</code> value. We can say that each has the same <em>call signature</em>, which is described by the return type followed by a comma-separated list of parameter types enclosed in a pair of parentheses. Thus, these six examples all have <code>double(double)</code> as the call signature.</p>
<p>The <code>function</code> template, declared in the <code>functional</code> header file, specifies an object in terms of a call signature, and it can be used to wrap a function pointer, function object, or lambda expression having the same call signature. For example, the following declaration creates a <code>function</code> object <code>fdci</code> that takes a <code>char</code> and an <code>int</code> argument and returns type <code>double</code>:</p>
<p class="programlisting">std::function&lt;double(char, int)&gt; fdci;</p>
<p>You can then assign to <code>fdci</code> any function pointer, function object, or lambda expression that takes type <code>char</code> and <code>int</code> arguments and returns type <code>double</code>.</p>
<p>The various callable arguments in <a href="#ch18ex07">Listing 18.7</a> all have the same call signature &#8211; <code>double(double)</code>. So to fix <a href="#ch18ex07">Listing 18.7</a> and reduce the number of instantiations, we can use <code>function&lt;double(double)&gt;</code> to create six wrappers for the six functions, functors, and lambdas. Then all six calls to <code>use_f()</code> can be made with the same type (<code>function&lt;double(double)&gt;</code>) for <code>F</code>, resulting in just one instantiation. <a href="#ch18ex08">Listing 18.8</a> shows the result.</p>
<p class="caption1"><a id="page_1195"/><a id="ch18ex08"/><strong>Listing 18.8. <code>wrapped.cpp</code></strong></p><hr/>
<p class="programlisting1">//wrapped.cpp -- using a function wrapper as an argument<br/>#include "somedefs.h"<br/>#include &lt;iostream&gt;<br/>#include &lt;functional&gt;<br/><br/>double dub(double x) {return 2.0*x;}<br/>double square(double x) {return x*x;}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;using std::function;<br/><br/>&#160;&#160;&#160;&#160;double y = 1.21;<br/>&#160;&#160;&#160;&#160;function&lt;double(double)&gt; ef1 = dub;<br/>&#160;&#160;&#160;&#160;function&lt;double(double)&gt; ef2 = square;<br/>&#160;&#160;&#160;&#160;function&lt;double(double)&gt; ef3 = Fq(10.0);<br/>&#160;&#160;&#160;&#160;function&lt;double(double)&gt; ef4 = Fp(10.0);<br/>&#160;&#160;&#160;&#160;function&lt;double(double)&gt; ef5 =&#160;&#160;[](double u) {return u*u;};<br/>&#160;&#160;&#160;&#160;function&lt;double(double)&gt; ef6 =&#160;&#160;[](double u) {return u+u/2.0;};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Function pointer dub:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, ef1) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Function pointer square:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, ef2) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Function object Fp:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, ef3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Function object Fq:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, ef4) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Lambda expression 1:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y, ef5) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Lambda expression 2:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f(y,ef6) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample output:</p>
<p class="programlisting">Function pointer dub:<br/>&#160;&#160;use_f count = 1, &#38;count = 0x404020<br/>&#160;&#160;2.42<br/>Function pointer sqrt:<br/>&#160;&#160;use_f count = 2, &#38;count = 0x404020<br/>&#160;&#160;1.1<br/><a id="page_1196"/>Function object Fp:<br/>&#160;&#160;use_f count = 3, &#38;count = 0x404020<br/>&#160;&#160;11.21<br/>Function object Fq:<br/>&#160;&#160;use_f count = 4, &#38;count = 0x404020<br/>&#160;&#160;12.1<br/>Lambda expression 1:<br/>&#160;&#160;use_f count = 5, &#38;count = 0x404020<br/>&#160;&#160;1.4641<br/>Lambda expression 2:<br/>&#160;&#160;use_f count = 6, &#38;count = 0x404020<br/>&#160;&#160;1.815</p>
<p>As you can see from the output, there is just one address for <code>count</code>, and the value of <code>count</code> shows <code>use_f()</code> has been called six times. So we now have just one instantiation invoked six times, reducing the size of the executable code.</p>
<h4 id="ch18lev2sec25">Further Options</h4>
<p>Let&#8217;s look at a couple more things you can do using <code>function</code>. First, we don&#8217;t actually have to declare six <code>function&lt;double(double)&gt;</code> objects in <a href="#ch18ex08">Listing 18.8</a>. Instead, we can use a temporary <code>function&lt;double(double)&gt;</code> object as an argument to the <code>use_f()</code> function:</p>
<p class="programlisting">typedef function&lt;double(double)&gt; fdd; // simplify the type declaration<br/>cout &lt;&lt; use_f(y, fdd(dub)) &lt;&lt; endl;&#160;&#160;&#160;// create and initialize object to dub<br/>cout &lt;&lt; use_f(y, fdd(square)) &lt;&lt; endl;<br/>...</p>
<p>Second, <a href="#ch18ex08">Listing 18.8</a> adapts the second arguments in <code>use_f()</code> to match the formal parameter <code>f</code>. Another approach is to adapt the type of the formal parameter <code>f</code> to match the original arguments. This can be done by using a function wrapper object as the second parameter for the <code>use_f()</code> template definition. We can define <code>use_f()</code> this way:</p>
<p class="programlisting">#include &lt;functional&gt;<br/>template &lt;typename T&gt;<br/>T use_f(T v,&#160;&#160;std::function&lt;T(T)&gt; f)&#160;&#160;&#160;// f call signature is T(T)<br/>{<br/>&#160;&#160;&#160;&#160;static int count = 0;<br/>&#160;&#160;&#160;&#160;count++;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "&#160;&#160;use_f count = " &lt;&lt; count<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ", &#38;count = " &lt;&lt; &#38;count &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;return f(v);<br/>}</p>
<p>Then the function calls can look like this:</p>
<p class="programlisting">cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f&lt;double&gt;(y, dub) &lt;&lt; endl;<br/>...<br/><a id="page_1197"/>cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f&lt;double&gt;(y, Fp(5.0)) &lt;&lt; endl;<br/>...<br/>cout &lt;&lt; "&#160;&#160;" &lt;&lt; use_f&lt;double&gt;(y, [](double u) {return u*u;}) &lt;&lt; endl;</p>
<p>The arguments <code>dub</code>, <code>Fp(5.0</code>), etc., are not themselves type <code>function&lt;double(double)&gt;</code>, and so the calls use <code>&lt;double&gt;</code> after <code>use_f</code> to indicate the desired specialization. Thus <code>T</code> is set to <code>double</code>, and <code>std::function&lt;T(T)&gt;</code> becomes <code>std::function&lt;double(double)&gt;</code>.</p>
<h3 id="ch18lev1sec6">Variadic Templates</h3>
<p>Variadic templates provide a means to create template functions and template classes that accept a variable number of arguments. We&#8217;ll look at variadic template functions here. For example, suppose we want a function that will accept any number of parameters of any type, providing the type can be displayed with <code>cout</code>, and display the arguments as a comma-separated list. For instance, consider this code:</p>
<p class="programlisting">int n = 14;<br/>double x = 2.71828;<br/>std::string mr = "Mr. String objects!";<br/>show_list(n, x);<br/>show_list(x*x, '!', 7, mr);</p>
<p>The goal is to be able to define <code>show_list()</code> in such a way that this code would compile and lead to this output:</p>
<p class="programlisting">14, 2.71828<br/>7.38905, !, 7, Mr. String objects!</p>
<p>There are a few key points to understand in order to create variadic templates:</p>
<p class="indenthandingB">&#8226; Template parameter packs</p>
<p class="indenthandingB">&#8226; Function parameter packs</p>
<p class="indenthandingB">&#8226; Unpacking a pack</p>
<p class="indenthandingB">&#8226; Recursion</p>
<h4 id="ch18lev2sec26">Template and Function Parameter Packs</h4>
<p>As a starting point to see how parameter packs work, let&#8217;s consider a simple template function, one that displays a list consisting of just one item:</p>
<p class="programlisting">template&lt;typename T&gt;<br/>void show_list0(T value)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; value &lt;&lt; ", ";<br/>}</p>
<p><a id="page_1198"/>This definition has two parameter lists. The template parameter list is just <code>T</code>. The function parameter list is just <code>value</code>. A function call such as the following sets <code>T</code> in the template parameter list to <code>double</code> and <code>value</code> in the function parameter list to <code>2.15</code>:</p>
<p class="programlisting">show_list0(2.15);</p>
<p>C++11 provides an ellipsis meta-operator that enables you to declare an identifier for a template parameter pack, essentially a list of types. Similarly, it lets you declare an identifier for a function parameter pack, essentially a list of values. The syntax looks like this:</p>
<p class="programlisting">template&lt;typename... Args&gt;&#160;&#160;&#160;&#160;// Args is a template parameter pack<br/>void show_list1(Args... args) // args is a function parameter pack<br/>{<br/>...<br/>}</p>
<p><code>Args</code> is a template parameter pack, and <code>args</code> is a function parameter pack. (As with other parameter names, any name satisfying C++ identifier rules can be used for these packs.) The difference between <code>Args</code> and <code>T</code> is that <code>T</code> matches a single type, whereas <code>Args</code> matches any number of types, including none. Consider the following function call:</p>
<p class="programlisting">show_list1('S', 80, "sweet", 4.5);</p>
<p>In this case the parameter pack <code>Args</code> contains the types matching the parameters in the function call: <code>char</code>, <code>int</code>, <code>const char *</code>, and <code>double</code>.</p>
<p>Next, much as</p>
<p class="programlisting">void show_list0(T value)</p>
<p>states that <code>value</code> is of type <code>T</code>, the line</p>
<p class="programlisting">void show_list1(Args... args)&#160;&#160;// args is a function parameter pack</p>
<p>states that <code>args</code> is of type <code>Args</code>. More precisely, this means that the function pack <code>args</code> contains a list of values that matches the list of types in the template pack <code>Args</code>, both in type and in number. In this case, <code>args</code> contains the values <code>'S'</code>, <code>80</code>, <code>"sweet"</code>, and <code>4.5</code>.</p>
<p>In this manner, the <code>show_list1()</code> variadic template can match any of the following function calls:</p>
<p class="programlisting">show_list1();<br/>show_list1(99);<br/>show_list1(88.5, "cat");<br/>show_list1(2,4,6,8, "who do we", std::string("appreciate));</p>
<p>In the last case, the <code>Args</code> template parameter pack would contain the types <code>int</code>, <code>int</code>, <code>int</code>, <code>int</code>, <code>const char *</code>, and <code>std::string</code>, and the <code>args</code> function parameter pack would contain the matching values <code>2</code>, <code>4</code>, <code>6</code>, <code>8</code>, <code>"who do we"</code>, and <code>std::string("appreciate")</code>.</p>
<h4 id="ch18lev2sec27">Unpacking the Packs</h4>
<p>But how can the function access the contents of these packs? There is no indexing feature. That is, you can&#8217;t use something like <code>Args[2]</code> to access the third type in a pack. <a id="page_1199"/>Instead, you can unpack the pack by placing the ellipsis to the right of the function parameter pack name. For example, consider the following flawed code:</p>
<p class="programlisting">template&lt;typename... Args&gt;&#160;&#160;&#160;&#160;// Args is a template parameter pack<br/>void show_list1(Args... args) // args is a function parameter pack<br/>{<br/>&#160;&#160;&#160;&#160;show_list1(args...); // passes unpacked args to show_list1()<br/>}</p>
<p>What does this mean, and why is it flawed? Suppose we have this function call:</p>
<p class="programlisting">show_list1(5,'L',0.5);</p>
<p>The call packs the values <code>5</code>, <code>'L'</code>, and <code>0.5</code> into <code>args</code>. Within the function, the call</p>
<p class="programlisting">show_list1(args...);</p>
<p>expands to the following:</p>
<p class="programlisting">show_list1(5,'L',0.5);</p>
<p>That is, the single entity <code>args</code> is replaced by the three values stored within the pack. So the notation <code>args...</code> expands to a list of discrete function arguments. Unfortunately, the new call is the same as the original function call, so it will call itself again with the same arguments, initiating an infinite and futile recursion. (That would be the flaw.)</p>
<h4 id="ch18lev2sec28">Using Recursion in Variadic Template Functions</h4>
<p>Although recursion dooms <code>show_list1()</code> aspirations to be a useful function, properly used recursion provides a solution to accessing pack items. The central idea is to unpack the function parameter pack, process the first item in the list, then pass the rest of the list on to a recursive call, and so on, until the list is empty. As usual with recursion, it&#8217;s important to make sure that there is a call that terminates the recursion. Part of the trick involves changing the template heading to this:</p>
<p class="programlisting">template&lt;typename T, typename... Args&gt;<br/>void show_list3( T value, Args... args)</p>
<p>With this definition, the first argument to <code>show_list3()</code> gets picked up as type <code>T</code> and is assigned to <code>value</code>. The remaining arguments are picked up by <code>Args</code> and <code>args</code>. This allows the function to do something with <code>value</code>, such as display it. Then the remaining arguments, in the form <code>args...</code>, can be passed to a recursive call of <code>show_list3()</code>. Each recursive call then prints a value and passes on a shortened list until the list is exhausted.</p>
<p><a href="#ch18ex09">Listing 18.9</a> presents an implementation that, although not perfect, illustrates the technique.</p>
<p class="caption1"><a id="ch18ex09"/><strong>Listing 18.9. <code>variadic1.cpp</code></strong></p><hr/>
<p class="programlisting1">//variadic1.cpp -- using recursion to unpack a parameter pack<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>// definition for 0 parameters -- terminating call<br/>void show_list3() {}<br/><br/>// definition for 1 or more parameters<br/>template&lt;typename T, typename... Args&gt;<br/>void show_list3( T value, Args... args)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; value &lt;&lt; ", ";<br/>&#160;&#160;&#160;&#160;show_list3(args...);<br/>}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;int n = 14;<br/>&#160;&#160;&#160;&#160;double x = 2.71828;<br/>&#160;&#160;&#160;&#160;std::string mr = "Mr. String objects!";<br/>&#160;&#160;&#160;&#160;show_list3(n, x);<br/>&#160;&#160;&#160;&#160;show_list3(x*x, '!', 7, mr);<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<h5 id="ch18lev3sec15">Program Notes</h5>
<p><a id="page_1200"/>Consider this function call:</p>
<p class="programlisting">show_list3(x*x, '!', 7, mr);</p>
<p>The first argument matches <code>T</code> to <code>double</code> and <code>value</code> to <code>x*x</code>. The remaining three types (<code>char</code>, <code>int</code>, and <code>std::string</code>) are placed in the <code>Args</code> pack, and the remaining three values (<code>'!'</code>, <code>7</code>, and <code>mr</code>) are placed in the <code>args</code> pack.</p>
<p>Next, the <code>show_list3()</code> function uses <code>cout</code> to display <code>value</code> (approximately <code>7.38905</code>) and the string <code>", "</code>. That takes care of displaying the first item in the list.</p>
<p>Next comes this call:</p>
<p class="programlisting">show_list3(args...);</p>
<p>This, given the expansion of <code>args...</code>, is the same as the following:</p>
<p class="programlisting">show_list3('!', 7, mr);</p>
<p>As promised, the list is shortened by one item. This time <code>T</code> and <code>value</code> become <code>char</code> and <code>'!'</code>, and the remaining two types and values are packed into <code>Args</code> and <code>args</code>, respectively. The next recursive call processes these reduced packs. Finally, when <code>args</code> is empty, the version of <code>show_list3()</code> with no arguments is called, and the process terminates.</p>
<p>Here is the output for the two function calls in <a href="#ch18ex05">Listing 18.5</a>:</p>
<p class="programlisting">14, 2.71828, 7.38905, !, 7, Mr. String objects!,</p>
<h5 id="ch18lev3sec16">Improvements</h5>
<p><a id="page_1201"/>We can improve <code>show_list3()</code> with a couple of changes. As it stands, the function displays a comma after every item in the list, but it would be better to omit the comma after the last item. This can be accomplished by adding a template for just one item and having it behave slightly differently from the general template:</p>
<p class="programlisting">// definition for 1 parameter<br/>template&lt;typename T&gt;<br/>void show_list3(T value)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; value &lt;&lt; '\n';<br/>}</p>
<p>Thus, when the <code>args</code> pack is reduced to one item, this version is called, and it prints a newline instead of a comma. Because it lacks a recursive call to <code>show_list3()</code>, it also terminates the recursion.</p>
<p>The second area for improvement is that the current version passes everything by value. This is okay for the simple types we&#8217;ve used, but it&#8217;s inefficient for classes of large size that might be printable by <code>cout</code>. It would be better to use <code>const</code> references. With variadic templates, you can impose a <em>pattern</em> on the unpacking. Instead of using</p>
<p class="programlisting">show_list3(Args... args);</p>
<p>you can use this:</p>
<p class="programlisting">show_list3(const Args&#38;... args);</p>
<p>That will cause each function parameter to have the <code>const&#38;</code> pattern applied. Thus, instead of <code>std::string mr</code>, the final paring of parameters becomes <code>const std::string&#38; mr</code>.</p>
<p><a href="#ch18ex10">Listing 18.10</a> incorporates these two changes.</p>
<p class="caption1"><a id="ch18ex10"/><strong>Listing 18.10. <code>variadic2.cpp</code></strong></p><hr/>
<p class="programlisting1">// variadic2.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/><br/>// definition for 0 parameters<br/>void show_list() {}<br/><br/>// definition for 1 parameter<br/>template&lt;typename T&gt;<br/>void show_list(const T&#38; value)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; value &lt;&lt; '\n';<br/>}<br/><br/>// definition for 2 or more parameters<br/>template&lt;typename T, typename... Args&gt;<br/>void show_list(const T&#38; value, const Args&#38;... args)<br/>{<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; value &lt;&lt; ", ";<br/>&#160;&#160;&#160;&#160;show_list(args...);<br/>}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;int n = 14;<br/>&#160;&#160;&#160;&#160;double x = 2.71828;<br/>&#160;&#160;&#160;&#160;std::string mr = "Mr. String objects!";<br/>&#160;&#160;&#160;&#160;show_list(n, x);<br/>&#160;&#160;&#160;&#160;show_list(x*x, '!', 7, mr);<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1202"/>Here is the output:</p>
<p class="programlisting">14, 2.71828<br/>7.38905, !, 7, Mr. String objects!</p>
<h3 id="ch18lev1sec7">More C++11 Features</h3>
<p>C++11 adds many more features than this book can cover, even ignoring the fact that many of them are not widely implemented at the time this book was written. Still, it&#8217;s worth taking a quick look at the nature of some of these features.</p>
<h4 id="ch18lev2sec29">Concurrent Programming</h4>
<p>These days it&#8217;s easier to improve computer performance by adding processors than it is to increase processor speed. So computers with dual-core or quad-core processors or even with multiple multicore processors are the norm. This enables computers to run multiple threads of execution simultaneously. One processor might handle a video download while another processor handles your spreadsheet.</p>
<p>Some activities can benefit from multiple threads, whereas others don&#8217;t. Consider searching for something in a singly linked list. A program has to start at the beginning and follow the links, in order, to the end of the list; there&#8217;s nothing much a second thread could do to help. Now consider an unsorted array. Using the random access feature of arrays, you could start one thread from the beginning of the array and one from the middle, thus halving the search time.</p>
<p>Multiple threads do raise many problems. What happens if one thread hangs up or if two threads try to access the same data simultaneously? C++11 addresses concurrency by <a id="page_1203"/>defining a memory model that supports threaded execution, by adding the keyword <code>thread_local</code>, and by providing library support. The keyword <code>thread_local</code> is used to declare variables having static storage duration relative to a particular thread; that is, they expire when the thread in which they are defined expires.</p>
<p>The library support consists of the atomic operations library, which specifies the <code>atomic</code> header file, and the thread support library, which specifies the <code>thread</code>, <code>mutex</code>, <code>condition_variable</code>, and <code>future</code> header files.</p>
<h4 id="ch18lev2sec30">Library Additions</h4>
<p>C++11 adds several specialized libraries. An extensible random number library, supported by the <code>random</code> header file, provides much more extensive and sophisticated random number facilities than <code>rand()</code>. For example, it offers a choice of random-number generators and a choice of distributions, including uniform (like <code>rand()</code>), binomial, normal, and several others.</p>
<p>The <code>chrono</code> header file supports ways to deal with time duration.</p>
<p>The <code>tuple</code> header file supports the <code>tuple</code> template. A <code>tuple</code> object is a generalization of a <code>pair</code> object. Whereas a <code>pair</code> object can hold two values whose types need not be the same, a <code>tuple</code> can hold an arbitrary number of items of different types.</p>
<p>The compile-time rational arithmetic library, supported by the <code>ratio</code> header file, allows the exact representation of any rational number whose numerator and denominator can be represented by the widest integer type. It also provides arithmetic operations for these numbers.</p>
<p>One of the most interesting additions is a regular expression library, supported by the <code>regex</code> header file. A regular expression specifies a pattern that can be used to match contents in a text string. For example, a bracket expression matches any single character in the brackets. Thus, <code>[cCkK]</code> matches a single <code>c</code>, <code>C</code>, <code>k</code>, or <code>K</code>, and <code>[cCkK]at</code> matches the words <code>cat</code>, <code>Cat</code>, <code>kat</code>, and <code>Kat</code>. Other patterns include <code>\d</code> for a digit, <code>\w</code> for a word, <code>\t</code> for a tab, and many, many others. The fact that a backslash has a special meaning in C++ as the first character in an escape sequence requires a pattern like <code>\d\t\w\d</code> (that is, digit-tab-word-digit) to be written as the string literal <code>"\\d\\t\\w\\d"</code>, using <code>\\</code> to represent <code>\</code>. This is one reason the raw string was introduced (see <a href="ch04.html#ch04">Chapter 4</a>); it enables you to write the same pattern as <code>R"\d\t\w\t"</code>.</p>
<p>Unix utilities such as <code>ed</code>, <code>grep</code>, and <code>awk</code> used regular expressions, and the interpreted language Perl extended their capabilities. The C++ regular expressions library allows you to choose from several flavors of regular expressions.</p>
<h4 id="ch18lev2sec31">Low-Level Programming</h4>
<p>The &#8220;low level&#8221; in low-level programming refers to the level of abstraction, not to the quality of the programming. Low level means closer to the bits and bytes of computer hardware and machine language. Low-level programming is important for embedded programming and for increasing the efficiency of some operations. C++11 offers some aids to those who do low-level programming.</p>
<p><a id="page_1204"/>One change is relaxing the constraints on what qualifies as &#8220;Plain Old Data,&#8221; or POD. In C++98, a POD is a scalar type (a one-value type, such as <code>int</code> or <code>double</code>) or an old-fashioned structure with no constructors, base classes, private data, virtual functions, and so on. The idea was that a POD is something for which it&#8217;s safe to make a byte-by-byte copy. That is still the idea, but C++11 recognizes one can remove some the C++98 restrictions and still have a viable POD. This helps low-level programming because some low-level operations, such as using the C functions for byte-wise copying or binary I/O, required PODs.</p>
<p>Another change is making unions more flexible by allowing them to have members that have constructors and destructors, but with some restrictions on other properties, for example, not allowing virtual functions. Unions are often utilized when minimizing the amount of memory used is important, and the new rules allow programmers to bring more flexibility and capability to these situations.</p>
<p>C++11 addresses memory alignment issues. Computer systems can restrict how data is stored in memory. For example, one system might require that a <code>double</code> value be stored at an even-numbered memory location, whereas another might require the storage to begin at a location that is a multiple of eight. The <code>alignof()</code> operator (see <a href="app05.html#app05">Appendix E</a>, &#8220;<a href="app05.html#app05">Other Operators</a>&#8221;) provides information on the alignment requirements for a type or object. The <code>alignas</code> specifier provides some control over the alignment used.</p>
<p>The <code>constexpr</code> mechanism expands the ability of the compiler to evaluate during compile time expressions that evaluate to a constant value. The low-level aspect of this is to allow <code>const</code> variables to be stored in read-only memory, which can be particularly useful in embedded programming. (Variables, <code>const</code> or otherwise, that are initialized during runtime, are stored in random-access memory.)</p>
<h4 id="ch18lev2sec32">Miscellaneous</h4>
<p>C++11 follows the lead of C99 in allowing for implementation-dependent extended integer types. Such types, for example, could be used on a system with 128-bit integers. Extended types are supported in the C header file <code>stdint.h</code> and in the C++ version, <code>cstdint</code>.</p>
<p>C++11 provides a mechanism, the <em>literal operator</em>, for creating user-defined literals. Using this mechanism, for instance, one can define binary literals, such as <code>1001001b</code>, which the corresponding literal operator will convert to an integer value.</p>
<p>C++ has a debugging tool called <code>assert</code>. It is a macro that checks during runtime if an assertion is true and which displays a message and calls <code>abort()</code> if the assertion is false. The assertion would typically be about something the programmer thinks should be true at that point in the program. C++11 adds the keyword <code>static_assert</code>, which can be used to test assertions during compile time. The primary motivation is to make it easier to debug templates for which instantiation takes place during compile time, not runtime.</p>
<p>C++11 provides more support for metaprogramming, which is creating programs that create or modify other programs or even themselves. In C++ this can be done during compile time using templates.</p>
<h3 id="ch18lev1sec8">Language Change</h3>
<p><a id="page_1205"/>How does a computer language grow and evolve? after usage of C++ became sufficiently widespread, the need for an international standard became clear, and control of the language essentially passed to a standards committee&#8212;first the ANSI committee, then the joint ISO/ANSI committees, and currently to ISO/IEC JTC1/SC22/WG21 (the C++ Standards Committee). ISO is the International Organization for Standardization, IEC is the International Electrotechnical Commission, JTC1 is the Joint Technical Committee 1 of the preceding two organizations, SC22 is the JTC1 subcommittee for programming languages, and WG21 is the SC22 working group for C++.</p>
<p>The committee considers defect reports and proposals for changes in and extensions to the language, and it attempts to reach a consensus. This is neither a speedy nor a simple process. <em>The Design and Evolution of C++</em> (Stroustrup, Addison-Wesley, 1994) provides some insight on this subject. Anyway, the possibly contentious and ponderous dynamics of a consensus-seeking committee are not the best way to encourage the blossoming of a multitude of innovations. Nor is that the proper role of a standards committee.</p>
<p>But with C++ there is a second avenue for change: direct action by the creative C++ programming community. Programmers can&#8217;t independently change the language, but they can create useful libraries. Well-designed libraries can extend the usefulness and versatility of the language, increase reliability, and make programming easier and more enjoyable. Libraries build on the existing features of a language, so they don&#8217;t require any additional compiler support. And if they are implemented through templates, they can be distributed as text files in the form of header files.</p>
<p>One example of this sort of change is the STL, primarily created by Alexander Stepanov, and made freely available by Hewlett-Packard. Its success with the programming community made it a candidate for the first ANSI/ISO standard. Indeed, its design influenced other aspects of the emerging standard.</p>
<h4 id="ch18lev2sec33">The Boost Project</h4>
<p>More recently, the Boost library has become an important part of C++ programming and has had a significant influence on C++11. The Boost project began in 1998 when Beman Dawes, the then-chairman of the C++ library working group, brought together a few other members of the group and developed a plan to generate new libraries outside the confines of the standards committee. The basic idea was to provide a website that acts as an open forum for people to post free C++ libraries. The project provides guidelines for licensing and programming practices, and it requires peer review of proposed libraries. The result is a group of highly praised and highly used libraries. The project provides an environment in which the programming community can test and evaluate programming ideas and provide feedback.</p>
<p>Boost has over 100 libraries at the time of this writing, and they can be downloaded as a set from <a href="http://www.boost.org">www.boost.org</a>, as can documentation. Most of the libraries can be used by including the appropriate header files.</p>
<h4 id="ch18lev2sec34">The TR1</h4>
<p><a id="page_1206"/>The Technical Report 1, or TR1, was a project of a subset of the C++ Standards committee. TR1 was a compilation of library extensions that were compatible with the C++98 standard, but which were not required by the standard. They were candidates for the next iteration of the standard. The TR1 library enabled the C++ community to test the worthiness of the library components. Thus, when the standards committee incorporated most of TR1 into C++11, it was dealing with known and proven libraries.</p>
<p>The Boost libraries contributed much to TR1. Examples include the <code>tuple</code> template class, the <code>array</code> template class, the <code>bind</code> and <code>function</code> templates, smart pointers (with some name and implementation changes), <code>static_assert</code>, the <code>regex</code> library, and the <code>random</code> library. Furthermore, the experiences of the Boost community and of users of the TR1 led to actual language changes, such as the deprecation of exception specifications, and the addition of variadic templates, which allows for a better implementation of the <code>tuple</code> template class and of the <code>function</code> template.</p>
<h4 id="ch18lev2sec35">Using Boost</h4>
<p>Although you now can access many Boost-developed libraries as part of the C++11 standard, there are many additional Boost libraries to explore. For example, <code>lexical_cast</code> from the Conversion library provides simple conversions between numeric and string types. The syntax is modeled after <code>dynamic_cast</code>, in which you provide the target type as a template parameter. <a href="#ch18ex11">Listing 18.11</a> shows a simple example.</p>
<p class="caption1"><a id="ch18ex11"/><strong>Listing 18.11. <code>lexcast.cpp</code></strong></p><hr/>
<p class="programlisting1">// lexcast.cpp -- simple cast from float to string<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include "boost/lexical_cast.hpp"<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your weight: ";<br/>&#160;&#160;&#160;&#160;float weight;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; weight;<br/>&#160;&#160;&#160;&#160;string gain = "A 10% increase raises ";<br/>&#160;&#160;&#160;&#160;string wt = boost::lexical_cast&lt;string&gt;(weight);<br/>&#160;&#160;&#160;&#160;gain = gain + wt + " to ";&#160;&#160;// string operator+()<br/>&#160;&#160;&#160;&#160;weight = 1.1 * weight;<br/>&#160;&#160;&#160;&#160;gain = gain + boost::lexical_cast&lt;string&gt;(weight) + ".";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; gain &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1207"/>Here are a couple of sample runs:</p>
<p class="programlisting">Enter your weight: <span class="EmpStrong">150</span><br/>A 10% increase raises 150 to 165.<br/><br/>Enter your weight: <span class="EmpStrong">156</span><br/>A 10% increase raises 156 to 171.600006.</p>
<p>The second sample run shows one of the limitations of <code>lexical_cast</code>; it doesn&#8217;t provide fine control over floating-point formatting. To get that, you need to use the more elaborate incore formatting facilities discussed in <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>.&#8221;</p>
<p>You also can use <code>lexical_cast</code> to convert strings to numeric values.</p>
<p>Obviously, there is much, much more to Boost. For example, the Any library allows you to store (and recover) a heterogeneous collection of values and objects of different types in an STL container, using the <code>Any</code> template as a wrapper for the various values. The Boost Math library extends the list of math functions beyond that of the standard math library. The Boost Filesystem library facilitates writing code that is portable across platforms using different file systems. You can refer to the Boost website (<a href="http://www.boost.org">www.boost.org</a>) to get more information about the contents of the library and how to add it to various platforms. Also some C++ distributions, such as the one from Cygwin, come with the Boost library included.</p>
<h3 id="ch18lev1sec9">What Now?</h3>
<p>If you have worked your way through this book, you should have a good grasp of the rules of C++. However, that&#8217;s just the beginning in learning this language. The second stage is learning to use the language effectively, and that is the longer journey. The best situation is to be in a work or learning environment that brings you into contact with good C++ code and programmers. Also now that you know C++, you can read books that concentrate on more advanced topics and on object-oriented programming. <a href="app08.html#app08">Appendix H</a>, &#8220;<a href="app08.html#app08">Selected Readings and Internet Resources</a>,&#8221; lists some of these resources.</p>
<p>One promise of OOP is to facilitate the development and enhance the reliability of large projects. One of the essential activities of the OOP approach is to invent the classes that represent the situation (called the <em>problem domain</em>) that you are modeling. Because real problems are often complex, finding a suitable set of classes can be challenging. Creating a complex system from scratch usually doesn&#8217;t work; instead, it&#8217;s best to take an iterative, evolutionary approach. Toward this end, practitioners in the field have developed several techniques and strategies. In particular, it&#8217;s important to do as much of the iteration and evolution in the analysis and design stages as possible instead of writing and rewriting actual code.</p>
<p>Two common techniques are <em>use-case analysis</em> and <em>CRC cards</em>. In use-case analysis, the development team lists the common ways, or scenarios, in which it expects the final system to be used, identifying elements, actions, and responsibilities that suggest possible <a id="page_1208"/>classes and class features. Using CRC (short for Class/Responsibilities/Collaborators) cards is a simple way to analyze such scenarios. The development team creates an index card for each class. On the card are the class name; class responsibilities, such as data represented and actions performed; and class collaborators, such as other classes with which the class must interact. Then the team can walk through a scenario, using the interface provided by the CRC cards. This can lead to suggestions for new classes, shifts of responsibility, and so on.</p>
<p>On a larger scale are the systematic methods for working on entire projects. The most recent of these is the Unified Modeling Language (UML). UML is not a programming language; rather, it is a language for representing the analysis and design of a programming project. It was developed by Grady Booch, Jim Rumbaugh, and Ivar Jacobson, who had been the primary developers of three earlier modeling languages: the Booch Method, OMT (Object Modeling Technique), and OOSE (Object-Oriented Software Engineering), respectively. UML is the evolutionary successor of these three, and ISO/IEC published a standard for it in 2005.</p>
<p>In addition to increasing your understanding of C++ in general, you might want to learn about specific class libraries. Microsoft and Embarcadero, for example, offer extensive class libraries to facilitate programming for the Windows environment, and Apple Xcode offers similar facilities for Apple products, including the iPhone.</p>
<h3 id="ch18lev1sec10">Summary</h3>
<p>The new C++ standard adds many features to the language. Some are intended to make the language easier to learn and easier to use. Examples include uniform braced list initialization, automatic type deduction with <code>auto</code>, in-class member initialization, and the range-based <code>for</code> loop. Other changes expand and clarify class design. These changes include defaulted and deleted methods, delegated constructors, inherited constructors, and the <code>override</code> and <code>final</code> specifiers for clarifying virtual function design.</p>
<p>Several additions aim to make programs and the act programming more efficient. Lambda expressions provide advantages over function pointers and functors. The <code>function</code> template can be used to reduce the number of template instantiations. The rvalue reference enables move semantics and allows for move constructors and move assignment operators.</p>
<p>Other changes deliver better ways of doing things. Scoped enumerations provide better control over the scope and underlying types for enumerations. The <code>unique_ptr</code> and <code>shared_ptr</code> templates provide better ways of handling memory allocated with <code>new</code>.</p>
<p>Template design has been enhanced with the addition of <code>decltype</code>, trailing return types, template aliases, and variadic templates.</p>
<p>Modified rules for unions, PODs, the <code>alignof()</code> operator, the <code>alignas</code> specifier, and the <code>constexpr</code> mechanism support low-level programming.</p>
<p>Several library additions, including the new STL classes, the <code>tuple</code> template, and the <code>regex</code> library, provide solutions to many common programming needs.</p>
<p><a id="page_1209"/>The new standard addresses concurrent programming with the <code>thread_local</code> keyword and the <code>atomic</code> library.</p>
<p>All in all, the new standard improves the usability and reliability of C++, both for novices and for experts.</p>
<h3 id="ch18lev1sec11">Chapter Review</h3>
<p class="question"><a id="ch18qa1q1" href="app10.html#ch18qa1a1"><strong>1.</strong></a> Rewrite the following code using braced initialization list syntax; the rewrite should dispense with using the array ar:</p>
<p class="programlistingB">class Z200<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;double z;<br/>public:<br/>&#160;&#160;&#160;&#160;Z200(int jv, char chv, zv) : j(jv), ch(chv), z(zv) {}<br/>...<br/>};<br/><br/>double x = 8.8;<br/>std::string s = "What a bracing effect!";<br/>int k(99);<br/>Z200 zip(200,'Z',0.675);<br/>std::vector&lt;int&gt; ai(5);<br/>int ar[5] = {3, 9, 4, 7, 1};<br/>for (auto pt = ai.begin(), int i = 0; pt != ai.end(); ++pt, ++i)<br/>&#160;&#160;&#160;&#160;*pt = ai[i];</p>
<p class="question"><a id="ch18qa1q2" href="app10.html#ch18qa1a2"><strong>2.</strong></a> For the following short program, which function calls are errors and why? For the valid calls, what does the reference argument refer to?</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>double up(double x) { return 2.0* x;}<br/>void r1(const double &#38;rx) {cout &lt;&lt; rx &lt;&lt; endl;}<br/>void r2(double &#38;rx) {cout &lt;&lt; rx &lt;&lt; endl;}<br/>void r3(double &#38;&#38;rx) {cout &lt;&lt; rx &lt;&lt; endl;}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double w = 10.0;<br/>&#160;&#160;&#160;&#160;r1(w);<br/>&#160;&#160;&#160;&#160;r1(w+1);<br/>&#160;&#160;&#160;&#160;r1(up(w));<br/><a id="page_1210"/>&#160;&#160;&#160;&#160;r2(w);<br/>&#160;&#160;&#160;&#160;r2(w+1);<br/>&#160;&#160;&#160;&#160;r2(up(w));<br/>&#160;&#160;&#160;&#160;r3(w);<br/>&#160;&#160;&#160;&#160;r3(w+1);<br/>&#160;&#160;&#160;&#160;r3(up(w));<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="question"><a id="ch18qa1q3" href="app10.html#ch18qa1a3"><strong>3.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> What does the following short program display and why?</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>double up(double x) { return 2.0* x;}<br/>void r1(const double &#38;rx) {cout &lt;&lt; "const double &#38; rx\n";}<br/>void r1(double &#38;rx) {cout &lt;&lt; "double &#38; rx\n";}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double w = 10.0;<br/>&#160;&#160;&#160;&#160;r1(w);<br/>&#160;&#160;&#160;&#160;r1(w+1);<br/>&#160;&#160;&#160;&#160;r1(up(w));<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="indenthandinga"><strong>b.</strong> What does the following short program display and why?</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>double up(double x) { return 2.0* x;}<br/>void r1(double &#38;rx) {cout &lt;&lt; "double &#38; rx\n";}<br/>void r1(double &#38;&#38;rx) {cout &lt;&lt; "double &#38;&#38; rx\n";}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double w = 10.0;<br/>&#160;&#160;&#160;&#160;r1(w);<br/>&#160;&#160;&#160;&#160;r1(w+1);<br/>&#160;&#160;&#160;&#160;r1(up(w));<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="indenthandinga"><strong>c.</strong> What does the following short program display and why?</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>using namespace std;<br/><br/><a id="page_1211"/>double up(double x) {return 2.0* x;}<br/>void r1(const double &#38;rx) {cout &lt;&lt; "const double &#38; rx\n";}<br/>void r1(double &#38;&#38;rx) {cout &lt;&lt; "double &#38;&#38; rx\n";}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double w = 10.0;<br/>&#160;&#160;&#160;&#160;r1(w);<br/>&#160;&#160;&#160;&#160;r1(w+1);<br/>&#160;&#160;&#160;&#160;r1(up(w));<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="question"><a id="ch18qa1q4" href="app10.html#ch18qa1a4"><strong>4.</strong></a> Which member functions are special member functions, and what makes them special?</p>
<p class="question"><a id="ch18qa1q5" href="app10.html#ch18qa1a5"><strong>5.</strong></a> Suppose the <code>Fizzle</code> class has only the data members shown:</p>
<p class="programlistingB">class Fizzle<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;double bubbles[4000];<br/>...<br/>};</p>
<p class="questionp">Why would this class not be a good candidate for a user-defined move constructor? What change in approach to storing the 4000 double values would make the class a good candidate for a move function?</p>
<p class="question"><a id="ch18qa1q6" href="app10.html#ch18qa1a6"><strong>6.</strong></a> Revise the following short program so that it uses a lambda expression instead of <code>f1()</code>. Don&#8217;t change <code>show2()</code>.</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>template&lt;typename T&gt;<br/>&#160;&#160;void show2(double x, T&#38; fp) {std::cout &lt;&lt; x &lt;&lt; " -&gt; " &lt;&lt; fp(x) &lt;&lt; '\n';}<br/>double f1(double x) { return 1.8*x + 32;}<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;show2(18.0, f1);<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="question"><a id="ch18qa1q7" href="app10.html#ch18qa1a7"><strong>7.</strong></a> Revise the following short and ugly program so that it uses a lambda expression instead of the <code>Adder</code> functor. Don&#8217;t change <code>sum()</code>.</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>#include &lt;array&gt;<br/>const int Size = 5;<br/>template&lt;typename T&gt;<br/><a id="page_1212"/>&#160;&#160;void sum(std::array&lt;double,Size&gt; a, T&#38; fp);<br/>class Adder<br/>{<br/>&#160;&#160;&#160;&#160;double tot;<br/>public:<br/>&#160;&#160;&#160;&#160;Adder(double q = 0) : tot(q) {}<br/>&#160;&#160;&#160;&#160;void operator()(double w) { tot +=w;}<br/>&#160;&#160;&#160;&#160;double tot_v () const {return tot;};<br/>};<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double total = 0.0;<br/>&#160;&#160;&#160;&#160;Adder ad(total);<br/>&#160;&#160;&#160;&#160;std::array&lt;double, Size&gt; temp_c = {32.1, 34.3, 37.8, 35.2, 34.7};<br/>&#160;&#160;&#160;&#160;sum(temp_c,ad);<br/>&#160;&#160;&#160;&#160;total = ad.tot_v();<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "total: " &lt;&lt; ad.tot_v() &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/>template&lt;typename T&gt;<br/>&#160;&#160;void sum(std::array&lt;double,Size&gt; a, T&#38; fp)<br/>{<br/>&#160;&#160;&#160;&#160;for(auto pt = a.begin(); pt != a.end(); ++pt)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fp(*pt);<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<h3 id="ch18lev1sec12">Programming Exercises</h3>
<p class="question"><a id="ch18qa2q1"/><strong>1.</strong> Here is part of a short program:</p>
<p class="programlistingB">int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;// list of double deduced from list contents<br/>&#160;&#160;&#160;&#160;auto q = average_list({15.4, 10.7, 9.0});<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; q &lt;&lt; endl;<br/>// list of int deduced from list contents<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; average_list({20, 30, 19, 17, 45, 38} ) &lt;&lt; endl;<br/>// forced list of double<br/>&#160;&#160;&#160;&#160;auto ad = average_list&lt;double&gt;({'A', 70, 65.33});<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ad &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="questionp"><a id="page_1213"/>Complete the program by supplying the <code>average_list()</code> function. It should be a template function, with the type parameter being used to specify the kind of <code>initialized_list</code> template to be used as the function parameter and also to give the function return type.</p>
<p class="question"><a id="ch18qa2q2"/><strong>2.</strong> Here is declaration for the <code>Cpmv</code> class:</p>
<p class="programlistingB">class Cpmv<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;struct Info<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::string qcode;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::string zcode;<br/>&#160;&#160;&#160;&#160;};<br/>private:<br/>&#160;&#160;&#160;&#160;Info *pi;<br/>public:<br/>&#160;&#160;&#160;&#160;Cpmv();<br/>&#160;&#160;&#160;&#160;Cpmv(std::string q, std::string z);<br/>&#160;&#160;&#160;&#160;Cpmv(const Cpmv &#38; cp);<br/>&#160;&#160;&#160;&#160;Cpmv(Cpmv &#38;&#38; mv);<br/>&#160;&#160;&#160;&#160;~Cpmv();<br/>&#160;&#160;&#160;&#160;Cpmv &#38; operator=(const Cpmv &#38; cp);<br/>&#160;&#160;&#160;&#160;Cpmv &#38; operator=(Cpmv &#38;&#38; mv);<br/>&#160;&#160;&#160;&#160;Cpmv operator+(const Cpmv &#38; obj) const;<br/>&#160;&#160;&#160;&#160;void Display() const;<br/>};</p>
<p class="questionp">The <code>operator+()</code> function should create an object whose <code>qcode</code> and <code>zcode</code> members concatenate the corresponding members of the operands. Provide code that implements move semantics for the move constructor and the move assignment operator. Write a program that uses all the methods. For testing purposes, make the various methods verbose so that you can see when they are used.</p>
<p class="question"><a id="ch18qa2q3"/><strong>3.</strong> Write and test a variadic template function <code>sum_values()</code> that accepts an arbitrarily long list of arguments with numeric values (they can be a mixture of types) and returns the sum as a <code>long double</code> value.</p>
<p class="question"><a id="ch18qa2q4"/><strong>4.</strong> Redo <a href="ch16.html#ch16ex05">Listing 16.5</a> using lambdas. In particular, replace the <code>outint()</code> function with a named lambda and replace the two uses of a functor with two anonymous lambda expressions.</p>
</body>
</html>
