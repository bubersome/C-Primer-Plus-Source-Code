<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17. Input, Output, and Files</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch17">17. Input, Output, and Files</h2>
<p><a id="page_1061"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; The C++ view of input and output</p>
<p class="indenthandingB">&#8226; The <code>iostream</code> family of classes</p>
<p class="indenthandingB">&#8226; Redirection</p>
<p class="indenthandingB">&#8226; <code>ostream</code> class methods</p>
<p class="indenthandingB">&#8226; Formatting output</p>
<p class="indenthandingB">&#8226; <code>istream</code> class methods</p>
<p class="indenthandingB">&#8226; Stream states</p>
<p class="indenthandingB">&#8226; File I/O</p>
<p class="indenthandingB">&#8226; Using the <code>ifstream</code> class for input from files</p>
<p class="indenthandingB">&#8226; Using the <code>ofstream</code> class for output to files</p>
<p class="indenthandingB">&#8226; Using the <code>fstream</code> class file input and output</p>
<p class="indenthandingB">&#8226; Command-line processing</p>
<p class="indenthandingB">&#8226; Binary files</p>
<p class="indenthandingB">&#8226; Random file access</p>
<p class="indenthandingB">&#8226; Incore formatting</p>
<p>Discussing C++ input and output (I/O) poses a problem. On the one hand, practically every program uses input and output, and learning how to use them is one of the first tasks facing someone learning a computer language. On the other hand, C++ uses many of its more advanced language features to implement input and output, including classes, derived classes, function overloading, virtual functions, templates, and multiple inheritance. Thus, to really understand C++ I/O, you must know a lot of C++. To get you started, the early chapters of this book outline the basic ways for using the <code>istream</code> class object <code>cin</code> and the <code>ostream</code> class object <code>cout</code> for input and output, and, to a lesser degree, using <code>ifstream</code> and <code>ofstream</code> objects for file input and output. This chapter takes a <a id="page_1062"/>longer look at C++&#8217;s input and output classes, showing how they are designed and explaining how to control the output format. (If you&#8217;ve skipped a few chapters just to learn advanced formatting, you can read the sections on formatting, noting the techniques and ignoring the explanations.)</p>
<p>The C++ facilities for file input and output are based on the same basic class definitions that <code>cin</code> and <code>cout</code> are based on, so this chapter uses the discussion of console I/O (keyboard and screen) as a springboard to investigating file I/O.</p>
<p>The ANSI/ISO C++ standards committee has worked to make C++ I/O more compatible with existing C I/O, and this has produced some changes from traditional C++ practices.</p>
<h3 id="ch17lev1sec1">An Overview of C++ Input and Output</h3>
<p>Most computer languages build input and output into the language itself. For example, if you look through the lists of keywords for languages such as BASIC and Pascal, you see that <code>PRINT</code> statements, <code>writeln</code> statements, and the like are part of the language vocabulary. But neither C nor C++ has built input and output into the language. If you look through the keywords for these languages, you find <code>for</code> and <code>if</code> but nothing relating to I/O. C originally left I/O to compiler implementers. One reason for this was to give implementers the freedom to design I/O functions that best fit the hardware requirements of the target computer. In practice, most implementers based I/O on a set of library functions originally developed for the Unix environment. ANSI C formalized recognition of this I/O package, called the Standard Input/Output package, by making it a mandatory component of the standard C library. C++ also recognizes this package, so if you&#8217;re familiar with the family of C functions declared in the <code>stdio.h</code> file, you can use them in C++ programs. (Newer implementations use the <code>cstdio</code> header file to support these functions.)</p>
<p>However, C++ relies on a C++ solution rather than a C solution to I/O, and that solution is a set of classes defined in the <code>iostream</code> (formerly <code>iostream.h</code>) and <code>fstream</code> (formerly <code>fstream.h</code>) header files. This class library is not part of the formal language definition (<code>cin</code> and <code>istream</code> are not keywords); after all, a computer language defines rules for how to do things, such as create classes, and doesn&#8217;t define what you should create by following those rules. But just as C implementations come with a standard library of functions, C++ comes with a standard library of classes. At first, that standard class library was an informal standard consisting solely of the classes defined in the <code>iostream</code> and <code>fstream</code> header files. The ANSI/ISO C++ committee decided to formalize this library as a standard class library and to add a few more standard classes, such as those discussed in <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library.&#8221; This chapter discusses standard C++ I/O. But first, let&#8217;s examine the conceptual framework for C++ I/O.</p>
<h4 id="ch17lev2sec1">Streams and Buffers</h4>
<p><a id="page_1063"/>A C++ program views input or output as a stream of bytes. On input, a program extracts bytes from an input stream, and on output, a program inserts bytes into the output stream. For a text-oriented program, each byte can represent a character. More generally, the bytes can form a binary representation of character or numeric data. The bytes in an input stream can come from the keyboard, but they can also come from a storage device, such as a hard disk, or from another program. Similarly, the bytes in an output stream can flow to the display, to a printer, to a storage device, or to another program. A stream acts as an intermediary between the program and the stream&#8217;s source or destination. This approach enables a C++ program to treat input from a keyboard in the same manner it treats input from a file; the C++ program merely examines the stream of bytes without needing to know where the bytes come from. Similarly, by using streams, a C++ program can process output in a manner independent of where the bytes are going. Managing input, then, involves two stages:</p>
<p class="indenthandingB">&#8226; Associating a stream with an input to a program</p>
<p class="indenthandingB">&#8226; Connecting the stream to a file</p>
<p>In other words, an input stream needs two connections, one at each end. The file-end connection provides a source for the stream, and the program-end connection dumps the stream outflow into the program. (The file-end connection can be a file, but it can also be a device, such as a keyboard.) Similarly, managing output involves connecting an output stream to the program and associating some output destination with the stream. It&#8217;s like plumbing with bytes instead of water (see <a href="#ch17fig01">Figure 17.1</a>).</p>
<p class="caption"><a id="ch17fig01"/><strong>Figure 17.1. C++ input and output.</strong></p>
<p class="image"><img src="graphics/17fig01.jpg" alt="Image"/></p>
<p>Usually, input and output can be handled more efficiently by using a buffer. A <em>buffer</em> is a block of memory used as an intermediate, temporary storage facility for the transfer of information from a device to a program or from a program to a device. Typically, devices such as disk drives transfer information in blocks of 512 bytes or more, whereas programs often process information 1 byte at a time. The buffer helps match these two disparate rates of information transfer. For example, assume that a program is supposed to count the number of dollar signs in a hard-disk file. The program could read one character from the file, process it, read the next character from the file, and so on. Reading a file a character at a time from a disk requires a lot of hardware activity and is slow. The buffered approach is to read a large chunk from the disk, store the chunk in the buffer, and read the buffer one character at a time. Because it is much quicker to read individual bytes of data from memory than from a hard disk, this approach is much faster as well as easier on the hardware. Of course, after the program reaches the end of the buffer, the program should then read another chunk of data from the disk. The principle is similar to that of a water reservoir that collects megagallons of runoff water during a big storm and then feeds water to your home at a more civilized rate of flow (see <a href="#ch17fig02">Figure 17.2</a>). Similarly, on output, a program can first fill the buffer and then transfer the entire block of data to a hard disk, clearing the buffer for the next batch of output. This is called <em>flushing the buffer</em>. Perhaps you can come up with your own plumbing-based analogy for that process.</p>
<p class="caption"><a id="ch17fig02"/><strong>Figure 17.2. A stream with a buffer.</strong></p>
<p class="image"><img src="graphics/17fig02.jpg" alt="Image"/></p>
<p><a id="page_1064"/>Keyboard input provides one character at a time, so in that case, a program doesn&#8217;t need a buffer to help match different data transfer rates. However, buffered keyboard input allows the user to back up and correct input before transmitting it to a program. A C++ program normally flushes the input buffer when you press Enter. That&#8217;s why the examples in this book don&#8217;t begin processing input until you press Enter. For output to the display, a C++ program normally flushes the output buffer when you transmit a newline character. Depending on the implementation, a program may flush input on other occasions, too, such as at impending input. That is, when a program reaches an input statement, it flushes any output currently in the output buffer. C++ implementations that are consistent with ANSI C should behave in that manner.</p>
<h4 id="ch17lev2sec2">Streams, Buffers, and the <code>iostream</code> File</h4>
<p>The business of managing streams and buffers can get a bit complicated, but including the <code>iostream</code> (formerly <code>iostream.h</code>) file brings in several classes designed to implement and manage streams and buffers for you. The C++98 version of C++ I/O defines class templates in order to support both <code>char</code> and <code>wchar_t</code> data. C++11 adds <code>char16_t</code> and <code>char32_t</code> specializations. By using the <code>typedef</code> facility, C++ makes the <code>char</code> specializations of these templates mimic the traditional non-template I/O implementation. Here are some of those classes (see <a href="#ch17fig03">Figure 17.3</a>):</p>
<p class="indenthandingB">&#8226; <a id="page_1065"/>The <code>streambuf</code> class provides memory for a buffer, along with class methods for filling the buffer, accessing buffer contents, flushing the buffer, and managing the buffer memory.</p>
<p class="indenthandingB">&#8226; The <code>ios_base</code> class represents general properties of a stream, such as whether it&#8217;s open for reading and whether it&#8217;s a binary or a text stream.</p>
<p class="indenthandingB">&#8226; The <code>ios</code> class is based on <code>ios_base</code>, and it includes a pointer member to a <code>streambuf</code> object.</p>
<p class="indenthandingB">&#8226; The <code>ostream</code> class derives from the <code>ios</code> class and provides output methods.</p>
<p class="indenthandingB">&#8226; The <code>istream</code> class derives from the <code>ios</code> class and provides input methods.</p>
<p class="indenthandingB">&#8226; The <code>iostream</code> class is based on the <code>istream</code> and <code>ostream</code> classes and thus inherits both input and output methods.</p>
<p class="caption"><a id="ch17fig03"/><strong>Figure 17.3. Some I/O classes.</strong></p>
<p class="image"><img src="graphics/17fig03.jpg" alt="Image"/></p>
<p>To use these facilities, you use objects of the appropriate classes. For example, you use an <code>ostream</code> object such as <code>cout</code> to handle output. Creating such an object opens a stream, automatically creates a buffer, and associates it with the stream. It also makes the class member functions available to you.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch17sb01"/><a id="page_1066"/>Redefining I/O</p>
<p class="sidebarpara">The ISO/ANSI C++98 Standard revised I/O a couple ways. First, there&#8217;s the change from <code>ostream.h</code> to <code>ostream</code>, with <code>ostream</code> placing the classes in the <code>std</code> namespace. Second, the I/O classes have been rewritten. To be an international language, C++ has to be able to handle international character sets that require a 16-bit or wider character type. So the language added the <code>wchar_t</code> (or &#8220;wide&#8221;) character type to the traditional 8-bit <code>char</code> (or &#8220;narrow&#8221;) type. C++11 adds <code>char16_t</code> and <code>char32_t</code> types. Each type needs its own I/O facilities. Rather than develop two (or, now, four) separate sets of classes, the standards committee developed a template set of I/O classes, including <code>basic_istream&lt;charT, traits&lt;charT&gt; &gt;</code> and <code>basic_ostream&lt;charT, traits&lt;charT&gt; &gt;</code>. The <code>traits&lt;charT&gt;</code> template, in turn, is a template class that defines particular traits for a character type, such as how to compare for equality and its EOF value. The C++11 Standard provides <code>char</code> and <code>wchar_t</code> specializations of the I/O classes. For example, <code>istream</code> and <code>ostream</code> are <code>typedef</code>s for <code>char</code> specializations. Similarly, <code>wistream</code> and <code>wostream</code> are <code>wchar_t</code> specializations. For example, there is a <code>wcout</code> object for outputting wide character streams. The <code>ostream</code> header file contains these definitions.</p>
<p class="sidebarpara">Certain type-independent information that used to be kept in the <code>ios</code> base class has been moved to the new <code>ios_base</code> class. This includes the various formatting constants such as <code>ios::fixed</code>, which is now <code>ios_base::fixed</code>. Also <code>ios_base</code> contains some options that aren&#8217;t available in the old <code>ios</code>.</p>
<hr/></div>
<p><a id="page_1067"/>The C++ <code>iostream</code> class library takes care of many details for you. For example, including the <code>iostream</code> file in a program creates eight stream objects (four for narrow character streams and four for wide character streams) automatically:</p>
<p class="indenthandingB">&#8226; The <code>cin</code> object corresponds to the standard input stream. By default, this stream is associated with the standard input device, typically a keyboard. The <code>wcin</code> object is similar but works with the <code>wchar_t</code> type.</p>
<p class="indenthandingB">&#8226; The <code>cout</code> object corresponds to the standard output stream. By default, this stream is associated with the standard output device, typically a monitor. The <code>wcout</code> object is similar but works with the <code>wchar_t</code> type.</p>
<p class="indenthandingB">&#8226; The <code>cerr</code> object corresponds to the standard error stream, which you can use for displaying error messages. By default, this stream is associated with the standard output device, typically a monitor, and the stream is unbuffered. This means that information is sent directly to the screen, without waiting for a buffer to fill or for a newline character. The <code>wcerr</code> object is similar but works with the <code>wchar_t</code> type.</p>
<p class="indenthandingB">&#8226; The <code>clog</code> object also corresponds to the standard error stream. By default, this stream is associated with the standard output device, typically a monitor, and the stream is buffered. The <code>wclog</code> object is similar but works with the <code>wchar_t</code> type.</p>
<p>What does it mean to say that an object represents a stream? Well, for example, when the <code>iostream</code> file declares a <code>cout</code> object for a program, that object has data members holding information relating to output, such as the field widths to be used in displaying data, the number of places after the decimal to use, what number base to use for displaying integers, and the address of a <code>streambuf</code> object that describes the buffer used to handle the output flow. A statement such as the following places the characters from the string <code>"Bjarne free"</code> into the buffer managed by <code>cout</code> via the pointed-to <code>streambuf</code> object:</p>
<p class="programlisting">cout &lt;&lt; "Bjarne free";</p>
<p>The <code>ostream</code> class defines the <code>operator&lt;&lt;()</code> function used in this statement, and the <code>ostream</code> class also supports the <code>cout</code> data members with a variety of other class methods, such as the ones this chapter discusses later. Furthermore, C++ sees to it that the output from the buffer is directed to the standard output, usually a monitor, provided by the operating system. In short, one end of a stream is connected to the program, the other end is connected to the standard output, and the <code>cout</code> object, with the help of a type <code>streambuf</code> object, manages the flow of bytes through the stream.</p>
<h4 id="ch17lev2sec3">Redirection</h4>
<p>The standard input and output streams normally connect to the keyboard and the screen. But many operating systems, including Unix, Linux, and Windows, support redirection, a facility that lets you change the associations for the standard input and the standard output. Suppose, for example, that you have an executable Windows command prompt C++ program called <code>counter.exe</code> that counts the number of characters in its input and reports the result. (From most versions of Windows you can select Start, Programs and then click the Command Prompt icon to open a command-prompt window.) A sample run might look like this:</p>
<p class="programlisting"><a id="page_1068"/>C&gt;counter<br/><span class="EmpStrong">Hello</span><br/><span class="EmpStrong">and goodbye!</span><br/><span class="EmpStrong">Control-Z</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; <span class="romanAlt">simulated end-of-file</span><br/>Input contained 19 characters.<br/>C&gt;</p>
<p>In this case, input came from the keyboard, and output went to the screen.</p>
<p>With input redirection (<strong><code>&lt;</code></strong>) and output redirection (<strong><code>&gt;</code></strong>), you can use the same program to count the number of characters in the <code>oklahoma</code> file and to place the results in the <code>cow_cnt</code> file:</p>
<p class="programlisting">C&gt;counter &lt;oklahoma &gt;cow_cnt<br/>C&gt;</p>
<p>The <code>&lt;oklahoma</code> part of the command line associates the standard input with the <code>oklahoma</code> file, causing <code>cin</code> to read input from that file instead of the keyboard. In other words, the operating system changes the connection at the inflow end of the input stream, while the outflow end remains connected to the program. The <code>&gt;cow_cnt</code> part of the command line associates the standard output with the <code>cow_cnt</code> file, causing <code>cout</code> to send output to that file instead of to the screen. That is, the operating system changes the outflow end connection of the output stream, leaving its inflow end still connected to the program. DOS, Windows command-prompt mode, Linux, and Unix automatically recognize this redirection syntax. (All of these other than early forms of DOS permit optional space characters between the redirection operators and the filenames.)</p>
<p>The standard output stream, represented by <code>cout</code>, is the normal channel for program output. The standard error streams (represented by <code>cerr</code> and <code>clog</code>) are intended for a program&#8217;s error messages. By default, all three of these objects are typically sent to the monitor. But redirecting the standard output doesn&#8217;t affect <code>cerr</code> or <code>clog</code>; thus, if you use one of these objects to print an error message, a program will display the error message on the screen even if the regular <code>cout</code> output is redirected elsewhere. For example, consider this code fragment:</p>
<p class="programlisting">if (success)<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Here come the goodies!\n";<br/>else<br/>{<br/>&#160;&#160;&#160;&#160;std::cerr &lt;&lt; "Something horrible has happened.\n";<br/>&#160;&#160;&#160;&#160;exit(1);<br/>}</p>
<p>If redirection is not in effect, whichever message is selected is displayed onscreen. If, however, the program output has been redirected to a file, the first message, if selected, would go to the file but the second message, if selected, would go to the screen. By the way, some operating systems permit redirecting the standard error, too. In Unix and Linux, for example, the <code>2&gt;</code> operator redirects the standard error.</p>
<h3 id="ch17lev1sec2">Output with <code>cout</code></h3>
<p><a id="page_1069"/>As mentioned previously, C++ considers output to be a stream of bytes. (Depending on the implementation and platform, these may be 8-bit, 16-bit, or 32-bit bytes, but they&#8217;re bytes nonetheless.) But many kinds of data in a program are organized into larger units than a single byte. An <code>int</code> type, for example, may be represented by a 16-bit or 32-bit binary value. And a <code>double</code> value may be represented by 64 bits of binary data. But when you send a stream of bytes to a screen, you want each byte to represent a character value. That is, to display the number -2.34 onscreen, you should send the five characters -, 2, ., 3, and 4 to the screen, and not the internal 64-bit floating-point representation of that value. Therefore, one of the most important tasks facing the <code>ostream</code> class is converting numeric types, such as <code>int</code> or <code>float</code>, into a stream of characters that represents the values in text form. That is, the <code>ostream</code> class translates the internal representation of data as binary bit patterns to an output stream of character bytes. (Some day we may have bionic implants to enable us to interpret binary data directly. I leave that development as another exercise for the reader.) To perform these translation tasks, the <code>ostream</code> class provides several class methods. We&#8217;ll look at them now, summarizing methods used throughout the book and describing additional methods that provide finer control over the appearance of the output.</p>
<h4 id="ch17lev2sec4">The Overloaded <code>&lt;&lt;</code> Operator</h4>
<p>Most often, this book has used <code>cout</code> with the <code>&lt;&lt;</code> operator, also called the <em>insertion</em> operator:</p>
<p class="programlisting">int clients = 22;<br/>cout &lt;&lt; clients;</p>
<p>In C++, as in C, by default the <code>&lt;&lt;</code> operator is used as the bitwise left-shift operator (see <a href="app05.html#app05">Appendix E</a>, &#8220;<a href="app05.html#app05">Other Operators</a>&#8221;). An expression such as <code>x&lt;&lt;3</code> means to take the binary representation of <code>x</code> and shift all the bits three units to the left. Obviously, this doesn&#8217;t have a lot to do with output. But the <code>ostream</code> class redefines the <code>&lt;&lt;</code> operator through overloading to output for the <code>ostream</code> class. In this guise, the <code>&lt;&lt;</code> operator is called the insertion operator instead of the left-shift operator. (The left-shift operator earned this new role through its visual aspect, which suggests a flow of information to the left.) The insertion operator is overloaded to recognize all the basic C++ types:</p>
<p class="indenthandingB">&#8226; <code>unsigned char</code></p>
<p class="indenthandingB">&#8226; <code>signed char</code></p>
<p class="indenthandingB">&#8226; <code>char</code></p>
<p class="indenthandingB">&#8226; <code>short</code></p>
<p class="indenthandingB">&#8226; <code>unsigned short</code></p>
<p class="indenthandingB">&#8226; <code>int</code></p>
<p class="indenthandingB">&#8226; <code>unsigned int</code></p>
<p class="indenthandingB">&#8226; <a id="page_1070"/><code>long</code></p>
<p class="indenthandingB">&#8226; <code>unsigned long</code></p>
<p class="indenthandingB">&#8226; <code>long long</code> (C++11)</p>
<p class="indenthandingB">&#8226; <code>unsigned long long</code> (C++11)</p>
<p class="indenthandingB">&#8226; <code>float</code></p>
<p class="indenthandingB">&#8226; <code>double</code></p>
<p class="indenthandingB">&#8226; <code>long double</code></p>
<p>The <code>ostream</code> class provides a definition for the <code>operator&lt;&lt;()</code> function for each of these data types. (Functions that have <em>operator</em> in their names are used to overload operators, as discussed in <a href="ch11.html#ch11">Chapter 11</a>, &#8220;<a href="ch11.html#ch11">Working with Classes</a>.&#8221;) Thus, if you use a statement of the following form, and if <em><code>value</code></em> is one of the preceding types, a C++ program can match it to an operator function with the corresponding signature:</p>
<p class="programlisting">cout &lt;&lt; <span class="EmpItalic">value</span>;</p>
<p>For example, the expression <code>cout &lt;&lt; 88</code> matches the following method prototype:</p>
<p class="programlisting">ostream &#38; operator&lt;&lt;(int);</p>
<p>Recall that this prototype indicates that the <code>operator&lt;&lt;()</code> function takes one type <code>int</code> argument. That&#8217;s the part that matches the <code>88</code> in the previous statement. The prototype also indicates that the function returns a reference to an <code>ostream</code> object. That property makes it possible to concatenate output, as in the following old rock hit:</p>
<p class="programlisting">cout &lt;&lt; "I'm feeling sedimental over " &lt;&lt; boundary &lt;&lt; "\n";</p>
<p>If you&#8217;re a C programmer who has suffered through C&#8217;s multitudinous <code>%</code> type specifiers and the problems that arise when you mismatch a specifier type to a value, using <code>cout</code> is almost sinfully easy. (And C++ input, of course, <em>is</em> <code>cin</code>fully easy.)</p>
<h5 id="ch17lev3sec1">Output and Pointers</h5>
<p>The <code>ostream</code> class defines insertion operator functions for the following pointer types:</p>
<p class="indenthandingB">&#8226; <code>const signed char *</code></p>
<p class="indenthandingB">&#8226; <code>const unsigned char *</code></p>
<p class="indenthandingB">&#8226; <code>const char *</code></p>
<p class="indenthandingB">&#8226; <code>void *</code></p>
<p>C++ represents a string, don&#8217;t forget, by using a pointer to the location of the string. The pointer can take the form of the name of an array of <code>char</code> or of an explicit <code>pointer-to-char</code> or of a quoted string. Thus, all the following <code>cout</code> statements display strings:</p>
<p class="programlisting">char name[20] = "Dudly Diddlemore";<br/>char * pn = "Violet D'Amore";<br/>cout &lt;&lt; "Hello!";<br/><a id="page_1071"/>cout &lt;&lt; name;<br/>cout &lt;&lt; pn;</p>
<p>The methods use the terminating null character in the string to determine when to stop displaying characters.</p>
<p>C++ matches a pointer of any other type with type <code>void *</code> and prints a numeric representation of the address. If you want the address of the string, you have to type cast it to another type, as shown in the following code fragment:</p>
<p class="programlisting">int eggs = 12;<br/>char * amount = "dozen";<br/>cout &lt;&lt; &#38;eggs;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prints address of eggs variable<br/>cout &lt;&lt; amount;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prints the string "dozen"<br/>cout &lt;&lt; (void *) amount;&#160;&#160;&#160;&#160;// prints the address of the "dozen" string</p>
<h5 id="ch17lev3sec2">Output Concatenation</h5>
<p>All the incarnations of the insertion operator are defined to return type <code>ostream &#38;</code>. That is, the prototypes have this form:</p>
<p class="programlisting">ostream &#38; operator&lt;&lt;(<span class="EmpItalic">type</span>);</p>
<p>(Here, <em><code>type</code></em> is the type to be displayed.) The <code>ostream &#38;</code> return type means that using this operator returns a reference to an <code>ostream</code> object. Which object? The function definitions say that the reference is to the object used to evoke the operator. In other words, an operator function&#8217;s return value is the same object that evokes the operator. For example, <code>cout &lt;&lt; "potluck"</code> returns the <code>cout</code> object. That&#8217;s the feature that lets you concatenate output by using insertion. For example, consider the following statement:</p>
<p class="programlisting">cout &lt;&lt; "We have " &lt;&lt; count &lt;&lt; " unhatched chickens.\n";</p>
<p>The expression <code>cout &lt;&lt; "We have "</code> displays the string and returns the <code>cout</code> object, reducing the statement to the following:</p>
<p class="programlisting">cout &lt;&lt; count &lt;&lt; " unhatched chickens.\n";</p>
<p>Then the expression <code>cout &lt;&lt; count</code> displays the value of the <code>count</code> variable and returns <code>cout</code>, which can then handle the final argument in the statement (see <a href="#ch17fig04">Figure 17.4</a>). This design technique really is a nice feature, which is why the examples of overloading the <code>&lt;&lt;</code> operator in the previous chapters shamelessly imitate it.</p>
<p class="caption"><a id="ch17fig04"/><strong>Figure 17.4. Output concatenation.</strong></p>
<p class="image"><img src="graphics/17fig04.jpg" alt="Image"/></p>
<h4 id="ch17lev2sec5">The Other <code>ostream</code> Methods</h4>
<p>Besides the various <code>operator&lt;&lt;()</code> functions, the <code>ostream</code> class provides the <code>put()</code> method for displaying characters and the <code>write()</code> method for displaying strings.</p>
<p><a id="page_1072"/>Originally, the <code>put()</code> method had the following prototype:</p>
<p class="programlisting">ostream &#38; put(char);</p>
<p>The current standard is equivalent, except it&#8217;s templated to allow for <code>wchar_t</code>. You invoke it by using the usual class method notation:</p>
<p class="programlisting">cout.put('W');&#160;&#160;&#160;&#160;&#160;&#160;// display the W character</p>
<p>Here <code>cout</code> is the invoking object and <code>put()</code> is the class member function. Like the <code>&lt;&lt;</code> operator functions, this function returns a reference to the invoking object, so you can concatenate output with it:</p>
<p class="programlisting">cout.put('I').put('t'); // displaying It with two put() calls</p>
<p>The function call <code>cout.put('I')</code> returns <code>cout</code>, which then acts as the invoking object for the <code>put('t')</code> call.</p>
<p>Given the proper prototype, you can use <code>put()</code> with arguments of numeric types other than <code>char</code>, such as <code>int</code>, and let function prototyping automatically convert the argument to the correct type <code>char</code> value. For example, you could use the following:</p>
<p class="programlisting">cout.put(65);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// display the A character<br/>cout.put(66.3);&#160;&#160;&#160;&#160;&#160;&#160;// display the B character</p>
<p><a id="page_1073"/>The first statement converts the <code>int</code> value <code>65</code> to a <code>char</code> value and then displays the character having <code>65</code> as its ASCII code. Similarly, the second statement converts the type <code>double</code> value <code>66.3</code> to a type <code>char</code> value <code>66</code> and displays the corresponding character.</p>
<p>This behavior comes in handy with versions prior to Release 2.0 C++; in those versions, the language represents character constants with type <code>int</code> values. Thus, a statement such as the following would interpret <code>'W'</code> as an <code>int</code> value and hence display it as the integer <code>87</code>, the ASCII value for the character:</p>
<p class="programlisting">cout &lt;&lt; 'W';</p>
<p>But the following statement works fine:</p>
<p class="programlisting">cout.put('W');</p>
<p>Because current C++ represents <code>char</code> constants as type <code>char</code>, you can now use either method.</p>
<p>Some compilers erroneously overload <code>put()</code> for three argument types: <code>char</code>, <code>unsigned char</code>, and <code>signed char</code>. This makes using <code>put()</code> with an <code>int</code> argument ambiguous because an <code>int</code> can be converted to any one of those three types.</p>
<p>The <code>write()</code> method writes an entire string and has the following template prototype:</p>
<p class="programlisting">basic_ostream&lt;charT,traits&gt;&#38; write(const char_type* s, streamsize n);</p>
<p>The first argument to <code>write()</code> provides the address of the string to be displayed, and the second argument indicates how many characters to display. Using <code>cout</code> to invoke <code>write()</code> invokes the <code>char</code> specialization, so the return type is <code>ostream &#38;</code>. <a href="#ch17ex01">Listing 17.1</a> shows how the <code>write()</code> method works.</p>
<p class="caption1"><a id="ch17ex01"/><strong>Listing 17.1. <code>write.cpp</code></strong></p><hr/>
<p class="programlisting1">// write.cpp -- using cout.write()<br/>#include &lt;iostream&gt;<br/>#include &lt;cstring&gt;&#160;&#160;// or else string.h<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;const char * state1 = "Florida";<br/>&#160;&#160;&#160;&#160;const char * state2 = "Kansas";<br/>&#160;&#160;&#160;&#160;const char * state3 = "Euphoria";<br/>&#160;&#160;&#160;&#160;int len = std::strlen(state2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Increasing loop index:\n";<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 1; i &lt;= len; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.write(state2,i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/><br/>// concatenate output<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Decreasing loop index:\n";<br/>&#160;&#160;&#160;&#160;for (i = len; i &gt; 0; i--)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.write(state2,i) &lt;&lt; endl;<br/><br/>// exceed string length<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Exceeding string length:\n";<br/>&#160;&#160;&#160;&#160;cout.write(state2, len + 5) &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1074"/>Some compilers may observe that the program defines but doesn&#8217;t use the arrays <code>state1</code> and <code>state3</code>. That&#8217;s okay because those two arrays are there just to provide data before and after the <code>state2</code> array so that you can see what happens when the program miscodes access to <code>state2</code>. Here is the output of the program in <a href="#ch17ex01">Listing 17.1</a>:</p>
<p class="programlisting">Increasing loop index:<br/>K<br/>Ka<br/>Kan<br/>Kans<br/>Kansa<br/>Kansas<br/>Decreasing loop index:<br/>Kansas<br/>Kansa<br/>Kans<br/>Kan<br/>Ka<br/>K<br/>Exceeding string length:<br/>Kansas Euph</p>
<p>Note that the <code>cout.write()</code> call returns the <code>cout</code> object. This is because the <code>write()</code> method returns a reference to the object that invokes it, and in this case, the <code>cout</code> object invokes it. This makes it possible to concatenate output because <code>cout.write()</code> is replaced by its return value, <code>cout</code>:</p>
<p class="programlisting">cout.write(state2,i) &lt;&lt; endl;</p>
<p>Also, note that the <code>write()</code> method doesn&#8217;t stop printing characters automatically when it reaches the null character. It simply prints how many characters you tell it to, even if that goes beyond the bounds of a particular string! In this case, the program brackets the string <code>"Kansas"</code> with two other strings so that adjacent memory locations would contain data. Compilers differ in the order in which they store data in memory and in how they align memory. For example, <code>"Kansas"</code> occupies 6 bytes, but this particular compiler <a id="page_1075"/>appears to align strings by using multiples of 4 bytes, so <code>"Kansas"</code> is padded out to 8 bytes. Some compilers store <code>"Florida"</code> after <code>"Kansas"</code>. So because of compiler differences, you may get a different result for the final line of output.</p>
<p>The <code>write()</code> method can also be used with numeric data. You would pass it the address of a number, type cast to <code>char *</code>:</p>
<p class="programlisting">long val = 560031841;<br/>cout.write( (char *) &#38;val, sizeof (long));</p>
<p>This doesn&#8217;t translate a number to the correct characters; instead, it transmits the bit representation as stored in memory. For example, a 4-byte <code>long</code> value such as <code>560031841</code> would be transmitted as 4 separate bytes. An output device such as a monitor would then try to interpret each byte as if it were ASCII (or whatever) code. So <code>560031841</code> would appear onscreen as some 4-character combination, most likely gibberish. (But maybe not; try it and see.) However, <code>write()</code> does provide a compact, accurate way to store numeric data in a file. We&#8217;ll return to this possibility later in this chapter.</p>
<h4 id="ch17lev2sec6">Flushing the Output Buffer</h4>
<p>Consider what happens as a program uses <code>cout</code> to send bytes on to the standard output. Because the <code>ostream</code> class buffers output handled by the <code>cout</code> object, output isn&#8217;t sent to its destination immediately. Instead, it accumulates in the buffer until the buffer is full. Then the program <em>flushes</em> the buffer, sending the contents on and clearing the buffer for new data. Typically, a buffer is 512 bytes or an integral multiple thereof. Buffering is a great time-saver when the standard output is connected to a file on a hard disk. After all, you don&#8217;t want a program to access the hard disk 512 times to send 512 bytes. It&#8217;s much more effective to collect 512 bytes in a buffer and write them to a hard disk in a single disk operation.</p>
<p>For screen output, however, filling the buffer first is less critical. Indeed, it would be inconvenient if you had to reword the message &#8220;Press any key to continue&#8221; so that it consumed the prerequisite 512 bytes to fill a buffer. Fortunately, in the case of screen output, the program doesn&#8217;t necessarily wait until the buffer is full. Sending a newline character to the buffer, for example, normally flushes the buffer. Also as mentioned before, most C++ implementations flush the buffer when input is pending. That is, suppose you have the following code:</p>
<p class="programlisting">cout &lt;&lt; "Enter a number: ";<br/>float num;<br/>cin &gt;&gt; num;</p>
<p>The fact that the program expects input causes it to display the <code>cout</code> message (that is, flush the <code>"Enter a number: "</code> message) immediately, even though the output string lacks a newline character. Without this feature, the program would wait for input without prompting the user with the <code>cout</code> message.</p>
<p>If your implementation doesn&#8217;t flush output when you want it to, you can force flushing by using one of two manipulators. The <code>flush</code> manipulator flushes the buffer, and the <a id="page_1076"/><code>endl</code> manipulator flushes the buffer and inserts a newline character. You use these manipulators the way you would use a variable name:</p>
<p class="programlisting">cout &lt;&lt; "Hello, good-looking! " &lt;&lt; flush;<br/>cout &lt;&lt; "Wait just a moment, please." &lt;&lt; endl;</p>
<p>Manipulators are, in fact, functions. For example, you can flush the <code>cout</code> buffer by calling the <code>flush()</code> function directly:</p>
<p class="programlisting">flush(cout);</p>
<p>However, the <code>ostream</code> class overloads the <code>&lt;&lt;</code> insertion operator in such a way that the following expression gets replaced with the <code>flush(cout)</code> function call:</p>
<p class="programlisting">cout &lt;&lt; flush</p>
<p>Thus, you can use the more convenient insertion notation to flush with success.</p>
<h4 id="ch17lev2sec7">Formatting with <code>cout</code></h4>
<p>The <code>ostream</code> insertion operators convert values to text form. By default, they format values as follows:</p>
<p class="indenthandingB">&#8226; A type <code>char</code> value, if it represents a printable character, is displayed as a character in a field one character wide.</p>
<p class="indenthandingB">&#8226; Numeric integer types are displayed as decimal integers in a field just wide enough to hold the number and, if present, a minus sign.</p>
<p class="indenthandingB">&#8226; Strings are displayed in a field equal in width to the length of the string.</p>
<p>The default behavior for floating-point types has changed. The following are the differences between ancient and current C++ implementations:</p>
<p class="indenthandingB">&#8226; <strong>New style&#8212;</strong> Floating-point types are displayed with a total of six digits, except that trailing zeros aren&#8217;t displayed. (Note that the number of digits displayed has no connection with the precision to which the number is stored.) The number is displayed in fixed-point notation or else in E notation (see <a href="ch03.html#ch03">Chapter 3</a>, &#8220;<a href="ch03.html#ch03">Dealing with Data</a>&#8221;), depending on the value of the number. In particular, E notation is used if the exponent is 6 or larger or -5 or smaller. Again, the field is just wide enough to hold the number and, if present, a minus sign. The default behavior corresponds to using the standard C library function <code>fprintf()</code> with a <code>%g</code> specifier.</p>
<p class="indenthandingB">&#8226; <strong>Old style&#8212;</strong> Floating-point types are displayed with six places to the right of the decimal, except that trailing zeros aren&#8217;t displayed. (Note that the number of digits displayed has no connection with the precision to which the number is stored.) The number is displayed in fixed-point notation or else in E notation (see <a href="ch03.html#ch03">Chapter 3</a>), depending on the value of the number. Again, the field is just wide enough to hold the number and, if present, a minus sign.</p>
<p>Because each value is displayed in a width equal to its size, you have to provide spaces between values explicitly; otherwise, consecutive values would run together.</p>
<p><a id="page_1077"/><a href="#ch17ex02">Listing 17.2</a> illustrates the output defaults. It displays a colon (<code>:</code>) after each value so you can see the width of the field used in each case. The program uses the expression <code>1.0 / 9.0</code> to generate a nonterminating fraction so you can see how many places get printed.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note01"/>Note</p>
<p class="notepara">Not all compilers generate output formatted in accordance with the current C++ Standard. Also the current standard does allow for regional variations. For example, a European implementation can follow the continental fashion of using a comma instead of a period for displaying decimal fractions. That is, it may write <code>2,54</code> instead of <code>2.54</code>. The locale library (header file <code>locale</code>) provides a mechanism for <em>imbuing</em> an input or output stream with a particular style, so a single compiler can offer more than one locale choice. This chapter uses the U.S. locale.</p>
<hr/></div>
<p class="caption1"><a id="ch17ex02"/><strong>Listing 17.2. <code>defaults.cpp</code></strong></p><hr/>
<p class="programlisting1">// defaults.cpp -- cout default formats<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "12345678901234567890\n";<br/>&#160;&#160;&#160;&#160;char ch = 'K';<br/>&#160;&#160;&#160;&#160;int t = 273;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ch &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; t &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; -t &lt;&lt;":\n";<br/><br/>&#160;&#160;&#160;&#160;double f1 = 1.200;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; f1 &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (f1 + 1.0 / 9.0) &lt;&lt; ":\n";<br/><br/>&#160;&#160;&#160;&#160;double f2 = 1.67E2;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; f2 &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;f2 += 1.0 / 9.0;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; f2 &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; (f2 * 1.0e4) &lt;&lt; ":\n";<br/><br/><br/>&#160;&#160;&#160;&#160;double f3 = 2.3e-4;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; f3 &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; f3 / 10 &lt;&lt; ":\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1078"/>Here is the output of the program in <a href="#ch17ex02">Listing 17.2</a>:</p>
<p class="programlisting">12345678901234567890<br/>K:<br/>273:<br/>-273:<br/>1.2:<br/>1.31111:<br/>167:<br/>167.111:<br/>1.67111e+006:<br/>0.00023:<br/>2.3e-005:</p>
<p>Each value fills its field. Note that the trailing zeros of 1.200 are not displayed but that floating-point values without terminating zeros have six places displayed. Also this particular implementation displays three digits in the exponent; others might use two.</p>
<h5 id="ch17lev3sec3">Changing the Number Base Used for Display</h5>
<p>The <code>ostream</code> class inherits from the <code>ios</code> class, which inherits from the <code>ios_base</code> class. The <code>ios_base</code> class stores information that describes the format state. For example, certain bits in one class member determine the number base used, whereas another member determines the field width. By using <em>manipulators</em>, you can control the number base used to display integers. By using <code>ios_base</code> member functions, you can control the field width and the number of places displayed to the right of the decimal. Because the <code>ios_base</code> class is an indirect base class for <code>ostream</code>, you can use its methods with <code>ostream</code> objects (or descendants), such as <code>cout</code>.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note02"/>Note</p>
<p class="notepara">The members and methods found in the <code>ios_base</code> class were formerly found in the <code>ios</code> class. Now <code>ios_base</code> is a base class to <code>ios</code>. In the new system, <code>ios</code> is a template class with <code>char</code> and <code>wchar_t</code> specializations, and <code>ios_base</code> contains the nontemplate features.</p>
<hr/></div>
<p>Let&#8217;s look at how to set the number base to be used in displaying integers. To control whether integers are displayed in base 10, base 16, or base 8, you can use the <code>dec</code>, <code>hex</code>, and <code>oct</code> manipulators. For example, the following function call sets the number base format state for the <code>cout</code> object to hexadecimal:</p>
<p class="programlisting">hex(cout);</p>
<p>After you do this, a program will print integer values in hexadecimal form until you set the format state to another choice. Note that the manipulators are not member functions, hence they don&#8217;t have to be invoked by an object.</p>
<p>Although the manipulators really are functions, you normally see them used this way:</p>
<p class="programlisting">cout &lt;&lt; hex;</p>
<p><a id="page_1079"/>The <code>ostream</code> class overloads the <code>&lt;&lt;</code> operator to make this usage equivalent to the function call <code>hex(cout)</code>. The manipulators are in the <code>std</code> namespace. <a href="#ch17ex03">Listing 17.3</a> illustrates using these manipulators. It shows the value of an integer and its square in three different number bases. Note that you can use a manipulator separately or as part of a series of insertions.</p>
<p class="caption1"><a id="ch17ex03"/><strong>Listing 17.3. <code>manip.cpp</code></strong></p><hr/>
<p class="programlisting1">// manip.cpp -- using format manipulators<br/>#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter an integer: ";<br/>&#160;&#160;&#160;&#160;int n;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; n;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "n&#160;&#160;&#160;&#160;&#160;n*n\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; n &lt;&lt; "&#160;&#160;&#160;&#160;&#160;" &lt;&lt; n * n &lt;&lt; " (decimal)\n";<br/>// set to hex mode<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; hex;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; n &lt;&lt; "&#160;&#160;&#160;&#160;&#160;";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; n * n &lt;&lt; " (hexadecimal)\n";<br/><br/>// set to octal mode<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; oct &lt;&lt; n &lt;&lt; "&#160;&#160;&#160;&#160;&#160;" &lt;&lt; n * n &lt;&lt; " (octal)\n";<br/><br/>// alternative way to call a manipulator<br/>&#160;&#160;&#160;&#160;dec(cout);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; n &lt;&lt; "&#160;&#160;&#160;&#160;&#160;" &lt;&lt; n * n &lt;&lt; " (decimal)\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is some sample output from the program in <a href="#ch17ex03">Listing 17.3</a>:</p>
<p class="programlisting">Enter an integer: <span class="EmpStrong">13</span><br/>n&#160;&#160;&#160;&#160;&#160;n*n<br/>13&#160;&#160;&#160;&#160;&#160;169 (decimal)<br/>d&#160;&#160;&#160;&#160;&#160;a9 (hexadecimal)<br/>15&#160;&#160;&#160;&#160;&#160;251 (octal)<br/>13&#160;&#160;&#160;&#160;&#160;169 (decimal)</p>
<h5 id="ch17lev3sec4">Adjusting Field Widths</h5>
<p><a id="page_1080"/>You probably noticed that the columns in output from <a href="#ch17ex03">Listing 17.3</a> don&#8217;t line up; that&#8217;s because the numbers have different field widths. You can use the <code>width</code> member function to place differently sized numbers in fields that have equal widths. The method has these prototypes:</p>
<p class="programlisting">int width();<br/>int width(int i);</p>
<p>The first form returns the current setting for field width. The second sets the field width to <code>i</code> spaces and returns the previous field width value. This allows you to save the previous value in case you want to restore the width to that value later.</p>
<p>The <code>width()</code> method affects only the next item displayed, and the field width reverts to the default value afterward. For example, consider the following statements:</p>
<p class="programlisting">cout &lt;&lt; '#';<br/>cout.width(12);<br/>cout &lt;&lt; 12 &lt;&lt; "#" &lt;&lt;&#160;&#160;24 &lt;&lt; "#\n";</p>
<p>Because <code>width()</code> is a member function, you have to use an object (<code>cout</code>, in this case) to invoke it. The output statement produces the following display:</p>
<p class="programlisting">#&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;12#24#</p>
<p>The <code>12</code> is placed in a field 12 characters wide at the right end of the field. This is called right-justification. After that, the field width reverts to the default, and the two <code>#</code> characters and the <code>24</code> are printed in fields equal to their own size.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note03"/>Caution</p>
<p class="notepara">The <code>width()</code> method affects only the next item displayed, and the field width reverts to the default value afterward.</p>
<hr/></div>
<p>C++ never truncates data, so if you attempt to print a seven-digit value in a field with a width of two, C++ expands the field to fit the data. (Some languages just fill the field with asterisks if the data doesn&#8217;t fit. The C/C++ philosophy is that showing all the data is more important than keeping the columns neat; C++ puts substance before form.) <a href="#ch17ex04">Listing 17.4</a> shows how the <code>width()</code> member function works.</p>
<p class="caption1"><a id="ch17ex04"/><strong>Listing 17.4. <code>width.cpp</code></strong></p><hr/>
<p class="programlisting1">// width.cpp -- using the width method<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;int w = cout.width(30);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "default field width = " &lt;&lt; w &lt;&lt; ":\n";<br/><br/>&#160;&#160;&#160;&#160;cout.width(5);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "N" &lt;&lt;':';<br/>&#160;&#160;&#160;&#160;cout.width(8);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "N * N" &lt;&lt; ":\n";<br/><br/>&#160;&#160;&#160;&#160;for (long i = 1; i &lt;= 100; i *= 10)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(5);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i &lt;&lt;':';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(8);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i * i &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1081"/>Here is the output of the program in <a href="#ch17ex04">Listing 17.4</a>:</p>
<p class="programlisting">&#160;&#160;&#160;&#160;&#160;&#160;default field width = 0:<br/>&#160;&#160;N:&#160;&#160;&#160;N * N:<br/>&#160;&#160;1:&#160;&#160;&#160;&#160;&#160;&#160;&#160;1:<br/>&#160;10:&#160;&#160;&#160;&#160;&#160;100:<br/>100:&#160;&#160;&#160;10000:</p>
<p>The output displays values right-justified in their fields. The output is padded with spaces. That is, <code>cout</code> achieves the full field width by adding spaces. With right-justification, the spaces are inserted to the left of the values. The character used for padding is termed the <em>fill character</em>. Right-justification is the default.</p>
<p>Note that the program in <a href="#ch17ex04">Listing 17.4</a> applies the field width of 30 to the string displayed by the first <code>cout</code> statement but not to the value of <code>w</code>. This is because the <code>width()</code> method affects only the next single item displayed. Also note that <code>w</code> has the value <code>0</code>. This is because <code>cout.width(30)</code> returns the previous field width, not the width to which it was just set. The fact that <code>w</code> is <code>0</code> means that zero is the default field width. Because C++ always expands a field to fit the data, this one size fits all. Finally, the program uses <code>width()</code> to align column headings and data by using a width of five characters for the first column and a width of eight characters for the second column.</p>
<h5 id="ch17lev3sec5">Fill Characters</h5>
<p>By default, <code>cout</code> fills unused parts of a field with spaces. You can use the <code>fill()</code> member function to change that. For example, the following call changes the fill character to an asterisk:</p>
<p class="programlisting">cout.fill('*');</p>
<p>That can be handy for, say, printing checks so that recipients can&#8217;t easily add a digit or two. <a href="#ch17ex05">Listing 17.5</a> illustrates using this member function.</p>
<p class="caption1"><a id="page_1082"/><a id="ch17ex05"/><strong>Listing 17.5. <code>fill.cpp</code></strong></p><hr/>
<p class="programlisting1">// fill.cpp -- changing fill character for fields<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;cout.fill('*');<br/>&#160;&#160;&#160;&#160;const char * staff[2] = { "Waldo Whipsnade", "Wilmarie Wooper"};<br/>&#160;&#160;&#160;&#160;long bonus[2] = {900, 1350};<br/><br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 2; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; staff[i] &lt;&lt; ": $";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(7);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; bonus[i] &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s the output of the program in <a href="#ch17ex05">Listing 17.5</a>:</p>
<p class="programlisting">Waldo Whipsnade: $****900<br/>Wilmarie Wooper: $***1350</p>
<p>Note that, unlike the field width, the new fill character stays in effect until you change it.</p>
<h5 id="ch17lev3sec6">Setting Floating-Point Display Precision</h5>
<p>The meaning of floating-point <em>precision</em> depends on the output mode. In the default mode, it means the total number of digits displayed. In the fixed and scientific modes, to be discussed soon, <em>precision</em> means the number of digits displayed to the right of the decimal place. The precision default for C++, as you&#8217;ve seen, is <code>6</code>. (Recall, however, that trailing zeros are dropped.) The <code>precision()</code> member function lets you select other values. For example, the following statement causes <code>cout</code> to set the precision to <code>2</code>:</p>
<p class="programlisting">cout.precision(2);</p>
<p>Unlike the case with <code>width()</code>, but like the case for <code>fill()</code>, a new precision setting stays in effect until it is reset. <a href="#ch17ex06">Listing 17.6</a> demonstrates precisely this point.</p>
<p class="caption1"><a id="ch17ex06"/><strong>Listing 17.6. <code>precise.cpp</code></strong></p><hr/>
<p class="programlisting1">// precise.cpp -- setting the precision<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;float price1 = 20.40;<br/>&#160;&#160;&#160;&#160;float price2 = 1.9 + 8.0 / 9.0;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"Furry Friends\" is $" &lt;&lt; price1 &lt;&lt; "!\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"Fiery Fiends\" is $" &lt;&lt; price2 &lt;&lt; "!\n";<br/><br/>&#160;&#160;&#160;&#160;cout.precision(2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"Furry Friends\" is $" &lt;&lt; price1 &lt;&lt; "!\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"Fiery Fiends\" is $" &lt;&lt; price2 &lt;&lt; "!\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1083"/>Here is the output of the program in <a href="#ch17ex06">Listing 17.6</a>:</p>
<p class="programlisting">"Furry Friends" is $20.4!<br/>"Fiery Fiends" is $2.78889!<br/>"Furry Friends" is $20!<br/>"Fiery Fiends" is $2.8!</p>
<p>Note that the third line of this output doesn&#8217;t include a trailing decimal point. Also the fourth line displays a total of two digits.</p>
<h5 id="ch17lev3sec7">Printing Trailing Zeros and Decimal Points</h5>
<p>Certain forms of output, such as prices or numbers in columns, look better if trailing zeros are retained. For example, the output to <a href="#ch17ex06">Listing 17.6</a> would look better as $20.40 than as $20.4. The <code>iostream</code> family of classes doesn&#8217;t provide a function whose sole purpose is to accomplish that. However, the <code>ios_base</code> class provides a <code>setf()</code> (for <em>set flag</em>) function that controls several formatting features. The class also defines several constants that can be used as arguments to this function. For example, the following function call causes <code>cout</code> to display trailing decimal points:</p>
<p class="programlisting">cout.setf(ios_base::showpoint);</p>
<p>In the default floating-point format, it also causes trailing zeros to be displayed. That is, instead of displaying <code>2.00</code> as <code>2</code>, <code>cout</code> will display it as <code>2.00000</code> if the default precision of 6 is in effect. <a href="#ch17ex07">Listing 17.7</a> adds this statement to <a href="#ch17ex06">Listing 17.6</a>.</p>
<p>In case you&#8217;re wondering about the notation <code>ios_base::showpoint</code>, <code>showpoint</code> is a class-scope static constant that is defined in the <code>ios_base</code> class declaration. Class scope means that you have to use the scope-resolution operator (<code>::</code>) with the constant name if you use the name outside a member function definition. So <code>ios_base::showpoint</code> names a constant defined in the <code>ios_base</code> class.</p>
<p class="caption1"><a id="page_1084"/><a id="ch17ex07"/><strong>Listing 17.7. <code>showpt.cpp</code></strong></p><hr/>
<p class="programlisting1">// showpt.cpp -- setting the precision, showing trailing point<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::ios_base;<br/><br/>&#160;&#160;&#160;&#160;float price1 = 20.40;<br/>&#160;&#160;&#160;&#160;float price2 = 1.9 + 8.0 / 9.0;<br/><br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::showpoint);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"Furry Friends\" is $" &lt;&lt; price1 &lt;&lt; "!\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"Fiery Fiends\" is $" &lt;&lt; price2 &lt;&lt; "!\n";<br/><br/>&#160;&#160;&#160;&#160;cout.precision(2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"Furry Friends\" is $" &lt;&lt; price1 &lt;&lt; "!\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"Fiery Fiends\" is $" &lt;&lt; price2 &lt;&lt; "!\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch17ex07">Listing 17.7</a>, using the current C++ formatting:</p>
<p class="programlisting">"Furry Friends" is $20.4000!<br/>"Fiery Fiends" is $2.78889!<br/>"Furry Friends" is $20.!<br/>"Fiery Fiends" is $2.8!</p>
<p>This output shows the trailing zeros for the first line. The third line shows the decimal point but no trailing zeros because the precision has been set to <code>2</code> and two digits already have been displayed.</p>
<h5 id="ch17lev3sec8">More About <code>setf()</code></h5>
<p>The <code>setf()</code> method controls several other formatting choices besides when the decimal point is displayed, so let&#8217;s take a closer look at it. The <code>ios_base</code> class has a protected data member in which individual bits (called <em>flags</em> in this context) control different formatting aspects, such as the number base and whether trailing zeros are displayed. Turning a flag on is called <em>setting the flag</em> (or bit) and means setting the bit to <code>1</code>. (Bit flags are the programming equivalent to setting DIP switches to configure computer hardware.) The <code>hex</code>, <code>dec</code>, and <code>oct</code> manipulators, for example, adjust the three flag bits that control the number base. The <code>setf()</code> function provides another means of adjusting flag bits.</p>
<p>The <code>setf()</code> function has two prototypes. The first is this:</p>
<p class="programlisting">fmtflags setf(fmtflags);</p>
<p><a id="page_1085"/>Here <code>fmtflags</code> is a <code>typedef</code> name for a <em>bitmask</em> type (see the following Note) used to hold the format flags. The name is defined in the <code>ios_base</code> class. This version of <code>setf()</code> is used for setting format information controlled by a single bit. The argument is a <code>fmtflags</code> value that indicates which bit to set. The return value is a type <code>fmtflags</code> number that indicates the former settings of all the flags. You can then save that value if you later want to restore the original settings. What value do you pass to <code>setf()</code>? If you want to set bit number 11 to <code>1</code>, you pass a number that has its number 11 bit set to <code>1</code>. The return value would have its number 11 bit assigned the prior value for that bit. Keeping track of bits sounds (and is) tedious. However, you don&#8217;t have to do that job; the <code>ios_base</code> class defines constants that represent the bit values. <a href="#ch17table01">Table 17.1</a> shows some of these definitions.</p>
<p class="caption"><a id="ch17table01"/><strong>Table 17.1. Formatting Constants</strong></p>
<p class="image"><img src="graphics/17tab01.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch17note04"/>Note</p>
<p class="notepara">A <em>bitmask type</em> is a type that is used to store individual bit values. It could be an integer type, an <code>enum</code>, or an STL <code>bitset</code> container. The main idea is that each bit is individually accessible and has its own meaning. The <code>iostream</code> package uses bitmask types to store state information.</p>
<hr/></div>
<p>Because these formatting constants are defined within the <code>ios_base</code> class, you must use the scope-resolution operator with them. That is, you must use <code>ios_base::uppercase</code>, not just <code>uppercase</code>. If you don&#8217;t use a <code>using</code> directive or <code>using</code> declaration, you can use the scope-resolution operator to indicate that these names are in the <code>std</code> namespace. That is, you can use <code>std::ios_base::showpos</code>, and so on. Changes remain in effect until they are overridden. <a href="#ch17ex08">Listing 17.8</a> illustrates using some of these constants.</p>
<p class="caption1"><a id="ch17ex08"/><strong>Listing 17.8. <code>setf.cpp</code></strong></p><hr/>
<p class="programlisting1">// setf.cpp -- using setf() to control formatting<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;using std::ios_base;<br/><br/>&#160;&#160;&#160;&#160;int temperature = 63;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Today's water temperature: ";<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::showpos);&#160;&#160;&#160;&#160;// show plus sign<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; temperature &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "For our programming friends, that's\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; std::hex &lt;&lt; temperature &lt;&lt; endl; // use hex<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::uppercase);&#160;&#160;&#160;// use uppercase in hex<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::showbase);&#160;&#160;&#160;&#160;// use 0X prefix for hex<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "or\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; temperature &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "How " &lt;&lt; true &lt;&lt; "!&#160;&#160;oops -- How ";<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::boolalpha);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; true &lt;&lt; "!\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1086"/>Here is the output of the program in <a href="#ch17ex08">Listing 17.8</a>:</p>
<p class="programlisting">Today's water temperature: +63<br/>For our programming friends, that's<br/>3f<br/>or<br/>0X3F<br/>How 0X1!&#160;&#160;oops -- How true!</p>
<p>Note that the plus sign is used only with the base 10 version. C++ treats hexadecimal and octal values as unsigned; therefore no sign is needed for them. (However, some C++ implementations may still display a plus sign.)</p>
<p>The second <code>setf()</code> prototype takes two arguments and returns the prior setting:</p>
<p class="programlisting">fmtflags setf(fmtflags , fmtflags );</p>
<p>This overloaded form of the function is used for format choices controlled by more than 1 bit. The first argument, as before, is a <code>fmtflags</code> value that contains the desired setting. The second argument is a value that first clears the appropriate bits. For example, suppose setting bit 3 to <code>1</code> means base 10, setting bit 4 to <code>1</code> means base 8, and setting bit 5 to <code>1</code> means base 16. Suppose output is in base 10, and you want to set it to base 16. Not only do you have to set bit 5 to <code>1</code>, you also have to set bit 3 to <code>0</code>; this is called <em>clearing the bit</em>. The clever <code>hex</code> manipulator does both tasks automatically. Using the <code>setf()</code> function requires a bit more work because you use the second argument to indicate which bits to clear and then use the first argument to indicate which bit to set. This is not as complicated as it sounds because the <code>ios_base</code> class defines constants (shown in <a href="#ch17table02">Table 17.2</a>) for this purpose. In particular, you should use the constant <code>ios_base::basefield</code> as the second argument and <code>ios_base::hex</code> as the first argument if you&#8217;re changing bases. That is, the following function call has the same effect as using the <code>hex</code> manipulator:</p>
<p class="programlisting">cout.setf(ios_base::hex, ios_base::basefield);</p>
<p class="caption"><a id="page_1087"/><a id="ch17table02"/><strong>Table 17.2. Arguments for <code>setf(long, long)</code></strong></p>
<p class="image"><img src="graphics/17tab02.jpg" alt="Image"/></p>
<p>The <code>ios_base</code> class defines three sets of formatting flags that can be handled this way. Each set consists of one constant to be used as the second argument and two to three constants to be used as a first argument. The second argument clears a batch of related bits; then the first argument sets one of those bits to <code>1</code>. <a href="#ch17table02">Table 17.2</a> shows the names of the constants used for the second <code>setf()</code> argument, the associated choice of constants for the first argument, and their meanings. For example, to select left-justification, you use <code>ios_base::adjustfield</code> for the second argument and <code>ios_base::left</code> as the first argument. Left-justification means starting a value at the left end of the field, and right-justification means ending a value at the right end of the field. Internal justification means placing any signs or base prefixes at the left of the field and the rest of the number at the right of the field. (Unfortunately, C++ does not provide a self-justification mode.)</p>
<p>Fixed-point notation means using the 123.4 style for floating-point values, regardless of the size of the number, and scientific notation means using the 1.23e04 style, regardless of the size of the number. If you are familiar with C&#8217;s <code>printf()</code> specifiers, it may help you to know that the default C++ mode corresponds to the <code>%g</code> specifier, <code>fixed</code> corresponds to the <code>%f</code> specifier, and <code>scientific</code> corresponds to the <code>%e</code> specifier.</p>
<p>Under the C++ Standard, both fixed and scientific notation have the following two properties:</p>
<p class="indenthandingB">&#8226; <em>Precision</em> means the number of digits to the right of the decimal rather than the total number of digits.</p>
<p class="indenthandingB">&#8226; Trailing zeros are displayed.</p>
<p>The <code>setf()</code> function is a member function of the <code>ios_base</code> class. Because that&#8217;s a base class for the <code>ostream</code> class, you can invoke the function by using the <code>cout</code> object. For example, to request left-justification, you use this call:</p>
<p class="programlisting">ios_base::fmtflags old = cout.setf(ios::left, ios::adjustfield);</p>
<p>To restore the previous setting, you use this:</p>
<p class="programlisting">cout.setf(old, ios::adjustfield);</p>
<p><a id="page_1088"/><a href="#ch17ex09">Listing 17.9</a> illustrates further examples of using <code>setf()</code> with two arguments.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note05"/>Note</p>
<p class="notepara">The program in <a href="#ch17ex09">Listing 17.9</a> uses a math function, and some C++ systems don&#8217;t automatically search the math library. For example, some Unix systems require that you use the following:</p>
<p class="programlistingB">$ CC setf2.C -lm</p>
<p class="notepara">The <code>-lm</code> option instructs the linker to search the math library. Similarly, some Linux systems using g++ require the same flag.</p>
<hr/></div>
<p class="caption1"><a id="ch17ex09"/><strong>Listing 17.9. <code>setf2.cpp</code></strong></p><hr/>
<p class="programlisting1">// setf2.cpp -- using setf() with 2 arguments to control formatting<br/>#include &lt;iostream&gt;<br/>#include &lt;cmath&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;// use left justification, show the plus sign, show trailing<br/>&#160;&#160;&#160;&#160;// zeros, with a precision of 3<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::left, ios_base::adjustfield);<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::showpos);<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::showpoint);<br/>&#160;&#160;&#160;&#160;cout.precision(3);<br/>&#160;&#160;&#160;&#160;// use e-notation and save old format setting<br/>&#160;&#160;&#160;&#160;ios_base::fmtflags old = cout.setf(ios_base::scientific,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Left Justification:\n";<br/>&#160;&#160;&#160;&#160;long n;<br/>&#160;&#160;&#160;&#160;for (n = 1; n &lt;= 41; n+= 10)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(4);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; n &lt;&lt; "|";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(12);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; sqrt(double(n)) &lt;&lt; "|\n";<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// change to internal justification<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::internal, ios_base::adjustfield);<br/>&#160;&#160;&#160;&#160;// restore default floating-point display style<br/>&#160;&#160;&#160;&#160;cout.setf(old, ios_base::floatfield);<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Internal Justification:\n";<br/>&#160;&#160;&#160;&#160;for (n = 1; n &lt;= 41; n+= 10)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(4);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; n &lt;&lt; "|";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(12);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; sqrt(double(n)) &lt;&lt; "|\n";<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;// use right justification, fixed notation<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::right, ios_base::adjustfield);<br/>&#160;&#160;&#160;&#160;cout.setf(ios_base::fixed, ios_base::floatfield);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Right Justification:\n";<br/>&#160;&#160;&#160;&#160;for (n = 1; n &lt;= 41; n+= 10)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(4);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; n &lt;&lt; "|";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(12);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; sqrt(double(n)) &lt;&lt; "|\n";<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1089"/>Here is the output of the program in <a href="#ch17ex09">Listing 17.9</a>:</p>
<p class="programlisting">Left Justification:<br/>+1&#160;&#160;|+1.000e+00&#160;&#160;|<br/>+11 |+3.317e+00&#160;&#160;|<br/>+21 |+4.583e+00&#160;&#160;|<br/>+31 |+5.568e+00&#160;&#160;|<br/>+41 |+6.403e+00&#160;&#160;|<br/>Internal Justification:<br/>+&#160;&#160;1|+&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.00|<br/>+ 11|+&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.32|<br/>+ 21|+&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.58|<br/>+ 31|+&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.57|<br/>+ 41|+&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.40|<br/>Right Justification:<br/>&#160;&#160;+1|&#160;&#160;&#160;&#160;&#160;&#160;+1.000|<br/>&#160;+11|&#160;&#160;&#160;&#160;&#160;&#160;+3.317|<br/>&#160;+21|&#160;&#160;&#160;&#160;&#160;&#160;+4.583|<br/>&#160;+31|&#160;&#160;&#160;&#160;&#160;&#160;+5.568|<br/>&#160;+41|&#160;&#160;&#160;&#160;&#160;&#160;+6.403|</p>
<p>Note how a precision of 3 causes the default floating-point display (used for internal justification in this program) to display a total of three digits, while the fixed and scientific modes display three digits to the right of the decimal. (The number of digits displayed in the exponent for e-notation depends on the implementation.)</p>
<p><a id="page_1090"/>The effects of calling <code>setf()</code> can be undone with <code>unsetf()</code>, which has the following prototype:</p>
<p class="programlisting">void unsetf(fmtflags mask);</p>
<p>Here <code>mask</code> is a bit pattern. All bits set to <code>1</code> in <code>mask</code> cause the corresponding bits to be unset. That is, <code>setf()</code> sets bits to <code>1</code>, and <code>unsetf()</code> sets bits back to <code>0</code>. Here&#8217;s an example:</p>
<p class="programlisting">cout.setf(ios_base::showpoint);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// show trailing decimal point<br/>cout.unsetf(ios_base::boolshowpoint); // don't show trailing decimal point<br/>cout.setf(ios_base::boolalpha);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// display true, false<br/>cout.unsetf(ios_base::boolalpha);&#160;&#160;&#160;&#160;&#160;// display 1, 0</p>
<p>You may have noticed that there is no special flag to indicate the default mode for displaying floating-point numbers. Here&#8217;s how the system works. Fixed notation is used if the fixed bit, and only the fixed bit is set. Scientific notation is used if the scientific bit and only the scientific bit is set. Any other combination, such as no bits set or both bits set, results in the default mode being used. So one way to invoke the default mode is this:</p>
<p class="programlisting">cout.setf(0, ios_base::floatfield);&#160;&#160;// go to default mode</p>
<p>The second argument turns both bits off, and the first argument doesn&#8217;t set any bits. A shorter way to accomplish the same end is to use <code>unsetf() with ios_base::floatfield</code>:</p>
<p class="programlisting">cout.unsetf(ios_base::floatfield);&#160;&#160;&#160;// go to default mode</p>
<p>If you knew for certain that <code>cout</code> were in the fixed state, you could use <code>ios_base::fixed</code> as an argument to <code>unsetf()</code>, but using <code>ios_base::floatfield</code> works, regardless of the current state of <code>cout</code>, so it&#8217;s a better choice.</p>
<h5 id="ch17lev3sec9">Standard Manipulators</h5>
<p>Using <code>setf()</code> is not the most user-friendly approach to formatting, so C++ offers several manipulators to invoke <code>setf()</code> for you, automatically supplying the right arguments. You&#8217;ve already seen <code>dec</code>, <code>hex</code>, and <code>oct</code>. These manipulators, most of which are not available to older C++ implementations, work like <code>hex</code>. For example, the following statement turns on left-justification and the fixed decimal point option:</p>
<p class="programlisting">cout &lt;&lt; left &lt;&lt; fixed;</p>
<p><a href="#ch17table03">Table 17.3</a> lists these along with several other manipulatrs.</p>
<p class="caption"><a id="ch17table03"/><strong>Table 17.3. Some Standard Manipulators</strong></p>
<p class="image"><img src="graphics/17tab03.jpg" alt="Image"/></p>
<div class="note"><hr/>
<p class="title"><a id="ch17note06"/><a id="page_1091"/>Tip</p>
<p class="notepara">If your system supports these manipulators, take advantage of them; if it doesn&#8217;t, you still have the option of using <code>setf()</code>.</p>
<hr/></div>
<h5 id="ch17lev3sec10">The <code>iomanip</code> Header File</h5>
<p>Setting some format values, such as the field width, can be awkward using the <code>iostream</code> tools. To make life easier, C++ supplies additional manipulators in the <code>iomanip</code> header file. They provide the same services already discussed, but in a notationally more convenient manner. The three most commonly used are <code>setprecision()</code> for setting the precision, <code>setfill()</code> for setting the fill character, and <code>setw()</code> for setting the field width. Unlike the manipulators discussed previously, these take arguments. The <code>setprecision()</code> manipulator takes an integer argument that specifies the precision, the <code>setfill()</code> manipulator takes a <code>char</code> argument that indicates the fill character, and the <code>setw()</code> manipulator takes an integer argument that specifies the field width. Because they are manipulators, <a id="page_1092"/>they can be concatenated in a <code>cout</code> statement. This makes the <code>setw()</code> manipulator particularly convenient when you&#8217;re displaying several columns of values. <a href="#ch17ex10">Listing 17.10</a> illustrates this by changing the field width and fill character several times for one output line. It also uses some of the newer standard manipulators.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note07"/>Note</p>
<p class="notepara">Some C++ systems don&#8217;t automatically search the math library. As mentioned before, some Unix systems require that you use the following to access the math library:</p>
<p class="programlistingB">$ CC iomanip.C -lm</p>
<hr/></div>
<p class="caption1"><a id="ch17ex10"/><strong>Listing 17.10. <code>iomanip.cpp</code></strong></p><hr/>
<p class="programlisting1">// iomanip.cpp -- using manipulators from iomanip<br/>// some systems require explicitly linking the math library<br/>#include &lt;iostream&gt;<br/>#include &lt;iomanip&gt;<br/>#include &lt;cmath&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;// use new standard manipulators<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; fixed &lt;&lt; right;<br/><br/>&#160;&#160;&#160;&#160;// use iomanip manipulators<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; setw(6) &lt;&lt; "N" &lt;&lt; setw(14) &lt;&lt; "square root"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setw(15) &lt;&lt; "fourth root\n";<br/><br/>&#160;&#160;&#160;&#160;double root;<br/>&#160;&#160;&#160;&#160;for (int n = 10; n &lt;=100; n += 10)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root = sqrt(double(n));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; setw(6) &lt;&lt; setfill('.') &lt;&lt; n &lt;&lt; setfill(' ')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setw(12) &lt;&lt; setprecision(3) &lt;&lt; root<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setw(14) &lt;&lt; setprecision(4) &lt;&lt; sqrt(root)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch17ex10">Listing 17.10</a>:</p>
<p class="programlisting">&#160;&#160;&#160;&#160;&#160;N&#160;&#160;&#160;square root&#160;&#160;&#160;fourth root<br/>....10&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.162&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1.7783<br/>....20&#160;&#160;&#160;&#160;&#160;&#160;&#160;4.472&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1147<br/><a id="page_1093"/>....30&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.477&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3403<br/>....40&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.325&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5149<br/>....50&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.071&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.6591<br/>....60&#160;&#160;&#160;&#160;&#160;&#160;&#160;7.746&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.7832<br/>....70&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.367&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.8925<br/>....80&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.944&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.9907<br/>....90&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.487&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.0801<br/>...100&#160;&#160;&#160;&#160;&#160;&#160;10.000&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1623</p>
<p>Now you can produce neatly aligned columns. Using the <code>fixed</code> manipulator causes trailing zeros to be displayed.</p>
<h3 id="ch17lev1sec3">Input with <code>cin</code></h3>
<p>Now it&#8217;s time to turn to input and getting data into a program. The <code>cin</code> object represents the standard input as a stream of bytes. Normally, you generate that stream of characters at the keyboard. If you type the character sequence <code>2011</code>, the <code>cin</code> object extracts those characters from the input stream. You may intend that input to be part of a string, to be an <code>int</code> value, to be a <code>float</code> value, or to be some other type. Thus, extraction also involves type conversion. The <code>cin</code> object, guided by the type of variable designated to receive the value, must use its methods to convert that character sequence into the intended type of value.</p>
<p>Typically, you use <code>cin</code> as follows:</p>
<p class="programlisting">cin &gt;&gt; <span class="EmpItalic">value_holder</span>;</p>
<p>Here <em><code>value_holder</code></em> identifies the memory location in which to store the input. It can be the name of a variable, a reference, a dereferenced pointer, or a member of a structure or of a class. How <code>cin</code> interprets the input depends on the data type for <em><code>value_holder</code></em>. The <code>istream</code> class, defined in the <code>iostream</code> header file, overloads the <code>&gt;&gt;</code> extraction operator to recognize the following basic types:</p>
<p class="indenthandingB">&#8226; <code>signed char &#38;</code></p>
<p class="indenthandingB">&#8226; <code>unsigned char &#38;</code></p>
<p class="indenthandingB">&#8226; <code>char &#38;</code></p>
<p class="indenthandingB">&#8226; <code>short &#38;</code></p>
<p class="indenthandingB">&#8226; <code>unsigned short &#38;</code></p>
<p class="indenthandingB">&#8226; <code>int &#38;</code></p>
<p class="indenthandingB">&#8226; <code>unsigned int &#38;</code></p>
<p class="indenthandingB">&#8226; <code>long &#38;</code></p>
<p class="indenthandingB">&#8226; <code>unsigned long &#38;</code></p>
<p class="indenthandingB">&#8226; <code>long long &#38;</code> (C++11)</p>
<p class="indenthandingB">&#8226; <code>unsigned long long &#38;</code> (C++11)</p>
<p class="indenthandingB">&#8226; <a id="page_1094"/><code>float &#38;</code></p>
<p class="indenthandingB">&#8226; <code>double &#38;</code></p>
<p class="indenthandingB">&#8226; <code>long double &#38;</code></p>
<p>These are referred to as <em>formatted input functions</em> because they convert the input data to the format indicated by the target.</p>
<p>A typical operator function has a prototype like the following:</p>
<p class="programlisting">istream &#38; operator&gt;&gt;(int &#38;);</p>
<p>Both the argument and the return value are references. With a reference argument (see <a href="ch08.html#ch08">Chapter 8</a>, &#8220;<a href="ch08.html#ch08">Adventures in Functions</a>&#8221;), a statement such as the following causes the <code>operator&gt;&gt;()</code> function to work with the variable <code>staff_size</code> itself rather than with a copy, as would be the case with a regular argument:</p>
<p class="programlisting">cin &gt;&gt; staff_size;</p>
<p>Because the argument type is a reference, <code>cin</code> is able to directly modify the value of a variable used as an argument. The preceding statement, for example, directly modifies the value of the <code>staff_size</code> variable. We&#8217;ll get to the significance of a reference return value in a moment. First, let&#8217;s examine the type conversion aspect of the extraction operator. For arguments of each type in the preceding list of types, the extraction operator converts the character input to the indicated type of value. For example, suppose <code>staff_size</code> is type <code>int</code>. In this case, the compiler matches</p>
<p class="programlisting">cin &gt;&gt; staff_size;</p>
<p>to the following prototype:</p>
<p class="programlisting">istream &#38; operator&gt;&gt;(int &#38;);</p>
<p>The function corresponding to that prototype then reads the stream of characters being sent to the program&#8212;say, the characters <code>2</code>, <code>3</code>, <code>1</code>, <code>8</code>, and <code>4</code>. For a system using a 2-byte <code>int</code>, the function then converts these characters to the 2-byte binary representation of the integer <code>23184</code>. If, on the other hand, <code>staff_size</code> were type <code>double</code>, <code>cin</code> would use <code>operator&gt;&gt;(double &#38;)</code> to convert the same input into the 8-byte floating-point representation of the value <code>23184.0</code>.</p>
<p>Incidentally, you can use the <code>hex</code>, <code>oct</code>, and <code>dec</code> manipulators with <code>cin</code> to specify that integer input is to be interpreted as hexadecimal, octal, or decimal format. For example, the following statement causes an input of <code>12</code> or <code>0x12</code> to be read as hexadecimal <code>12</code>, or decimal <code>18</code>, and it causes <code>ff</code> or <code>FF</code> to be read as decimal <code>255</code>:</p>
<p class="programlisting">cin &gt;&gt; hex;</p>
<p>The <code>istream</code> class also overloads the <code>&gt;&gt;</code> extraction operator for character pointer types:</p>
<p class="indenthandingB">&#8226; <code>signed char</code> *</p>
<p class="indenthandingB">&#8226; <code>char</code> *</p>
<p class="indenthandingB">&#8226; <code>unsigned char</code> *</p>
<p><a id="page_1095"/>For this type of argument, the extraction operator reads the next word from input and places it at the indicated address, adding a null character to make a string. For example, suppose you have this code:</p>
<p class="programlisting">cout &lt;&lt; "Enter your first name:\n";<br/>char name[20];<br/>cin &gt;&gt; name;</p>
<p>If you respond to the request by typing <strong><code>Liz</code></strong>, the extraction operator places the characters <code>Liz\0</code> in the <code>name</code> array. (As usual, <code>\0</code> represents the terminating null character.) The <code>name</code> identifier, being the name of a <code>char</code> array, acts as the address of the array&#8217;s first element, making <code>name</code> type <code>char *</code> (pointer-to-<code>char</code>).</p>
<p>The fact that each extraction operator returns a reference to the invoking object lets you concatenate input, just as you can concatenate output:</p>
<p class="programlisting">char name[20];<br/>float fee;<br/>int group;<br/>cin &gt;&gt; name &gt;&gt; fee &gt;&gt; group;</p>
<p>Here, for example, the <code>cin</code> object returned by <code>cin &gt;&gt; name</code> becomes the object that handles <code>fee</code>.</p>
<h4 id="ch17lev2sec8">How <code>cin &gt;&gt;</code> Views Input</h4>
<p>The various versions of the extraction operator share a common way of looking at the input stream. They skip over white space (blanks, newlines, and tabs) until they encounter a non-white-space character. This is true even for the single-character modes (those in which the argument is type <code>char</code>, <code>unsigned char</code>, or <code>signed char</code>), which is not true of C&#8217;s character input functions (see <a href="#ch17fig05">Figure 17.5</a>). In the single-character modes, the <code>&gt;&gt;</code> operator reads that character and assigns it to the indicated location. In the other modes, the operator reads in one unit of the indicated type. That is, it reads everything from the initial non-white-space character up to the first character that doesn&#8217;t match the destination type.</p>
<p class="caption"><a id="ch17fig05"/><strong>Figure 17.5. <code>cin &gt;&gt;</code> skips over white space.</strong></p>
<p class="image"><img src="graphics/17fig05.jpg" alt="Image"/></p>
<p>For example, consider the following code:</p>
<p class="programlisting">int elevation;<br/>cin &gt;&gt; elevation;</p>
<p>Suppose you type the following characters:</p>
<p class="programlisting">-123Z</p>
<p>The operator will read the <code>-</code>, <code>1</code>, <code>2</code>, and <code>3</code> characters because they are all valid parts of an integer. But the <code>Z</code> character isn&#8217;t valid, so the last character accepted for input is the <code>3</code>. The <code>Z</code> remains in the input stream, and the next <code>cin</code> statement will start reading at that point. Meanwhile, the operator converts the character sequence <code>-123</code> to an integer value and assigns it to <code>elevation</code>.</p>
<p><a id="page_1096"/>It can happen that input fails to meet a program&#8217;s expectation. For example, suppose you enter <strong><code>Zcar</code></strong> instead of <strong><code>-123Z</code></strong>. In that case, the extraction operator leaves the value of <code>elevation</code> unchanged and returns the value <code>0</code>. (More technically, an <code>if</code> or <code>while</code> statement evaluates an <code>istream</code> object as <code>false</code> if it&#8217;s had an error state set; we&#8217;ll discuss this in more depth later in this chapter.) The <code>false</code> return value allows a program to check whether input meets the program requirements, as <a href="#ch17ex11">Listing 17.11</a> shows.</p>
<p class="caption1"><a id="ch17ex11"/><strong>Listing 17.11. <code>check_it.cpp</code></strong></p><hr/>
<p class="programlisting1">// check_it.cpp -- checking for valid input<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter numbers: ";<br/><br/>&#160;&#160;&#160;&#160;int sum = 0;<br/>&#160;&#160;&#160;&#160;int input;<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; input)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum += input;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Last value entered = " &lt;&lt; input &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sum = " &lt;&lt; sum &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1097"/>Here&#8217;s the output of the program in <a href="#ch17ex11">Listing 17.11</a> when some inappropriate input (<code>-123Z</code>) sneaks into the input stream:</p>
<p class="programlisting">Enter numbers: <span class="EmpStrong">200</span><br/><span class="EmpStrong">10 -50 -123Z 60</span><br/>Last value entered = -123<br/>Sum = 37</p>
<p>Because input is buffered, the second line of keyboard input values didn&#8217;t get sent to the program until you pressed Enter at the end of the line. But the loop quit processing input at the <code>Z</code> character because it didn&#8217;t match any of the floating-point formats. The failure of input to match the expected format, in turn, caused the expression <code>cin&gt;&gt; input</code> to evaluate to <code>false</code>, thus terminating the <code>while</code> loop.</p>
<h4 id="ch17lev2sec9">Stream States</h4>
<p>Let&#8217;s take a closer look at what happens for inappropriate input. A <code>cin</code> or <code>cout</code> object contains a data member (inherited from the <code>ios_base</code> class) that describes the <em>stream state</em>. A stream state (defined as type <code>iostate</code>, which, in turn, is a bitmask type, such as described earlier) consists of the three <code>ios_base</code> elements: <code>eofbit</code>, <code>badbit</code>, and <code>failbit</code>. Each element is a single bit that can be <code>1</code> (set) or <code>0</code> (cleared). When a <code>cin</code> operation reaches the end of a file, it sets <code>eofbit</code>. When a <code>cin</code> operation fails to read the expected characters, as in the earlier example, it sets <code>failbit</code>. I/O failures, such as trying to read a non-accessible file or trying to write to a write-protected disk, also can set <code>failbit</code> to <code>1</code>. The <code>badbit</code> element is set when some undiagnosed failure may have corrupted the stream. (Implementations don&#8217;t necessarily agree about which events set <code>failbit</code> and which set <code>badbit</code>.) When all three of these state bits are set to <code>0</code>, everything is fine. Programs can check the stream state and use that information to decide what to do next. <a href="#ch17table04">Table 17.4</a> lists these bits, along with some <code>ios_base</code> methods that report or alter the stream state.</p>
<p class="caption"><a id="ch17table04"/><strong>Table 17.4. Stream States</strong></p>
<p class="image"><img src="graphics/17tab04.jpg" alt="Image"/></p>
<h5 id="ch17lev3sec11">Setting States</h5>
<p><a id="page_1098"/>Two of the methods in <a href="#ch17table04">Table 17.4</a>, <code>clear()</code> and <code>setstate()</code>, are similar. Both reset the state, but they do so in a different fashion. The <code>clear()</code> method sets the state to its argument. Thus, the following call uses the default argument of <code>0</code>, which clears all three state bits (<code>eofbit</code>, <code>badbit</code>, and <code>failbit</code>):</p>
<p class="programlisting">clear();</p>
<p>Similarly, the following call makes the state equal to <code>eofbit</code>; that is, <code>eofbit</code> is set, and the other two state bits are cleared:</p>
<p class="programlisting">clear(eofbit);</p>
<p>The <code>setstate()</code> method, however, affects only those bits that are set in its argument. Thus, the following call sets <code>eofbit</code> without affecting the other bits:</p>
<p class="programlisting">setstate(eofbit);</p>
<p>So if <code>failbit</code> was already set, it stays set.</p>
<p>Why would you reset the stream state? For a program writer, the most common reason is to use <code>clear()</code> with no argument to reopen input after encountering mismatched input or end-of-file; whether doing so makes sense depends on what the program is trying to accomplish. You&#8217;ll see some examples shortly. The main purpose for <code>setstate()</code> is to provide a means for input and output functions to change the state. For example, if <code>num</code> is an <code>int</code>, the following call can result in <code>operator&gt;&gt;(int &#38;)</code> using <code>setstate()</code> to set <code>failbit</code> or <code>eofbit</code>:</p>
<p class="programlisting">cin &gt;&gt; num;&#160;&#160;// read an int</p>
<h5 id="ch17lev3sec12">I/O and Exceptions</h5>
<p><a id="page_1099"/>Suppose that an input function sets <code>eofbit</code>. Does this cause an exception to be thrown? By default, the answer is no. However, you can use the <code>exceptions()</code> method to control how exceptions are handled.</p>
<p>First, here&#8217;s some background. The <code>exceptions()</code> method returns a bitfield with three bits corresponding to <code>eofbit</code>, <code>failbit</code>, and <code>badbit</code>. Changing the stream state involves either <code>clear()</code> or <code>setstate()</code>, which uses <code>clear()</code>. After changing the stream state, the <code>clear()</code> method compares the current stream state to the value returned by <code>exceptions()</code>. If a bit is set in the return value and the corresponding bit is set in the current state, <code>clear()</code> throws an <code>ios_base::failure</code> exception. This would happen, for example, if both values had <code>badbit</code> set. It follows that if <code>exceptions()</code> returns <code>goodbit</code>, no exceptions are thrown. The <code>ios_base::failure</code> exception class derives from the <code>std::exception</code> class and thus has a <code>what()</code> method.</p>
<p>The default setting for <code>exceptions()</code> is <code>goodbit</code>&#8212;that is, no exceptions thrown. However, the overloaded <code>exceptions(iostate)</code> function gives you control over the behavior:</p>
<p class="programlisting">cin.exceptions(badbit);&#160;&#160;// setting badbit causes exception to be thrown</p>
<p>The bitwise OR operator (<code>|</code>), as discussed in <a href="app05.html#app05">Appendix E</a>, allows you to specify more than one bit. For example, the following statement results in an exception being thrown if either <code>badbit</code> or <code>eofbit</code> is subsequently set:</p>
<p class="programlisting">cin.exceptions(badbit | eofbit);</p>
<p><a href="#ch17ex12">Listing 17.12</a> modifies <a href="#ch17ex11">Listing 17.11</a> so that the program throws and catches an exception if <code>failbit</code> is set.</p>
<p class="caption1"><a id="ch17ex12"/><strong>Listing 17.12. <code>cinexcp.cpp</code></strong></p><hr/>
<p class="programlisting1">// cinexcp.cpp -- having cin throw an exception<br/>#include &lt;iostream&gt;<br/>#include &lt;exception&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;// have failbit cause an exception to be thrown<br/>&#160;&#160;&#160;&#160;cin.exceptions(ios_base::failbit);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter numbers: ";<br/>&#160;&#160;&#160;&#160;int sum = 0;<br/>&#160;&#160;&#160;&#160;int input;<br/>&#160;&#160;&#160;&#160;try {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin &gt;&gt; input)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum += input;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;} catch(ios_base::failure &#38; bf)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; bf.what() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "O! the horror!\n";<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Last value entered = " &lt;&lt; input &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Sum = " &lt;&lt; sum &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1100"/>Here is a sample run of the program in <a href="#ch17ex12">Listing 17.12</a>; the <code>what()</code> message depends on the implementation:</p>
<p class="programlisting">Enter numbers: <span class="EmpStrong">20 30 40 pi 6</span><br/>ios_base failure in clear<br/>O! the horror!<br/>Last value entered = 40.00<br/>Sum = 90.00</p>
<p>So that&#8217;s how you can use exceptions for input. But should you use them? It depends on the context. For this example, the answer is no. An exception should catch an unusual, unexpected occurrence, but this particular program uses a type mismatch as the intended way to exit the loop. It might make sense, however, for this program to throw an exception for <code>badbit</code> because that circumstance would be unexpected. Or if the program were designed to read numbers from a data file up to end-of-file, it might make sense to throw an exception for <code>failbit</code> because that would represent a problem with the data file.</p>
<h5 id="ch17lev3sec13">Stream State Effects</h5>
<p>An <code>if</code> or <code>while</code> test such as the following tests as <code>true</code> only if the stream state is good (all bits cleared):</p>
<p class="programlisting">while (cin &gt;&gt; input)</p>
<p>If a test fails, you can use the member functions in <a href="#ch17table04">Table 17.4</a> to discriminate among possible causes. For example, you could modify the central part of <a href="#ch17ex11">Listing 17.11</a> to look like this:</p>
<p class="programlisting">while (cin &gt;&gt; input)<br/>{<br/>&#160;&#160;&#160;&#160;sum += input;<br/>}<br/>if (cin.eof())<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Loop terminated because EOF encountered\n";</p>
<p>Setting a stream state bit has a very important consequence: The stream is closed for further input or output until the bit is cleared. For example, the following code won&#8217;t work:</p>
<p class="programlisting">while (cin &gt;&gt; input)<br/>{<br/><a id="page_1101"/>&#160;&#160;&#160;&#160;sum += input;<br/>}<br/>cout &lt;&lt; "Last value entered = " &lt;&lt; input &lt;&lt; endl;<br/>cout &lt;&lt; "Sum = " &lt;&lt; sum &lt;&lt; endl;<br/>cout &lt;&lt; "Now enter a new number: ";<br/>cin &gt;&gt; input;&#160;&#160;&#160;// won't work</p>
<p>If you want a program to read further input after a stream state bit has been set, you have to reset the stream state to good. This can be done by calling the <code>clear()</code> method:</p>
<p class="programlisting">while (cin &gt;&gt; input)<br/>{<br/>&#160;&#160;&#160;&#160;sum += input;<br/>}<br/>cout &lt;&lt; "Last value entered = " &lt;&lt; input &lt;&lt; endl;<br/>cout &lt;&lt; "Sum = " &lt;&lt; sum &lt;&lt; endl;<br/>cout &lt;&lt; "Now enter a new number: ";<br/>cin.clear();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// reset stream state<br/>while (!isspace(cin.get()))<br/>&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// get rid of bad input<br/>cin &gt;&gt; input;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// will work now</p>
<p>Note that it is not enough to reset the stream state. The mismatched input that terminated the input loop is still in the input queue, and the program has to get past it. One way is to keep reading characters until reaching white space. The <code>isspace()</code> function (see <a href="ch06.html#ch06">Chapter 6</a>, &#8220;<a href="ch06.html#ch06">Branching Statements and Logical Operators</a>&#8221;) is a <code>cctype</code> function that returns <code>true</code> if its argument is a white-space character. Or you can discard the rest of the line instead of just the next word:</p>
<p class="programlisting">while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;continue;&#160;&#160;// get rid rest of line</p>
<p>This example assumes that the loop terminated because of inappropriate input. Suppose, instead, that the loop terminated because of end-of-file or because of a hardware failure. Then the new code disposing of bad input makes no sense. You can fix matters by using the <code>fail()</code> method to test whether the assumption was correct. Because for historical reasons, <code>fail()</code> returns <code>true</code> if either <code>failbit</code> or <code>eofbit</code> is set, the code has to exclude the latter case. The following code shows an example of such exclusion:</p>
<p class="programlisting">while (cin &gt;&gt; input)<br/>{<br/>&#160;&#160;&#160;&#160;sum += input;<br/>}<br/>cout &lt;&lt; "Last value entered = " &lt;&lt; input &lt;&lt; endl;<br/>cout &lt;&lt; "Sum = " &lt;&lt; sum &lt;&lt; endl;<br/>if (cin.fail() &#38;&#38; !cin.eof() ) // failed because of mismatched input<br/>{<br/><br/><a id="page_1102"/>&#160;&#160;&#160;&#160;&#160;&#160;cin.clear();&#160;&#160;&#160;&#160;&#160;&#160;// reset stream state<br/>&#160;&#160;&#160;&#160;&#160;&#160;while (!isspace(cin.get()))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;&#160;&#160;&#160;&#160;// get rid of bad input<br/>}<br/>else // else bail out<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "I cannot go on!\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;exit(1);<br/>}<br/>cout &lt;&lt; "Now enter a new number: ";<br/>cin &gt;&gt; input;&#160;&#160;// will work now</p>
<h4 id="ch17lev2sec10">Other <code>istream</code> Class Methods</h4>
<p><a href="ch03.html#ch03">Chapters 3</a> through <a href="ch05.html#ch05">5</a> discuss the <code>get()</code> and <code>getline()</code> methods. As you may recall, they provide the following additional input capabilities:</p>
<p class="indenthandingB">&#8226; The <code>get(char &#38;)</code> and <code>get(void)</code> methods provide single-character input that doesn&#8217;t skip over white space.</p>
<p class="indenthandingB">&#8226; The <code>get(char *, int, char)</code> and <code>getline(char *, int, char)</code> functions by default read entire lines rather than single words.</p>
<p>These are termed <em>unformatted input functions</em> because they simply read character input as it is, without skipping over white space and without performing data conversions.</p>
<p>Let&#8217;s look at these two groups of <code>istream</code> class member functions.</p>
<h5 id="ch17lev3sec14">Single-Character Input</h5>
<p>When used with a <code>char</code> argument or no argument at all, the <code>get()</code> methods fetch the next input character, even if it is a space, tab, or newline character. The <code>get(char &#38; ch)</code> version assigns the input character to its argument, and the <code>get(void)</code> version uses the input character, converted to an integer type (typically <code>int</code>), as its return value.</p>
<h6 id="ch17lev4sec1">The <code>get(char &#38;)</code> Member Function</h6>
<p>Let&#8217;s try <code>get(char &#38;)</code> first. Suppose you have the following loop in a program:</p>
<p class="programlisting">int ct = 0;<br/>char ch;<br/>cin.get(ch);<br/>while (ch != '\n')<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;ct++;<br/>&#160;&#160;&#160;&#160;cin.get(ch);<br/>}<br/>cout &lt;&lt; ct &lt;&lt; endl;</p>
<p><a id="page_1103"/>Next, suppose you type the following optimistic input:</p>
<p class="programlisting"><span class="EmpStrong">I C++ clearly.</span>&lt;Enter&gt;</p>
<p>Pressing the Enter key sends this input line to the program. The program fragment reads the <code>I</code> character, displays it with <code>cout</code>, and increments <code>ct</code> to <code>1</code>. Next, it reads the space character following the <code>I</code>, displays it, and increments <code>ct</code> to <code>2</code>. This continues until the program processes the Enter key as a newline character and terminates the loop. The main point here is that, by using <code>get(ch)</code>, the code reads, displays, and counts the spaces as well as the printing characters.</p>
<p>Suppose, instead, that the program tried to use <code>&gt;&gt;</code>:</p>
<p class="programlisting">int ct = 0;<br/>char ch;<br/>cin &gt;&gt; ch;<br/>while (ch != '\n')&#160;&#160;&#160;&#160;// FAILS<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;ct++;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ch;<br/>}<br/>cout &lt;&lt; ct &lt;&lt; endl;</p>
<p>First, the code would skip the spaces, thus not counting them and compressing the corresponding output to this:</p>
<p class="programlisting">IC++clearly.</p>
<p>Worse, the loop would never terminate! Because the extraction operator skips newlines, the code would never assign the newline character to <code>ch</code>, so the <code>while</code> loop test would never terminate the loop.</p>
<p>The <code>get(char &#38;)</code> member function returns a reference to the <code>istream</code> object used to invoke it. This means you can concatenate other extractions following <code>get(char &#38;)</code>:</p>
<p class="programlisting">char c1, c2, c3;<br/>cin.get(c1).get(c2) &gt;&gt; c3;</p>
<p>First, <code>cin.get(c1)</code> assigns the first input character to <code>c1</code> and returns the invoking object, which is <code>cin</code>. This reduces the code to <code>cin.get(c2) &gt;&gt; c3</code>, which assigns the second input character to <code>c2</code>. The function call returns <code>cin</code>, reducing the code to <code>cin &gt;&gt; c3</code>. This, in turn, assigns the next non-white-space character to <code>c3</code>. Note that <code>c1</code> and <code>c2</code> could wind up being assigned white space, but <code>c3</code> couldn&#8217;t.</p>
<p>If <code>cin.get(char &#38;)</code> encounters the end of a file, either real or simulated from the keyboard (Ctrl+Z for DOS and Windows command prompt mode, Ctrl+D at the beginning of a line for Unix), it does not assign a value to its argument. This is quite right because if the program has reached the end of the file, there is no value to be assigned. Furthermore, the method calls <code>setstate(failbit)</code>, which causes <code>cin</code> to test as <code>false</code>:</p>
<p class="programlisting"><a id="page_1104"/>char ch;<br/>while (cin.get(ch))<br/>{<br/>&#160;&#160;&#160;&#160;&#160;// process input<br/>}</p>
<p>As long as there&#8217;s valid input, the return value for <code>cin.get(ch)</code> is <code>cin</code>, which evaluates as <code>true</code>, so the loop continues. Upon reaching end-of-file, the return value evaluates as <code>false</code>, terminating the loop.</p>
<h6 id="ch17lev4sec2">The <code>getchar()</code> Member Function</h6>
<p>The <code>get(void)</code> member function also reads white space, but it uses its return value to communicate input to a program. So you would use it this way:</p>
<p class="programlisting">int ct = 0;<br/>char ch;<br/>ch = cin.get();&#160;&#160;&#160;&#160;&#160;&#160;// use return value<br/>while (ch != '\n')<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;ct++;<br/>&#160;&#160;&#160;&#160;ch = cin.get();<br/>}<br/>cout &lt;&lt; ct &lt;&lt; endl;</p>
<p>The <code>get(void)</code> member function returns type <code>int</code> (or some larger integer type, depending on the character set and locale). This makes the following invalid:</p>
<p class="programlisting">char c1, c2, c3;<br/>cin.get().get() &gt;&gt; c3;&#160;&#160;// not valid</p>
<p>Here <code>cin.get()</code> returns a type <code>int</code> value. Because that return value is not a class object, you can&#8217;t apply the membership operator to it. Thus, you get a syntax error. However, you can use <code>get()</code> at the end of an extraction sequence:</p>
<p class="programlisting">char c1;<br/>cin.get(c1).get();&#160;&#160;&#160;// valid</p>
<p>The fact that <code>get(void)</code> returns type <code>int</code> means you can&#8217;t follow it with an extraction operator. But because <code>cin.get(c1)</code> returns <code>cin</code>, it makes it a suitable prefix to <code>get()</code>. This particular code would read the first input character, assign it to <code>c1</code>, and then read the second input character and discard it.</p>
<p>Upon reaching the end-of-file, real or simulated, <code>cin.get(void)</code> returns the value <code>EOF</code>, which is a symbolic constant provided by the <code>iostream</code> header file. This design feature allows the following construction for reading input:</p>
<p class="programlisting">int ch;<br/>while ((ch = cin.get()) != EOF)<br/>{<br/><a id="page_1105"/>&#160;&#160;&#160;&#160;// process input<br/>}</p>
<p>You should use type <code>int</code> for <code>ch</code> instead of type <code>char</code> here because the value <code>EOF</code> may not be expressed as a <code>char</code> type.</p>
<p><a href="ch05.html#ch05">Chapter 5</a>, &#8220;<a href="ch05.html#ch05">Loops and Relational Expressions</a>,&#8221; describes these functions in a bit more detail, and <a href="#ch17table05">Table 17.5</a> summarizes the features of the single-character input functions.</p>
<p class="caption"><a id="ch17table05"/><strong>Table 17.5. <code>cin.get(ch)</code> Versus <code>cin.get()</code></strong></p>
<p class="image"><img src="graphics/17tab05.jpg" alt="Image"/></p>
<h6 id="ch17lev4sec3">Which Form of Single-Character Input to Use?</h6>
<p>Given the choice of <code>&gt;&gt;</code>, <code>get(char &#38;)</code>, and <code>get(void)</code>, which should you use? First, you need to decide whether you want input to skip over white space. If skipping white space is convenient, you should use the extraction operator, <code>&gt;&gt;</code>. For example, skipping white space is convenient for offering menu choices:</p>
<p class="programlisting">cout&#160;&#160;&lt;&lt; "a. annoy client&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;b. bill client\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "c. calm client&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d. deceive client\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "q.\n";<br/>cout&#160;&#160;&lt;&lt; "Enter a, b, c, d, or q: ";<br/>char ch;<br/>cin &gt;&gt; ch;<br/>while (ch != 'q')<br/>{<br/>&#160;&#160;&#160;&#160;switch(ch)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;...<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a, b, c, d, or q: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ch;<br/>}</p>
<p>To enter, say, a <code>b</code> response, you type <strong><code>b</code></strong> and press Enter, generating the two-character response <code>b\n</code>. If you used either form of <code>get()</code>, you would have to add code to process that <code>\n</code> character on each loop cycle, but the extraction operator conveniently skips it. (If you&#8217;ve programmed in C, you&#8217;ve probably encountered a situation in which the newline appears to the program as an invalid response. It&#8217;s an easy problem to fix, but it is a nuisance.)</p>
<p><a id="page_1106"/>If you want a program to examine every character, you should use one of the <code>get()</code> methods. For example, a word-counting program could use white space to determine when a word came to an end. Of the two <code>get()</code> methods, the <code>get(char &#38;)</code> method has the classier interface. The main advantage of the <code>get(void)</code> method is that it closely resembles the standard C <code>getchar()</code> function, which means you can convert a C program to a C++ program by including <code>iostream</code> instead of <code>stdio.h</code>, globally replacing <code>getchar()</code> with <code>cin.get()</code>, and globally replacing C&#8217;s <code>putchar(ch)</code> with <code>cout.put(ch)</code>.</p>
<h5 id="ch17lev3sec15">String Input: <code>getline()</code>, <code>get()</code>, and <code>ignore()</code></h5>
<p>Next, let&#8217;s review the string input member functions introduced in <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>&#8221;. The <code>getline()</code> member function and the string-reading version of <code>get()</code> both read strings, and both have the same function signatures (here simplified from the more general template declaration):</p>
<p class="programlisting">istream &#38; get(char *, int, char);<br/>istream &#38; get(char *, int);<br/>istream &#38; getline(char *, int, char);<br/>istream &#38; getline(char *, int);</p>
<p>The first argument, recall, is the address of the location to place the input string. The second argument is one greater than the maximum number of characters to be read. (The additional character leaves space for the terminating null character used in storing the input as a string.) The third argument specifies a character to act as a delimiter to input. The versions with just two arguments use the newline character as a delimiter. Each function reads up to the maximum characters or until it encounters the delimiter character, whichever comes first.</p>
<p>For example, the following code reads character input into the character array <code>line</code>:</p>
<p class="programlisting">char line[50];<br/>cin.get(line, 50);</p>
<p>The <code>cin.get()</code> function quits reading input into the array after encountering 49 characters or, by default, after encountering a newline character, whichever comes first. The chief difference between <code>get()</code> and <code>getline()</code> is that <code>get()</code> leaves the newline character in the input stream, making it the first character seen by the next input operation, whereas <code>getline()</code> extracts and discards the newline character from the input stream.</p>
<p><a href="ch04.html#ch04">Chapter 4</a> illustrated using the two-argument form for these two member functions. Now let&#8217;s look at the three-argument versions. The third argument is the delimiter character. Encountering the delimiter character causes input to cease, even if the maximum number of characters hasn&#8217;t been reached. So by default, both methods quit reading input if they reach the end of a line before reading the allotted number of characters. Just as in the default case, <code>get()</code> leaves the delimiter character in the input queue, and <code>getline()</code> does not.</p>
<p><a href="#ch17ex13">Listing 17.13</a> demonstrates how <code>getline()</code> and <code>get()</code> work. It also introduces the <code>ignore()</code> member function. <code>ignore()</code> takes two arguments: a number specifying a maximum number of characters to read and a character that acts as a delimiter character for <a id="page_1107"/>input. For example, the following function call reads and discards the next 255 characters or up through the first newline character, whichever comes first:</p>
<p class="programlisting">cin.ignore(255, '\n');</p>
<p>The prototype provides defaults of <code>1</code> and <code>EOF</code> for the two arguments, and the function return type is <code>istream &#38;</code>:</p>
<p class="programlisting">istream &#38; ignore(int = 1, int = EOF);</p>
<p>(The <code>EOF</code> default value causes <code>ignore()</code> to read up to the specified number of characters or until end-of-file, whichever comes first.)</p>
<p>The function returns the invoking object. This lets you concatenate function calls, as in the following:</p>
<p class="programlisting">cin.ignore(255, '\n').ignore(255, '\n');</p>
<p>Here the first <code>ignore()</code> method reads and discards one line, and the second call reads and discards the second line. Together the two functions read through two lines.</p>
<p>Now check out <a href="#ch17ex13">Listing 17.13</a>.</p>
<p class="caption1"><a id="ch17ex13"/><strong>Listing 17.13. <code>get_fun.cpp</code></strong></p><hr/>
<p class="programlisting1">// get_fun.cpp -- using get() and getline()<br/>#include &lt;iostream&gt;<br/>const int Limit = 255;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;char input[Limit];<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a string for getline() processing:\n";<br/>&#160;&#160;&#160;&#160;cin.getline(input, Limit, '#');<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here is your input:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; input &lt;&lt; "\nDone with phase 1\n";<br/><br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;cin.get(ch);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The next input character is " &lt;&lt; ch &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;if (ch != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.ignore(Limit, '\n');&#160;&#160;&#160;&#160;// discard rest of line<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter a string for get() processing:\n";<br/>&#160;&#160;&#160;&#160;cin.get(input, Limit, '#');<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here is your input:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; input &lt;&lt; "\nDone with phase 2\n";<br/><br/>&#160;&#160;&#160;&#160;cin.get(ch);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "The next input character is " &lt;&lt; ch &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1108"/>Here is a sample run of the program in <a href="#ch17ex13">Listing 17.13</a>:</p>
<p class="programlisting">Enter a string for getline() processing:<br/><span class="EmpStrong">Please pass</span><br/><span class="EmpStrong">me a #3 melon!</span><br/>Here is your input:<br/>Please pass<br/>me a<br/>Done with phase 1<br/>The next input character is 3<br/>Enter a string for get() processing:<br/><span class="EmpStrong">I still</span><br/><span class="EmpStrong">want my #3 melon!</span><br/>Here is your input:<br/>I still<br/>want my<br/>Done with phase 2<br/>The next input character is #</p>
<p>Note that the <code>getline()</code> function discards the <code>#</code> termination character in the input, and the <code>get()</code> function does not.</p>
<h6 id="ch17lev4sec4">Unexpected String Input</h6>
<p>Some forms of input for <code>get(char *, int)</code> and <code>getline()</code> affect the stream state. As with the other input functions, encountering end-of-file sets <code>eofbit</code>, and anything that corrupts the stream, such as device failure, sets <code>badbit</code>. Two other special cases are no input and input that meets or exceeds the maximum number of characters specified by the function call. Let&#8217;s look at those cases now.</p>
<p>If either method fails to extract any characters, the method places a null character into the input string and uses <code>setstate()</code> to set <code>failbit</code>. When would a method fail to extract any characters? One possibility is if an input method immediately encounters end-of-file. For <code>get(char *, int)</code>, another possibility is if you enter an empty line:</p>
<p class="programlisting">char temp[80];<br/>while (cin.get(temp,80))&#160;&#160;// terminates on empty line<br/>&#160;&#160;&#160;&#160;&#160;&#160;...</p>
<p><a id="page_1109"/>Interestingly, an empty line does not cause <code>getline()</code> to set <code>failbit</code>. That&#8217;s because <code>getline()</code> still extracts the newline character, even if it doesn&#8217;t store it. If you want a <code>getline()</code> loop to terminate on an empty line, you can write it this way:</p>
<p class="programlisting">char temp[80];<br/>while (cin.getline(temp,80) &#38;&#38; temp[0] != '\0') // terminates on empty line</p>
<p>Now suppose the number of characters in the input queue meets or exceeds the maximum specified by the input method. First, consider <code>getline()</code> and the following code:</p>
<p class="programlisting">char temp[30];<br/>while (cin.getline(temp,30))</p>
<p>The <code>getline()</code> method will read consecutive characters from the input queue, placing them in successive elements of the <code>temp</code> array, until (in order of testing) end-of-file is encountered, until the next character to be read is the newline character, or until 29 characters have been stored. If end-of-file is encountered, <code>eofbit</code> is set. If the next character to be read is a newline character, that character is read and discarded. And if 29 characters were read, <code>failbit</code> is set, unless the next character is a newline. Thus, an input line of 30 characters or more will terminate input.</p>
<p>Now consider the <code>get(char *, int)</code> method. It tests the number of characters first, end-of-file second, and for the next character being a newline third. It does not set the <code>failbit</code> flag if it reads the maximum number of characters. Nonetheless, you can tell if too many input characters caused the method to quit reading. You can use <code>peek()</code> (see the next section) to examine the next input character. If it&#8217;s a newline, then <code>get()</code> must have read the entire line. If it&#8217;s not a newline, then <code>get()</code> must have stopped before reaching the end. This technique doesn&#8217;t necessarily work with <code>getline()</code> because <code>getline()</code> reads and discards the newline, so looking at the next character doesn&#8217;t tell you anything. But if you use <code>get()</code>, you have the option of doing something if less than an entire line is read. The next section includes an example of this approach. Meanwhile, <a href="#ch17table06">Table 17.6</a> summarizes these behaviors.</p>
<p class="caption"><a id="ch17table06"/><strong>Table 17.6. Input Behavior</strong></p>
<p class="image"><img src="graphics/17tab06.jpg" alt="Image"/></p>
<h4 id="ch17lev2sec11">Other <code>istream</code> Methods</h4>
<p>Other <code>istream</code> methods besides the ones discussed so far include <code>read()</code>, <code>peek()</code>, <code>gcount()</code>, and <code>putback()</code>. The <code>read()</code> function reads a given number of bytes and stores them in the specified location. For example, the following statements read 144 characters from the standard input and place them in the <code>gross</code> array:</p>
<p class="programlisting"><a id="page_1110"/>char gross[144];<br/>cin.read(gross, 144);</p>
<p>Unlike <code>getline()</code> and <code>get()</code>, <code>read()</code> does not append a null character to input, so it doesn&#8217;t convert input to string form. The <code>read()</code> method is not intended for keyboard input. Instead, it is most often used in conjunction with the <code>ostream write()</code> function for file input and output. The method&#8217;s return type is <code>istream &#38;</code>, so it can be concatenated as follows:</p>
<p class="programlisting">char gross[144];<br/>char score[20];<br/>cin.read(gross, 144).read(score, 20);</p>
<p>The <code>peek()</code> function returns the next character from input without extracting from the input stream. That is, it lets you peek at the next character. Suppose you want to read input up to the first newline or period, whichever comes first. You can use <code>peek()</code> to peek at the next character in the input stream in order to judge whether to continue:</p>
<p class="programlisting">char great_input[80];<br/>char ch;<br/>int i = 0;<br/>while ((ch = cin.peek()) != '.' &#38;&#38; ch != '\n')<br/>&#160;&#160;&#160;&#160;cin.get(great_input[i++]);<br/>great_input [i] = '\0';</p>
<p>The call to <code>cin.peek()</code> peeks at the next input character and assigns its value to <code>ch</code>. Then the <code>while</code> loop test condition checks that <code>ch</code> is neither a period nor a newline. If this is the case, the loop reads the character into the array and updates the array index. When the loop terminates, the period or newline character remains in the input stream, positioned to be the first character read by the next input operation. Then the code appends a null character to the array, making it a string.</p>
<p>The <code>gcount()</code> method returns the number of characters read by the last unformatted extraction method. That means characters read by a <code>get()</code>, <code>getline()</code>, <code>ignore()</code>, or <code>read()</code> method but not by the extraction operator (<code>&gt;&gt;</code>), which formats input to fit particular data types. For example, suppose you&#8217;ve just used <code>cin.get(myarray, 80)</code> to read a line into the <code>myarray</code> array and you want to know how many characters were read. You could use the <code>strlen()</code> function to count the characters in the array, but it would be quicker to use <code>cin.gcount()</code> to report how many characters were just read from the input stream.</p>
<p>The <code>putback()</code> function inserts a character back in the input string. The inserted character then becomes the first character read by the next input statement. The <code>putback()</code> method takes one <code>char</code> argument, which is the character to be inserted, and it returns type <code>istream &#38;</code>, which allows the call to be concatenated with other <code>istream</code> methods. Using <code>peek()</code> is like using <code>get()</code> to read a character and then using <code>putback()</code> to place the character back in the input stream. However, <code>putback()</code> gives you the option of putting back a character that is different from the one just read.</p>
<p><a id="page_1111"/><a href="#ch17ex14">Listing 17.14</a> uses two approaches to read and echo input up to, but not including, a <code>#</code> character. The first approach reads through the <code>#</code> character and then uses <code>putback()</code> to insert the character back into the input. The second approach uses <code>peek()</code> to look ahead before reading input.</p>
<p class="caption1"><a id="ch17ex14"/><strong>Listing 17.14. <code>peeker.cpp</code></strong></p><hr/>
<p class="programlisting1">// peeker.cpp -- some istream methods<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>//&#160;&#160;read and echo input up to a # character<br/>&#160;&#160;&#160;&#160;char ch;<br/><br/>&#160;&#160;&#160;&#160;while(cin.get(ch))&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// terminates on EOF<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ch != '#')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.putback(ch);&#160;&#160;&#160;&#160;// reinsert character<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;if (!cin.eof())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(ch);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; ch &lt;&lt; " is next input character.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "End of file reached.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::exit(0);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;while(cin.peek() != '#')&#160;&#160;&#160;&#160;// look ahead<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(ch);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;if (!cin.eof())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(ch);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; ch &lt;&lt; " is next input character.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "End of file reached.\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/><br/>}</p><hr/>
<p><a id="page_1112"/>Here is a sample run of the program in <a href="#ch17ex14">Listing 17.14</a>:</p>
<p class="programlisting"><span class="EmpStrong">I used a #3 pencil when I should have used a #2.</span><br/>I used a<br/># is next input character.<br/>3 pencil when I should have used a<br/># is next input character.</p>
<h5 id="ch17lev3sec16">Program Notes</h5>
<p>Let&#8217;s look more closely at some of the code in <a href="#ch17ex14">Listing 17.14</a>. The first approach uses a <code>while</code> loop to read input:</p>
<p class="programlisting">while(cin.get(ch))&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// terminates on EOF<br/>{<br/>&#160;&#160;&#160;&#160;if (ch != '#')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.putback(ch);&#160;&#160;// reinsert character<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<p>The expression <code>cin.get(ch)</code> returns <code>false</code> on reaching the end-of-file condition, so simulating end-of-file from the keyboard terminates the loop. If the <code>#</code> character shows up first, the program puts the character back in the input stream and uses a break statement to terminate the loop.</p>
<p>The second approach is simpler in appearance:</p>
<p class="programlisting">while(cin.peek() != '#')&#160;&#160;&#160;&#160;&#160;// look ahead<br/>{<br/>&#160;&#160;&#160;&#160;cin.get(ch);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>}</p>
<p><a id="page_1113"/>The program peeks at the next character. If it is not the <code>#</code> character, the program reads the next character, echoes it, and peeks at the next character. This continues until the terminating character shows up.</p>
<p>Now let&#8217;s look, as promised, at an example&#8212;<a href="#ch17ex15">Listing 17.15</a>&#8212;that uses <code>peek()</code> to determine whether an entire line has been read. If only part of a line fits in the input array, the program discards the rest of the line.</p>
<p class="caption1"><a id="ch17ex15"/><strong>Listing 17.15. <code>truncate.cpp</code></strong></p><hr/>
<p class="programlisting1">// truncate.cpp -- using get() to truncate input line, if necessary<br/>#include &lt;iostream&gt;<br/>const int SLEN = 10;<br/>inline void eatline() { while (std::cin.get() != '\n') continue; }<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;char name[SLEN];<br/>&#160;&#160;&#160;&#160;char title[SLEN];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your name: ";<br/>&#160;&#160;&#160;&#160;cin.get(name,SLEN);<br/>&#160;&#160;&#160;&#160;if (cin.peek() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Sorry, we only have enough room for "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; name &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;eatline();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Dear " &lt;&lt; name &lt;&lt; ", enter your title: \n";<br/>&#160;&#160;&#160;&#160;cin.get(title,SLEN);<br/>&#160;&#160;&#160;&#160;if (cin.peek() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "We were forced to truncate your title.\n";<br/>&#160;&#160;&#160;&#160;eatline();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; " Name: " &lt;&lt; name<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "\nTitle: " &lt;&lt; title &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/><br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch17ex15">Listing 17.15</a>:</p>
<p class="programlisting">Enter your name: <span class="EmpStrong">Ella Fishsniffer</span><br/>Sorry, we only have enough room for Ella Fish<br/>Dear Ella Fish, enter your title:<br/>Executive Adjunct<br/>We were forced to truncate your title.<br/><a id="page_1114"/>&#160;Name: Ella Fish<br/>Title: Executive</p>
<p>Note that the following code makes sense whether or not the first input statement reads the entire line:</p>
<p class="programlisting">while (cin.get() != '\n') continue;</p>
<p>If <code>get()</code> reads the whole line, it still leaves the newline in place, and this code reads and discards the newline character. If <code>get()</code> reads just part of the line, this code reads and discards the rest of the line. If you didn&#8217;t dispose of the rest of the line, the next input statement would begin reading at the beginning of the remaining input on the first input line. With this example, that would result in the program reading the string <code>sniffer</code> into the <code>title</code> array.</p>
<h3 id="ch17lev1sec4">File Input and Output</h3>
<p>Most computer programs work with files. Word processors create document files. Database programs create and search files of information. Compilers read source code files and generate executable files. A file itself is a bunch of bytes stored on some device, perhaps magnetic tape, perhaps an optical disk, a floppy disk, or a hard disk. Typically, the operating system manages files, keeping track of their locations, their sizes, when they were created, and so on. Unless you&#8217;re programming on the operating system level, you normally don&#8217;t have to worry about those things. What you do need is a way to connect a program to a file, a way to have a program read the contents of a file, and a way to have a program create and write to files. Redirection (as discussed earlier in this chapter) can provide some file support, but it is more limited than explicit file I/O from within a program. Also redirection comes from the operating system, not from C++, so it isn&#8217;t available on all systems. This book has already touched on file I/O, and this chapter explores the topic more thoroughly.</p>
<p>The C++ I/O class package handles file input and output much as it handles standard input and output. To write to a file, you create an <code>ofstream</code> object and use the <code>ostream</code> methods, such as the <code>&lt;&lt;</code> insertion operator or <code>write()</code>. To read a file, you create an <code>ifstream</code> object and use the <code>istream</code> methods, such as the <code>&gt;&gt;</code> extraction operator or <code>get()</code>. Files require more management than the standard input and output, however. For example, you have to associate a newly opened file with a stream. You can open a file in read-only mode, write-only mode, or read-and-write mode. If you write to a file, you might want to create a new file, replace an old file, or add to an old file. Or you might want to move back and forth through a file. To help handle these tasks, C++ defines several new classes in the <code>fstream</code> (formerly <code>fstream.h</code>) header file, including the <code>ifstream</code> class for file input and the <code>ofstream</code> class for file output. C++ also defines the <code>fstream</code> class for simultaneous file I/O. These classes are derived from the classes in the <code>iostream</code> header file, so objects of these new classes are able to use the methods you&#8217;ve already learned.</p>
<h4 id="ch17lev2sec12">Simple File I/O</h4>
<p><a id="page_1115"/>Suppose you want a program to write to a file. You must do the following:</p>
<p class="indenthandingN"><strong>1.</strong> Create an <code>ofstream</code> object to manage the output stream.</p>
<p class="indenthandingN"><strong>2.</strong> Associate that object with a particular file.</p>
<p class="indenthandingN"><strong>3.</strong> Use the object the same way you would use <code>cout</code>; the only difference is that output goes to the file instead of to the screen.</p>
<p>To accomplish this, you begin by including the <code>fstream</code> header file. Including this file automatically includes the <code>iostream</code> file for most, but not all, implementations, so you may not have to include <code>iostream</code> explicitly. Then you declare an <code>ofstream</code> object:</p>
<p class="programlisting">ofstream fout;&#160;&#160;&#160;&#160;&#160;&#160;// create an ofstream object named fout</p>
<p>The object&#8217;s name can be any valid C++ name, such as <code>fout</code>, <code>outFile</code>, <code>cgate</code>, or <code>didi</code>.</p>
<p>Next, you must associate this object with a particular file. You can do so by using the <code>open()</code> method. Suppose, for example, that you want to open the <code>jar.txt</code> file for output. You would do the following:</p>
<p class="programlisting">fout.open("jar.txt");&#160;&#160;// associate fout with jar.txt</p>
<p>You can combine these two steps (creating the object and associating a file) into a single statement by using a different constructor:</p>
<p class="programlisting">ofstream fout("jar.txt");&#160;&#160;// create fout object, associate it with jar.txt</p>
<p>When you&#8217;ve gotten this far, you use <code>fout</code> (or whatever name you choose) in the same manner as <code>cout</code>. For example, if you want to put the words <code>Dull Data</code> into the file, you can do the following:</p>
<p class="programlisting">fout &lt;&lt; "Dull Data";</p>
<p>Indeed, because <code>ostream</code> is a base class for the <code>ofstream</code> class, you can use all the <code>ostream</code> methods, including the various insertion operator definitions and the formatting methods and manipulators. The <code>ofstream</code> class uses buffered output, so the program allocates space for an output buffer when it creates an <code>ofstream</code> object such as <code>fout</code>. If you create two <code>ofstream</code> objects, the program creates two buffers, one for each object. An <code>ofstream</code> object such as <code>fout</code> collects output byte-by-byte from the program; then, when the buffer is filled, it transfers the buffer contents en masse to the destination file. Because disk drives are designed to transfer data in larger chunks, not byte-by-byte, the buffered approach greatly speeds up the transfer rate of data from a program to a file.</p>
<p>Opening a file for output this way creates a new file if there is no file of that name. If a file by that name exists prior to opening it for output, the act of opening it truncates it so that output starts with a clean file. Later in this chapter you&#8217;ll see how to open an existing file and retain its contents.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note08"/><a id="page_1116"/>Caution</p>
<p class="notepara">Opening a file for output in the default mode automatically truncates the file to zero size, in effect disposing of the prior contents.</p>
<hr/></div>
<p>The requirements for reading a file are much like those for writing to a file:</p>
<p class="indenthandingN"><strong>1.</strong> Create an <code>ifstream</code> object to manage the input stream.</p>
<p class="indenthandingN"><strong>2.</strong> Associate that object with a particular file.</p>
<p class="indenthandingN"><strong>3.</strong> Use the object the same way you would use <code>cin</code>.</p>
<p>The steps for reading a file are similar to those for writing to a file. First, of course, you include the <code>fstream</code> header file. Then you declare an <code>ifstream</code> object and associate it with the filename. You can do so in two statements or one:</p>
<p class="programlisting">// two statements<br/>ifstream fin;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create ifstream object called fin<br/>fin.open("jellyjar.txt");&#160;&#160;// open jellyjar.txt for reading<br/>// one statement<br/>ifstream fis("jamjar.txt"); // create fis and associate with jamjar.txt</p>
<p>You can then use <code>fin</code> or <code>fis</code> much as you would use <code>cin</code>. For example, you can use the following:</p>
<p class="programlisting">char ch;<br/>fin &gt;&gt; ch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a character from the jellyjar.txt file<br/>char buf[80];<br/>fin &gt;&gt; buf;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a word from the file<br/>fin.getline(buf, 80);&#160;&#160;&#160;&#160;// read a line from the file<br/>string line;<br/>getline(fin, line);&#160;&#160;&#160;&#160;&#160;&#160;// read from a file to a string object</p>
<p>Input, like output, is buffered, so creating an <code>ifstream</code> object such as <code>fin</code> creates an input buffer, which the <code>fin</code> object manages. As with output, buffering moves data much faster than byte-by-byte transfer.</p>
<p>The connections with a file are closed automatically when the input and output stream objects expire&#8212;for example, when the program terminates. Also you can close a connection with a file explicitly by using the <code>close()</code> method:</p>
<p class="programlisting">fout.close();&#160;&#160;&#160;&#160;// close output connection to file<br/>fin.close();&#160;&#160;&#160;&#160;&#160;// close input connection to file</p>
<p>Closing such a connection does not eliminate the stream; it just disconnects it from the file. However, the stream management apparatus remains in place. For example, the <code>fin</code> object still exists, along with the input buffer it manages. As you&#8217;ll see later, you can reconnect the stream to the same file or to another file.</p>
<p>Let&#8217;s look at a short example. The program in <a href="#ch17ex16">Listing 17.16</a> asks for a filename. It creates a file that has that name, writes some information to it, and closes the file. Closing the file flushes the buffer, guaranteeing that the file is updated. Then the program opens the <a id="page_1117"/>same file for reading and displays its contents. Note that the program uses <code>fin</code> and <code>fout</code> in the same manner as you&#8217;d use <code>cin</code> and <code>cout</code>. Also, the program reads the filename into a <code>string</code> object and then uses the <code>c_str()</code> method to provide C-style string arguments for the <code>ofstream</code> and <code>ifstream</code> constructors.</p>
<p class="caption1"><a id="ch17ex16"/><strong>Listing 17.16. <code>fileio.cpp</code></strong></p><hr/>
<p class="programlisting1">// fileio.cpp -- saving to a file<br/>#include &lt;iostream&gt; // not needed for many systems<br/>#include &lt;fstream&gt;<br/>#include &lt;string&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;string filename;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter name for new file: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; filename;<br/><br/>// create output stream object for new file and call it fout<br/>&#160;&#160;&#160;&#160;ofstream fout(filename.c_str());<br/><br/>&#160;&#160;&#160;&#160;fout &lt;&lt; "For your eyes only!\n";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// write to file<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your secret number: ";&#160;&#160;&#160;// write to screen<br/>&#160;&#160;&#160;&#160;float secret;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; secret;<br/>&#160;&#160;&#160;&#160;fout &lt;&lt; "Your secret number is " &lt;&lt; secret &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;fout.close();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// close file<br/><br/>// create input stream object for new file and call it fin<br/>&#160;&#160;&#160;&#160;ifstream fin(filename.c_str());<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the contents of " &lt;&lt; filename &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;while (fin.get(ch))&#160;&#160;&#160;&#160;&#160;// read character from file and<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// write it to screen<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done\n";<br/>&#160;&#160;&#160;&#160;fin.close();<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is a sample run of the program in <a href="#ch17ex16">Listing 17.16</a>:</p>
<p class="programlisting">Enter name for new file: <span class="EmpStrong">pythag</span><br/>Enter your secret number: <span class="EmpStrong">3.14159</span><br/><a id="page_1118"/>Here are the contents of pythag:<br/>For your eyes only!<br/>Your secret number is 3.14159<br/>Done</p>
<p>If you check the directory that contains the program, you should find a file named <code>pythag</code>, and any text editor should show the same contents that the program output displays. (So much for secrecy.)</p>
<h4 id="ch17lev2sec13">Stream Checking and <code>is_open()</code></h4>
<p>The C++ file stream classes inherit a stream-state member from the <code>ios_base</code> class. This member, as discussed earlier, stores information that reflects the stream status: All is well, end-of-file has been reached, I/O operation failed, and so on. If all is well, the stream state is zero (no news is good news). The various other states are recorded by setting particular bits to <code>1</code>. The file stream classes also inherit the <code>ios_base</code> methods that report about the stream state and that are summarized in <a href="#ch17table04">Table 17.4</a>. You can check the stream state to find whether the most recent stream operation succeeded or failed. For file streams, this includes checking the success of an attempt to open a file. For example, attempting to open a non-existent file for input sets <code>failbit</code>. So you could check this way:</p>
<p class="programlisting">fin.open(argv[file]);<br/>if (fin.fail())&#160;&#160;// open attempt failed<br/>{<br/>&#160;&#160;&#160;...<br/>}</p>
<p>Or because an <code>ifstream</code> object, like an <code>istream</code> object, is converted to a <code>bool</code> type where a <code>bool</code> type is expected, you could use this:</p>
<p class="programlisting">fin.open(argv[file]);<br/>if (!fin)&#160;&#160;// open attempt failed<br/>{<br/>&#160;&#160;&#160;...<br/>}</p>
<p>However, newer C++ implementations have a better way to check whether a file has been opened&#8212;the <code>is_open()</code> method:</p>
<p class="programlisting">if (!fin.is_open())&#160;&#160;// open attempt failed<br/>{<br/>&#160;&#160;&#160;...<br/>}</p>
<p>The reason this is better is that it tests for some subtle problems that the other forms miss, as discussed in the following Caution.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note09"/><a id="page_1119"/>Caution</p>
<p class="notepara">In the past, the usual tests for successful opening of a file were the following:</p>
<p class="programlistingB">if(fin.fail()) ...&#160;&#160;// failed to open<br/>if(!fin.good()) ... // failed to open<br/>if (!fin) ...&#160;&#160;&#160;&#160;&#160;&#160;&#160;// failed to open</p>
<p class="notepara">The <code>fin</code> object, when used in a test condition, is converted to <code>false</code> if <code>fin.good()</code> is <code>false</code> and to <code>true</code> otherwise, so the two forms are equivalent. However, these tests fail to detect one circumstance, which is attempting to open a file by using an inappropriate file mode (see the &#8220;<a href="#ch17lev2sec16">File Modes</a>&#8221; section, later in this chapter). The <code>is_open()</code> method catches this form of error, along with those caught by the <code>good()</code> method. However, older C++ implementations do not have <code>is_open(</code>).</p>
<hr/></div>
<h4 id="ch17lev2sec14">Opening Multiple Files</h4>
<p>You might require that a program open more than one file. The strategy for opening multiple files depends on how they will be used. If you need two files open simultaneously, you must create a separate stream for each file. For example, a program that collates two sorted files into a third file would create two <code>ifstream</code> objects for the two input files and an <code>ofstream</code> object for the output file. The number of files you can open simultaneously depends on the operating system.</p>
<p>However, you may plan to process a group of files sequentially. For example, you might want to count how many times a name appears in a set of 10 files. In this case, you can open a single stream and associate it with each file in turn. This conserves computer resources more effectively than opening a separate stream for each file. To use this approach, you declare an <code>ifstream</code> object without initializing it and then use the <code>open()</code> method to associate the stream with a file. For example, this is how you could handle reading two files in succession:</p>
<p class="programlisting">ifstream fin;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// create stream using default constructor<br/>fin.open("fat.txt");&#160;&#160;&#160;&#160;// associate stream with fat.txt file<br/>...&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// do stuff<br/>fin.close();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// terminate association with fat.txt<br/>fin.clear();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// reset fin (may not be needed)<br/>fin.open("rat.txt");&#160;&#160;&#160;&#160;// associate stream with rat.txt file<br/>...<br/>fin.close();</p>
<p>We&#8217;ll look at an example shortly, but first, let&#8217;s examine a technique for feeding a list of files to a program in a manner that allows the program to use a loop to process them.</p>
<h4 id="ch17lev2sec15">Command-Line Processing</h4>
<p>File-processing programs often use command-line arguments to identify files. <em>Command-line arguments</em> are arguments that appear on the command line when you type a <a id="page_1120"/>command. For example, to count the number of words in some files on a Unix or Linux system, you would type this command at the command-line prompt:</p>
<p class="programlisting">wc report1 report2 report3</p>
<p>Here <code>wc</code> is the program name, and <code>report1</code>, <code>report2</code>, and <code>report3</code> are filenames passed to the program as command-line arguments.</p>
<p>C++ has a mechanism for letting a program running in a command-line environment access the command-line arguments. You can use the following alternative function heading for <code>main()</code>:</p>
<p class="programlisting">int main(int argc, char *argv[])</p>
<p>The <code>argc</code> argument represents the number of arguments on the command line. The count includes the command name itself. The <code>argv</code> variable is a pointer to a pointer to a <code>char</code>. This sounds a bit abstract, but you can treat <code>argv</code> as if it were an array of pointers to the command-line arguments, with <code>argv[0]</code> being a pointer to the first character of a string holding the command name, <code>argv[1]</code> being a pointer to the first character of a string holding the first command-line argument, and so on. That is, <code>argv[0]</code> is the first string from the command line, and so on. For example, suppose you have the following command line:</p>
<p class="programlisting">wc report1 report2 report3</p>
<p>In this case, <code>argc</code> would be <code>4</code>, <code>argv[0]</code> would be <code>wc</code>, <code>argv[1]</code> would be <code>report1</code>, and so on. The following loop would print each command-line argument on a separate line:</p>
<p class="programlisting">for (int i = 1; i &lt; argc; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; argv[i] &lt;&lt; endl;</p>
<p>Starting with <code>i = 1</code> just prints the command-line arguments; starting with <code>i = 0</code> would print the command name as well.</p>
<p>Command-line arguments, of course, go hand-in-hand with command-line operating systems such as the Windows command prompt mode, Unix, and Linux. Other setups may still allow you to use command-line arguments:</p>
<p class="indenthandingB">&#8226; Many Windows IDEs (Integrated Development Environments) have an option for providing command-line arguments. Typically, you have to navigate through a series of menu choices that lead to a box into which you can type the command-line arguments. The exact set of steps varies from vendor to vendor and from upgrade to upgrade, so check your documentation.</p>
<p class="indenthandingB">&#8226; Many Windows IDEs can produce executable files that run under in the Windows command prompt mode.</p>
<p><a href="#ch17ex17">Listing 17.17</a> combines the command-line technique with file stream techniques to count characters in files listed on the command line.</p>
<p class="caption1"><a id="page_1121"/><a id="ch17ex17"/><strong>Listing 17.17. <code>count.cpp</code></strong></p><hr/>
<p class="programlisting1">// count.cpp -- counting characters in a list of files<br/>#include &lt;iostream&gt;<br/>#include &lt;fstream&gt;<br/>#include &lt;cstdlib&gt;&#160;&#160;&#160;// for exit()<br/>int main(int argc, char * argv[])<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;if (argc == 1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// quit if no arguments<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " filename[s]\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;ifstream fin;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// open stream<br/>&#160;&#160;&#160;&#160;long count;<br/>&#160;&#160;&#160;&#160;long total = 0;<br/>&#160;&#160;&#160;&#160;char ch;<br/><br/>&#160;&#160;&#160;&#160;for (int file = 1; file &lt; argc; file++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fin.open(argv[file]);&#160;&#160;// connect stream to argv[file]<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!fin.is_open())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Could not open " &lt;&lt; argv[file] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fin.clear();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (fin.get(ch))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; count &lt;&lt; " characters in " &lt;&lt; argv[file] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;total += count;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fin.clear();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// needed for some implementations<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fin.close();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// disconnect file<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; total &lt;&lt; " characters in all files\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<div class="note"><hr/>
<p class="title"><a id="ch17note10"/>Note</p>
<p class="notepara">Some C++ implementations require using <code>fin.clear()</code> at the end of the program, and others do not. It depends on whether associating a new file with the <code>ifstream</code> object automatically resets the stream state. In does no harm to use <code>fin.clear()</code> even if it isn&#8217;t needed.</p>
<hr/></div>
<p><a id="page_1122"/>On a Linux system, for example, you could compile <a href="#ch17ex17">Listing 17.17</a> to an executable file called <code>a.out</code>. Then sample runs could look like this:</p>
<p class="programlisting">$ <span class="EmpStrong">a.out</span><br/>Usage: a.out filename[s]<br/>$ <span class="EmpStrong">a.out paris rome</span><br/>3580 characters in paris<br/>4886 characters in rome<br/>8466 characters in all files<br/>$</p>
<p>Note that the program uses <code>cerr</code> for the error message. A minor point is that the message uses <code>argv[0]</code> instead of <code>a.out</code>:</p>
<p class="programlisting">cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " filename[s]\n";</p>
<p>This way, if you change the name of the executable file, the program will automatically use the new name.</p>
<p>The program uses the <code>is_open()</code> method to verify that it was able to open the requested file. Let&#8217;s examine that matter further.</p>
<h4 id="ch17lev2sec16">File Modes</h4>
<p>The file mode describes how a file is to be used: read it, write to it, append it, and so on. When you associate a stream with a file, either by initializing a file stream object with a filename or by using the <code>open()</code> method, you can provide a second argument that specifies the file mode:</p>
<p class="programlisting">ifstream fin("banjo", mode1);&#160;&#160;// constructor with mode argument<br/>ofstream fout();<br/>fout.open("harp", mode2);&#160;&#160;&#160;&#160;&#160;&#160;// open() with mode arguments</p>
<p>The <code>ios_base</code> class defines an <code>openmode</code> type to represent the mode; like the <code>fmtflags</code> and <code>iostate</code> types, it is a <code>bitmask</code> type. (In the old days, it was type <code>int</code>.) You can choose from several constants defined in the <code>ios_base</code> class to specify the mode. <a href="#ch17table07">Table 17.7</a> lists the constants and their meanings. C++ file I/O has undergone several changes to make it compatible with ANSI C file I/0.</p>
<p class="caption"><a id="ch17table07"/><strong>Table 17.7. File Mode Constants</strong></p>
<p class="image"><img src="graphics/17tab07.jpg" alt="Image"/></p>
<p><a id="page_1123"/>If the <code>ifstream</code> and <code>ofstream</code> constructors and the <code>open()</code> methods each take two arguments, how have we gotten by using just one in the previous examples? As you have probably guessed, the prototypes for these class member functions provide default values for the second argument (the file mode argument). For example, the <code>ifstream open()</code> method and constructor use <code>ios_base::in</code> (open for reading) as the default value for the mode argument, and the <code>ofstream open()</code> method and constructor use <code>ios_base::out | ios_base::trunc</code> (open for writing and truncate the file) as the default. The bitwise OR operator (<code>|</code>) is used to combine two bit values into a single value that can be used to set both bits. The <code>fstream</code> class doesn&#8217;t provide a mode default, so you have to provide a mode explicitly when creating an object of that class.</p>
<p>Note that the <code>ios_base::trunc</code> flag means an existing file is truncated when opened to receive program output; that is, its previous contents are discarded. Although this behavior commendably minimizes the danger of running out of disk space, you can probably imagine situations in which you don&#8217;t want to wipe out a file when you open it. Of course, C++ provides other choices. If, for example, you want to preserve the file contents and add (append) new material to the end of the file, you can use the <code>ios_base::app</code> mode:</p>
<p class="programlisting">ofstream fout("bagels", ios_base::out | ios_base::app);</p>
<p>Again, the code uses the <code>|</code> operator to combine modes. So <code>ios_base::out | ios_base::app</code> means to invoke both the <code>out</code> mode and the <code>app</code> mode (see <a href="#ch17fig06">Figure 17.6</a>).</p>
<p class="caption"><a id="ch17fig06"/><strong>Figure 17.6. Some file-opening modes.</strong></p>
<p class="image"><img src="graphics/17fig06.jpg" alt="Image"/></p>
<p>You can expect to find some differences among older C++ implementations. For example, some allow you to omit the <code>ios_base::out</code> in the previous example, and some don&#8217;t. If you aren&#8217;t using the default mode, the safest approach is to provide all the mode elements explicitly. Some compilers don&#8217;t support all the choices in <a href="#ch17table06">Table 17.6</a>, and some may offer choices beyond those in the table. One consequence of these differences is that you may have to make some alterations in the following examples to use them on your system. The good news is that the development of the C++ Standard is providing greater uniformity.</p>
<p>Standard C++ defines parts of file I/O in terms of ANSI C standard I/O equivalents. A C++ statement like</p>
<p class="programlisting">ifstream fin(<span class="EmpItalic">filename</span>, <span class="EmpItalic">c++mode</span>);</p>
<p>is implemented as if it uses the C <code>fopen()</code> function:</p>
<p class="programlisting">fopen(<span class="EmpItalic">filename</span>, <span class="EmpItalic">cmode</span>);</p>
<p>Here <em><code>c++mode</code></em> is a type <code>openmode</code> value, such as <code>ios_base::in</code>, and <em><code>cmode</code></em> is the corresponding C-mode string, such as <code>"r"</code>. <a href="#ch17table08">Table 17.8</a> shows the correspondence between C++ modes and C modes. Note that <code>ios_base::out</code> by itself causes truncation but that it doesn&#8217;t cause truncation when combined with <code>ios_base::in</code>. Unlisted combinations, such as <code>ios_base::in | ios_base::trunc</code>, prevent the file from being opened. The <code>is_open()</code> method detects this failure.</p>
<p class="caption"><a id="page_1124"/><a id="ch17table08"/><strong>Table 17.8. C++ and C File-Opening Modes</strong></p>
<p class="image"><img src="graphics/17tab08.jpg" alt="Image"/></p>
<p><a id="page_1125"/>Note that both <code>ios_base::ate</code> and <code>ios_base::app</code> place you (or, more precisely, a file pointer) at the end of the file just opened. The difference between the two is that the <code>ios_base::app</code> mode allows you to add data to the end of the file only, while the <code>ios_base::ate</code> mode merely positions the pointer at the end of the file.</p>
<p>Clearly, there are many possible combinations of modes. We&#8217;ll look at a few representative ones.</p>
<h5 id="ch17lev3sec17">Appending to a File</h5>
<p>Let&#8217;s look at a program that appends data to the end of a file. The program maintains a file that contains a guest list. When the program begins, it displays the current contents of the file, if it exists. It can use the <code>is_open()</code> method after attempting to open the file to check whether the file exists. Next, the program opens the file for output, using the <code>ios_base::app</code> mode. Then it solicits input from the keyboard to add to the file. Finally, the program displays the revised file contents. <a href="#ch17ex18">Listing 17.18</a> illustrates how to accomplish these goals. Note how the program uses the <code>is_open()</code> method to test whether the file has been opened successfully.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note11"/>Note</p>
<p class="notepara">File I/O was perhaps the least standardized aspect of C++ in its earlier days, and many older compilers don&#8217;t quite conform to the current standard. Some, for example, used modes such as <code>nocreate</code> that are not part of the current standard. Also only some compilers require the <code>fin.clear()</code> call before opening the same file a second time for reading.</p>
<hr/></div>
<p class="caption1"><a id="ch17ex18"/><strong>Listing 17.18. <code>append.cpp</code></strong></p><hr/>
<p class="programlisting1">// append.cpp -- appending information to a file<br/>#include &lt;iostream&gt;<br/>#include &lt;fstream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;cstdlib&gt;&#160;&#160;&#160;&#160;&#160;&#160;// (for exit()<br/><br/>const char * file = "guests.txt";<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char ch;<br/><br/><a id="page_1126"/>// show initial contents<br/>&#160;&#160;&#160;&#160;ifstream fin;<br/>&#160;&#160;&#160;&#160;fin.open(file);<br/><br/>&#160;&#160;&#160;&#160;if (fin.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the current contents of the "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; file &lt;&lt; " file:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (fin.get(ch))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fin.close();<br/>&#160;&#160;&#160;&#160;}<br/><br/>// add new names<br/>&#160;&#160;&#160;&#160;ofstream fout(file, ios::out | ios::app);<br/>&#160;&#160;&#160;&#160;if (!fout.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Can't open " &lt;&lt; file &lt;&lt; " file for output.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter guest names (enter a blank line to quit):\n";<br/>&#160;&#160;&#160;&#160;string name;<br/>&#160;&#160;&#160;&#160;while (getline(cin,name) &#38;&#38; name.size() &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fout &lt;&lt; name &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;fout.close();<br/><br/>// show revised file<br/>&#160;&#160;&#160;&#160;fin.clear();&#160;&#160;&#160;&#160;// not necessary for some compilers<br/>&#160;&#160;&#160;&#160;fin.open(file);<br/>&#160;&#160;&#160;&#160;if (fin.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the new contents of the "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; file &lt;&lt; " file:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (fin.get(ch))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ch;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fin.close();<br/>&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/><br/>}</p><hr/>
<p><a id="page_1127"/>Here&#8217;s a sample first run of the program in <a href="#ch17ex18">Listing 17.18</a>:</p>
<p class="programlisting">Enter guest names (enter a blank line to quit):<br/><span class="EmpStrong">Genghis Kant</span><br/><span class="EmpStrong">Hank Attila</span><br/><span class="EmpStrong">Charles Bigg</span><br/><br/>Here are the new contents of the guests.txt file:<br/>Genghis Kant<br/>Hank Attila<br/>Charles Bigg<br/>Done.</p>
<p>At this point the <code>guests.txt</code> file hasn&#8217;t been created, so the program doesn&#8217;t preview the file.</p>
<p>Next time the program is run, however, the <code>guests.txt</code> file does exist, so the program does preview the file. Also note that the new data are appended to the old file contents rather than replacing them:</p>
<p class="programlisting">Here are the current contents of the guests.txt file:<br/>Genghis Kant<br/>Hank Attila<br/>Charles Bigg<br/>Enter guest names (enter a blank line to quit):<br/><span class="EmpStrong">Greta Greppo</span><br/><span class="EmpStrong">LaDonna Mobile</span><br/><span class="EmpStrong">Fannie Mae</span><br/><br/>Here are the new contents of the guests.txt file:<br/>Ghengis Kant<br/>Hank Attila<br/>Charles Bigg<br/>Greta Greppo<br/>LaDonna Mobile<br/>Fannie Mae<br/>Done.</p>
<p>You should be able to read the contents of <code>guest.txt</code> with any text editor, including the editor you use to write your source code.</p>
<h5 id="ch17lev3sec18">Binary Files</h5>
<p>When you store data in a file, you can store the data in text form or in binary format. Text form means you store everything as text, even numbers. For example, storing the value -2.324216e+07 in text form means storing the 13 characters used to write this number. That requires converting the computer&#8217;s internal representation of a floating-point number to character form, and that&#8217;s exactly what the <code>&lt;&lt;</code> insertion operator does. Binary format, on the other hand, means storing the computer&#8217;s internal representation of a value. <a id="page_1128"/>That is, instead of storing characters, the computer stores the (typically) 64-bit <code>double</code> representation of the value. For a character, the binary representation is the same as the text representation&#8212;the binary representation of the character&#8217;s ASCII code (or equivalent). For numbers, however, the binary representation is much different from the text representation (see <a href="#ch17fig07">Figure 17.7</a>).</p>
<p class="caption"><a id="ch17fig07"/><strong>Figure 17.7. Binary and text representations of a floating-point number.</strong></p>
<p class="image"><img src="graphics/17fig07.jpg" alt="Image"/></p>
<p>Each format has advantages. The text format is easy to read. With it, you can use an ordinary editor or word processor to read and edit a text file. You can easily transfer a text file from one computer system to another. The binary format is more accurate for numbers because it stores the exact internal representation of a value. There are no conversion errors or round-off errors. Saving data in binary format can be faster because there is no conversion and because you may be able to save data in larger chunks. And the binary format usually takes less space, depending on the nature of the data. Transferring to another system can be a problem, however, if the new system uses a different internal representation for values. Even different compilers on the same system may use different internal representations for structure layouts. In these cases, you (or someone) may have to write a program to translate one data format to another.</p>
<p>Let&#8217;s look at a more concrete example. Consider the following structure definition and declaration:</p>
<p class="programlisting">const int LIM = 20;<br/>struct planet<br/>{<br/>&#160;&#160;&#160;&#160;char name[LIM];&#160;&#160;&#160;&#160;&#160;&#160;&#160;// name of planet<br/>&#160;&#160;&#160;&#160;double population;&#160;&#160;&#160;// its population<br/>&#160;&#160;&#160;&#160;double g;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// its acceleration of gravity<br/>};<br/>planet pl;</p>
<p><a id="page_1129"/>To save the contents of the structure <code>pl</code> in text form, you can use this:</p>
<p class="programlisting">ofstream fout("planets.dat", ios_base:: out | ios_base::app);<br/>fout &lt;&lt; pl.name &lt;&lt; " " &lt;&lt; pl.population &lt;&lt; " " &lt;&lt; pl.g &lt;&lt; "\n";</p>
<p>Note that you have to provide each structure member explicitly by using the membership operator, and you have to separate adjacent data for legibility. If the structure contains, say, 30 members, this could get tedious.</p>
<p>To save the same information in binary format, you can use this:</p>
<p class="programlisting">ofstream fout("planets.dat",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ios_base:: out | ios_base::app | ios_base::binary);<br/>fout.write( (char *) &#38;pl, sizeof pl);</p>
<p>This code saves the entire structure as a single unit, using the computer&#8217;s internal representation of data. You won&#8217;t be able to read the file as text, but the information will be stored more compactly and precisely than as text. And it is certainly easier to type the code. This approach makes two changes:</p>
<p class="indenthandingB">&#8226; It uses a binary file mode.</p>
<p class="indenthandingB">&#8226; It uses the <code>write()</code> member function.</p>
<p>Let&#8217;s examine these changes more closely.</p>
<p>Some systems, such as Windows, support two file formats: text and binary. If you want to save data in binary form, you should use the binary file format. In C++ you do so by using the <code>ios_base::binary</code> constant in the file mode. If you want to know why you should do this on a Windows system, check the discussion in the following sidebar, &#8220;<a href="#ch17sb02">Binary Files and Text Files</a>.&#8221;</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch17sb02"/>Binary Files and Text Files</p>
<p class="sidebarpara">Using a binary file mode causes a program to transfer data from memory to a file, or vice versa, without any hidden translation taking place. Such is not necessarily the case for the default text mode. For example, consider Windows text files. They represent a newline with a two-character combination: carriage return, linefeed. Macintosh text files represent a newline with a carriage return. Unix and Linux files represent a newline with a linefeed. C++, which grew up on Unix, also represents a newline with a linefeed. For portability, a Windows C++ program automatically translates the C++ newline to a carriage return and linefeed when writing to a text mode file; and a Macintosh C++ program translates the newline to a carriage return when writing to a file. When reading a text file, these programs convert the local newline back to the C++ form. The text format can cause problems with binary data because a byte in the middle of a <code>double</code> value could have the same bit pattern as the ASCII code for the newline character. Also there are differences in how end-of-file is detected. So you should use the binary file mode when saving data in binary format. (Unix systems have just one file mode, so on them the binary mode is the same as the text mode.)</p>
<hr/></div>
<p>To save data in binary form instead of text form, you can use the <code>write()</code> member function. This method, recall, copies a specified number of bytes from memory to a file. This chapter used it earlier to copy text, but it will copy any type of data byte-by-byte <a id="page_1130"/>with no conversion. For example, if you pass to it the address of a <code>long</code> variable and tell it to copy 4 bytes, it will copy the 4 bytes constituting the <code>long</code> value verbatim to a file and not convert it to text. The only awkwardness is that you have to type cast the address to type pointer-to-<code>char</code>. You can use the same approach to copy an entire <code>planet</code> structure. To get the number of bytes, you use the <code>sizeof</code> operator:</p>
<p class="programlisting">fout.write( (char *) &#38;pl, sizeof pl);</p>
<p>This statement causes the program to go to the address of the <code>pl</code> structure and copy the 36 bytes (the value of the <code>sizeof pl</code> expression) beginning at this address to the file connected to <code>fout</code>.</p>
<p>To recover the information from a file, you use the corresponding <code>read()</code> method with an <code>ifstream</code> object:</p>
<p class="programlisting">ifstream fin("planets.dat", ios_base::in | ios_base::binary);<br/>fin.read((char *) &#38;pl, sizeof pl);</p>
<p>This copies <code>sizeof pl</code> bytes from the file to the <code>pl</code> structure. This same approach can be used with classes that don&#8217;t use virtual functions. In that case, just the data members are saved, not the methods. If the class does have virtual methods, then a hidden pointer to a table of pointers to virtual functions is also copied. Because the next time you run the program it might locate the virtual function table at a different location, copying old pointer information into objects from a file can create havoc. (Also see the Note in Programming Exercise 6.)</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note12"/>Tip</p>
<p class="notepara">The <code>read()</code> and <code>write()</code> member functions complement each other. You use <code>read()</code> to recover data that has been written to a file with <code>write()</code>.</p>
<hr/></div>
<p><a href="#ch17ex19">Listing 17.19</a> uses these methods to create and read a binary file. In form, the program is similar to <a href="#ch17ex18">Listing 17.18</a>, but it uses <code>write()</code> and <code>read()</code> instead of the insertion operator and the <code>get()</code> method. It also uses manipulators to format the screen output.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note13"/>Note</p>
<p class="notepara">Although the binary file concept is part of ANSI C, some C and C++ implementations do not provide support for the binary file mode. The reason for this oversight is that some systems have only one file type in the first place, so you can use binary operations such as <code>read()</code> and <code>write()</code> with the standard file format. Therefore, if your implementation rejects <code>ios_base::binary</code> as a valid constant, you can just omit it from your program. If your implementation doesn&#8217;t support the <code>fixed</code> and <code>right</code> manipulators, you can use <code>cout.setf(ios_base::fixed, ios_base::floatfield)</code> and <code>cout.setf(ios_base::right, ios_base::adjustfield)</code>. Also you may have to substitute <code>ios</code> for <code>ios_base</code>. Other compilers, particularly older ones, may have other idiosyncrasies.</p>
<hr/></div>
<p class="caption1"><a id="page_1131"/><a id="ch17ex19"/><strong>Listing 17.19. <code>binary.cpp</code></strong></p><hr/>
<p class="programlisting1">// binary.cpp -- binary file I/O<br/>#include &lt;iostream&gt; // not required by most systems<br/>#include &lt;fstream&gt;<br/>#include &lt;iomanip&gt;<br/>#include &lt;cstdlib&gt;&#160;&#160;// for exit()<br/><br/>inline void eatline() { while (std::cin.get() != '\n') continue; }<br/>struct planet<br/>{<br/>&#160;&#160;&#160;&#160;char name[20];&#160;&#160;&#160;&#160;&#160;&#160;// name of planet<br/>&#160;&#160;&#160;&#160;double population;&#160;&#160;// its population<br/>&#160;&#160;&#160;&#160;double g;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// its acceleration of gravity<br/>};<br/><br/>const char * file = "planets.dat";<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;planet pl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; fixed &lt;&lt; right;<br/><br/>// show initial contents<br/>&#160;&#160;&#160;&#160;ifstream fin;<br/>&#160;&#160;&#160;&#160;fin.open(file, ios_base::in |ios_base::binary);&#160;&#160;// binary file<br/>&#160;&#160;&#160;&#160;//NOTE: some systems don't accept the ios_base::binary mode<br/>&#160;&#160;&#160;&#160;if (fin.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the current contents of the "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; file &lt;&lt; " file:\n";<br/>&#160;&#160;&#160;&#160;while (fin.read((char *) &#38;pl, sizeof pl))<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; setw(20) &lt;&lt; pl.name &lt;&lt; ": "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;fin.close();<br/>&#160;&#160;&#160;&#160;}<br/><br/>// add new data<br/>&#160;&#160;&#160;&#160;ofstream fout(file,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ios_base::out | ios_base::app | ios_base::binary);<br/>&#160;&#160;&#160;&#160;//NOTE: some systems don't accept the ios::binary mode<br/>&#160;&#160;&#160;&#160;if (!fout.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Can't open " &lt;&lt; file &lt;&lt; " file for output:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter planet name (enter a blank line to quit):\n";<br/>&#160;&#160;&#160;&#160;cin.get(pl.name, 20);<br/>&#160;&#160;&#160;&#160;while (pl.name[0] != '\0')<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;eatline();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter planetary population: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; pl.population;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter planet's acceleration of gravity: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; pl.g;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;eatline();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fout.write((char *) &#38;pl, sizeof pl);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter planet name (enter a blank line "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"to quit):\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(pl.name, 20);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;fout.close();<br/><br/>// show revised file<br/>&#160;&#160;&#160;&#160;fin.clear();&#160;&#160;&#160;&#160;// not required for some implementations, but won't hurt<br/>&#160;&#160;&#160;&#160;fin.open(file, ios_base::in | ios_base::binary);<br/>&#160;&#160;&#160;&#160;if (fin.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the new contents of the "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; file &lt;&lt; " file:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (fin.read((char *) &#38;pl, sizeof pl))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; setw(20) &lt;&lt; pl.name &lt;&lt; ": "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fin.close();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1132"/>Here is a sample initial run of the program in <a href="#ch17ex19">Listing 17.19</a>:</p>
<p class="programlisting">Enter planet name (enter a blank line to quit):<br/><span class="EmpStrong">Earth</span><br/>Enter planetary population: <span class="EmpStrong">6928198253</span><br/>Enter planet's acceleration of gravity: <span class="EmpStrong">9.81</span><br/><a id="page_1133"/>Enter planet name (enter a blank line to quit):<br/><br/>Here are the new contents of the planets.dat file:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Earth:&#160;&#160;&#160;6928198253&#160;&#160;9.81<br/>Done.</p>
<p>And here is a sample follow-up run:</p>
<p class="programlisting">Here are the current contents of the planets.dat file:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Earth:&#160;&#160;&#160;6928198253&#160;&#160;9.81<br/>Enter planet name (enter a blank line to quit):<br/><span class="EmpStrong">Jenny's World</span><br/>Enter planetary population: <span class="EmpStrong">32155648</span><br/>Enter planet's acceleration of gravity: <span class="EmpStrong">8.93</span><br/>Enter planet name (enter a blank line to quit):<br/><br/>Here are the new contents of the planets.dat file:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Earth:&#160;&#160;&#160;6928198253&#160;&#160;9.81<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Jenny's World:&#160;&#160;&#160;&#160;&#160;32155648&#160;&#160;8.93<br/>Done.</p>
<p>You&#8217;ve already seen the major features of the program, but let&#8217;s re-examine an old point. The program uses this code (in the form of the inline <code>eatline()</code> function) after reading the planet&#8217;s <code>g</code> value:</p>
<p class="programlisting">while (std::cin.get() != '\n') continue;</p>
<p>This reads and discards input up through the newline character. Consider the next input statement in the loop:</p>
<p class="programlisting">cin.get(pl.name, 20);</p>
<p>If the newline were left in place, this statement would read the newline as an empty line, terminating the loop.</p>
<p>You might wonder if this program could use a <code>string</code> object instead of a character array for the <code>name</code> member of the <code>planet</code> structure. The answer is no&#8212;at least not without major changes in design. The problem is that a <code>string</code> object doesn&#8217;t actually contain the string within itself; instead, it contains a pointer to the memory location where the string is stored. So if you copy the structure to a file, you don&#8217;t copy the string data, you just copy the address of where the string was stored. When you run the program again, that address is meaningless.</p>
<h4 id="ch17lev2sec17">Random Access</h4>
<p>For our last file example, let&#8217;s look at random access. <em>Random access</em> means moving directly to any location in the file instead of moving through it sequentially. The random access approach is often used with database files. A program will maintain a separate index file, giving the location of data in the main data file. Then it can jump directly to that location, read the data there, and perhaps modify it. This approach is done most simply if the file <a id="page_1134"/>consists of a collection of equal-sized records. Each record represents a related collection of data. For example, in the example in <a href="#ch17ex19">Listing 17.19</a>, each file record would represent all the data about a particular planet. A file record corresponds rather naturally to a program structure or class.</p>
<p>This example is based on the binary file program in <a href="#ch17ex19">Listing 17.19</a>, to take advantage of the fact that the <code>planet</code> structure provides a pattern for a file record. To add to the creative tension of programming, the example opens the file in a read-and-write mode so that it can both read and modify a record. You can do this by creating an <code>fstream</code> object. The <code>fstream</code> class derives from the <code>iostream</code> class, which, in turn, is based on both the <code>istream</code> and <code>ostream</code> classes, so it inherits the methods of both. It also inherits two buffers, one for input and one for output, and synchronizes the handling of the two buffers. That is, as the program reads the file or writes to it, it moves both an input pointer in the input buffer and an output pointer in the output buffer in tandem.</p>
<p>The example does the following:</p>
<p class="indenthandingN"><strong>1.</strong> Displays the current contents of the <code>planets.dat</code> file.</p>
<p class="indenthandingN"><strong>2.</strong> Asks which record you want to modify.</p>
<p class="indenthandingN"><strong>3.</strong> Modifies that record.</p>
<p class="indenthandingN"><strong>4.</strong> Shows the revised file.</p>
<p>A more ambitious program would use a menu and a loop to let you select from the list of actions indefinitely, but this version performs each action just once. This simplified approach allows you to examine several aspects of read/write files without getting bogged down in matters of program design.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note14"/>Caution</p>
<p class="notepara">This program assumes that the <code>planets.dat</code> file already exists and was created by the <code>binary.cpp</code> program in <a href="#ch17ex19">Listing 17.19</a>.</p>
<hr/></div>
<p>The first question to answer is what file mode to use. In order to read the file, you need the <code>ios_base::in</code> mode. For binary I/O, you need the <code>ios_base::binary</code> mode. (Again, on some nonstandard systems you can omit&#8212;indeed, you may have to omit&#8212;this mode.) In order to write to the file, you need the <code>ios_base::out</code> or the <code>ios_base::app</code> mode. However, the append mode allows a program to add data to the end of the file only. The rest of the file is read-only; that is, you can read the original data but not modify it&#8212;so, to be able to modify the data, you have to use <code>ios_base::out</code>. As <a href="#ch17table08">Table 17.8</a> indicates, using the <code>in</code> and <code>out</code> modes simultaneously provides a read/write mode, so you just have to add the binary element. As mentioned earlier, you use the <code>|</code> operator to combine modes. Thus, you need the following statement to set up business:</p>
<p class="programlistingB">finout.open(file,ios_base::in | ios_base::out | ios_base::binary);</p>
<p>Next, you need a way to move through a file. The <code>fstream</code> class inherits two methods for this: <code>seekg()</code> moves the input pointer to a given file location, and <code>seekp()</code> moves the output pointer to a given file location. (Actually, because the <code>fstream</code> class uses buffers <a id="page_1135"/>for intermediate storage of data, the pointers point to locations in the buffers, not in the actual file.) You can also use <code>seekg()</code> with an <code>ifstream</code> object and <code>seekp()</code> with an <code>ofstream</code> object. Here are the <code>seekg()</code> prototypes:</p>
<p class="programlisting">basic_istream&lt;charT,traits&gt;&#38; seekg(off_type, ios_base::seekdir);<br/>basic_istream&lt;charT,traits&gt;&#38; seekg(pos_type);</p>
<p>As you can see, they are templates. This chapter uses a template specialization for the <code>char</code> type. For the <code>char</code> specialization, the two prototypes are equivalent to the following:</p>
<p class="programlisting">istream &#38; seekg(streamoff, ios_base::seekdir);<br/>istream &#38; seekg(streampos);</p>
<p>The first prototype represents locating a file position measured, in bytes, as an offset from a file location specified by the second argument. The second prototype represents locating a file position measured, in bytes, from the beginning of a file.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch17sb03"/>Type Escalation</p>
<p class="sidebarpara">When C++ was young, life was simpler for the <code>seekg()</code> methods. The <code>streamoff</code> and <code>streampos</code> types were <code>typedef</code>s for some standard integer type, such as <code>long</code>. However, the quest for creating a portable standard had to deal with the realization that an integer argument might not provide enough information for some file systems, so <code>streamoff</code> and <code>streampos</code> were allowed to be structure or class types, as long as they allowed some basic operations, such as using an integer value as an initialization value. Next, the old <code>istream</code> class was replaced with the <code>basic_istream</code> template, and <code>streampos</code> and <code>streamoff</code> were replaced with the template-based types <code>pos_type</code> and <code>off_type</code>. However, <code>streampos</code> and <code>streamoff</code> continue to exist as <code>char</code> specializations of <code>pos_type</code> and <code>off_type</code>. Similarly, you can use the <code>wstreampos</code> and <code>wstreamoff</code> types if you use <code>seekg()</code> with a <code>wistream</code> object.</p>
<hr/></div>
<p>Let&#8217;s take a look at the arguments to the first prototype of <code>seekg()</code>. Values of the <code>streamoff</code> type are used to measure offsets, in bytes, from a particular location in a file. The <code>streamoff</code> argument represents the file position, in bytes, measured as an offset from one of three locations. (The type may be defined as an integer type or as a class.) The <code>seek_dir</code> argument is another integer type that is defined, along with three possible values, in the <code>ios_base</code> class. The constant <code>ios_base::beg</code> means measure the offset from the beginning of the file. The constant <code>ios_base::cur</code> means measure the offset from the current position. The constant <code>ios_base::end</code> means measure the offset from the end of the file. Here are some sample calls, assuming that <code>fin</code> is an <code>ifstream</code> object:</p>
<p class="programlisting">fin.seekg(30, ios_base::beg);&#160;&#160;&#160;&#160;// 30 bytes beyond the beginning<br/>fin.seekg(-1, ios_base::cur);&#160;&#160;&#160;&#160;// back up one byte<br/>fin.seekg(0, ios_base::end);&#160;&#160;&#160;&#160;&#160;// go to the end of the file</p>
<p>Now let&#8217;s look at the second prototype. Values of the <code>streampos</code> type locate a position in a file. It can be a class, but, if so, the class includes a constructor with a <code>streamoff</code> argument and a constructor with an integer argument, providing a path to convert both types to <code>streampos</code> values. A <code>streampos</code> value represents an absolute location in a file, measured <a id="page_1136"/>from the beginning of the file. You can treat a <code>streampos</code> position as if it measures a file location in bytes from the beginning of a file, with the first byte being byte 0. So the following statement locates the file pointer at byte 112, which would be the 113th byte in the file:</p>
<p class="programlisting">fin.seekg(112);</p>
<p>If you want to check the current position of a file pointer, you can use the <code>tellg()</code> method for input streams and the <code>tellp()</code> methods for output streams. Each returns a <code>streampos</code> value representing the current position, in bytes, measured from the beginning of the file. When you create an <code>fstream</code> object, the input and output pointers move in tandem, so <code>tellg()</code> and <code>tellp()</code> return the same value. But if you use an <code>istream</code> object to manage the input stream and an <code>ostream</code> object to manage the output stream to the same file, the input and output pointers move independently of one another, and <code>tellg()</code> and <code>tellp()</code> can return different values.</p>
<p>You can then use <code>seekg()</code> to go to the file beginning. Here is a section of code that opens a file, goes to the beginning, and displays the file contents:</p>
<p class="programlisting">fstream finout;&#160;&#160;&#160;&#160;&#160;// read and write streams<br/>finout.open(file,ios::in | ios::out |ios::binary);<br/>//NOTE: Some Unix systems require omitting | ios::binary<br/>int ct = 0;<br/>if (finout.is_open())<br/>{<br/>&#160;&#160;&#160;&#160;finout.seekg(0);&#160;&#160;&#160;&#160;// go to beginning<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the current contents of the "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; file &lt;&lt; " file:\n";<br/>&#160;&#160;&#160;&#160;while (finout.read((char *) &#38;pl, sizeof pl))<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ct++ &lt;&lt; ": " &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; ": "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;if (finout.eof())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;finout.clear(); // clear eof flag<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Error in reading " &lt;&lt; file &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>else<br/>{<br/>&#160;&#160;&#160;&#160;cerr &lt;&lt; file &lt;&lt; " could not be opened -- bye.\n";<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}</p>
<p><a id="page_1137"/>This is similar to the start of <a href="#ch17ex19">Listing 17.19</a>, but there are some changes and additions. First, as just described, the program uses an <code>fstream</code> object with a read/write mode, and it uses <code>seekg()</code> to position the file pointer at the start of the file. (This isn&#8217;t really needed for this example, but it shows how <code>seekg()</code> is used.) Next, the program makes the minor change of numbering the records as they are displayed. Then it makes the following important addition:</p>
<p class="programlisting">if (finout.eof())<br/>&#160;&#160;&#160;&#160;finout.clear(); // clear eof flag<br/>else<br/>{<br/>&#160;&#160;&#160;&#160;cerr &lt;&lt; "Error in reading " &lt;&lt; file &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}</p>
<p>The problem this code addresses is that when the program finishes reading and displaying the entire file, it sets the <code>eofbit</code> element. This convinces the program that it&#8217;s finished with the file and disables any further reading of or writing to the file. Using the <code>clear()</code> method resets the stream state, turning off <code>eofbit</code>. Now the program can once again access the file. The <code>else</code> part handles the possibility that the program quits reading the file for some reason other than reaching the end-of-file, such as a hardware failure.</p>
<p>The next step is to identify the record to be changed and then change it. To do this, the program asks the user to enter a record number. Multiplying the number by the number of bytes in a record yields the byte number for the beginning of the record. If <code>record</code> is the record number, the desired byte number is <code>record * sizeof pl</code>:</p>
<p class="programlisting">cout &lt;&lt; "Enter the record number you wish to change: ";<br/>long rec;<br/>cin &gt;&gt; rec;<br/>eatline();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// get rid of newline<br/>if (rec &lt; 0 || rec &gt;= ct)<br/>{<br/>&#160;&#160;&#160;&#160;cerr &lt;&lt; "Invalid record number -- bye\n";<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}<br/>streampos place = rec * sizeof pl;&#160;&#160;// convert to streampos type<br/>finout.seekg(place);&#160;&#160;&#160;&#160;// random access</p>
<p>The variable <code>ct</code> represents the number of records; the program exits if you try to go beyond the limits of the file.</p>
<p>Next, the program displays the current record:</p>
<p class="programlisting">finout.read((char *) &#38;pl, sizeof pl);<br/>cout &lt;&lt; "Your selection:\n";<br/>cout &lt;&lt; rec &lt;&lt; ": " &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; ": "<br/>&lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population<br/>&lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl;<br/>if (finout.eof())<br/>&#160;&#160;&#160;&#160;finout.clear();&#160;&#160;&#160;&#160;&#160;// clear eof flag</p>
<p><a id="page_1138"/>After displaying the record, the program lets you change the record:</p>
<p class="programlisting">cout &lt;&lt; "Enter planet name: ";<br/>cin.get(pl.name, LIM);<br/>eatline();<br/>cout &lt;&lt; "Enter planetary population: ";<br/>cin &gt;&gt; pl.population;<br/>cout &lt;&lt; "Enter planet's acceleration of gravity: ";<br/>cin &gt;&gt; pl.g;<br/>finout.seekp(place);&#160;&#160;&#160;&#160;// go back<br/>finout.write((char *) &#38;pl, sizeof pl) &lt;&lt; flush;<br/><br/>if (finout.fail())<br/>{<br/>&#160;&#160;&#160;&#160;cerr &lt;&lt; "Error on attempted write\n";<br/>&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>}</p>
<p>The program flushes the output to guarantee that the file is updated before proceeding to the next stage.</p>
<p>Finally, to display the revised file, the program uses <code>seekg()</code> to reset the file pointer to the beginning. <a href="#ch17ex20">Listing 17.20</a> shows the complete program. Don&#8217;t forget that it assumes that a <code>planets.dat</code> file created using the <code>binary.cpp</code> program is available.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note15"/>Note</p>
<p class="notepara">The older the implementation, the more likely it is to run afoul of the C++ Standard. Some systems don&#8217;t recognize the binary flag, the <code>fixed</code> and <code>right</code> manipulators, and <code>ios_base</code>.</p>
<hr/></div>
<p class="caption1"><a id="ch17ex20"/><strong>Listing 17.20. <code>random.cpp</code></strong></p><hr/>
<p class="programlisting1">// random.cpp -- random access to a binary file<br/>#include &lt;iostream&gt;&#160;&#160;&#160;&#160;&#160;// not required by most systems<br/>#include &lt;fstream&gt;<br/>#include &lt;iomanip&gt;<br/>#include &lt;cstdlib&gt;&#160;&#160;&#160;&#160;&#160;&#160;// for exit()<br/>const int LIM = 20;<br/>struct planet<br/>{<br/>&#160;&#160;&#160;&#160;char name[LIM];&#160;&#160;&#160;&#160;&#160;// name of planet<br/>&#160;&#160;&#160;&#160;double population;&#160;&#160;// its population<br/>&#160;&#160;&#160;&#160;double g;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// its acceleration of gravity<br/>};<br/><br/>const char * file = "planets.dat";&#160;&#160;// ASSUMED TO EXIST (binary.cpp example)<br/>inline void eatline() { while (std::cin.get() != '\n') continue; }<br/><br/>int main()<br/>{<br/><a id="page_1139"/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;planet pl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; fixed;<br/><br/>// show initial contents<br/>&#160;&#160;&#160;&#160;fstream finout;&#160;&#160;&#160;&#160;&#160;// read and write streams<br/>&#160;&#160;&#160;&#160;finout.open(file,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ios_base::in | ios_base::out | ios_base::binary);<br/>&#160;&#160;&#160;&#160;//NOTE: Some Unix systems require omitting | ios::binary<br/>&#160;&#160;&#160;&#160;int ct = 0;<br/>&#160;&#160;&#160;&#160;if (finout.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;finout.seekg(0);&#160;&#160;&#160;&#160;// go to beginning<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the current contents of the "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; file &lt;&lt; " file:\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (finout.read((char *) &#38;pl, sizeof pl))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ct++ &lt;&lt; ": " &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; ": "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (finout.eof())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;finout.clear(); // clear eof flag<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Error in reading " &lt;&lt; file &lt;&lt; ".\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; file &lt;&lt; " could not be opened -- bye.\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/><br/>// change a record<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the record number you wish to change: ";<br/>&#160;&#160;&#160;&#160;long rec;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; rec;<br/>&#160;&#160;&#160;&#160;eatline();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// get rid of newline<br/>&#160;&#160;&#160;&#160;if (rec &lt; 0 || rec &gt;= ct)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Invalid record number -- bye\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;streampos place = rec * sizeof pl;&#160;&#160;// convert to streampos type<br/>&#160;&#160;&#160;&#160;finout.seekg(place);&#160;&#160;&#160;&#160;// random access<br/><a id="page_1140"/>&#160;&#160;&#160;&#160;if (finout.fail())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Error on attempted seek\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;finout.read((char *) &#38;pl, sizeof pl);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Your selection:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; rec &lt;&lt; ": " &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; ": "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;if (finout.eof())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;finout.clear();&#160;&#160;&#160;&#160;&#160;// clear eof flag<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter planet name: ";<br/>&#160;&#160;&#160;&#160;cin.get(pl.name, LIM);<br/>&#160;&#160;&#160;&#160;eatline();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter planetary population: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; pl.population;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter planet's acceleration of gravity: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; pl.g;<br/>&#160;&#160;&#160;&#160;finout.seekp(place);&#160;&#160;&#160;&#160;// go back<br/>&#160;&#160;&#160;&#160;finout.write((char *) &#38;pl, sizeof pl) &lt;&lt; flush;<br/>&#160;&#160;&#160;&#160;if (finout.fail())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Error on attempted write\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/><br/>// show revised file<br/>&#160;&#160;&#160;&#160;ct = 0;<br/>&#160;&#160;&#160;&#160;finout.seekg(0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// go to beginning of file<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are the new contents of the " &lt;&lt; file<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " file:\n";<br/>&#160;&#160;&#160;&#160;while (finout.read((char *) &#38;pl, sizeof pl))<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ct++ &lt;&lt; ": " &lt;&lt; setw(LIM) &lt;&lt; pl.name &lt;&lt; ": "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(0) &lt;&lt; setw(12) &lt;&lt; pl.population<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setprecision(2) &lt;&lt; setw(6) &lt;&lt; pl.g &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;finout.close();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_1141"/>Here&#8217;s a sample run of the program in <a href="#ch17ex20">Listing 17.20</a>, based on a <code>planets.dat</code> file that has had a few more entries added since you last saw it:</p>
<p class="programlisting">Here are the current contents of the planets.dat file:<br/>0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Earth:&#160;&#160;&#160;6928198253&#160;&#160;9.81<br/>1:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Jenny's World:&#160;&#160;&#160;&#160;&#160;32155648&#160;&#160;8.93<br/>2:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Tramtor:&#160;&#160;89000000000 15.03<br/>3:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Trellan:&#160;&#160;&#160;&#160;&#160;&#160;5214000&#160;&#160;9.62<br/>4:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Freestone:&#160;&#160;&#160;3945851000&#160;&#160;8.68<br/>5:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Taanagoot:&#160;&#160;&#160;&#160;361000004 10.23<br/>6:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Marin:&#160;&#160;&#160;&#160;&#160;&#160;&#160;252409&#160;&#160;9.79<br/>Enter the record number you wish to change: 2<br/>Your selection:<br/>2:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Tramtor:&#160;&#160;89000000000 15.03<br/>Enter planet name: <span class="EmpStrong">Trantor</span><br/>Enter planetary population: <span class="EmpStrong">89521844777</span><br/>Enter planet's acceleration of gravity: <span class="EmpStrong">10.53</span><br/>Here are the new contents of the planets.dat file:<br/>0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Earth:&#160;&#160;&#160;6928198253&#160;&#160;9.81<br/>1:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Jenny's World:&#160;&#160;&#160;&#160;&#160;32155648&#160;&#160;8.93<br/>2:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Trantor:&#160;&#160;89521844777 10.53<br/>3:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Trellan:&#160;&#160;&#160;&#160;&#160;&#160;5214000&#160;&#160;9.62<br/>4:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Freestone:&#160;&#160;&#160;3945851000&#160;&#160;8.68<br/>5:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Taanagoot:&#160;&#160;&#160;&#160;361000004 10.23<br/>6:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Marin:&#160;&#160;&#160;&#160;&#160;&#160;&#160;252409&#160;&#160;9.79<br/>Done.</p>
<p>By using the techniques in this program, you can extend it so that it allows you to add new material and delete records. If you were to expand the program, it would be a good idea to reorganize it by using classes and functions. For example, you could convert the <code>planet</code> structure to a class definition; then you could overload the <code>&lt;&lt;</code> insertion operator so that <code>cout &lt;&lt; pl</code> displays the class data members formatted as in the example. Also the example doesn&#8217;t bother to verify input, so you could add code to check for numeric input where appropriate.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch17sb04"/>Working with Temporary Files</p>
<p class="sidebarpara">Developing applications often requires the use of temporary files whose lifetimes are transient and must be controlled by the program. Have you ever thought about how to go about this in C++? It&#8217;s really quite easy to create a temporary file, copy the contents of another file, and delete the file. First of all, you need to come up with a naming scheme for your temporary file(s). But wait...how can you ensure that each file is assigned a unique name? The <code>tmpnam()</code> standard function declared in <code>cstdio</code> has you covered:</p>
<p class="programlistingB">char* tmpnam( char* pszName );</p>
<p class="sidebarpara">The <code>tmpnam()</code> function creates a temporary name and places it in the C-style string that is pointed to by <code>pszName</code>. The constants <code>L_tmpnam</code> and <code>TMP_MAX</code>, both defined in <code>cstdio</code>, limit the number of characters in the filename and the maximum number of times <code>tmpnam()</code> can be called without generating a duplicate filename in the current directory. The following example generates 10 temporary names:</p>
<p class="programlistingB">#include &lt;cstdio&gt;<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "This system can generate up to " &lt;&lt; TMP_MAX<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " temporary names of up to " &lt;&lt; L_tmpnam<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " characters.\n";<br/>&#160;&#160;&#160;&#160;char pszName[ L_tmpnam ] = {'\0'};<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here are ten names:\n";<br/>&#160;&#160;&#160;&#160;for( int i=0; 10 &gt; i; i++ )<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tmpnam( pszName );<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; pszName &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="sidebarpara">More generally, by using <code>tmpnam()</code>, you can now generate <code>TMP_NAM</code> unique filenames with up to <code>L_tmpnam</code> characters per name. The names themselves depend on the compiler. You can run this program to see what names your compiler comes up with.</p>
<hr/></div>
<h3 id="ch17lev1sec5">Incore Formatting</h3>
<p><a id="page_1142"/>The <code>iostream</code> family supports I/O between a program and a terminal. The <code>fstream</code> family uses the same interface to provide I/O between a program and a file. The C++ library also provides an <code>sstream</code> family, which uses the same interface to provide I/O between a program and a <code>string</code> object. That is, you can use the same <code>ostream</code> methods you&#8217;ve used with <code>cout</code> to write formatted information into a <code>string</code> object, and you can use <code>istream</code> methods such as <code>getline()</code> to read information from a <code>string</code> object. The process of reading formatted information from a <code>string</code> object or of writing formatted information to a <code>string</code> object is termed <em>incore</em> formatting. Let&#8217;s take a brief look at these facilities. (The <code>sstream</code> family of <code>string</code> support supersedes the <code>strstream.h</code> family of <code>char</code>-array support.)</p>
<p>The <code>sstream</code> header file defines an <code>ostringstream</code> class that is derived from the <code>ostream</code> class. (There is also a <code>wostringstream</code> class based on <code>wostream</code>, for wide character sets.) If you create an <code>ostringstream</code> object, you can write information to it, which it stores. You can use the same methods with an <code>ostringstream</code> object that you can with <code>cout</code>. That is, you can do something like the following:</p>
<p class="programlisting">ostringstream outstr;<br/>double price = 380.0;<br/><a id="page_1143"/>char * ps = " for a copy of the ISO/EIC C++ standard!";<br/>outstr.precision(2);<br/>outstr &lt;&lt; fixed;<br/>outstr &lt;&lt; "Pay only CHF " &lt;&lt; price &lt;&lt; ps &lt;&lt; endl;</p>
<p>The formatted text goes into a buffer, and the object uses dynamic memory allocation to expand the buffer size as needed. The <code>ostringstream</code> class has a member function, called <code>str()</code>, that returns a string object initialized to the buffer&#8217;s contents:</p>
<p class="programlisting">string mesg = outstr.str();&#160;&#160;&#160;&#160;// returns string with formatted information</p>
<p>Using the <code>str()</code> method &#8220;freezes&#8221; the object, and you can no longer write to it.</p>
<p><a href="#ch17ex21">Listing 17.21</a> provides a short example of incore formatting.</p>
<p class="caption1"><a id="ch17ex21"/><strong>Listing 17.21. <code>strout.cpp</code></strong></p><hr/>
<p class="programlisting1">// strout.cpp -- incore formatting (output)<br/>#include &lt;iostream&gt;<br/>#include &lt;sstream&gt;<br/>#include &lt;string&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;ostringstream outstr;&#160;&#160;&#160;// manages a string stream<br/><br/>&#160;&#160;&#160;&#160;string hdisk;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "What's the name of your hard disk? ";<br/>&#160;&#160;&#160;&#160;getline(cin, hdisk);<br/>&#160;&#160;&#160;&#160;int cap;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "What's its capacity in GB? ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; cap;<br/>&#160;&#160;&#160;&#160;// write formatted information to string stream<br/>&#160;&#160;&#160;&#160;outstr &lt;&lt; "The hard disk " &lt;&lt; hdisk &lt;&lt; " has a capacity of "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; cap &lt;&lt; " gigabytes.\n";<br/>&#160;&#160;&#160;&#160;string result = outstr.str();&#160;&#160;&#160;// save result<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; result;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// show contents<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/><br/>}</p><hr/>
<p>Here&#8217;s a sample run of the program in <a href="#ch17ex21">Listing 17.21</a>:</p>
<p class="programlisting">What's the name of your hard disk? <span class="EmpStrong">Datarapture</span><br/>What's its capacity in GB? <span class="EmpStrong">2000</span><br/>The hard disk Datarapture has a capacity of 2000 gigabytes.</p>
<p>The <code>istringstream</code> class lets you use the <code>istream</code> family of methods to read data from an <code>istringstream</code> object, which can be initialized from a <code>string</code> object. <a id="page_1144"/>Suppose <code>facts</code> is a <code>string</code> object. To create an <code>istringstream</code> object associated with this string, you can use the following:</p>
<p class="programlisting">istringstream instr(facts);&#160;&#160;&#160;&#160;&#160;// use facts to initialize stream</p>
<p>Then you use <code>istream</code> methods to read data from <code>instr</code>. For example, if <code>instr</code> contained a bunch of integers in character format, you could read them as follows:</p>
<p class="programlisting">int n;<br/>int sum = 0;<br/>while (instr &gt;&gt; n)<br/>&#160;&#160;&#160;&#160;sum += n;</p>
<p><a href="#ch17ex22">Listing 17.22</a> uses the overloaded <code>&gt;&gt;</code> operator to read the contents of a string one word at a time.</p>
<p class="caption1"><a id="ch17ex22"/><strong>Listing 17.22. <code>strin.cpp</code></strong></p><hr/>
<p class="programlisting1">// strin.cpp -- formatted reading from a char array<br/>#include &lt;iostream&gt;<br/>#include &lt;sstream&gt;<br/>#include &lt;string&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;string lit = "It was a dark and stormy day, and "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" the full moon glowed brilliantly. ";<br/>&#160;&#160;&#160;&#160;istringstream instr(lit);&#160;&#160;&#160;// use buf for input<br/>&#160;&#160;&#160;&#160;string word;<br/>&#160;&#160;&#160;&#160;while (instr &gt;&gt; word)&#160;&#160;&#160;&#160;&#160;&#160;&#160;// read a word a time<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; word &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/><br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch17ex22">Listing 17.22</a>:</p>
<p class="programlisting">It<br/>was<br/>a<br/>dark<br/>and<br/>stormy<br/>day,<br/>and<br/>the<br/>full<br/>moon<br/>glowed<br/>brilliantly.</p>
<p><a id="page_1145"/>In short, the <code>istringstream</code> and <code>ostringstream</code> classes give you the power of the <code>istream</code> and <code>ostream</code> class methods to manage character data stored in strings.</p>
<h3 id="ch17lev1sec6">Summary</h3>
<p>A stream is a flow of bytes into or out of a program. A buffer is a temporary holding area in memory that acts as an intermediary between a program and a file or other I/O devices. Information can be transferred between a buffer and a file, using large chunks of data of the size most efficiently handled by devices such as disk drives. And information can be transferred between a buffer and a program in a byte-by-byte flow that often is more convenient for the processing done in a program. C++ handles input by connecting a buffered stream to a program and to its source of input. Similarly, C++ handles output by connecting a buffered stream to a program and to its output target. The <code>iostream</code> and <code>fstream</code> files constitute an I/O class library that defines a rich set of classes for managing streams. C++ programs that include the <code>iostream</code> file automatically open eight streams, managing them with eight objects. The <code>cin</code> object manages the standard input stream, which, by default, connects to the standard input device, typically a keyboard. The <code>cout</code> object manages the standard output stream, which, by default, connects to the standard output device, typically a monitor. The <code>cerr</code> and <code>clog</code> objects manage unbuffered and buffered streams connected to the standard error device, typically a monitor. These four objects have four wide character counterparts, named <code>wcin</code>, <code>wcout</code>, <code>wcerr</code>, and <code>wclog</code>.</p>
<p>The I/O class library provides a variety of useful methods. The <code>istream</code> class defines versions of the extraction operator (<code>&gt;&gt;</code>) that recognize all the basic C++ types and that convert character input to those types. The <code>get()</code> family of methods and the <code>getline()</code> method provide further support for single-character input and for string input. Similarly, the <code>ostream</code> class defines versions of the insertion operator (<code>&lt;&lt;</code>) that recognize all the basic C++ types and that convert them to suitable character output. The <code>put()</code> method provides further support for single-character output. The <code>wistream</code> and <code>wostream</code> classes provide similar support for wide characters.</p>
<p>You can control how a program formats output by using <code>ios_base</code> class methods and by using manipulators (functions that can be concatenated with insertion) defined in the <code>iostream</code> and <code>iomanip</code> files. These methods and manipulators let you control the number base, the field width, the number of decimal places displayed, the system used to display floating-point values, and other elements.</p>
<p>The <code>fstream</code> file provides class definitions that extend the <code>iostream</code> methods to file I/O. The <code>ifstream</code> class derives from the <code>istream</code> class. By associating an <code>ifstream</code> object with a file, you can use all the <code>istream</code> methods for reading the file. Similarly, associating an <code>ofstream</code> object with a file lets you use the <code>ostream</code> methods to write to a file. And associating an <code>fstream</code> object with a file lets you employ both input and output methods with the file.</p>
<p>To associate a file with a stream, you can provide the filename when initializing a file stream object or you can first create a file stream object and then use the <code>open()</code> method to associate the stream with a file. The <code>close()</code> method terminates the connection <a id="page_1146"/>between a stream and a file. The class constructors and the <code>open()</code> method take an optional second argument that provides the file mode. The file mode determines such things as whether the file is to be read and/or written to, whether opening a file for writing truncates it, whether attempting to open a non-existent file is an error, and whether to use the binary or text mode.</p>
<p>A text file stores all information in character form. For example, numeric values are converted to character representations. The usual insertion and extraction operators, along with <code>get()</code> and <code>getline()</code>, support this mode. A binary file stores all information by using the same binary representation the computer uses internally. Binary files store data, particularly floating-point values, more accurately and compactly than text files, but they are less portable. The <code>read()</code> and <code>write()</code> methods support binary input and output.</p>
<p>The <code>seekg()</code> and <code>seekp()</code> functions provide C++ random access for files. These class methods let you position a file pointer relative to the beginning of a file, relative to the end, or relative to the current position. The <code>tellg()</code> and <code>tellp()</code> methods report the current file position.</p>
<p>The <code>sstream</code> header file defines <code>istringstream</code> and <code>ostringstream</code> classes that let you use <code>istream</code> and <code>ostream</code> methods to extract information from a string and to format information placed into a string.</p>
<h3 id="ch17lev1sec7">Chapter Review</h3>
<p class="question"><a id="ch17qa1q1" href="app10.html#ch17qa1a1"><strong>1.</strong></a> What role does the <code>iostream</code> file play in C++ I/O?</p>
<p class="question"><a id="ch17qa1q2" href="app10.html#ch17qa1a2"><strong>2.</strong></a> Why does typing a number such as 121 as input require a program to make a conversion?</p>
<p class="question"><a id="ch17qa1q3" href="app10.html#ch17qa1a3"><strong>3.</strong></a> What&#8217;s the difference between the standard output and the standard error?</p>
<p class="question"><a id="ch17qa1q4" href="app10.html#ch17qa1a4"><strong>4.</strong></a> Why is <code>cout</code> able to display various C++ types without being provided explicit instructions for each type?</p>
<p class="question"><a id="ch17qa1q5" href="app10.html#ch17qa1a5"><strong>5.</strong></a> What feature of the output method definitions allows you to concatenate output?</p>
<p class="question"><a id="ch17qa1q6" href="app10.html#ch17qa1a6"><strong>6.</strong></a> Write a program that requests an integer and then displays it in decimal, octal, and hexadecimal forms. Display each form on the same line, in fields that are 15 characters wide, and use the C++ number base prefixes.</p>
<p class="question"><a id="ch17qa1q7" href="app10.html#ch17qa1a7"><strong>7.</strong></a> Write a program that requests the following information and that formats it as shown:</p>
<p class="programlistingB">Enter your name: <span class="EmpStrong">Billy Gruff</span><br/>Enter your hourly wages: <span class="EmpStrong">12</span><br/>Enter number of hours worked: <span class="EmpStrong">7.5</span><br/>First format:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Billy Gruff: $&#160;&#160;&#160;&#160;&#160;12.00:&#160;&#160;7.5<br/>Second format:<br/>Billy Gruff&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: $12.00&#160;&#160;&#160;&#160;&#160;:7.5</p>
<p class="question"><a id="page_1147"/><a id="ch17qa1q8" href="app10.html#ch17qa1a8"><strong>8.</strong></a> Consider the following program:</p>
<p class="programlistingB">//rq17-8.cpp<br/>#include &lt;iostream&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;int ct1 = 0;<br/><br/>&#160;&#160;&#160;&#160;cin &gt;&gt; ch;<br/>&#160;&#160;&#160;&#160;while (ch != 'q')<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ct1++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; ch;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;int ct2 = 0;<br/>&#160;&#160;&#160;&#160;cin.get(ch);<br/>&#160;&#160;&#160;&#160;while (ch != 'q')<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ct2++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get(ch);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "ct1 = " &lt;&lt; ct1 &lt;&lt; "; ct2 = " &lt;&lt; ct2 &lt;&lt; "\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="questionp">What does it print, given the following input:</p>
<p class="programlistingB">I see a q&lt;Enter&gt;<br/>I see a q&lt;Enter&gt;</p>
<p class="questionp">Here <code>&lt;Enter&gt;</code> signifies pressing the Enter key.</p>
<p class="question"><a id="ch17qa1q9" href="app10.html#ch17qa1a9"><strong>9.</strong></a> Both of the following statements read and discard characters up to and including the end of a line. In what way does the behavior of one differ from that of the other?</p>
<p class="programlistingB">while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;continue;<br/>cin.ignore(80, '\n');</p>
<h3 id="ch17lev1sec8">Programming Exercises</h3>
<p class="question"><a id="page_1148"/><a id="ch17qa2q1"/><strong>1.</strong> Write a program that counts the number of characters up to the first <code>$</code> in input and that leaves the <code>$</code> in the input stream.</p>
<p class="question"><a id="ch17qa2q2"/><strong>2.</strong> Write a program that copies your keyboard input (up to the simulated end-of-file) to a file named on the command line.</p>
<p class="question"><a id="ch17qa2q3"/><strong>3.</strong> Write a program that copies one file to another. Have the program take the filenames from the command line. Have the program report if it cannot open a file.</p>
<p class="question"><a id="ch17qa2q4"/><strong>4.</strong> Write a program that opens two text files for input and one for output. The program should concatenate the corresponding lines of the input files, use a space as a separator, and write the results to the output file. If one file is shorter than the other, the remaining lines in the longer file should also be copied to the output file. For example, suppose the first input file has these contents:</p>
<p class="programlistingB">eggs kites donuts<br/>balloons hammers<br/>stones</p>
<p class="questionp">And suppose the second input file has these contents:</p>
<p class="programlistingB">zero lassitude<br/>finance drama</p>
<p class="questionp">The resulting file would have these contents:</p>
<p class="programlistingB">eggs kites donuts zero lassitude<br/>balloons hammers finance drama<br/>stones</p>
<p class="question"><a id="ch17qa2q5"/><strong>5.</strong> Mat and Pat want to invite their friends to a party, much as they did in Programming Exercise 8 in <a href="ch16.html#ch16">Chapter 16</a>, except now they want a program that uses files. They have asked you to write a program that does the following:</p>
<p class="indenthandingNB">&#8226; Reads a list of Mat&#8217;s friends&#8217; names from a text file called <code>mat.dat</code>, which lists one friend per line. The names are stored in a container and then displayed in sorted order.</p>
<p class="indenthandingNB">&#8226; Reads a list of Pat&#8217;s friends&#8217; names from a text file called <code>pat.dat</code>, which lists one friend per line. The names are stored in a container and then displayed in sorted order.</p>
<p class="indenthandingNB">&#8226; Merges the two lists, eliminating duplicates and stores the result in the file <code>matnpat.dat</code>, one friend per line.</p>
<p class="question"><a id="page_1149"/><a id="ch17qa2q6"/><strong>6.</strong> Consider the class definitions of Programming Exercise 5 in <a href="ch14.html#ch14">Chapter 14</a>, &#8220;<a href="ch14.html#ch14">Reusing Code in C++</a>&#8221;. If you haven&#8217;t yet done that exercise, do so now. Then do the following:</p>
<p class="questionp">Write a program that uses standard C++ I/O and file I/O in conjunction with data of types <code>employee</code>, <code>manager</code>, <code>fink</code>, and <code>highfink</code>, as defined in Programming Exercise 5 in <a href="ch14.html#ch14">Chapter 14</a>. The program should be along the general lines of <a href="#ch17ex17">Listing 17.17</a> in that it should let you add new data to a file. The first time through, the program should solicit data from the user, show all the entries, and save the information in a file. On subsequent uses, the program should first read and display the file data, let the user add data, and show all the data. One difference is that data should be handled by an array of pointers to type <code>employee</code>. That way, a pointer can point to an <code>employee</code> object or to objects of any of the three derived types. Keep the array small to facilitate checking the program; for example, you might limit the array to 10 elements:</p>
<p class="programlistingB">const int MAX = 10;&#160;&#160;&#160;&#160;&#160;// no more than 10 objects<br/>...<br/>employee * pc[MAX];</p>
<p class="questionp">For keyboard entry, the program should use a menu to offer the user the choice of which type of object to create. The menu should use a switch to use <code>new</code> to create an object of the desired type and to assign the object&#8217;s address to a pointer in the <code>pc</code> array. Then that object can use the virtual <code>setall()</code> function to elicit the appropriate data from the user:</p>
<p class="programlistingB">pc[i]-&gt;setall();&#160;&#160;// invokes function corresponding to type of object</p>
<p class="questionp">To save the data to a file, devise a virtual <code>writeall()</code> function for that purpose:</p>
<p class="programlistingB">for (i = 0; i &lt; index; i++)<br/>&#160;&#160;&#160;&#160;pc[i]-&gt;writeall(fout);// fout ofstream connected to output file</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note16"/>Note</p>
<p class="notepara">Use text I/O, not binary I/O, for Programming Exercise 6. (Unfortunately, virtual objects include pointers to tables of pointers to virtual functions, and <code>write()</code> copies this information to a file. An object filled by using <code>read()</code> from the file gets weird values for the function pointers, which really messes up the behavior of virtual functions.) Use a newline character to separate each data field from the next; this makes it easier to identify fields on input. Or you could still use binary I/O, but not write objects as a whole. Instead, you could provide class methods that apply the <code>write()</code> and <code>read()</code> functions to each class member individually rather than to the object as a whole. That way, the program could save just the intended data to a file.</p>
<hr/></div>
<p class="questionp"><a id="page_1150"/>The tricky part is recovering the data from the file. The problem is, how can the program know whether the next item to be recovered is an <code>employee</code> object, a <code>manager</code> object, a <code>fink</code> type, or a <code>highfink</code> type? One approach is, when writing the data for an object to a file, precede the data with an integer that indicates the type of object to follow. Then, on file input, the program can read the integer and then use <code>switch</code> to create the appropriate object to receive the data:</p>
<p class="programlistingB">enum classkind{Employee, Manager, Fink, Highfink}; // in class header<br/>...<br/>int classtype;<br/>while((fin &gt;&gt; classtype).get(ch)){ // newline separates int from data<br/>&#160;&#160;&#160;&#160;switch(classtype) {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case Employee&#160;&#160;: pc[i] = new employee;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: break;</p>
<p class="questionp">Then you can use the pointer to invoke a virtual <code>getall()</code> function to read the information:</p>
<p class="programlistingB">pc[i++]-&gt;getall();</p>
<p class="question"><a id="ch17qa2q7"/><strong>7.</strong> Here is part of a program that reads keyboard input into a vector of <code>string</code> objects, stores the string contents (not the objects) in a file, and then copies the file contents back into a vector of <code>string</code> objects:</p>
<p class="programlistingB">int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;vector&lt;string&gt; vostr;<br/>&#160;&#160;&#160;&#160;string temp;<br/><br/>// acquire strings<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter strings (empty line to quit):\n";<br/>&#160;&#160;&#160;&#160;while (getline(cin,temp) &#38;&#38; temp[0] != '\0')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vostr.push_back(temp);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Here is your input.\n";<br/>&#160;&#160;&#160;&#160;for_each(vostr.begin(), vostr.end(), ShowStr);<br/><br/>// store in a file<br/>&#160;&#160;&#160;&#160;ofstream fout("strings.dat", ios_base::out | ios_base::binary);<br/>&#160;&#160;&#160;&#160;for_each(vostr.begin(), vostr.end(), Store(fout));<br/>&#160;&#160;&#160;&#160;fout.close();<br/><br/>// recover file contents<br/>&#160;&#160;&#160;&#160;vector&lt;string&gt; vistr;<br/>&#160;&#160;&#160;&#160;ifstream fin("strings.dat", ios_base::in | ios_base::binary);<br/>&#160;&#160;&#160;&#160;if (!fin.is_open())<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; "Could not open file for input.\n";<br/><a id="page_1151"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;GetStrs(fin, vistr);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nHere are the strings read from the file:\n";<br/>&#160;&#160;&#160;&#160;for_each(vistr.begin(), vistr.end(), ShowStr);<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="questionp">Note that the file is opened in binary format and that the intention is that I/O be accomplished with <code>read()</code> and <code>write()</code>. Quite a bit remains to be done:</p>
<p class="indenthandingNB">&#8226; Write a <code>void ShowStr(const string &#38;)</code> function that displays a <code>string</code> object followed by a newline character.</p>
<p class="indenthandingNB">&#8226; Write a <code>Store</code> functor that writes string information to a file. The <code>Store</code> constructor should specify an <code>ifstream</code> object, and the overloaded <code>operator()(const string &#38;)</code> should indicate the string to write. A workable plan is to first write the string&#8217;s size to the file and then write the string contents. For example, if <code>len</code> holds the string size, you could use this:</p>
<p class="programlistingB">os.write((char *)&#38;len, sizeof(std::size_t));&#160;&#160;// store length<br/>os.write(s.data(), len);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// store characters</p>
<p class="indenthandinga1">The <code>data()</code> member returns a pointer to an array that holds the characters in the string. It&#8217;s similar to the <code>c_str()</code> member except that the latter appends a null character.</p>
<p class="indenthandingNB">&#8226; Write a <code>GetStrs()</code> function that recovers information from the file. It can use <code>read()</code> to obtain the size of a string and then use a loop to read that many characters from the file, appending them to an initially empty temporary string. Because a string&#8217;s data is private, you have to use a class method to get data into the string rather than read directly into it.</p>
</body>
</html>
