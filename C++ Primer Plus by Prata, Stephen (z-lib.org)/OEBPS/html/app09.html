<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>I. Converting to ISO Standard C++</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="app09">I. Converting to ISO Standard C++</h2>
<p><a id="page_1327"/>You might have programs (or programming habits) that you developed in C or in older versions of C++ and you want to convert to standard C++. This appendix provides some guidelines. Some pertain to moving from C to C++, and others pertain to moving from older C++ to standard C++.</p>
<h3 id="app09lev1sec1">Use Alternatives for Some Preprocessor Directives</h3>
<p>The C/C++ preprocessor provides an array of directives. In general, C++ practice is to use those directives that are designed to manage the compilation process and to avoid using directives as a substitute for code. For example, the <code>#include</code> directive is an essential component for managing program files. Other directives, such as <code>#ifndef</code> and <code>#endif</code>, let you control whether particular blocks of code get compiled. The <code>#pragma</code> directive lets you control compiler-specific compilation options. These are all useful, sometimes necessary, tools. You should exercise caution, however, when it comes to the <code>#define</code> directive.</p>
<h4 id="app09lev2sec1">Use <code>const</code> Instead of <code>#define</code> to Define Constants</h4>
<p>Symbolic constants make code more readable and maintainable. The constant&#8217;s name indicates its meaning, and if you need to change the value, you just have to change the value once, in the definition, and then recompile. C uses the preprocessor to create symbolic names for a constant:</p>
<p class="programlisting">#define MAX_LENGTH 100</p>
<p>The preprocessor then does a text substitution in your source code, replacing occurrences of <code>MAX_LENGTH</code> with <code>100</code> prior to compilation.</p>
<p>The C++ approach is to apply the <code>const</code> modifier to a variable declaration:</p>
<p class="programlisting">const int MAX_LENGTH = 100;</p>
<p><a id="page_1328"/>This treats <code>MAX_LENGTH</code> as a read-only <code>int</code>.</p>
<p>There are several advantages to using the <code>const</code> approach. First, the declaration explicitly names the type. With <code>#define</code>, you must use various suffixes to a number to indicate types other than <code>char</code>, <code>int</code>, or <code>double</code>; for example, you use <code>100L</code> to indicate a <code>long</code> type and <code>3.14F</code> to indicate a <code>float</code> type. More importantly, the <code>const</code> approach can just as easily be used with compound types, as in this example:</p>
<p class="programlisting">const int base_vals[5] = {1000, 2000, 3500, 6000, 10000};<br/>const string ans[3] = {"yes", "no", "maybe"};</p>
<p>Finally, <code>const</code> identifiers obey the same scope rules as variables. Thus, you can create constants with global scope, named namespace scope, and block scope. If, say, you define a constant in a particular function, you don&#8217;t have to worry about the definition conflicting with a global constant used elsewhere in a program. For example, consider the following:</p>
<p class="programlisting">#define n 5<br/>const int dz = 12;<br/>...<br/>void fizzle()<br/>{<br/>&#160;&#160;&#160;&#160;int n;<br/>&#160;&#160;&#160;&#160;int dz;<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>The preprocessor will replace</p>
<p class="programlisting">int n;</p>
<p>with</p>
<p class="programlisting">int 5;</p>
<p>and induce a compilation error. The <code>dz</code> defined in <code>fizzle()</code>, however, will be a local variable. Also if necessary, <code>fizzle()</code> can use the scope-resolution operator (<code>::</code>) and access the constant as <code>::dz</code>.</p>
<p>C++ has borrowed the <code>const</code> keyword from C, but the C++ version is more useful. For example, the C++ version has internal linkage for external <code>const</code> values rather than the default external linkage used by variables and by the C <code>const</code>. This means that each file in a program using a <code>const</code> needs that <code>const</code> defined in that particular file. This might sound like extra work, but, in fact, it makes life easier. With internal linkage, you can place <code>const</code> definitions in a header file used by various files in a project. That is a compiler error for external linkage but not for internal linkage. Also because a <code>const</code> must be defined in the file that uses it (being in a header file used by that file satisfies the requirement), you can use <code>const</code> values as array size arguments:</p>
<p class="programlisting">const int MAX_LENGTH = 100;<br/>...<br/>double loads[MAX_LENGTH];<br/><a id="page_1329"/>for (int i = 0; i &lt; MAX_LENGTH; i++)<br/>&#160;&#160;&#160;&#160;loads[i] = 50;</p>
<p>This won&#8217;t work in C because the defining declaration for <code>MAX_LENGTH</code> could be in a separate file and not be available when this particular file is compiled. In fairness, it should be added that, in C, you could use the <code>static</code> modifier to create constants with internal linkage. It&#8217;s just that C++, by making <code>static</code> the default, requires one fewer thing for you to remember.</p>
<p>Incidentally, the revised C Standard (C99) allows you to use a <code>const</code> as an array size specification, but the array is treated as a new form of array, called a <em>variable array</em>, that is not part of the C++ Standard.</p>
<p>One role for the <code>#define</code> directive is still quite useful&#8212;the standard idiom for controlling when a header file is compiled:</p>
<p class="programlisting">// blooper.h<br/>#ifndef _BLOOPER_H_<br/>#define _BLOOPER_H_<br/>// code goes here<br/>#endif</p>
<p>For typical symbolic constants, however, you should get into the habit of using <code>const</code> instead of <code>#define</code>. Another good alternative, particularly when you have a set of related integer constants, is to use <code>enum</code>:</p>
<p class="programlisting">enum {LEVEL1 = 1, LEVEL2 = 2, LEVEL3 = 4, LEVEL4 = 8};</p>
<h4 id="app09lev2sec2">Use <code>inline</code> Instead of <code>#define</code> to Define Short Functions</h4>
<p>The traditional C way to create the near-equivalent of an inline function is to use a <code>#define</code> macro definition:</p>
<p class="programlisting">#define Cube(X) X*X*X</p>
<p>This leads the preprocessor to do text substitution, with <code>X</code> being replaced by the corresponding argument to <code>Cube()</code>:</p>
<p class="programlisting">y = Cube(x);&#160;&#160;&#160;&#160;&#160;&#160;// replaced with y = x*x*x;<br/>y = Cube(x + z++);&#160;&#160;// replaced with x + z++*x + z++*x + z++;</p>
<p>Because the preprocessor uses text substitution instead of true passing of arguments, using such macros can lead to unexpected and incorrect results. Such errors can be reduced by using lots of parentheses in the macro to ensure the correct order of operations:</p>
<p class="programlisting">#define Cube(X) ((X)*(X)*(X))</p>
<p>Even this, however, doesn&#8217;t deal with cases such as using values like <code>z++</code>.</p>
<p><a id="page_1330"/>The C++ approach of using the keyword <code>inline</code> to identify inline functions is much more dependable because it uses true argument passing. Furthermore, C++ inline functions can be regular functions or class methods:</p>
<p class="programlisting">class dormant<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int period;<br/>&#160;&#160;&#160;&#160;...<br/>public:<br/>&#160;&#160;&#160;&#160;int Period() const { return period; } // automatically inline<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>One positive feature of the <code>#define</code> macro is that it is typeless, so it can be used with any type for which the operation makes sense. In C++ you can create inline templates to achieve type-independent functions while retaining argument passing.</p>
<p>In short, you should use C++ inlining instead of C <code>#define</code> macros.</p>
<h3 id="app09lev1sec2">Use Function Prototypes</h3>
<p>Actually, you don&#8217;t have a choice: Although prototyping is optional in C, it is mandatory in C++. Note that a function that is defined before its first use, such as an inline function, serves as its own prototype.</p>
<p>You should use <code>const</code> in function prototypes and headers when appropriate. In particular, you should use <code>const</code> with pointer parameters and reference parameters representing data that is not to be altered. Not only does this allow the compiler to catch errors that change data, it also makes a function more general. That is, a function with a <code>const</code> pointer or reference can process both <code>const</code> and non-<code>const</code> data, whereas a function that fails to use <code>const</code> with a pointer or reference can process only non-<code>const</code>.</p>
<h3 id="app09lev1sec3">Use Type Casts</h3>
<p>One of Stroustrup&#8217;s pet peeves about C is its undisciplined type cast operator. True, type casts are often necessary, but the standard type cast is too unrestrictive. For example, consider the following code:</p>
<p class="programlisting">struct Doof<br/>{<br/>&#160;&#160;&#160;&#160;double feeb;<br/>&#160;&#160;&#160;&#160;double steeb;<br/>&#160;&#160;&#160;&#160;char sgif[10];<br/>};<br/>Doof leam;<br/>short * ps = (short *) &#38; leam;&#160;&#160;// old syntax<br/>int * pi = int * (&#38;leam);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// new syntax</p>
<p><a id="page_1331"/>Nothing in the C language prevents you from casting a pointer of one type to a pointer to a totally unrelated type.</p>
<p>In a way, the situation is similar to that of the <code>goto</code> statement. The problem with the <code>goto</code> statement was that it was too flexible, leading to twisted code. The solution was to provide more limited, structured versions of <code>goto</code> to handle the most common tasks for which <code>goto</code> was needed. This was the genesis of language elements such as <code>for</code> and <code>while</code> loops and <code>if else</code> statements. Standard C++ provides a similar solution for the problem of the undisciplined type cast&#8212;namely, restricted type casts to handle the most common situations requiring type casts. The following are the type cast operators discussed in <a href="ch15.html#ch15">Chapter 15</a>, &#8220;<a href="ch15.html#ch15">Friends, Exceptions, and More</a>&#8221;:</p>
<p class="programlisting">dynamic_cast<br/>static_cast<br/>const_cast<br/>reinterpret_cast</p>
<p>So if you are doing a type cast involving pointers, you should use one of these operators if possible. Doing so both documents the intent of the type cast and provides checking that the type cast is being used as intended.</p>
<h3 id="app09lev1sec4">Become Familiar with C++ Features</h3>
<p>If you&#8217;ve been using <code>malloc()</code> and <code>free()</code>, you should switch to using <code>new</code> and <code>delete</code> instead. If you&#8217;ve been using <code>setjmp()</code> and <code>longjmp()</code> for error handling, you should use <code>try</code>, <code>throw</code>, and <code>catch</code> instead. You should try using the <code>bool</code> type for values representing <code>true</code> and <code>false</code>.</p>
<h3 id="app09lev1sec5">Use the New Header Organization</h3>
<p>The C++ Standard specifies new names for the header files, as described in <a href="ch02.html#ch02">Chapter 2</a>, &#8220;<a href="ch02.html#ch02">Setting Out to C++</a>.&#8221; If you&#8217;ve been using the old-style header files, you should change over to using the new-style names. This is not just a cosmetic change because the new versions sometimes add new features. For example, the <code>ostream</code> header file provides support for wide-character input and output. It also provides new manipulators such as <code>boolalpha</code> and <code>fixed</code> (as described in <a href="ch17.html#ch17">Chapter 17</a>, &#8220;<a href="ch17.html#ch17">Input, Output, and Files</a>&#8221;). These offer a simpler interface than using <code>setf()</code> or the <code>iomanip</code> functions for setting many formatting options. If you do use <code>setf()</code>, you should use <code>ios_base</code> instead of <code>ios</code> when specifying constants; that is, you should use <code>ios_base::fixed</code> instead of <code>ios::fixed</code>. Also the new header files incorporate namespaces.</p>
<h3 id="app09lev1sec6">Use Namespaces</h3>
<p>Namespaces help organize identifiers used in a program in order to avoid name conflicts. Because the standard library, as implemented with the new header file organization, <a id="page_1332"/>places names in the <code>std</code> namespace, using these header files requires that you deal with namespaces.</p>
<p>The examples in this book, for simplicity, most often utilize a <code>using</code> directive to make all the names from the <code>std</code> namespace available:</p>
<p class="programlisting">#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a using-directive</p>
<p>However, the wholesale exporting of all the names in a namespace, whether needed or not, runs counter to the goals of namespaces.</p>
<p>Somewhat better is placing a <code>using</code> directive inside a function; this makes the names available just inside that function.</p>
<p>Even better, and the recommended approach, is to use either <code>using</code> declarations or the scope-resolution operator (<code>::</code>) to make available just those names a program needs. For example, the following makes <code>cin</code>, <code>cout</code>, and <code>endl</code> available for the rest of the file:</p>
<p class="programlisting">#include &lt;iostream&gt;<br/>using std::cin;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a using-declaration<br/>using std::cout;<br/>using std::endl;</p>
<p>Using the scope-resolution operator, however, makes a name available just in the expression that uses the operator:</p>
<p class="programlisting">cout &lt;&lt; std::fixed &lt;&lt; x &lt;&lt; endl;&#160;&#160;&#160;&#160;//using the scope resolution operator</p>
<p>This could get wearisome, but you could collect your common <code>using</code> declarations in a header file:</p>
<p class="programlisting">// mynames &#8212; a header file<br/>using std::cin;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a using-declaration<br/>using std::cout;<br/>using std::endl;</p>
<p>Going a step further, you could collect <code>using</code> declarations in namespaces:</p>
<p class="programlisting">// mynames &#8212; a header file<br/>#include &lt;iostream&gt;<br/><br/>namespace io<br/>{<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>}<br/><br/>namespace formats<br/>{<br/><a id="page_1333"/>&#160;&#160;&#160;&#160;using std::fixed;<br/>&#160;&#160;&#160;&#160;using std::scientific;<br/>&#160;&#160;&#160;&#160;using std:boolalpha;<br/>}</p>
<p>Then a program could include this file and use the namespaces it needs:</p>
<p class="programlisting">#include "mynames"<br/>using namespace io;</p>
<h3 id="app09lev1sec7">Use Smart Pointers</h3>
<p>Each use of <code>new</code> should be paired with a use of <code>delete</code>. This can lead to problems if a function in which <code>new</code> is used terminates early via an exception being thrown. As discussed in <a href="ch15.html#ch15">Chapter 15</a>, using an <code>autoptr</code> object to keep track of an object created by <code>new</code> automates the activation of <code>delete</code>. The C++11 additions <code>unique_ptr</code> and <code>shared_ptr</code> provide yet better alternatives.</p>
<h3 id="app09lev1sec8">Use the <code>string</code> Class</h3>
<p>The traditional C-style string suffers from not being a real type. You can store a string in a character array, and you can initialize a character array to a string. But you can&#8217;t use the assignment operator to assign a string to a character array; instead, you must remember to use <code>strcpy()</code> or <code>strncpy()</code>. You can&#8217;t use the relational operators to compare C-style strings; instead, you must remember to use <code>strcmp()</code>. (And if you forget and use, say, the <code>&gt;</code> operator, you don&#8217;t get a syntax error; instead, the program compares string addresses instead of string contents.)</p>
<p>The <code>string</code> class (see <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library,&#8221; and <a href="app06.html#app06">Appendix F</a>, &#8220;The <code>string</code> Template Class&#8221;), on the other hand, lets you use objects to represent strings. Assignment operators, relational operators, and the addition operator (for concatenation) are all defined. Furthermore, the <code>string</code> class provides automatic memory management so that you normally don&#8217;t have to worry about someone entering a string that either overruns an array or gets truncated before being stored.</p>
<p>The <code>string</code> class provides many convenience methods. For example, you can append one <code>string</code> object to another, but you can also append a C-style string or even a <code>char</code> value to a <code>string</code> object. For functions that require a C-style string argument, you can use the <code>c_str()</code> method to return a suitable pointer-to-<code>char</code>.</p>
<p>Not only does the <code>string</code> class provide a well-designed set of methods for handling string-related tasks, such as finding substrings, but it also features a design that is compatible with the Standard Template Library (STL) so that you can use STL algorithms with <code>string</code> objects.</p>
<h3 id="app09lev1sec9">Use the STL</h3>
<p><a id="page_1334"/>The STL (see <a href="ch16.html#ch16">Chapter 16</a> and <a href="app07.html#app07">Appendix G</a>, &#8220;The STL methods and Functions&#8221;) provides ready-made solutions to many programming needs, so you should use it. For example, instead of declaring an array of <code>double</code> or of <code>string</code> objects, you can create a <code>vector&lt;double&gt;</code> object or a <code>vector&lt;string&gt;</code> object. The advantages are similar to those of using <code>string</code> objects instead of C-style strings. Assignment is defined, so you can use the assignment operator to assign one <code>vector</code> object to another. You can pass a <code>vector</code> object by reference, and a function receiving such an object can use the <code>size()</code> method to determine the number of elements in the <code>vector</code> object. Built-in memory management allows for automatic resizing when you use the <code>pushback()</code> method to add elements to a <code>vector</code> object. And of course, several useful class methods and general algorithms are at your service. Or with C++11, if a fixed-size array is a better fit, use <code>array&lt;double&gt;</code> or <code>array&lt;string&gt;</code>.</p>
<p>If you need a list, a double-ended queue (or deque), a stack, a regular queue, a set, or a map, you should use the STL, which provides useful container templates. The algorithm library is designed so that you can easily copy the contents of a vector to a list or compare the contents of a set to a vector. This design makes the STL a toolkit that provides basic units that you can assemble as needed.</p>
<p>The extensive algorithm library was designed with efficiency as one of the main design goals, so you can get top-flight results with relatively little programming effort on your part. And the iterator concept used to implement the algorithms means that the algorithms aren&#8217;t limited to being used with STL containers. In particular, they can be applied to traditional arrays, too.</p>
</body>
</html>
