<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>14. Reusing Code in C++</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch14">14. Reusing Code in C++</h2>
<p><a id="page_785"/>In this chapter you&#8217;ll learn about the following:</p>
<p class="indenthandingB">&#8226; <em>Has-a</em> relationships</p>
<p class="indenthandingB">&#8226; Classes with member objects (containment)</p>
<p class="indenthandingB">&#8226; The <code>valarray</code> template class</p>
<p class="indenthandingB">&#8226; Private and protected inheritance</p>
<p class="indenthandingB">&#8226; Multiple inheritance</p>
<p class="indenthandingB">&#8226; Virtual base classes</p>
<p class="indenthandingB">&#8226; Creating class templates</p>
<p class="indenthandingB">&#8226; Using class templates</p>
<p class="indenthandingB">&#8226; Template specializations</p>
<p>One of the main goals of C++ is to facilitate the reuse of code. Public inheritance is one mechanism for achieving this goal, but it&#8217;s not the only one. This chapter investigates other choices. One technique is to use class members that are themselves objects of another class. This is referred to as <em>containment</em> or <em>composition</em> or <em>layering</em>. Another option is to use private or protected inheritance. Containment, private inheritance, and protected inheritance are typically used to implement <em>has-a</em> relationships&#8212;that is, relationships for which the new class has an object of another class. For example, a <code>HomeTheater</code> class might have a <code>BluRayPlayer</code> object. Multiple inheritance lets you create classes that inherit from two or more base classes, combining their functionality.</p>
<p><a href="ch10.html#ch10">Chapter 10</a>, &#8220;<a href="ch10.html#ch10">Objects and Classes</a>,&#8221; introduces function templates. In this chapter we&#8217;ll look at class templates, which provide another way of reusing code. A class template lets you define a class in generic terms. Then you can use the template to create specific classes defined for specific types. For example, you could define a general stack template and then use the template to create one class that represents a stack of <code>int</code> values and another class that represents a stack of <code>double</code> values. You could even generate a class that represents a stack of stacks.</p>
<h3 id="ch14lev1sec1">Classes with Object Members</h3>
<p><a id="page_786"/>Let&#8217;s begin with classes that include class objects as members. Some classes, such as the <code>string</code> class or the standard C++ class templates discussed in <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library,&#8221; offer convenient ways of representing components of a more extensive class. Let&#8217;s look at a particular example now.</p>
<p>What is a student? Someone enrolled in a school? Someone engaged in thoughtful investigation? A refugee from the harsh exigencies of the real world? Someone with an identifying name and a set of quiz scores? Clearly, the last definition is a totally inadequate characterization of a person, but it is well suited for a simple computer representation. So let&#8217;s develop a <code>Student</code> class based on that definition.</p>
<p>Simplifying a student to a name and a set of quiz scores suggests using a class with two members: one to represent the name and one to represent the scores. For the name, you could use a character array, but that puts a size limitation on the name. Or you could use a <code>char</code> pointer and dynamic memory allocation. However, as <a href="ch12.html#ch12">Chapter 12</a>, &#8220;<a href="ch12.html#ch12">Classes and Dynamic Memory Allocation</a>,&#8221; illustrates, that requires a lot of supporting code. Better yet, you could use an object of a class for which someone has already done all the work. For example, you could use an object of the <code>String</code> class (see <a href="ch12.html#ch12">Chapter 12</a>) or of the standard C++ <code>string</code> class. The simpler choice is the <code>string</code> class because the C++ library already provides all the implementation code as well as a superior implementation. (To use the <code>String</code> class, you&#8217;d have to make the <code>string1.cpp</code> implementation file part of your project.)</p>
<p>Representing the quiz scores presents similar choices. You could use a fixed-size array, which places a size limitation. You could use dynamic memory allocation and provide a large body of supporting code. You could use your own design of a class, using dynamic memory allocation to represent an array. You could look for a standard C++ library class that is capable of representing the data.</p>
<p>Developing your own class is not out of the question. A simple version wouldn&#8217;t be that difficult because an array of <code>double</code> shares many similarities with an array of <code>char</code>, so you could base the design of an array-of-<code>double</code> class on the <code>String</code> class design. And in fact, that is what earlier editions of this book do.</p>
<p>But, of course, it is even easier if the library already provides a suitable class, and it does: the <code>valarray</code> class.</p>
<h4 id="ch14lev2sec1">The <code>valarray</code> Class: A Quick Look</h4>
<p>The <code>valarray</code> class is supported by the <code>valarray</code> header file. As its name suggests, the class is targeted to deal with numeric values (or with classes with similar properties), so it supports operations such as summing the contents and finding the largest and smallest values in an array. So that it can handle different data types, <code>valarray</code> is defined as a template class. Later, this chapter goes into how to define template classes, but all you need to know now is how to use one.</p>
<p><a id="page_787"/>The template aspect means that you have to provide a specific type when declaring an object. To do so when declaring an object, you follow the identifier <code>valarray</code> with angle brackets that contain the desired type:</p>
<p class="programlisting">valarray&lt;int&gt; q_values;&#160;&#160;&#160;&#160;&#160;// an array of int<br/>valarray&lt;double&gt; weights;&#160;&#160;&#160;// an array of double</p>
<p>You&#8217;ve seen this syntax before in <a href="ch04.html#ch04">Chapter 4</a>, &#8220;<a href="ch04.html#ch04">Compound Types</a>,&#8221; with the <code>vector</code> and <code>array</code> classes, and it&#8217;s pretty easy. (Those template classes also can hold numbers, but they don&#8217;t provide all the arithmetic support the <code>valarray</code> class does.)</p>
<p>The class aspect means that to use <code>valarray</code> objects, you need to know something about class constructors and other class methods. Here are several examples that use some of the constructors:</p>
<p class="programlisting">double gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};<br/>valarray&lt;double&gt; v1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// an array of double, size 0<br/>valarray&lt;int&gt; v2(8);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// an array of 8 int elements<br/>valarray&lt;int&gt; v3(10,8);&#160;&#160;&#160;&#160;&#160;&#160;// an array of 8 int elements,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// each set to 10<br/>valarray&lt;double&gt; v4(gpa, 4); // an array of 4 elements<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// initialized to the first 4 elements of gpa</p>
<p>As you can see, you can create an empty array of zero size, an empty array of a given size, an array with all elements initialized to the same value, and an array initialized using the values from an ordinary array. With C++11, you also can use an initializer list:</p>
<p class="programlisting">valarray&lt;int&gt; v5 = {20, 32, 17, 9};&#160;&#160;// C++11</p>
<p>Next, here are a few of the methods:</p>
<p class="indenthandingB">&#8226; The <code>operator[]()</code> method provides access to individual elements.</p>
<p class="indenthandingB">&#8226; The <code>size()</code> method returns the number of elements.</p>
<p class="indenthandingB">&#8226; The <code>sum()</code> method returns the sum of the elements.</p>
<p class="indenthandingB">&#8226; The <code>max()</code> method returns the largest element.</p>
<p class="indenthandingB">&#8226; The <code>min()</code> method returns the smallest element.</p>
<p>There are many more methods, some of which are presented in <a href="ch16.html#ch16">Chapter 16</a>, but you&#8217;ve already seen more than enough to proceed with this example.</p>
<h4 id="ch14lev2sec2">The <code>Student</code> Class Design</h4>
<p>At this point, the design plan for the <code>Student</code> class is to use a <code>string</code> object to represent the name and a <code>valarray&lt;double&gt;</code> object to represent the quiz scores. How should this be done? You might be tempted to publicly derive a <code>Student</code> class from these two classes. That would be an example of multiple public inheritance, which C++ allows, but it would be inappropriate here. The reason is that the relationship of a student to these classes doesn&#8217;t fit the <em>is-a</em> model. A student is not a name. A student is not an array of quiz <a id="page_788"/>scores. What you have here is a <em>has-a</em> relationship. A student has a name, and a student has an array of quiz scores. The usual C++ technique for modeling <em>has-a</em> relationships is to use composition or containment&#8212;that is, to create a class composed of, or containing, members that are objects of another class. For example, you can begin a <code>Student</code> class declaration like this:</p>
<p class="programlisting">class Student<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;string name;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use a string object for name<br/>&#160;&#160;&#160;&#160;valarray&lt;double&gt; scores;&#160;&#160;// use a valarray&lt;double&gt; object for scores<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>As usual, the class makes the data members private. This implies that the <code>Student</code> class member functions can use the public interfaces of the <code>string</code> and <code>valarray&lt;double&gt;</code> classes to access and modify the <code>name</code> and <code>scores</code> objects, but the outside world cannot do so. The only access the outside world will have to <code>name</code> and <code>scores</code> is through the public interface defined for the <code>Student</code> class (see <a href="#ch14fig01">Figure 14.1</a>). A common way of describing this is to say that the <code>Student</code> class acquires the implementation of its member objects but doesn&#8217;t inherit the interface. For example, a <code>Student</code> object uses the <code>string</code> implementation rather than a <code>char * name</code> or a <code>char name[26]</code> implementation for holding the name. But a <code>Student</code> object does not innately have the ability to use the <code>string operator+=()</code> function for appending.</p>
<p class="caption"><a id="ch14fig01"/><strong>Figure 14.1. Objects within objects: containment.</strong></p>
<p class="image"><img src="graphics/14fig01.jpg" alt="Image"/></p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14sb01"/>Interfaces and Implementations</p>
<p class="sidebarpara">With public inheritance, a class inherits an interface, and, perhaps, an implementation. (Pure virtual functions in a base class can provide an interface without an implementation.) Acquiring the interface is part of the <em>is-a</em> relationship. With composition, on the other hand, a class acquires the implementation without the interface. Not inheriting the interface is part of the <em>has-a</em> relationship.</p>
<hr/></div>
<p>The fact that a class object doesn&#8217;t automatically acquire the interface of a contained object is a good thing for a <em>has-a</em> relationship. For example, <code>string</code> overloads the <code>+</code> operator to allow concatenating two strings, but, conceptually, it doesn&#8217;t make sense to concatenate two <code>Student</code> objects. That&#8217;s one reason not to use public inheritance in this case. On the other hand, parts of the interface for the contained class may make sense for the new class. For example, you might want to use the <code>operator&lt;()</code> method from the <code>string</code> interface to sort <code>Student</code> objects by name. You can do so by defining a <code>Student::operator&lt;()</code> member function that internally uses the <code>string::operator&lt;()</code> function. Let&#8217;s move on to some details.</p>
<h4 id="ch14lev2sec3">The <code>Student</code> Class Example</h4>
<p><a id="page_789"/>At this point you need to provide the <code>Student</code> class declaration. It should, of course, include constructors and at least a few functions to provide an interface for the <code>Student</code> class. <a href="#ch14ex01">Listing 14.1</a> does this, defining all the constructors inline. It also supplies some friends for input and output.</p>
<p class="caption1"><a id="ch14ex01"/><strong>Listing 14.1. <code>studentc.h</code></strong></p><hr/>
<p class="programlisting1">// studentc.h -- defining a Student class using containment<br/>#ifndef STUDENTC_H_<br/>#define STUDENTC_H_<br/><br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;valarray&gt;<br/>class Student<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;typedef std::valarray&lt;double&gt; ArrayDb;<br/>&#160;&#160;&#160;&#160;std::string name;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// contained object<br/>&#160;&#160;&#160;&#160;ArrayDb scores;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// contained object<br/>&#160;&#160;&#160;&#160;// private method for scores output<br/>&#160;&#160;&#160;&#160;std::ostream &#38; arr_out(std::ostream &#38; os) const;<br/>public:<br/>&#160;&#160;&#160;&#160;Student() : name("Null Student"), scores() {}<br/>&#160;&#160;&#160;&#160;explicit Student(const std::string &#38; s)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: name(s), scores() {}<br/>&#160;&#160;&#160;&#160;explicit Student(int n) : name("Nully"), scores(n) {}<br/>&#160;&#160;&#160;&#160;Student(const std::string &#38; s, int n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: name(s), scores(n) {}<br/>&#160;&#160;&#160;&#160;Student(const std::string &#38; s, const ArrayDb &#38; a)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: name(s), scores(a) {}<br/>&#160;&#160;&#160;&#160;Student(const char * str, const double * pd, int n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: name(str), scores(pd, n) {}<br/>&#160;&#160;&#160;&#160;~Student() {}<br/>&#160;&#160;&#160;&#160;double Average() const;<br/>&#160;&#160;&#160;&#160;const std::string &#38; Name() const;<br/>&#160;&#160;&#160;&#160;double &#38; operator[](int i);<br/>&#160;&#160;&#160;&#160;double operator[](int i) const;<br/>// friends<br/>&#160;&#160;&#160;&#160;// input<br/>&#160;&#160;&#160;&#160;friend std::istream &#38; operator&gt;&gt;(std::istream &#38; is,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Student &#38; stu);&#160;&#160;// 1 word<br/>&#160;&#160;&#160;&#160;friend std::istream &#38; getline(std::istream &#38; is,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Student &#38; stu);&#160;&#160;&#160;&#160;&#160;// 1 line<br/>&#160;&#160;&#160;&#160;// output<br/>&#160;&#160;&#160;&#160;friend std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const Student &#38; stu);<br/>};<br/><br/>#endif</p><hr/>
<p><a id="page_790"/>In order to simplify notation, the <code>Student</code> class contains this <code>typedef</code>:</p>
<p class="programlisting">typedef std::valarray&lt;double&gt; ArrayDb;</p>
<p>This enables the remaining code to use the more convenient notation <code>ArrayDb</code> instead of <code>std::valarray&lt;double&gt;</code>. Thus, methods and friends can refer to the <code>ArrayDb</code> type. Placing this <code>typedef</code> in the private portion of the class definition means that it can be used internally in the <code>Student</code> implementation but not by outside users of the <code>Student</code> class.</p>
<p>Note the use of the keyword <code>explicit</code>:</p>
<p class="programlisting">explicit Student(const std::string &#38; s)<br/>&#160;&#160;&#160;&#160;: name(s), scores() {}<br/>explicit Student(int n) : name("Nully"), scores(n) {}</p>
<p>Recall that a constructor that can be called with one argument serves as an implicit conversion function from the argument type to the class type. This often is not a good idea. In the second constructor, for instance, the first argument represents the number of elements in an array rather than a value for the array, so having the constructor serve as an <a id="page_791"/><code>int</code>-to-<code>Student</code> conversion function does not make sense. Using <code>explicit</code> turns off implicit conversions. If this keyword were omitted, code like the following would be possible:</p>
<p class="programlisting">Student doh("Homer", 10);&#160;&#160;// store "Homer", create array of 10 elements<br/>doh = 5;&#160;&#160;&#160;// reset name to "Nully", reset to empty array of 5 elements</p>
<p>Here, the inattentive programmer typed <code>doh</code> instead of <code>doh[0]</code>. If the constructor omitted <code>explicit</code>, <code>5</code> would be converted to a temporary <code>Student</code> object, using the constructor call <code>Student(5)</code>, with the value of <code>"Nully"</code> being used to set the <code>name</code> member. Then assignment would replace the original <code>doh</code> with the temporary object. With <code>explicit</code> in place, the compiler will catch the assignment operator as an error.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14sb02"/>C++ and Constraints</p>
<p class="sidebarpara">C++ is full of features that allow programmers to constrain programmatic constructs to certain limits&#8212;<code>explicit</code> to remove the implicit conversion of single-argument constructors, <code>const</code> to constrain the use of methods to modify data, and more. The underlying motive is simply this: Compile-time errors are better than runtime errors.</p>
<hr/></div>
<h5 id="ch14lev3sec1">Initializing Contained Objects</h5>
<p>Note that constructors all use the by-now-familiar member initializer list syntax to initialize the <code>name</code> and <code>scores</code> member objects. In some cases earlier in this book, such as the following, the constructors use it to initialize members that are built-in types:</p>
<p class="programlisting">Queue::Queue(int qs) : qsize(qs)&#160;&#160;{...} // initialize qsize to qs</p>
<p>This code uses the name of the data member (<code>qsize</code>) in a member initializer list. Also constructors from previous examples, such as the following, use a member initializer list to initialize the base-class portion of a derived object:</p>
<p class="programlisting">hasDMA::hasDMA(const hasDMA &#38; hs) : baseDMA(hs) {...}</p>
<p>For <em>inherited</em> objects, constructors use the <em>class</em> name in the member initializer list to invoke a specific base-class constructor. For <em>member</em> objects, constructors use the <em>member</em> name. For example, look at the last constructor in <a href="#ch14ex01">Listing 14.1</a>:</p>
<p class="programlisting">Student(const char * str, const double * pd, int n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;: name(str), scores(pd, n) {}</p>
<p>Because it initializes member objects, not inherited objects, this constructor uses the member names, not the class names, in the initialization list. Each item in this initialization list invokes the matching constructor. That is, <code>name(str)</code> invokes the <code>string(const char *)</code> constructor, and <code>scores(pd, n)</code> invokes the <code>ArrayDb(const double *, int)</code> constructor, which, because of the <code>typedef</code>, really is the <code>valarray&lt;double&gt;(const double *, int)</code> constructor.</p>
<p>What happens if you don&#8217;t use the initialization list syntax? As with inherited components, C++ requires that all member objects be constructed before the rest of an object is constructed. So if you omit the initialization list, C++ uses the default constructors defined for the member objects&#8217; classes.</p>
<div class="sidebar"><hr/>
<p class="title"><a id="ch14sb03"/><a id="page_792"/>Initialization Order</p>
<p class="sidebarpara">When you have a member initializer list that initializes more than one item, the items are initialized in the order in which they were declared, not in the order in which they appear in the initializer list. For example, suppose you write a <code>Student</code> constructor this way:</p>
<p class="programlistingB">Student(const char * str, const double * pd, int n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;: scores(pd, n),&#160;&#160;name(str) {}</p>
<p class="sidebarpara">The <code>name</code> member would still be initialized first because it is declared first in the class definition. The exact initialization order is not important for this example, but it would be important if the code used the value of one member as part of the initialization expression for a second member.</p>
<hr/></div>
<h5 id="ch14lev3sec2">Using an Interface for a Contained Object</h5>
<p>The interface for a contained object isn&#8217;t public, but it can be used within the class methods. For example, here is how you can define a function that returns the average of a student&#8217;s scores:</p>
<p class="programlisting">double Student::Average() const<br/>{<br/>&#160;&#160;&#160;&#160;if (scores.size() &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return scores.sum()/scores.size();<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p>This defines a method that can be invoked by a <code>Student</code> object. Internally, it uses the valarray <code>size()</code> and <code>sum()</code> methods. That&#8217;s because <code>scores</code> is a <code>valarray</code> object, so it can invoke the member functions of the <code>valarray</code> class. In short, the <code>Student</code> object invokes a <code>Student</code> method, and the <code>Student</code> method uses the contained <code>valarray</code> object to invoke <code>valarray</code> methods.</p>
<p>Similarly, you can define a friend function that uses the <code>string</code> version of the <code>&lt;&lt;</code> operator:</p>
<p class="programlisting">// use string version of operator&lt;&lt;()<br/>ostream &#38; operator&lt;&lt;(ostream &#38; os, const Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Scores for " &lt;&lt; stu.name &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;...<br/>}</p>
<p>Because <code>stu.name</code> is a <code>string</code> object, it invokes the <code>operator&lt;&lt;(ostream &#38;, const string &#38;)</code> function, which is provided as part of the <code>string</code> class package. Note that the <code>operator&lt;&lt;(ostream &#38; os, const Student &#38; stu)</code> function has to be a friend to the <code>Student</code> class so that it can access the <code>name</code> member. (Alternatively, the function could use the public <code>Name()</code> method instead of the private <code>name</code> data member.)</p>
<p><a id="page_793"/>Similarly, the function could use the <code>valarray</code> implementation of <code>&lt;&lt;</code> for output; unfortunately, there is none. Therefore, the class defines a private helper method to handle this task:</p>
<p class="programlisting">// private method<br/>ostream &#38; Student::arr_out(ostream &#38; os) const<br/>{<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;int lim = scores.size();<br/>&#160;&#160;&#160;&#160;if (lim &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 0; i &lt; lim; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; scores[i] &lt;&lt; " ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % 5 == 4)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % 5 != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; " empty array ";<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p>Using a helper like this gathers the messy details together in one place and makes the coding of the friend function neater:</p>
<p class="programlisting">// use string version of operator&lt;&lt;()<br/>ostream &#38; operator&lt;&lt;(ostream &#38; os, const Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Scores for " &lt;&lt; stu.name &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;stu.arr_out(os);&#160;&#160;// use private method for scores<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p>The helper function could also act as a building block for other user-level output functions, should you choose to provide them.</p>
<p><a href="#ch14ex02">Listing 14.2</a> shows the class methods file for the <code>Student</code> class. It includes methods that allow you to use the <code>[]</code> operator to access individual scores in a <code>Student</code> object.</p>
<p class="caption1"><a id="ch14ex02"/><strong>Listing 14.2. <code>studentc.cpp</code></strong></p><hr/>
<p class="programlisting1">// studentc.cpp -- Student class using containment<br/>#include "studentc.h"<br/>using std::ostream;<br/>using std::endl;<br/>using std::istream;<br/>using std::string;<br/><br/><a id="page_794"/>//public methods<br/>double Student::Average() const<br/>{<br/>&#160;&#160;&#160;&#160;if (scores.size() &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return scores.sum()/scores.size();<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>const string &#38; Student::Name() const<br/>{<br/>&#160;&#160;&#160;&#160;return name;<br/>}<br/><br/>double &#38; Student::operator[](int i)<br/>{<br/>&#160;&#160;&#160;&#160;return scores[i];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use valarray&lt;double&gt;::operator[]()<br/>}<br/><br/>double Student::operator[](int i) const<br/>{<br/>&#160;&#160;&#160;&#160;return scores[i];<br/>}<br/><br/>// private method<br/>ostream &#38; Student::arr_out(ostream &#38; os) const<br/>{<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;int lim = scores.size();<br/>&#160;&#160;&#160;&#160;if (lim &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 0; i &lt; lim; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; scores[i] &lt;&lt; " ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % 5 == 4)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % 5 != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; " empty array ";<br/>&#160;&#160;&#160;&#160;return os;<br/>}<br/><br/>// friends<br/><br/>// use string version of operator&gt;&gt;()<br/>istream &#38; operator&gt;&gt;(istream &#38; is, Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;is &gt;&gt; stu.name;<br/>&#160;&#160;&#160;&#160;return is;<br/>}<br/><br/>// use string friend getline(ostream &#38;, const string &#38;)<br/>istream &#38; getline(istream &#38; is, Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;getline(is, stu.name);<br/>&#160;&#160;&#160;&#160;return is;<br/>}<br/><br/>// use string version of operator&lt;&lt;()<br/>ostream &#38; operator&lt;&lt;(ostream &#38; os, const Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Scores for " &lt;&lt; stu.name &lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;stu.arr_out(os);&#160;&#160;// use private method for scores<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p><hr/>
<p><a id="page_795"/>Aside from the private helper method, <a href="#ch14ex02">Listing 14.2</a> doesn&#8217;t require much new code. Using containment allows you to take advantage of the code you or someone else has already written.</p>
<h5 id="ch14lev3sec3">Using the New <code>Student</code> Class</h5>
<p>Let&#8217;s put together a small program to test the new <code>Student</code> class. To keep things simple, it should use an array of just three <code>Student</code> objects, each holding five quiz scores. And it should use an unsophisticated input cycle that doesn&#8217;t verify input and that doesn&#8217;t let you cut the input process short. <a href="#ch14ex03">Listing 14.3</a> presents the test program. Be sure to compile it along with <code>studentc.cpp</code>.</p>
<p class="caption1"><a id="ch14ex03"/><strong>Listing 14.3. <code>use_stuc.cpp</code></strong></p><hr/>
<p class="programlisting1">// use_stuc.cpp -- using a composite class<br/>// compile with studentc.cpp<br/>#include &lt;iostream&gt;<br/>#include "studentc.h"<br/>using std::cin;<br/>using std::cout;<br/>using std::endl;<br/><br/>void set(Student &#38; sa, int n);<br/><br/>const int pupils = 3;<br/>const int quizzes = 5;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Student ada[pupils] =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{Student(quizzes), Student(quizzes), Student(quizzes)};<br/><br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; pupils; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set(ada[i], quizzes);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nStudent List:\n";<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; pupils; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ada[i].Name() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nResults:";<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; pupils; ++i)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; ada[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "average: " &lt;&lt; ada[i].Average() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void set(Student &#38; sa, int n)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter the student's name: ";<br/>&#160;&#160;&#160;&#160;getline(cin, sa);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter " &lt;&lt; n &lt;&lt; " quiz scores:\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; sa[i];<br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>}</p><hr/>
<p><a id="page_796"/>Here is a sample run of the program in <a href="#ch14ex01">Listings 14.1</a>, <a href="#ch14ex02">14.2</a>, and <a href="#ch14ex03">14.3</a>:</p>
<p class="programlisting">Please enter the student's name: <span class="EmpStrong">Gil Bayts</span><br/>Please enter 5 quiz scores:<br/><span class="EmpStrong">92 94 96 93 95</span><br/>Please enter the student's name: <span class="EmpStrong">Pat Roone</span><br/>Please enter 5 quiz scores:<br/><span class="EmpStrong">83 89 72 78 95</span><br/>Please enter the student's name: <span class="EmpStrong">Fleur O'Day</span><br/>Please enter 5 quiz scores:<br/><span class="EmpStrong">92 89 96 74 64</span><br/><br/><a id="page_797"/>Student List:<br/>Gil Bayts<br/>Pat Roone<br/>Fleur O'Day<br/><br/>Results:<br/>Scores for Gil Bayts:<br/>92 94 96 93 95<br/>average: 94<br/><br/>Scores for Pat Roone:<br/>83 89 72 78 95<br/>average: 83.4<br/><br/>Scores for Fleur O'Day:<br/>92 89 96 74 64<br/>average: 83<br/>Done.</p>
<h3 id="ch14lev1sec2">Private Inheritance</h3>
<p>C++ has a second means of implementing the <em>has-a</em> relationship: private inheritance. With <em>private inheritance</em>, public and protected members of the base class become private members of the derived class. This means the methods of the base class do not become part of the public interface of the derived object. They can be used, however, inside the member functions of the derived class.</p>
<p>Let&#8217;s look at the interface topic more closely. With public inheritance, the public methods of the base class become public methods of the derived class. In short, the derived class inherits the base-class interface. This is part of the <em>is-a</em> relationship. With private inheritance, the public methods of the base class become private methods of the derived class. In short, the derived class does not inherit the base-class interface. As you saw with contained objects, this lack of inheritance is part of the <em>has-</em>a relationship.</p>
<p>With private inheritance, a class does inherit the implementation. For example, if you base a <code>Student</code> class on a <code>string</code> class, the <code>Student</code> class winds up with an inherited <code>string</code> class component that can be used to store a string. Furthermore, the <code>Student</code> methods can use the <code>string</code> methods internally to access the <code>string</code> component.</p>
<p>Containment adds an object to a class as a named member object, whereas private inheritance adds an object to a class as an unnamed inherited object. This book uses the term <em>subobject</em> to denote an object added by inheritance or by containment.</p>
<p>Private inheritance, then, provides the same features as containment: Acquire the implementation, don&#8217;t acquire the interface. Therefore it, too, can be used to implement a <em>has-a</em> relationship. In fact, you can produce a <code>Student</code> class that uses private inheritance and has the same public interface as the containment version. Thus the differences between the two approaches affect the implementation, not the interface. Let&#8217;s see how you can use private inheritance to redesign the <code>Student</code> class.</p>
<h4 id="ch14lev2sec4">A New Version of the <code>Student</code> Class Example</h4>
<p><a id="page_798"/>To get private inheritance, use the keyword <code>private</code> instead of <code>public</code> when defining the class. (Actually, <code>private</code> is the default, so omitting an access qualifier also leads to private inheritance.) The <code>Student</code> class should inherit from two classes, so the declaration should list both:</p>
<p class="programlisting">class Student : private std::string, private std::valarray&lt;double&gt;<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>Having more than one base class is called <em>multiple inheritance</em> (MI). In general, MI, particularly public MI, can lead to problems that have to be resolved with additional syntax rules. We&#8217;ll talk about such matters later in this chapter. But in this particular case, MI causes no problems.</p>
<p>Note that the new class doesn&#8217;t need private data. That&#8217;s because the two inherited base classes already provide all the needed data members. The containment version of this example provides two explicitly named objects as members. Private inheritance, however, provides two nameless subobjects as inherited members. This is the first of the main differences in the two approaches.</p>
<h5 id="ch14lev3sec4">Initializing Base-Class Components</h5>
<p>Having implicitly inherited components instead of member objects affects the coding of this example because you can no longer use <code>name</code> and <code>scores</code> to describe the objects. Instead, you have to go back to the techniques you used for public inheritance. For example, consider constructors. Containment uses this constructor:</p>
<p class="programlisting">Student(const char * str, const double * pd, int n)<br/>&#160;&#160;&#160;: name(str), scores(pd, n) {}&#160;&#160;&#160;&#160;&#160;&#160;// use object names for containment</p>
<p>The new version should use the member initializer list syntax for inherited classes, which uses the <em>class</em> name instead of a <em>member</em> name to identify a constructor:</p>
<p class="programlisting">Student(const char * str, const double * pd, int n)<br/>&#160;&#160;&#160;: std::string(str), ArrayDb(pd, n) {}&#160;&#160;// use class names for inheritance</p>
<p>Here, as in the preceding example, <code>ArrayDb</code> is a <code>typedef</code> for <code>std::valarray&lt;double&gt;</code>. Be sure to note that the member initializer list uses terms such as <code>std::string(str)</code> instead of <code>name(str)</code>. This is the second main difference in the two approaches</p>
<p><a href="#ch14ex04">Listing 14.4</a> shows the new class declaration. The only changes are the omission of explicit object names and the use of class names instead of member names in the inline constructors.</p>
<p class="caption1"><a id="page_799"/><a id="ch14ex04"/><strong>Listing 14.4. <code>studenti.h</code></strong></p><hr/>
<p class="programlisting1">// studenti.h -- defining a Student class using private inheritance<br/>#ifndef STUDENTC_H_<br/>#define STUDENTC_H_<br/><br/>#include &lt;iostream&gt;<br/>#include &lt;valarray&gt;<br/>#include &lt;string&gt;<br/>class Student : private std::string, private std::valarray&lt;double&gt;<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;typedef std::valarray&lt;double&gt; ArrayDb;<br/>&#160;&#160;&#160;&#160;// private method for scores output<br/>&#160;&#160;&#160;&#160;std::ostream &#38; arr_out(std::ostream &#38; os) const;<br/>public:<br/>&#160;&#160;&#160;&#160;Student() : std::string("Null Student"), ArrayDb() {}<br/>&#160;&#160;&#160;&#160;explicit Student(const std::string &#38; s)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: std::string(s), ArrayDb() {}<br/>&#160;&#160;&#160;&#160;explicit Student(int n) : std::string("Nully"), ArrayDb(n) {}<br/>&#160;&#160;&#160;&#160;Student(const std::string &#38; s, int n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: std::string(s), ArrayDb(n) {}<br/>&#160;&#160;&#160;&#160;Student(const std::string &#38; s, const ArrayDb &#38; a)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: std::string(s), ArrayDb(a) {}<br/>&#160;&#160;&#160;&#160;Student(const char * str, const double * pd, int n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: std::string(str), ArrayDb(pd, n) {}<br/>&#160;&#160;&#160;&#160;~Student() {}<br/>&#160;&#160;&#160;&#160;double Average() const;<br/>&#160;&#160;&#160;&#160;double &#38; operator[](int i);<br/>&#160;&#160;&#160;&#160;double operator[](int i) const;<br/>&#160;&#160;&#160;&#160;const std::string &#38; Name() const;<br/>// friends<br/>&#160;&#160;&#160;&#160;// input<br/>&#160;&#160;&#160;&#160;friend std::istream &#38; operator&gt;&gt;(std::istream &#38; is,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Student &#38; stu);&#160;&#160;// 1 word<br/>&#160;&#160;&#160;&#160;friend std::istream &#38; getline(std::istream &#38; is,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Student &#38; stu);&#160;&#160;&#160;&#160;&#160;// 1 line<br/>&#160;&#160;&#160;&#160;// output<br/>&#160;&#160;&#160;&#160;friend std::ostream &#38; operator&lt;&lt;(std::ostream &#38; os,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const Student &#38; stu);<br/>};<br/><br/>#endif</p><hr/>
<h5 id="ch14lev3sec5">Accessing Base-Class Methods</h5>
<p><a id="page_800"/>Private inheritance limits the use of base-class methods to within derived-class methods. Sometimes, however, you might like to make a base-class facility available publicly. For example, the <code>Student</code> class declaration suggests the ability to use an <code>Average()</code> function. As with containment, the technique for doing this is to use the <code>valarray size()</code> and <code>sum()</code> methods within a public <code>Student::average()</code> function (see <a href="#ch14fig02">Figure 14.2</a>). Containment invoked the methods with an object:</p>
<p class="programlisting">double Student::Average() const<br/>{<br/>&#160;&#160;&#160;&#160;if (scores.size() &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return scores.sum()/scores.size();<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="caption"><a id="ch14fig02"/><strong>Figure 14.2. Objects within objects: private inheritance.</strong></p>
<p class="image"><img src="graphics/14fig02.jpg" alt="Image"/></p>
<p>Here, however, inheritance lets you use the class name and the scope-resolution operator to invoke base-class methods:</p>
<p class="programlisting">double Student::Average() const<br/>{<br/>&#160;&#160;&#160;&#160;if (ArrayDb::size() &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ArrayDb::sum()/ArrayDb::size();<br/><a id="page_801"/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p>In short, the containment approach uses object names to invoke a method, whereas private inheritance uses the class name and the scope-resolution operator instead.</p>
<h5 id="ch14lev3sec6">Accessing Base-Class Objects</h5>
<p>The scope-resolution operator allows you access to a base-class method, but what if you need the base-class object itself? For example, the containment version of the <code>Student</code> class implements the <code>Name()</code> method by having the method return the <code>name</code> member <code>string</code> object. But with private inheritance, the <code>string</code> object has no name. How, then, can <code>Student</code> code access the inner <code>string</code> object?</p>
<p>The answer is to use a type cast. Because <code>Student</code> is derived from <code>string</code>, it&#8217;s possible to type cast a <code>Student</code> object to a <code>string</code> object; the result is the inherited <code>string</code> object. Recall that the <code>this</code> pointer points to the invoking object, so <code>*this</code> is the invoking object&#8212;in this case, a type <code>Student</code> object. To avoid invoking constructors to create new objects, you use the type cast to create a reference:</p>
<p class="programlisting">const string &#38; Student::Name() const<br/>{<br/>&#160;&#160;&#160;&#160;return (const string &#38;) *this;<br/>}</p>
<p>This code returns a reference to the inherited <code>string</code> object residing in the invoking <code>Student</code> object.</p>
<h5 id="ch14lev3sec7">Accessing Base-Class Friends</h5>
<p>The technique of explicitly qualifying a function name with its class name doesn&#8217;t work for friend functions because a friend function doesn&#8217;t belong to a class. However, you can use an explicit type cast to the base class to invoke the correct functions. This is basically the same technique used to access a base-class object in a class method, but with friends you have a name for the <code>Student</code> object, so the code uses the name instead of <code>*this</code>. For example, consider the following friend function definition:</p>
<p class="programlisting">ostream &#38; operator&lt;&lt;(ostream &#38; os, const Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; "Scores for " &lt;&lt; (const String &#38;) stu &lt;&lt; ":\n";<br/>...<br/><br/>}</p>
<p>If <code>plato</code> is a <code>Student</code> object, then the following statement invokes that function, with <code>stu</code> being a reference to <code>plato</code> and <code>os</code> being a reference to <code>cout</code>:</p>
<p class="programlisting">cout &lt;&lt; plato;</p>
<p><a id="page_802"/>Consider the following line of code:</p>
<p class="programlisting">os &lt;&lt; "Scores for " &lt;&lt; (const String &#38;) stu &lt;&lt; ":\n";</p>
<p>The typecast explicitly converts <code>stu</code> to a reference to a type <code>string</code> object; that type, in turn, invokes the <code>operator&lt;&lt;(ostream &#38;, const String &#38;)</code> function.</p>
<p>The reference <code>stu</code> doesn&#8217;t get converted automatically to a <code>string</code> reference. The fundamental reason is that with private inheritance, a reference or pointer to a base class cannot be assigned a reference or pointer to a derived class without an explicit type cast.</p>
<p>However, even if the example used public inheritance, it would have to use explicit type casts. One reason is that without a type cast, code like the following matches the friend function prototype, leading to a recursive call:</p>
<p class="programlisting">os &lt;&lt; stu;</p>
<p>A second reason is that because the class uses MI, the compiler can&#8217;t tell which base class to convert to if both base classes happen to provide an <code>operator&lt;&lt;()</code> function. <a href="#ch14ex05">Listing 14.5</a> shows all the <code>Student</code> class methods, other than those defined inline in the class declaration.</p>
<p class="caption1"><a id="ch14ex05"/><strong>Listing 14.5. <code>studenti.cpp</code></strong></p><hr/>
<p class="programlisting1">// studenti.cpp -- Student class using private inheritance<br/>#include "studenti.h"<br/>using std::ostream;<br/>using std::endl;<br/>using std::istream;<br/>using std::string;<br/><br/>// public methods<br/>double Student::Average() const<br/>{<br/>&#160;&#160;&#160;&#160;if (ArrayDb::size() &gt; 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ArrayDb::sum()/ArrayDb::size();<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>const string &#38; Student::Name() const<br/>{<br/>&#160;&#160;&#160;&#160;return (const string &#38;) *this;<br/>}<br/><br/>double &#38; Student::operator[](int i)<br/>{<br/>&#160;&#160;&#160;&#160;return ArrayDb::operator[](i);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use ArrayDb::operator[]()<br/>}<br/><br/><a id="page_803"/>double Student::operator[](int i) const<br/>{<br/>&#160;&#160;&#160;&#160;return ArrayDb::operator[](i);<br/>}<br/><br/>// private method<br/>ostream &#38; Student::arr_out(ostream &#38; os) const<br/>{<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;int lim = ArrayDb::size();<br/>&#160;&#160;&#160;&#160;if (lim &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (i = 0; i &lt; lim; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; ArrayDb::operator[](i) &lt;&lt; " ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % 5 == 4)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i % 5 != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os &lt;&lt; " empty array ";<br/>&#160;&#160;&#160;&#160;return os;<br/>}<br/><br/>// friends<br/>// use String version of operator&gt;&gt;()<br/>istream &#38; operator&gt;&gt;(istream &#38; is, Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;is &gt;&gt; (string &#38;)stu;<br/>&#160;&#160;&#160;&#160;return is;<br/>}<br/><br/>// use string friend getline(ostream &#38;, const string &#38;)<br/>istream &#38; getline(istream &#38; is, Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;getline(is, (string &#38;)stu);<br/>&#160;&#160;&#160;&#160;return is;<br/>}<br/><br/>// use string version of operator&lt;&lt;()<br/>ostream &#38; operator&lt;&lt;(ostream &#38; os, const Student &#38; stu)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; "Scores for " &lt;&lt; (const string &#38;) stu&#160;&#160;&lt;&lt; ":\n";<br/>&#160;&#160;&#160;&#160;stu.arr_out(os);&#160;&#160;// use private method for scores<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p><hr/>
<p><a id="page_804"/>Again, because the example reuses the <code>string</code> and <code>valarray</code> code, relatively little new code is needed, aside from the private helper method.</p>
<h5 id="ch14lev3sec8">Using the Revised <code>Student</code> Class</h5>
<p>Once again, it&#8217;s time to test a new class. Note that the two versions of the <code>Student</code> class have exactly the same public interface, so you can test the two versions with exactly the same program. The only difference is that you have to include <code>studenti.h</code> instead of <code>studentc.h</code>, and you have to link the program with <code>studenti.cpp</code> instead of with <code>studentc.cpp</code>. <a href="#ch14ex06">Listing 14.6</a> shows the program. Be sure to compile it along with <code>studenti.cpp</code>.</p>
<p class="caption1"><a id="ch14ex06"/><strong>Listing 14.6. <code>use_stui.cpp</code></strong></p><hr/>
<p class="programlisting1">// use_stui.cpp -- using a class with private inheritance<br/>// compile with studenti.cpp<br/>#include &lt;iostream&gt;<br/>#include "studenti.h"<br/>using std::cin;<br/>using std::cout;<br/>using std::endl;<br/><br/>void set(Student &#38; sa, int n);<br/><br/>const int pupils = 3;<br/>const int quizzes = 5;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Student ada[pupils] =<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{Student(quizzes), Student(quizzes), Student(quizzes)};<br/><br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; pupils; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;set(ada[i], quizzes);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nStudent List:\n";<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; pupils; ++i)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ada[i].Name() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nResults:";<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; pupils; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl &lt;&lt; ada[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "average: " &lt;&lt; ada[i].Average() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/><br/>void set(Student &#38; sa, int n)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter the student's name: ";<br/>&#160;&#160;&#160;&#160;getline(cin, sa);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter " &lt;&lt; n &lt;&lt; " quiz scores:\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; sa[i];<br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>}</p><hr/>
<p><a id="page_805"/>Here is a sample run of the program in <a href="#ch14ex06">Listing 14.6</a>:</p>
<p class="programlisting">Please enter the student's name: <span class="EmpStrong">Gil Bayts</span><br/>Please enter 5 quiz scores:<br/><span class="EmpStrong">92 94 96 93 95</span><br/>Please enter the student's name: <span class="EmpStrong">Pat Roone</span><br/>Please enter 5 quiz scores:<br/><span class="EmpStrong">83 89 72 78 95</span><br/>Please enter the student's name: <span class="EmpStrong">Fleur O'Day</span><br/>Please enter 5 quiz scores:<br/><span class="EmpStrong">92 89 96 74 64</span><br/><br/>Student List:<br/>Gil Bayts<br/>Pat Roone<br/>Fleur O'Day<br/><br/>Results:<br/>Scores for Gil Bayts:<br/>92 94 96 93 95<br/>average: 94<br/><br/>Scores for Pat Roone:<br/>83 89 72 78 95<br/>average: 83.4<br/><br/>Scores for Fleur O'Day:<br/>92 89 96 74 64<br/>average: 83<br/>Done.</p>
<p>The same input as before leads to the same output that the containment version produces.</p>
<h4 id="ch14lev2sec5">Containment or Private Inheritance?</h4>
<p><a id="page_806"/>Given that you can model a <em>has-a</em> relationship either with containment or with private inheritance, which should you use? Most C++ programmers prefer containment. First, it&#8217;s easier to follow. When you look at the class declaration, you see explicitly named objects representing the contained classes, and your code can refer to these objects by name. Using inheritance makes the relationship appear more abstract. Second, inheritance can raise problems, particularly if a class inherits from more than one base class. You may have to deal with issues such as separate base classes having methods with the same name or of separate base classes sharing a common ancestor. All in all, you&#8217;re less likely to run into trouble using containment. Also containment allows you to include more than one subobject of the same class. If a class needs three <code>string</code> objects, you can declare three separate <code>string</code> members by using the containment approach. But inheritance limits you to a single object. (It is difficult to tell objects apart when they are all nameless.)</p>
<p>However, private inheritance does offer features beyond those provided by containment. Suppose, for example, that a class has protected members, which could either be data members or member functions. Such members are available to derived classes but not to the world at large. If you include such a class in another class by using composition, the new class is part of the world at large, not a derived class. Hence it can&#8217;t access protected members. But using inheritance makes the new class a derived class, so it can access protected members.</p>
<p>Another situation that calls for using private inheritance is if you want to redefine virtual functions. Again, this is a privilege accorded to a derived class but not to a containing class. With private inheritance, the redefined functions would be usable just within the class, not publicly.</p>
<div class="note"><hr/>
<p class="title"><a id="ch14note01"/>Tip</p>
<p class="notepara">In general, you should use containment to model a <em>has-a</em> relationship. You should use private inheritance if the new class needs to access protected members in the original class or if it needs to redefine virtual functions.</p>
<hr/></div>
<h4 id="ch14lev2sec6">Protected Inheritance</h4>
<p>Protected inheritance is a variation on private inheritance. It uses the keyword <code>protected</code> when listing a base class:</p>
<p class="programlisting">class Student : protected std::string,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;protected std::valarray&lt;double&gt;<br/>{...};</p>
<p>With protected inheritance, public and protected members of a base class become protected members of the derived class. As with private inheritance, the interface for the base class is available to the derived class but not to the outside world. The main difference between private and protected inheritance occurs when you derive another class from the derived class. With private inheritance, this third-generation class doesn&#8217;t get the internal use of the base-class interface. That&#8217;s because the public base-class methods become <a id="page_807"/>private in the derived class, and private members and methods can&#8217;t be directly accessed by the next level of derivation. With protected inheritance, public base-class methods become protected in the second generation and so are available internally to the next level of derivation.</p>
<p><a href="#ch14table01">Table 14.1</a> summarizes public, private, and protected inheritance. The term <em>implicit upcasting</em> means that you can have a base-class pointer or reference refer to a derived class object without using an explicit type cast.</p>
<p class="caption"><a id="ch14table01"/><strong>Table 14.1. Varieties of Inheritance</strong></p>
<p class="image"><img src="graphics/14tab01.jpg" alt="Image"/></p>
<h4 id="ch14lev2sec7">Redefining Access with <code>using</code></h4>
<p>Public members of a base class become protected or private when you use protected or private derivation. Suppose you want to make a particular base-class method available publicly in the derived class. One option is to define a derived-class method that uses the base-class method. For example, suppose you want the <code>Student</code> class to be able to use the <code>valarray sum()</code> method. You can declare a <code>sum()</code> method in the class declaration and then define the method this way:</p>
<p class="programlisting">double Student::sum() const&#160;&#160;&#160;&#160;// public Student method<br/>{<br/>&#160;&#160;&#160;&#160;return std::valarray&lt;double&gt;::sum(); // use privately-inherited method<br/>}</p>
<p>Then a <code>Student</code> object can invoke <code>Student::sum()</code>, which, in turn, applies the <code>valarray&lt;double&gt;::sum()</code> method to the embedded <code>valarray</code> object. (If the <code>ArrayDb typedef</code> is in scope, you can use <code>ArrayDb</code> instead of <code>std::valarray&lt;double&gt;</code>.)</p>
<p>There is an alternative to wrapping one function call in another: use a <code>using</code> declaration (such as those used with namespaces) to announce that a particular base-class member can be used by the derived class, even though the derivation is private. For example, suppose you want to be able to use the <code>valarray min()</code> and <code>max()</code> methods with the <a id="page_808"/><code>Student</code> class. In this case, in <code>studenti.h</code>, you can add <code>using</code> declarations to the public section:</p>
<p class="programlisting">class Student : private std::string, private std::valarray&lt;double&gt;<br/>{<br/>...<br/>public:<br/>&#160;&#160;&#160;&#160;using std::valarray&lt;double&gt;::min;<br/>&#160;&#160;&#160;&#160;using std::valarray&lt;double&gt;::max;<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>The <code>using</code> declaration makes the <code>valarray&lt;double&gt;::min()</code> and <code>valarray&lt;double&gt;::max()</code> methods available as if they were public <code>Student</code> methods:</p>
<p class="programlisting">cout &lt;&lt; "high score: " &lt;&lt; ada[i].max() &lt;&lt; endl;</p>
<p>Note that the <code>using</code> declaration just uses the member name&#8212;no parentheses, no function signatures, no return types. For example, to make the <code>valarray operator[]()</code> method available to the <code>Student</code> class, you&#8217;d place the following <code>using</code> declaration in the public section of the <code>Student</code> class declaration:</p>
<p class="programlisting">using std::valarray&lt;double&gt;::operator[];</p>
<p>This would make both versions (<code>const</code> and non-<code>const</code>) available. You could then remove the existing prototypes and definitions for <code>Student::operator[]()</code>. The <code>using</code> declaration approach works only for inheritance and not for containment.</p>
<p>There is an older way to redeclare base-class methods in a privately derived class: You place the method name in the public section of the derived class. Here&#8217;s how you would do that:</p>
<p class="programlisting">class Student : private std::string, private std::valarray&lt;double&gt;<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;std::valarray&lt;double&gt;::operator[];&#160;&#160;// redeclare as public, just use name<br/>&#160;&#160;&#160;&#160;...<br/><br/>};</p>
<p>This looks like a <code>using</code> declaration without the <code>using</code> keyword. This approach is <em>deprecated</em>, meaning that the intention is to phase it out. So if your compiler supports the <code>using</code> declaration, you can use it to make a method from a private base class available to the derived class.</p>
<h3 id="ch14lev1sec3">Multiple Inheritance</h3>
<p>MI describes a class that has more than one immediate base class. As with single inheritance, public MI should express an <em>is-a</em> relationship. For example, if you have a <code>Waiter</code> class and a <code>Singer</code> class, you could derive a <code>SingingWaiter</code> class from the two:</p>
<p class="programlisting"><a id="page_809"/>class SingingWaiter : public Waiter, public Singer {...};</p>
<p>Note that you must qualify each base class with the keyword <code>public</code>. That&#8217;s because the compiler assumes private derivation unless instructed otherwise:</p>
<p class="programlisting">class SingingWaiter : public Waiter, Singer {...}; // Singer is a private base</p>
<p>As discussed earlier in this chapter, private and protected MI can express a <em>has-a</em> relationship; the <code>studenti.h</code> implementation of the <code>Student</code> class is an example. We&#8217;ll concentrate on public inheritance now.</p>
<p>MI can introduce new problems for programmers. The two chief problems are inheriting different methods with the same name from two different base classes and inheriting multiple instances of a class via two or more related immediate base classes. Solving these problems involves introducing a few new rules and syntax variations. Thus, using MI can be more difficult and problem-prone than using single inheritance. For this reason, many in the C++ community object strongly to MI; some want it removed from the language. Others love MI and argue that it&#8217;s very useful, even necessary, for particular projects. Still others suggest using MI cautiously and in moderation.</p>
<p>Let&#8217;s explore a particular example and see what the problems and solutions are. You need several classes to create an MI situation. For this example, we&#8217;ll define an abstract <code>Worker</code> base class and derive a <code>Waiter</code> class and a <code>Singer</code> class from it. Then we can use MI to derive a <code>SingingWaiter</code> class from the <code>Waiter</code> and <code>Singer</code> classes (see <a href="#ch14fig03">Figure 14.3</a>). This is a case in which a base class (<code>Worker</code>) is inherited via two separate derivations, which is the circumstance that causes the most difficulties with MI. We start with declarations for the <code>Worker</code>, <code>Waiter</code>, and <code>Singer</code> classes, as shown in <a href="#ch14ex07">Listing 14.7</a>.</p>
<p class="caption"><a id="ch14fig03"/><strong>Figure 14.3. MI with a shared ancestor.</strong></p>
<p class="image"><img src="graphics/14fig03.jpg" alt="Image"/></p>
<p class="caption1"><a id="page_810"/><a id="ch14ex07"/><strong>Listing 14.7. <code>worker0.h</code></strong></p><hr/>
<p class="programlisting1">// worker0.h&#160;&#160;-- working classes<br/>#ifndef WORKER0_H_<br/>#define WORKER0_H_<br/><br/>#include &lt;string&gt;<br/><br/>class Worker&#160;&#160;&#160;// an abstract base class<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string fullname;<br/>&#160;&#160;&#160;&#160;long id;<br/>public:<br/>&#160;&#160;&#160;&#160;Worker() : fullname("no one"), id(0L) {}<br/>&#160;&#160;&#160;&#160;Worker(const std::string &#38; s, long n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: fullname(s), id(n) {}<br/>&#160;&#160;&#160;&#160;virtual ~Worker() = 0;&#160;&#160;&#160;// pure virtual destructor<br/>&#160;&#160;&#160;&#160;virtual void Set();<br/>&#160;&#160;&#160;&#160;virtual void Show() const;<br/>};<br/><br/>class Waiter : public Worker<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int panache;<br/>public:<br/>&#160;&#160;&#160;&#160;Waiter() : Worker(), panache(0) {}<br/>&#160;&#160;&#160;&#160;Waiter(const std::string &#38; s, long n, int p = 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(s, n), panache(p) {}<br/>&#160;&#160;&#160;&#160;Waiter(const Worker &#38; wk, int p = 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(wk), panache(p) {}<br/>&#160;&#160;&#160;&#160;void Set();<br/>&#160;&#160;&#160;&#160;void Show() const;<br/>};<br/><br/>class Singer : public Worker<br/>{<br/>protected:<br/>&#160;&#160;&#160;&#160;enum {other, alto, contralto, soprano,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bass, baritone, tenor};<br/>&#160;&#160;&#160;&#160;enum {Vtypes = 7};<br/>private:<br/>&#160;&#160;&#160;&#160;static char *pv[Vtypes];&#160;&#160;&#160;&#160;// string equivs of voice types<br/>&#160;&#160;&#160;&#160;int voice;<br/>public:<br/>&#160;&#160;&#160;&#160;Singer() : Worker(), voice(other) {}<br/>&#160;&#160;&#160;&#160;Singer(const std::string &#38; s, long n, int v = other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(s, n), voice(v) {}<br/>&#160;&#160;&#160;&#160;Singer(const Worker &#38; wk, int v = other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(wk), voice(v) {}<br/>&#160;&#160;&#160;&#160;void Set();<br/>&#160;&#160;&#160;&#160;void Show() const;<br/>};<br/><br/>#endif</p><hr/>
<p><a id="page_811"/>The class declarations in <a href="#ch14ex07">Listing 14.7</a> include some internal constants that represent voice types. An enumeration makes <code>alto</code>, <code>contralto</code>, and so on symbolic constants for voice types, and the static array <code>pv</code> holds pointers to the C-style string equivalents. The implementation file, shown in <a href="#ch14ex08">Listing 14.8</a>, initializes this array and provides method definitions.</p>
<p class="caption1"><a id="ch14ex08"/><strong>Listing 14.8. <code>worker0.cpp</code></strong></p><hr/>
<p class="programlisting1">// worker0.cpp -- working class methods<br/>#include "worker0.h"<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>using std::cin;<br/>using std::endl;<br/>// Worker methods<br/><br/>// must implement virtual destructor, even if pure<br/>Worker::~Worker() {}<br/><br/>void Worker::Set()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter worker's name: ";<br/>&#160;&#160;&#160;&#160;getline(cin, fullname);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter worker's ID: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; id;<br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>}<br/><br/>void Worker::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: " &lt;&lt; fullname &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Employee ID: " &lt;&lt; id &lt;&lt; "\n";<br/>}<br/><br/>// Waiter methods<br/>void Waiter::Set()<br/><a id="page_812"/>{<br/>&#160;&#160;&#160;&#160;Worker::Set();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter waiter's panache rating: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; panache;<br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>}<br/><br/>void Waiter::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Category: waiter\n";<br/>&#160;&#160;&#160;&#160;Worker::Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Panache rating: " &lt;&lt; panache &lt;&lt; "\n";<br/>}<br/><br/>// Singer methods<br/><br/>char * Singer::pv[] = {"other", "alto", "contralto",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"soprano", "bass", "baritone", "tenor"};<br/><br/>void Singer::Set()<br/>{<br/>&#160;&#160;&#160;&#160;Worker::Set();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter number for singer's vocal range:\n";<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; Vtypes; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; pv[i] &lt;&lt; "&#160;&#160;&#160;";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( i % 4 == 3)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;if (i % 4 != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt;&#160;&#160;voice &#38;&#38; (voice &lt; 0 || voice &gt;= Vtypes) )<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter a value &gt;= 0 and &lt; " &lt;&lt; Vtypes &lt;&lt; endl;<br/><br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>}<br/><br/>void Singer::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Category: singer\n";<br/>&#160;&#160;&#160;&#160;Worker::Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Vocal range: " &lt;&lt; pv[voice] &lt;&lt; endl;<br/>}</p><hr/>
<p><a id="page_813"/><a href="#ch14ex09">Listing 14.9</a> provides a brief test of the classes, using a polymorphic array of pointers.</p>
<p class="caption1"><a id="ch14ex09"/><strong>Listing 14.9. <code>worktest.cpp</code></strong></p><hr/>
<p class="programlisting1">// worktest.cpp -- test worker class hierarchy<br/>#include &lt;iostream&gt;<br/>#include "worker0.h"<br/>const int LIM = 4;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Waiter bob("Bob Apple", 314L, 5);<br/>&#160;&#160;&#160;&#160;Singer bev("Beverly Hills", 522L, 3);<br/>&#160;&#160;&#160;&#160;Waiter w_temp;<br/>&#160;&#160;&#160;&#160;Singer s_temp;<br/><br/>&#160;&#160;&#160;&#160;Worker * pw[LIM] = {&#38;bob, &#38;bev, &#38;w_temp, &#38;s_temp};<br/><br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 2; i &lt; LIM; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pw[i]-&gt;Set();<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; LIM; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pw[i]-&gt;Show();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here is the output of the program in <a href="#ch14ex07">Listings 14.7</a>, <a href="#ch14ex08">14.8</a>, and <a href="#ch14ex09">14.9</a>:</p>
<p class="programlisting">Enter waiter's name: <span class="EmpStrong">Waldo Dropmaster</span><br/>Enter worker's ID: <span class="EmpStrong">442</span><br/>Enter waiter's panache rating: <span class="EmpStrong">3</span><br/>Enter singer's name: <span class="EmpStrong">Sylvie Sirenne</span><br/>Enter worker's ID: <span class="EmpStrong">555</span><br/>Enter number for singer's vocal range:<br/>0: other&#160;&#160;&#160;1: alto&#160;&#160;&#160;2: contralto&#160;&#160;&#160;3: soprano<br/>4: bass&#160;&#160;&#160;5: baritone&#160;&#160;&#160;6: tenor<br/><span class="EmpStrong">3</span><br/>Category: waiter<br/>Name: Bob Apple<br/>Employee ID: 314<br/>Panache rating: 5<br/><br/>Category: singer<br/>Name: Beverly Hills<br/><a id="page_814"/>Employee ID: 522<br/>Vocal range: soprano<br/><br/>Category: waiter<br/>Name: Waldo Dropmaster<br/>Employee ID: 442<br/>Panache rating: 3<br/><br/>Category: singer<br/>Name: Sylvie Sirenne<br/>Employee ID: 555<br/>Vocal range: soprano</p>
<p>The design seems to work, with pointers to <code>Waiter</code> invoking <code>Waiter::Show()</code> and <code>Waiter::Set(</code>), and pointers to <code>Singer</code> invoking <code>Singer::Show()</code> and <code>Singer::Set()</code>. However, it leads to some problems if you add a <code>SingingWaiter</code> class derived from both the <code>Singer</code> class and <code>Waiter</code> class. In particular, you&#8217;ll need to face the following questions:</p>
<p class="indenthandingB">&#8226; How many workers?</p>
<p class="indenthandingB">&#8226; Which method?</p>
<h4 id="ch14lev2sec8">How Many Workers?</h4>
<p>Suppose you begin by publicly deriving <code>SingingWaiter</code> from <code>Singer</code> and <code>Waiter</code>:</p>
<p class="programlisting">class SingingWaiter: public Singer, public&#160;&#160;Waiter {...};</p>
<p>Because both <code>Singer</code> and <code>Waiter</code> inherit a <code>Worker</code> component, <code>SingingWaiter</code> winds up with two <code>Worker</code> components (see <a href="#ch14fig04">Figure 14.4</a>).</p>
<p class="caption"><a id="ch14fig04"/><strong>Figure 14.4. Inheriting two base-class objects.</strong></p>
<p class="image"><img src="graphics/14fig04.jpg" alt="Image"/></p>
<p>As you might expect, this raises problems. For example, ordinarily you can assign the address of a derived-class object to a base-class pointer, but this becomes ambiguous now:</p>
<p class="programlisting">SingingWaiter ed;<br/>Worker * pw = &#38;ed;&#160;&#160;&#160;// ambiguous</p>
<p>Normally, such an assignment sets a base-class pointer to the address of the base-class object within the derived object. But <code>ed</code> contains two <code>Worker</code> objects, so there are two addresses from which to choose. You could specify which object by using a type cast:</p>
<p class="programlisting">Worker * pw1 = (Waiter *) &#38;ed;&#160;&#160;&#160;// the Worker in Waiter<br/>Worker * pw2 = (Singer *) &#38;ed;&#160;&#160;&#160;// the Worker in Singer</p>
<p>This certainly complicates the technique of using an array of base-class pointers to refer to a variety of objects (polymorphism).</p>
<p>Having two copies of a <code>Worker</code> object causes other problems, too. However, the real issue is why should you have two copies of a <code>Worker</code> object at all? A singing waiter, like any other worker, should have just one name and one ID. When C++ added MI to its bag of tricks, it added a virtual base class to make this possible.</p>
<h5 id="ch14lev3sec9">Virtual Base Classes</h5>
<p><a id="page_815"/>Virtual base classes allow an object derived from multiple bases that themselves share a common base to inherit just one object of that shared base class. For this example, you would make <code>Worker</code> a virtual base class to <code>Singer</code> and <code>Waiter</code> by using the keyword <code>virtual</code> in the class declarations (<code>virtual</code> and <code>public</code> can appear in either order):</p>
<p class="programlisting">class Singer : virtual public Worker {...};<br/>class Waiter : public virtual Worker {...};</p>
<p>Then you would define <code>SingingWaiter</code> as before:</p>
<p class="programlisting">class SingingWaiter: public Singer, public&#160;&#160;Waiter {...};</p>
<p>Now a <code>SingingWaiter</code> object will contain a single copy of a <code>Worker</code> object. In essence, the inherited <code>Singer</code> and <code>Waiter</code> objects share a common <code>Worker</code> object instead of each bringing in its own copy (see <a href="#ch14fig05">Figure 14.5</a>). Because <code>SingingWaiter</code> now contains one <code>Worker</code> subobject, you can use polymorphism again.</p>
<p class="caption"><a id="page_816"/><a id="ch14fig05"/><strong>Figure 14.5. Inheritance with a virtual base class.</strong></p>
<p class="image"><img src="graphics/14fig05.jpg" alt="Image"/></p>
<p>Let&#8217;s look at some questions you might have:</p>
<p class="indenthandingB">&#8226; Why the term <em>virtual</em>?</p>
<p class="indenthandingB">&#8226; Why don&#8217;t we dispense with declaring base classes virtual and make virtual behavior the norm for MI?</p>
<p class="indenthandingB">&#8226; Are there any catches?</p>
<p>First, why the term virtual? After all, there doesn&#8217;t seem to be an obvious connection between the concepts of virtual functions and virtual base classes. There is strong pressure from the C++ community to resist the introduction of new keywords. It would be awkward, for example, if a new keyword corresponded to the name of some important function or variable in a major program. So C++ merely recycled the keyword <code>virtual</code> for the new facility&#8212;a bit of keyword overloading.</p>
<p>Next, why don&#8217;t we dispense with declaring base classes virtual and make virtual behavior the norm for MI? First, there are cases in which you might want multiple copies of a base. Second, making a base class virtual requires that a program do some additional accounting, and you shouldn&#8217;t have to pay for that facility if you don&#8217;t need it. Third, there are the disadvantages presented in the next paragraph.</p>
<p>Finally, are there catches? Yes. Making virtual base classes work requires adjustments to C++ rules, and you have to code some things differently. Also using virtual base classes may involve changing existing code. For example, adding the <code>SingingWaiter</code> class to the <a id="page_817"/><code>Worker</code> hierarchy requires that you go back and add the <code>virtual</code> keyword to the <code>Singer</code> and <code>Waiter</code> classes.</p>
<h5 id="ch14lev3sec10">New Constructor Rules</h5>
<p>Having virtual base classes requires a new approach to class constructors. With nonvirtual base classes, the <em>only</em> constructors that can appear in an initialization list are constructors for the immediate base classes. But these constructors can, in turn, pass information on to their bases. For example, you can have the following organization of constructors:</p>
<p class="programlisting">class A<br/>{<br/>&#160;&#160;&#160;&#160;int a;<br/>public:<br/>&#160;&#160;&#160;&#160;A(int n = 0) : a(n) {}<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>class B: public A<br/>{<br/>&#160;&#160;&#160;&#160;int b;<br/>public:<br/>&#160;&#160;&#160;&#160;B(int m = 0, int n = 0) : A(n), b(m)&#160;&#160;{}<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>class C : public B<br/>{<br/>&#160;&#160;&#160;&#160;int c;<br/>public:<br/>&#160;&#160;&#160;&#160;C(int q = 0, int m = 0, int n = 0) : B(m, n), c(q) {}<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>A <code>C</code> constructor can invoke only constructors from the <code>B</code> class, and a <code>B</code> constructor can invoke only constructors from the <code>A</code> class. Here the <code>C</code> constructor uses the <code>q</code> value and passes the values of <code>m</code> and <code>n</code> back to the <code>B</code> constructor. The <code>B</code> constructor uses the value of <code>m</code> and passes the value of <code>n</code> back to the <code>A</code> constructor.</p>
<p>This automatic passing of information doesn&#8217;t work if <code>Worker</code> is a virtual base class. For example, consider the following possible constructor for the MI example:</p>
<p class="programlisting">SingingWaiter(const Worker &#38; wk, int p = 0, int v = Singer::other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Waiter(wk,p), Singer(wk,v) {}&#160;&#160;// flawed</p>
<p>The problem is that automatic passing of information would pass <code>wk</code> to the <code>Worker</code> object via two separate paths (<code>Waiter</code> and <code>Singer</code>). To avoid this potential conflict, C++ disables the automatic passing of information through an intermediate class to a base class <em>if</em> the base class is virtual. Thus, the previous constructor will initialize the <code>panache</code> and <code>voice</code> members, but the information in the <code>wk</code> argument <em>won&#8217;t</em> get to the <code>Waiter</code> subobject. However, the compiler must construct a base object component before constructing derived objects; in this case, it will use the default <code>Worker</code> constructor.</p>
<p><a id="page_818"/>If you want to use something other than the default constructor for a virtual base class, you need to invoke the appropriate base constructor explicitly. Thus, the constructor should look like this:</p>
<p class="programlisting">SingingWaiter(const Worker &#38; wk, int p = 0, int v = Singer::other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(wk), Waiter(wk,p), Singer(wk,v) {}</p>
<p>Here the code explicitly invokes the <code>Worker(const Worker &#38;)</code> constructor. Note that this usage is legal and often necessary for virtual base classes, and it is illegal for nonvirtual base classes.</p>
<div class="note"><hr/>
<p class="title"><a id="ch14note02"/>Caution</p>
<p class="notepara">If a class has an indirect virtual base class, a constructor for that class should explicitly invoke a constructor for the virtual base class unless all that is needed is the default constructor for the virtual base class.</p>
<hr/></div>
<h4 id="ch14lev2sec9">Which Method?</h4>
<p>In addition to introducing changes in class constructor rules, MI often requires other coding adjustments. Consider the problem of extending the <code>Show()</code> method to the <code>SingingWaiter</code> class. Because a <code>SingingWaiter</code> object has no new data members, you might think the class could just use the inherited methods. This brings up the first problem. Suppose you do omit a new version of <code>Show()</code> and try to use a <code>SingingWaiter</code> object to invoke an inherited <code>Show()</code> method:</p>
<p class="programlisting">SingingWaiter newhire("Elise Hawks", 2005, 6, soprano);<br/>newhire.Show();&#160;&#160;// ambiguous</p>
<p>With single inheritance, failing to redefine <code>Show()</code> results in using the most recent ancestral definition. In this case, each direct ancestor has a <code>Show()</code> function, which makes this call ambiguous.</p>
<div class="note"><hr/>
<p class="title"><a id="ch14note03"/>Caution</p>
<p class="notepara">Multiple Inheritance can result in ambiguous function calls. For example, a <code>BadDude</code> class could inherit two quite different <code>Draw()</code> methods from a <code>Gunslinger</code> class and a <code>PokerPlayer</code> class.</p>
<hr/></div>
<p>You can use the scope-resolution operator to clarify what you mean:</p>
<p class="programlisting">SingingWaiter newhire("Elise Hawks", 2005, 6, soprano);<br/>newhire.Singer::Show();&#160;&#160;// use Singer version</p>
<p>However, a better approach is to redefine <code>Show()</code> for <code>SingingWaiter</code> and to have it specify which <code>Show()</code> to use. For example, if you want a <code>SingingWaiter</code> object to use the <code>Singer</code> version, you could use this:</p>
<p class="programlisting"><a id="page_819"/>void SingingWaiter::Show()<br/>{<br/>&#160;&#160;&#160;&#160;Singer::Show();<br/>}</p>
<p>This method of having the derived method call the base method works well enough for single inheritance. For example, suppose that the <code>HeadWaiter</code> class derives from the <code>Waiter</code> class. You could use a sequence of definitions like this, with each derived class adding to the information displayed by its base class:</p>
<p class="programlisting">void Worker::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: " &lt;&lt; fullname &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Employee ID: " &lt;&lt; id &lt;&lt; "\n";<br/>}<br/><br/>void Waiter::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;Worker::Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Panache rating: " &lt;&lt; panache &lt;&lt; "\n";<br/>}<br/>void HeadWaiter::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;Waiter::Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Presence rating: " &lt;&lt; presence &lt;&lt; "\n";<br/>}</p>
<p>This incremental approach fails for the <code>SingingWaiter</code> case, however. The following method fails because it ignores the <code>Waiter</code> component:</p>
<p class="programlisting">void SingingWaiter::Show()<br/>{<br/>&#160;&#160;&#160;&#160;Singer::Show();<br/>}</p>
<p>You can remedy that by calling the <code>Waiter</code> version also:</p>
<p class="programlisting">void SingingWaiter::Show()<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;Singer::Show();<br/>&#160;&#160;&#160;&#160;&#160;&#160;Waiter::Show();<br/>}</p>
<p>However, this displays a person&#8217;s name and ID twice because <code>Singer::Show()</code> and with <code>Waiter::Show()</code> both call <code>Worker::Show()</code>.</p>
<p>How can you fix this? One way is to use a modular approach instead of an incremental approach. That is, you can provide a method that displays only <code>Worker</code> components, another method that displays only <code>Waiter</code> components (instead of <code>Waiter</code> plus <code>Worker</code> components), and another that displays only <code>Singer</code> components. Then the <a id="page_820"/><code>SingingWaiter::Show()</code> method can put those components together. For example, you could use this:</p>
<p class="programlisting">void Worker::Data() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: " &lt;&lt; fullname &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Employee ID: " &lt;&lt; id &lt;&lt; "\n";<br/>}<br/><br/>void Waiter::Data() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Panache rating: " &lt;&lt; panache &lt;&lt; "\n";<br/>}<br/><br/>void Singer::Data() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Vocal range: " &lt;&lt; pv[voice] &lt;&lt; "\n";<br/>}<br/><br/>void SingingWaiter::Data() const<br/>{<br/>&#160;&#160;&#160;&#160;Singer::Data();<br/>&#160;&#160;&#160;&#160;Waiter::Data();<br/>}<br/><br/>void SingingWaiter::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Category: singing waiter\n";<br/>&#160;&#160;&#160;&#160;Worker::Data();<br/>&#160;&#160;&#160;&#160;Data();<br/>}</p>
<p>Similarly, the other <code>Show()</code> methods would be built from the appropriate <code>Data()</code> components.</p>
<p>With this approach, objects would still use the <code>Show()</code> method publicly. The <code>Data()</code> methods, on the other hand, should be internal to the classes; they should be helper methods used to facilitate the public interface. However, making the <code>Data()</code> methods private would prevent, say, <code>Waiter</code> code from using <code>Worker::Data()</code>. Here is just the kind of situation for which the protected access class is useful. If the <code>Data()</code> methods are protected, they can by used internally by all the classes in the hierarchy while being kept hidden from the outside world.</p>
<p>Another approach would be to make all the data components protected instead of private, but using protected methods instead of protected data puts tighter control on the allowable access to the data.</p>
<p>The <code>Set()</code> methods, which solicit data for setting object values, present a similar problem. For example, <code>SingingWaiter::Set()</code>should ask for <code>Worker</code> information once, not <a id="page_821"/>twice. The same solution used for <code>Show()</code> works. You can provide protected <code>Get()</code> methods that solicit information for just a single class, and then you can put together <code>Set()</code> methods that use the <code>Get()</code> methods as building blocks.</p>
<p>In short, introducing MI with a shared ancestor requires introducing virtual base classes, altering the rules for constructor initialization lists, and possibly recoding the classes if they were written with MI in mind. <a href="#ch14ex10">Listing 14.10</a> shows the modified class declarations with these changes institutes, and <a href="#ch14ex11">Listing 14.11</a> shows the implementation.</p>
<p class="caption1"><a id="ch14ex10"/><strong>Listing 14.10. <code>workermi.h</code></strong></p><hr/>
<p class="programlisting1">// workermi.h&#160;&#160;-- working classes with MI<br/>#ifndef WORKERMI_H_<br/>#define WORKERMI_H_<br/><br/>#include &lt;string&gt;<br/><br/>class Worker&#160;&#160;&#160;// an abstract base class<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string fullname;<br/>&#160;&#160;&#160;&#160;long id;<br/>protected:<br/>&#160;&#160;&#160;&#160;virtual void Data() const;<br/>&#160;&#160;&#160;&#160;virtual void Get();<br/>public:<br/>&#160;&#160;&#160;&#160;Worker() : fullname("no one"), id(0L) {}<br/>&#160;&#160;&#160;&#160;Worker(const std::string &#38; s, long n)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: fullname(s), id(n) {}<br/>&#160;&#160;&#160;&#160;virtual ~Worker() = 0; // pure virtual function<br/>&#160;&#160;&#160;&#160;virtual void Set() = 0;<br/>&#160;&#160;&#160;&#160;virtual void Show() const = 0;<br/>};<br/><br/>class Waiter : virtual public Worker<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int panache;<br/>protected:<br/>&#160;&#160;&#160;&#160;void Data() const;<br/>&#160;&#160;&#160;&#160;void Get();<br/>public:<br/>&#160;&#160;&#160;&#160;Waiter() : Worker(), panache(0) {}<br/>&#160;&#160;&#160;&#160;Waiter(const std::string &#38; s, long n, int p = 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(s, n), panache(p) {}<br/>&#160;&#160;&#160;&#160;Waiter(const Worker &#38; wk, int p = 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(wk), panache(p) {}<br/><a id="page_822"/>&#160;&#160;&#160;&#160;void Set();<br/>&#160;&#160;&#160;&#160;void Show() const;<br/>};<br/><br/>class Singer : virtual public Worker<br/>{<br/>protected:<br/>enum {other, alto, contralto, soprano,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bass, baritone, tenor};<br/>&#160;&#160;&#160;&#160;enum {Vtypes = 7};<br/>&#160;&#160;&#160;&#160;void Data() const;<br/>&#160;&#160;&#160;&#160;void Get();<br/>private:<br/>&#160;&#160;&#160;&#160;static char *pv[Vtypes];&#160;&#160;&#160;&#160;// string equivs of voice types<br/>&#160;&#160;&#160;&#160;int voice;<br/>public:<br/>&#160;&#160;&#160;&#160;Singer() : Worker(), voice(other) {}<br/>&#160;&#160;&#160;&#160;Singer(const std::string &#38; s, long n, int v = other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(s, n), voice(v) {}<br/>&#160;&#160;&#160;&#160;Singer(const Worker &#38; wk, int v = other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(wk), voice(v) {}<br/>&#160;&#160;&#160;&#160;void Set();<br/>&#160;&#160;&#160;&#160;void Show() const;<br/>};<br/><br/>// multiple inheritance<br/>class SingingWaiter : public Singer, public Waiter<br/>{<br/>protected:<br/>&#160;&#160;&#160;&#160;void Data() const;<br/>&#160;&#160;&#160;&#160;void Get();<br/>public:<br/>&#160;&#160;&#160;&#160;SingingWaiter()&#160;&#160;{}<br/>&#160;&#160;&#160;&#160;SingingWaiter(const std::string &#38; s, long n, int p = 0,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int v = other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(s,n), Waiter(s, n, p), Singer(s, n, v) {}<br/>&#160;&#160;&#160;&#160;SingingWaiter(const Worker &#38; wk, int p = 0, int v = other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(wk), Waiter(wk,p), Singer(wk,v) {}<br/>&#160;&#160;&#160;&#160;SingingWaiter(const Waiter &#38; wt, int v = other)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(wt),Waiter(wt), Singer(wt,v) {}<br/>&#160;&#160;&#160;&#160;SingingWaiter(const Singer &#38; wt, int p = 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Worker(wt),Waiter(wt,p), Singer(wt) {}<br/>&#160;&#160;&#160;&#160;void Set();<br/>&#160;&#160;&#160;&#160;void Show() const;<br/>};<br/><br/>#endif</p><hr/>
<p class="caption1"><a id="page_823"/><a id="ch14ex11"/><strong>Listing 14.11. <code>workermi.cpp</code></strong></p><hr/>
<p class="programlisting1">// workermi.cpp -- working class methods with MI<br/>#include "workermi.h"<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>using std::cin;<br/>using std::endl;<br/>// Worker methods<br/>Worker::~Worker() { }<br/><br/>// protected methods<br/>void Worker::Data() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Name: " &lt;&lt; fullname &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Employee ID: " &lt;&lt; id &lt;&lt; endl;<br/>}<br/><br/>void Worker::Get()<br/>{<br/>&#160;&#160;&#160;&#160;getline(cin, fullname);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter worker's ID: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; id;<br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>}<br/><br/>// Waiter methods<br/>void Waiter::Set()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter waiter's name: ";<br/>&#160;&#160;&#160;&#160;Worker::Get();<br/>&#160;&#160;&#160;&#160;Get();<br/>}<br/><br/>void Waiter::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Category: waiter\n";<br/>&#160;&#160;&#160;&#160;Worker::Data();<br/>&#160;&#160;&#160;&#160;Data();<br/>}<br/><br/>// protected methods<br/>void Waiter::Data() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Panache rating: " &lt;&lt; panache &lt;&lt; endl;<br/>}<br/><br/><a id="page_824"/>void Waiter::Get()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter waiter's panache rating: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; panache;<br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>}<br/><br/>// Singer methods<br/><br/>char * Singer::pv[Singer::Vtypes] = {"other", "alto", "contralto",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"soprano", "bass", "baritone", "tenor"};<br/><br/>void Singer::Set()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter singer's name: ";<br/>&#160;&#160;&#160;&#160;Worker::Get();<br/>&#160;&#160;&#160;&#160;Get();<br/>}<br/><br/>void Singer::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Category: singer\n";<br/>&#160;&#160;&#160;&#160;Worker::Data();<br/>&#160;&#160;&#160;&#160;Data();<br/>}<br/><br/>// protected methods<br/>void Singer::Data() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Vocal range: " &lt;&lt; pv[voice] &lt;&lt; endl;<br/>}<br/><br/>void Singer::Get()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter number for singer's vocal range:\n";<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; Vtypes; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; pv[i] &lt;&lt; "&#160;&#160;&#160;";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( i % 4 == 3)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;if (i % 4 != 0)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;cin &gt;&gt;&#160;&#160;voice;<br/>&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>}<br/><br/>// SingingWaiter methods<br/>void SingingWaiter::Data() const<br/>{<br/>&#160;&#160;&#160;&#160;Singer::Data();<br/>&#160;&#160;&#160;&#160;Waiter::Data();<br/>}<br/><br/>void SingingWaiter::Get()<br/>{<br/>&#160;&#160;&#160;&#160;Waiter::Get();<br/>&#160;&#160;&#160;&#160;Singer::Get();<br/>}<br/><br/>void SingingWaiter::Set()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter singing waiter's name: ";<br/>&#160;&#160;&#160;&#160;Worker::Get();<br/>&#160;&#160;&#160;&#160;Get();<br/>}<br/><br/>void SingingWaiter::Show() const<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Category: singing waiter\n";<br/>&#160;&#160;&#160;&#160;Worker::Data();<br/>&#160;&#160;&#160;&#160;Data();<br/>}</p><hr/>
<p><a id="page_825"/>Of course, curiosity demands that you test these classes, and <a href="#ch14ex12">Listing 14.12</a> provides code to do so. Note that the program makes use of polymorphism by assigning the addresses of various kinds of classes to base-class pointers. Also the program uses the C-style <code>string</code> library function <code>strchr()</code> in the following test:</p>
<p class="programlisting">while (strchr("wstq", choice) == NULL)</p>
<p>This function returns the address of the first occurrence of the <code>choice</code> character value in the string <code>"wstq"</code>; the function returns the <code>NULL</code> pointer if the character isn&#8217;t found. This test is simpler to write than an <code>if</code> statement that compares <code>choice</code> to each letter individually.</p>
<p>Be sure to compile <a href="#ch14ex12">Listing 14.12</a> along with <code>workermi.cpp</code>.</p>
<p class="caption1"><a id="page_826"/><a id="ch14ex12"/><strong>Listing 14.12. <code>workmi.cpp</code></strong></p><hr/>
<p class="programlisting1">// workmi.cpp -- multiple inheritance<br/>// compile with workermi.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;cstring&gt;<br/>#include "workermi.h"<br/>const int SIZE = 5;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;using std::strchr;<br/><br/>&#160;&#160;&#160;Worker * lolas[SIZE];<br/><br/>&#160;&#160;&#160;&#160;int ct;<br/>&#160;&#160;&#160;&#160;for (ct = 0; ct &lt; SIZE; ct++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char choice;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter the employee category:\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "w: waiter&#160;&#160;s: singer&#160;&#160;"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "t: singing waiter&#160;&#160;q: quit\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; choice;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (strchr("wstq", choice) == NULL)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter a w, s, t, or q: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; choice;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (choice == 'q')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch(choice)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'w':&#160;&#160;&#160;lolas[ct] = new Waiter;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 's':&#160;&#160;&#160;lolas[ct] = new Singer;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 't':&#160;&#160;&#160;lolas[ct] = new SingingWaiter;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lolas[ct]-&gt;Set();<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\nHere is your staff:\n";<br/>&#160;&#160;&#160;&#160;int i;<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; ct; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lolas[i]-&gt;Show();<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; ct; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete lolas[i];<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye.\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_827"/>Here is a sample run of the program in <a href="#ch14ex10">Listings 14.10</a>, <a href="#ch14ex11">14.11</a>, and <a href="#ch14ex12">14.12</a>:</p>
<p class="programlisting">Enter the employee category:<br/>w: waiter&#160;&#160;s: singer&#160;&#160;t: singing waiter&#160;&#160;q: quit<br/><span class="EmpStrong">w</span><br/>Enter waiter's name: <span class="EmpStrong">Wally Slipshod</span><br/>Enter worker's ID: <span class="EmpStrong">1040</span><br/>Enter waiter's panache rating: <span class="EmpStrong">4</span><br/>Enter the employee category:<br/>w: waiter&#160;&#160;s: singer&#160;&#160;t: singing waiter&#160;&#160;q: quit<br/><span class="EmpStrong">s</span><br/>Enter singer's name: <span class="EmpStrong">Sinclair Parma</span><br/>Enter worker's ID: <span class="EmpStrong">1044</span><br/>Enter number for singer's vocal range:<br/>0: other&#160;&#160;&#160;1: alto&#160;&#160;&#160;2: contralto&#160;&#160;&#160;3: soprano<br/>4: bass&#160;&#160;&#160;5: baritone&#160;&#160;&#160;6: tenor<br/><span class="EmpStrong">5</span><br/>Enter the employee category:<br/>w: waiter&#160;&#160;s: singer&#160;&#160;t: singing waiter&#160;&#160;q: quit<br/><span class="EmpStrong">t</span><br/>Enter singing waiter's name: <span class="EmpStrong">Natasha Gargalova</span><br/>Enter worker's ID: <span class="EmpStrong">1021</span><br/>Enter waiter's panache rating: <span class="EmpStrong">6</span><br/>Enter number for singer's vocal range:<br/>0: other&#160;&#160;&#160;1: alto&#160;&#160;&#160;2: contralto&#160;&#160;&#160;3: soprano<br/>4: bass&#160;&#160;&#160;5: baritone&#160;&#160;&#160;6: tenor<br/><span class="EmpStrong">3</span><br/>Enter the employee category:<br/>w: waiter&#160;&#160;s: singer&#160;&#160;t: singing waiter&#160;&#160;q: quit<br/><span class="EmpStrong">q</span><br/><br/>Here is your staff:<br/><br/>Category: waiter<br/>Name: Wally Slipshod<br/><a id="page_828"/>Employee ID: 1040<br/>Panache rating: 4<br/><br/>Category: singer<br/>Name: Sinclair Parma<br/>Employee ID: 1044<br/>Vocal range: baritone<br/><br/>Category: singing waiter<br/>Name: Natasha Gargalova<br/>Employee ID: 1021<br/>Vocal range: soprano<br/>Panache rating: 6<br/>Bye.</p>
<p>Let&#8217;s look at a few more matters concerning MI.</p>
<h5 id="ch14lev3sec11">Mixed Virtual and Nonvirtual Bases</h5>
<p>Let&#8217;s consider again the case of a derived class that inherits a base class by more than one route. If the base class is virtual, the derived class contains one subobject of the base class. If the base class is not virtual, the derived class contains multiple subobjects. What if there is a mixture? Suppose, for example, that class <code>B</code> is a virtual base class to classes <code>C</code> and <code>D</code> and a nonvirtual base class to classes <code>X</code> and <code>Y</code>. Furthermore, suppose class <code>M</code> is derived from <code>C</code>, <code>D</code>, <code>X</code>, and <code>Y</code>. In this case, class <code>M</code> contains one class <code>B</code> subobject for all the virtually derived ancestors (that is, classes <code>C</code> and <code>D</code>) and a separate class <code>B</code> subobject for each nonvirtual ancestor (that is, classes <code>X</code> and <code>Y</code>). So, all told, it would contain three class <code>B</code> subobjects. When a class inherits a particular base class through several virtual paths and several nonvirtual paths, the class has one base-class subobject to represent all the virtual paths and a separate base-class subobject to represent each nonvirtual path.</p>
<h5 id="ch14lev3sec12">Virtual Base Classes and Dominance</h5>
<p>Using virtual base classes alters how C++ resolves ambiguities. With nonvirtual base classes, the rules are simple. If a class inherits two or more members (data or methods) with the same name from different classes, using that name without qualifying it with a class name is ambiguous. If virtual base classes are involved, however, such a use may or may not be ambiguous. In this case, if one name <em>dominates</em> all others, it can be used unambiguously without a qualifier.</p>
<p>So how does one member name dominate another? A name in a derived class dominates the same name in any ancestor class, whether direct or indirect. For example, consider the following definitions:</p>
<p class="programlisting">class B<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;short q();<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/><a id="page_829"/>};<br/><br/>class C : virtual public B<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;long q();<br/>&#160;&#160;&#160;&#160;&#160;&#160;int omg()<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};<br/><br/>class D : public C<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};<br/><br/>class E : virtual public B<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;int omg();<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};<br/><br/>class F:&#160;&#160;public D, public E<br/>{<br/>&#160;&#160;&#160;&#160;&#160;...<br/>};</p>
<p>Here the definition of <code>q()</code> in class <code>C</code> dominates the definition in class <code>B</code> because <code>C</code> is derived from <code>B</code>. Thus, methods in <code>F</code> can use <code>q()</code> to denote <code>C::q()</code>. On the other hand, neither definition of <code>omg()</code> dominates the other because neither <code>C</code> nor <code>E</code> is a base class to the other. Therefore, an attempt by <code>F</code> to use an unqualified <code>omg()</code> would be ambiguous.</p>
<p>The virtual ambiguity rules pay no attention to access rules. That is, even though <code>E::omg()</code> is private and hence not directly accessible to class <code>F</code>, using <code>omg()</code> is ambiguous. Similarly, even if <code>C::q()</code> were private, it would dominate <code>D::q()</code>. In that case, you could call <code>B::q()</code> in class <code>F</code>, but an unqualified <code>q()</code> for that would refer to the inaccessible <code>C::q()</code>.</p>
<h4 id="ch14lev2sec10">Multiple Inheritance Synopsis</h4>
<p>First, let&#8217;s review MI without virtual base classes. This form of MI imposes no new rules. However, if a class inherits two members with the same name but from different classes, you need to use class qualifiers in the derived class to distinguish between the two members. That is, methods in the <code>BadDude</code> class, derived from <code>Gunslinger</code> and <code>PokerPlayer</code>, would use <code>Gunslinger::draw()</code> and <code>PokerPlayer::draw()</code> to distinguish between <code>draw()</code> methods inherited from the two classes. Otherwise, the compiler should complain about ambiguous usage.</p>
<p><a id="page_830"/>If one class inherits from a nonvirtual base class by more than one route, then the class inherits one base-class object for each nonvirtual instance of the base class. In some cases, this may be what you want, but more often, multiple instances of a base class are a problem.</p>
<p>Next, let&#8217;s look at MI with virtual base classes. A class becomes a virtual base class when a derived class uses the keyword <code>virtual</code> when indicating derivation:</p>
<p class="programlisting">class marketing : public virtual reality { ... };</p>
<p>The main change, and the reason for virtual base classes, is that a class that inherits from one or more instances of a virtual base class inherits just one base-class object. Implementing this feature entails other requirements:</p>
<p class="indenthandingB">&#8226; A derived class with an indirect virtual base class should have its constructors invoke the indirect base-class constructors directly, which is illegal for indirect nonvirtual base classes.</p>
<p class="indenthandingB">&#8226; Name ambiguity is resolved via the dominance rule.</p>
<p>As you can see, MI can introduce programming complexities. However, most of these complexities arise when a derived class inherits from the same base class by more than one route. If you avoid that situation, about the only thing you need to watch for is qualifying inherited names when necessary.</p>
<h3 id="ch14lev1sec4">Class Templates</h3>
<p>Inheritance (public, private, or protected) and containment aren&#8217;t always the solution when you want to reuse code. Consider, for example, the <code>Stack</code> class (see <a href="ch10.html#ch10">Chapter 10</a>) and the <code>Queue</code> class (see <a href="ch12.html#ch12">Chapter 12</a>). These are examples of <em>container classes</em>, which are classes designed to hold other objects or data types. The <code>Stack</code> class from <a href="ch10.html#ch10">Chapter 10</a>, for example, stores <code>unsigned long</code> values. You could just as easily define a stack class for storing <code>double</code> values or <code>string</code> objects. The code would be identical except for the type of object stored. However, rather than write new class declarations, it would be nice if you could define a stack in a generic (that is, type-independent) fashion and then provide a specific type as a parameter to the class. Then you could use the same generic code to produce stacks of different kinds of values. In <a href="ch10.html#ch10">Chapter 10</a>, the <code>Stack</code> example uses <code>typedef</code> as a first pass at dealing with this desire. However, that approach has a couple drawbacks. First, you have to edit the header file each time you change the type. Second, you can use the technique to generate just one kind of stack per program. That is, you can&#8217;t have a <code>typedef</code> represent two different types simultaneously, so you can&#8217;t use the method to define a stack of <code>int</code>s and a stack of <code>string</code>s in the same program.</p>
<p>C++&#8217;s class templates provide a better way to generate generic class declarations. (C++ originally did not support templates, and since their introduction, templates have continued to evolve, so it is possible that your compiler, if old, may not support all the features presented here.) Templates provide <em>parameterized</em> types&#8212;that is, they are capable of passing a type name as an argument to a recipe for building a class or a function. By feeding the <a id="page_831"/>type name <code>int</code> to a <code>Queue</code> template, for example, you can get the compiler to construct a <code>Queue</code> class for queuing <code>int</code>s.</p>
<p>The C++ library provides several template classes. Earlier in this chapter, you worked with the <code>valarray</code> template class, and <a href="ch04.html#ch04">Chapter 4</a> introduced the <code>vector</code> and <code>array</code> template classes. C++&#8217;s Standard Template Library (STL), which <a href="ch16.html#ch16">Chapter 16</a> discusses in part, provides powerful and flexible template implementations of several container classes. This chapter explores designs of a more elementary nature.</p>
<h4 id="ch14lev2sec11">Defining a Class Template</h4>
<p>Let&#8217;s use the <code>Stack</code> class from <a href="ch10.html#ch10">Chapter 10</a> as a model from which to build a template. Here&#8217;s the original class declaration:</p>
<p class="programlisting">typedef unsigned long Item;<br/><br/><br/>class Stack<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {MAX = 10};&#160;&#160;&#160;&#160;// constant specific to class<br/>&#160;&#160;&#160;&#160;Item items[MAX];&#160;&#160;&#160;&#160;// holds stack items<br/>&#160;&#160;&#160;&#160;int top;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// index for top stack item<br/>public:<br/>&#160;&#160;&#160;&#160;Stack();<br/>&#160;&#160;&#160;&#160;bool isempty() const;<br/>&#160;&#160;&#160;&#160;bool isfull() const;<br/>&#160;&#160;&#160;&#160;// push() returns false if stack already is full, true otherwise<br/>&#160;&#160;&#160;&#160;bool push(const Item &#38; item);&#160;&#160;&#160;// add item to stack<br/>&#160;&#160;&#160;&#160;// pop() returns false if stack already is empty, true otherwise<br/>&#160;&#160;&#160;&#160;bool pop(Item &#38; item);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pop top into item<br/>};</p>
<p>The template approach will replace the <code>Stack</code> definition with a template definition and the <code>Stack</code> member functions with template member functions. As with template functions, you preface a template class with code that has the following form:</p>
<p class="programlisting">template &lt;class <span class="EmpItalic">Type</span>&gt;</p>
<p>The keyword <code>template</code> informs the compiler that you&#8217;re about to define a template. The part in angle brackets is analogous to an argument list to a function. You can think of the keyword <code>class</code> as serving as a type name for a variable that accepts a type as a value, and of <em><code>Type</code></em> as representing a name for this variable.</p>
<p>Using <code>class</code> here doesn&#8217;t mean that <em><code>Type</code></em> must be a class; it just means that <em><code>Type</code></em> serves as a generic type specifier for which a real type will be substituted when the template is used. Newer C++ implementations allow you to use the less confusing keyword <code>typename</code> instead of <code>class</code> in this context:</p>
<p class="programlisting">template &lt;typename <span class="EmpItalic">Type</span>&gt;&#160;&#160;// newer choice</p>
<p><a id="page_832"/>You can use your choice of generic type name in the <em><code>Type</code></em> position; the name rules are the same as those for any other identifier. Popular choices include <code>T</code> and <code>Type</code>; in this case, we&#8217;ll use the latter. When a template is invoked, <em><code>Type</code></em> will be replaced with a specific type value, such as <code>int</code> or <code>string</code>. Within the template definition, you can use the generic type name to identify the type to be stored in the stack. For the <code>Stack</code> case, that would mean using <code>Type</code> wherever the old declaration formerly used the <code>typedef</code> identifier <code>Item</code>. For example,</p>
<p class="programlisting">Item items[MAX];&#160;&#160;// holds stack items</p>
<p>becomes the following:</p>
<p class="programlisting">Type items[MAX];&#160;&#160;// holds stack items</p>
<p>Similarly, you can replace the class methods of the original class with template member functions. Each function heading will be prefaced with the same template announcement:</p>
<p class="programlisting">template &lt;class Type&gt;</p>
<p>Again, you should replace the <code>typedef</code> identifier <code>Item</code> with the generic type name <code>Type</code>. One more change is that you need to change the class qualifier from <code>Stack::</code> to <code>Stack&lt;Type&gt;::</code>. For example,</p>
<p class="programlisting">bool Stack::push(const Item &#38; item)<br/>{<br/>...<br/>}</p>
<p>becomes the following:</p>
<p class="programlisting">template &lt;class Type&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// or template &lt;typename Type&gt;<br/>bool Stack&lt;Type&gt;::push(const Type &#38; item)<br/>{<br/>...<br/>}</p>
<p>If you define a method within the class declaration (an inline definition), you can omit the template preface and the class qualifier.</p>
<p><a href="#ch14ex13">Listing 14.13</a> shows the combined class and member function templates. It&#8217;s important to realize that these templates are not class and member function definitions. Rather, they are instructions to the C++ compiler about how to generate class and member function definitions. A particular actualization of a template, such as a stack class for handling <code>string</code> objects, is called an <em>instantiation</em> or a <em>specialization</em>. Placing the template member functions in a separate implementation file won&#8217;t work. (For a while, the standard did provide the keyword <code>export</code> to allow such a separate implementation file. But not many vendors implemented it. C++11 discontinues that use of <code>export</code> but reserves the <code>export</code> keyword for possible future use.) Because the templates aren&#8217;t functions, they can&#8217;t be compiled separately. Templates have to be used in conjunction with requests for particular instantiations of templates. The simplest way to make this work is to place all the template <a id="page_833"/>information in a header file and to include the header file in the file that will use the templates.</p>
<p class="caption1"><a id="ch14ex13"/><strong>Listing 14.13. <code>stacktp.h</code></strong></p><hr/>
<p class="programlisting1">// stacktp.h -- a stack template<br/>#ifndef STACKTP_H_<br/>#define STACKTP_H_<br/>template &lt;class Type&gt;<br/>class Stack<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {MAX = 10};&#160;&#160;&#160;&#160;// constant specific to class<br/>&#160;&#160;&#160;&#160;Type items[MAX];&#160;&#160;&#160;&#160;// holds stack items<br/>&#160;&#160;&#160;&#160;int top;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// index for top stack item<br/>public:<br/>&#160;&#160;&#160;&#160;Stack();<br/>&#160;&#160;&#160;&#160;bool isempty();<br/>&#160;&#160;&#160;&#160;bool isfull();<br/>&#160;&#160;&#160;&#160;bool push(const Type &#38; item); // add item to stack<br/>&#160;&#160;&#160;&#160;bool pop(Type &#38; item);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pop top into item<br/>};<br/><br/>template &lt;class Type&gt;<br/>Stack&lt;Type&gt;::Stack()<br/>{<br/>&#160;&#160;&#160;&#160;top = 0;<br/>}<br/><br/>template &lt;class Type&gt;<br/>bool Stack&lt;Type&gt;::isempty()<br/>{<br/>&#160;&#160;&#160;&#160;return top == 0;<br/>}<br/><br/>template &lt;class Type&gt;<br/>bool Stack&lt;Type&gt;::isfull()<br/>{<br/>&#160;&#160;&#160;&#160;return top == MAX;<br/>}<br/><br/>template &lt;class Type&gt;<br/>bool Stack&lt;Type&gt;::push(const Type &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (top &lt; MAX)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;items[top++] = item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/><br/>template &lt;class Type&gt;<br/>bool Stack&lt;Type&gt;::pop(Type &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (top &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;item = items[--top];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/><br/>#endif</p><hr/>
<h4 id="ch14lev2sec12">Using a Template Class</h4>
<p><a id="page_834"/>Merely including a template in a program doesn&#8217;t generate a template class. You have to ask for an instantiation. To do this, you declare an object of the template class type, replacing the generic type name with the particular type you want. For example, here&#8217;s how you would create two stacks, one for stacking <code>int</code>s and one for stacking <code>string</code> objects:</p>
<p class="programlisting">Stack&lt;int&gt; kernels;&#160;&#160;&#160;&#160;&#160;&#160;// create a stack of ints<br/>Stack&lt;string&gt; colonels;&#160;&#160;// create a stack of string objects</p>
<p>Seeing these two declarations, the compiler will follow the <code>Stack&lt;Type&gt;</code> template to generate two separate class declarations and two separate sets of class methods. The <code>Stack&lt;int&gt;</code> class declaration will replace <code>Type</code> throughout with <code>int</code>, and the <code>Stack&lt;string&gt;</code> class declaration will replace <code>Type</code> throughout with <code>string</code>. Of course, the algorithms you use have to be consistent with the types. The <code>Stack</code> class, for example, assumes that you can assign one item to another. This assumption is true for basic types, structures, and classes (unless you make the assignment operator private) but not for arrays.</p>
<p>Generic type identifiers such as <code>Type</code> in the example are called <em>type parameters</em>, meaning that they act something like variables, but instead of assigning a numeric value to a type parameter, you assign a type to it. So in the <code>kernel</code> declaration, the type parameter <code>Type</code> has the value <code>int</code>.</p>
<p>Notice that you have to provide the desired type explicitly. This is different from ordinary function templates, for which the compiler can use the argument types to a function to figure out what kind of function to generate:</p>
<p class="programlisting"><a id="page_835"/>template &lt;class T&gt;<br/>void simple(T t) { cout &lt;&lt; t &lt;&lt; '\n';}<br/>...<br/>simple(2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// generate void simple(int)<br/>simple("two");&#160;&#160;&#160;// generate void simple(const char *)</p>
<p><a href="#ch14ex14">Listing 14.14</a> modifies the original stack-testing program (<a href="ch10.html#ch10ex12">Listing 10.12</a>) to use string purchase order IDs instead of <code>unsigned long</code> values.</p>
<p class="caption1"><a id="ch14ex14"/><strong>Listing 14.14. <code>stacktem.cpp</code></strong></p><hr/>
<p class="programlisting1">// stacktem.cpp -- testing the template stack class<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>#include &lt;cctype&gt;<br/>#include "stacktp.h"<br/>using std::cin;<br/>using std::cout;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;Stack&lt;std::string&gt; st;&#160;&#160;&#160;// create an empty stack<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;std::string po;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter A to add a purchase order,\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "P to process a PO, or Q to quit.\n";<br/>&#160;&#160;&#160;&#160;while (cin &gt;&gt; ch &#38;&#38; std::toupper(ch) != 'Q')<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!std::isalpha(ch))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; '\a';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch(ch)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'A':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'a': cout &lt;&lt; "Enter a PO number to add: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; po;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (st.isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "stack already full\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.push(po);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'P':<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case 'p': if (st.isempty())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "stack already empty\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.pop(po);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "PO #" &lt;&lt; po &lt;&lt; " popped\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Please enter A to add a purchase order,\n"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "P to process a PO, or Q to quit.\n";<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_836"/>Here&#8217;s a sample run of the program in <a href="#ch14ex14">Listing 14.14</a>:</p>
<p class="programlisting">Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">A</span><br/>Enter a PO number to add: <span class="EmpStrong">red911porsche</span><br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">A</span><br/>Enter a PO number to add: <span class="EmpStrong">blueR8audi</span><br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">A</span><br/>Enter a PO number to add: <span class="EmpStrong">silver747boeing</span><br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">P</span><br/>PO #silver747boeing popped<br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">P</span><br/>PO #blueR8audi popped<br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">P</span><br/>PO #red911porsche popped<br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">P</span><br/>stack already empty<br/>Please enter A to add a purchase order,<br/>P to process a PO, or Q to quit.<br/><span class="EmpStrong">Q</span><br/>Bye</p>
<h4 id="ch14lev2sec13">A Closer Look at the Template Class</h4>
<p><a id="page_837"/>You can use a built-in type or a class object as the type for the <code>Stack&lt;Type&gt;</code> class template. What about a pointer? For example, can you use a pointer to a <code>char</code> instead of a <code>string</code> object in <a href="#ch14ex14">Listing 14.14</a>? After all, such pointers are the built-in way for handling C-style strings. The answer is that you can create a stack of pointers, but it won&#8217;t work very well without major modifications in the program. The compiler can create the class, but it&#8217;s your task to see that it&#8217;s used sensibly. Let&#8217;s see why such a stack of pointers doesn&#8217;t work very well with <a href="#ch14ex14">Listing 14.14</a>, and then let&#8217;s look at an example where a stack of pointers is useful.</p>
<h5 id="ch14lev3sec13">Using a Stack of Pointers Incorrectly</h5>
<p>Let&#8217;s quickly look at three simple, but flawed, attempts to adapt <a href="#ch14ex14">Listing 14.14</a> to use a stack of pointers. These attempts illustrate the lesson that you should keep the design of a template in mind and not just use it blindly. All three examples begin with this perfectly valid invocation of the <code>Stack&lt;Type&gt;</code> template:</p>
<p class="programlisting">Stack&lt;char *&gt; st; // create a stack for pointers-to-char</p>
<p>Version 1 then replaces</p>
<p class="programlisting">string po;</p>
<p>in <a href="#ch14ex14">listing 14.14</a> with</p>
<p class="programlisting">char * po;</p>
<p>The idea is to use a <code>char</code> pointer instead of a <code>string</code> object to receive the keyboard input. This approach fails immediately because merely creating a pointer doesn&#8217;t create space to hold the input strings. (The program would compile, but it would quite possibly crash after <code>cin</code> tried to store input in some inappropriate location.)</p>
<p>Version 2 replaces</p>
<p class="programlisting">string po;</p>
<p>with</p>
<p class="programlisting">char po[40];</p>
<p>This allocates space for an input string. Furthermore, <code>po</code> is of type <code>char *</code>, so it can be placed on the stack. But an array is fundamentally at odds with the assumptions made for the <code>pop()</code> method:</p>
<p class="programlisting">template &lt;class Type&gt;<br/>bool Stack&lt;Type&gt;::pop(Type &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (top &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;item = items[--top];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/><a id="page_838"/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}</p>
<p>First, the reference variable <code>item</code> has to refer to an lvalue of some sort, not to an array name. Second, the code assumes that you can assign to <code>item</code>. Even if <code>item</code> could refer to an array, you can&#8217;t assign to an array name. So this approach fails, too.</p>
<p>Version 3 replaces</p>
<p class="programlisting">string po;</p>
<p>with</p>
<p class="programlisting">char * po = new char[40];</p>
<p>This allocates space for an input string. Furthermore, <code>po</code> is a variable and hence compatible with the code for <code>pop()</code>. Here, however, you come up against the most fundamental problem: There is only one <code>po</code> variable, and it always points to the same memory location. True, the contents of the memory change each time a new string is read, but every push operation puts exactly the same address onto the stack. So when you pop the stack, you always get the same address back, and it always refers to the last string read into memory. In particular, the stack is not storing each new string separately as it comes in, and it serves no useful purpose.</p>
<h5 id="ch14lev3sec14">Using a Stack of Pointers Correctly</h5>
<p>One way to use a stack of pointers is to have the calling program provide an array of pointers, with each pointer pointing to a different string. Putting these pointers on a stack then makes sense because each pointer will refer to a different string. Note that it is the responsibility of the calling program, not the stack, to create the separate pointers. The stack&#8217;s job is to manage the pointers, not create them.</p>
<p>For example, suppose you have to simulate the following situation. Someone has delivered a cart of folders to Plodson. If Plodson&#8217;s in-basket is empty, he removes the top folder from the cart and places it in his in-basket. If his in-basket is full, Plodson removes the top file from the basket, processes it, and places it in his out-basket. If the in-basket is neither empty nor full, Plodson may process the top file in the in-basket, or he may take the next file from the cart and put it into his in-basket. In what he secretly regards as a bit of madcap self-expression, he flips a coin to decide which of these actions to take. You&#8217;d like to investigate the effects of his method on the original file order.</p>
<p>You can model this with an array of pointers to strings representing the files on the cart. Each string will contain the name of the person described by the file. You can use a stack to represent the in-basket, and you can use a second array of pointers to represent the out-basket. Adding a file to the in-basket is represented by pushing a pointer from the input array onto the stack, and processing a file is represented by popping an item from the stack and adding it to the out-basket.</p>
<p><a id="page_839"/>Given the importance of examining all aspects of this problem, it would be useful to be able to try different stack sizes. <a href="#ch14ex15">Listing 14.15</a> redefines the <code>Stack&lt;Type&gt;</code> class slightly so that the <code>Stack</code> constructor accepts an optional size argument. This involves using a dynamic array internally, so the class now needs a destructor, a copy constructor, and an assignment operator. Also the definition shortens the code by making several of the methods inline.</p>
<p class="caption1"><a id="ch14ex15"/><strong>Listing 14.15. <code>stcktp1.h</code></strong></p><hr/>
<p class="programlisting1">// stcktp1.h -- modified Stack template<br/>#ifndef STCKTP1_H_<br/>#define STCKTP1_H_<br/><br/>template &lt;class Type&gt;<br/>class Stack<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {SIZE = 10};&#160;&#160;&#160;&#160;// default size<br/>&#160;&#160;&#160;&#160;int stacksize;<br/>&#160;&#160;&#160;&#160;Type * items;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// holds stack items<br/>&#160;&#160;&#160;&#160;int top;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// index for top stack item<br/>public:<br/>&#160;&#160;&#160;&#160;explicit Stack(int ss = SIZE);<br/>&#160;&#160;&#160;&#160;Stack(const Stack &#38; st);<br/>&#160;&#160;&#160;&#160;~Stack() { delete [] items; }<br/>&#160;&#160;&#160;&#160;bool isempty() { return top == 0; }<br/>&#160;&#160;&#160;&#160;bool isfull() { return top == stacksize; }<br/>&#160;&#160;&#160;&#160;bool push(const Type &#38; item);&#160;&#160;&#160;// add item to stack<br/>&#160;&#160;&#160;&#160;bool pop(Type &#38; item);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pop top into item<br/>&#160;&#160;&#160;&#160;Stack &#38; operator=(const Stack &#38; st);<br/>};<br/><br/>template &lt;class Type&gt;<br/>Stack&lt;Type&gt;::Stack(int ss) : stacksize(ss), top(0)<br/>{<br/>&#160;&#160;&#160;&#160;items = new Type [stacksize];<br/>}<br/><br/>template &lt;class Type&gt;<br/>Stack&lt;Type&gt;::Stack(const Stack &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;stacksize = st.stacksize;<br/>&#160;&#160;&#160;&#160;top = st.top;<br/>&#160;&#160;&#160;&#160;items = new Type [stacksize];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; top; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;items[i] = st.items[i];<br/>}<br/><br/>template &lt;class Type&gt;<br/>bool Stack&lt;Type&gt;::push(const Type &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (top &lt; stacksize)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;items[top++] = item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/><br/>template &lt;class Type&gt;<br/>bool Stack&lt;Type&gt;::pop(Type &#38; item)<br/>{<br/>&#160;&#160;&#160;&#160;if (top &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;item = items[--top];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false;<br/>}<br/><br/>template &lt;class Type&gt;<br/>Stack&lt;Type&gt; &#38; Stack&lt;Type&gt;::operator=(const Stack&lt;Type&gt; &#38; st)<br/>{<br/>&#160;&#160;&#160;&#160;if (this == &#38;st)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return *this;<br/>&#160;&#160;&#160;&#160;delete [] items;<br/>&#160;&#160;&#160;&#160;stacksize = st.stacksize;<br/>&#160;&#160;&#160;&#160;top = st.top;<br/>&#160;&#160;&#160;&#160;items = new Type [stacksize];<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; top; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;items[i] = st.items[i];<br/>&#160;&#160;&#160;&#160;return *this;<br/>}<br/><br/>#endif</p><hr/>
<p><a id="page_840"/>Notice that the prototype declares the return type for the assignment operator function to be a reference to <code>Stack</code>, and the actual template function definition identifies the type as <code>Stack&lt;Type&gt;</code>. The former is an abbreviation for the latter, but it can be used only within the class scope. That is, you can use <code>Stack</code> inside the template declaration and inside the template function definitions, but outside the class, as when identifying return <a id="page_841"/>types and when using the scope-resolution operator, you need to use the full <code>Stack&lt;Type&gt;</code> form.</p>
<p>The program in <a href="#ch14ex16">Listing 14.16</a> uses the new stack template to implement the Plodson simulation. It uses <code>rand()</code>, <code>srand()</code>, and <code>time()</code> in the same way previous simulations have used them to generate random numbers. In this case, randomly generating a 0 or a 1 simulates the coin toss.</p>
<p class="caption1"><a id="ch14ex16"/><strong>Listing 14.16. <code>stkoptr1.cpp</code></strong></p><hr/>
<p class="programlisting1">// stkoptr1.cpp -- testing stack of pointers<br/>#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt;&#160;&#160;&#160;&#160;&#160;// for rand(), srand()<br/>#include &lt;ctime&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// for time()<br/>#include "stcktp1.h"<br/>const int Num = 10;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;std::srand(std::time(0)); // randomize rand()<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Please enter stack size: ";<br/>&#160;&#160;&#160;&#160;int stacksize;<br/>&#160;&#160;&#160;&#160;std::cin &gt;&gt; stacksize;<br/>// create an empty stack with stacksize slots<br/>&#160;&#160;&#160;&#160;Stack&lt;const char *&gt; st(stacksize);<br/><br/>// in basket<br/>&#160;&#160;&#160;&#160;const char * in[Num] = {<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" 1: Hank Gilgamesh", " 2: Kiki Ishtar",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" 3: Betty Rocker", " 4: Ian Flagranti",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" 5: Wolfgang Kibble", " 6: Portia Koop",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" 7: Joy Almondo", " 8: Xaverie Paprika",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;" 9: Juan Moore", "10: Misha Mache"<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;// out basket<br/>&#160;&#160;&#160;&#160;const char * out[Num];<br/><br/>&#160;&#160;&#160;&#160;int processed = 0;<br/>&#160;&#160;&#160;&#160;int nextin = 0;<br/>&#160;&#160;&#160;&#160;while (processed &lt; Num)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (st.isempty())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.push(in[nextin++]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (st.isfull())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.pop(out[processed++]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (std::rand() % 2&#160;&#160;&#38;&#38; nextin &lt; Num)&#160;&#160;&#160;// 50-50 chance<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.push(in[nextin++]);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;st.pop(out[processed++]);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; Num; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; out[i] &lt;&lt; std::endl;<br/><br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Bye\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_842"/>Two sample runs of the program in <a href="#ch14ex16">Listing 14.16</a> follow (note that, thanks to the randomizing feature, the final file ordering can differ quite a bit from one trial to the next, even when the stack size is kept unaltered):</p>
<p class="programlisting">Please enter stack size: <span class="EmpStrong">5</span><br/>&#160;2: Kiki Ishtar<br/>&#160;1: Hank Gilgamesh<br/>&#160;3: Betty Rocker<br/>&#160;5: Wolfgang Kibble<br/>&#160;4: Ian Flagranti<br/>&#160;7: Joy Almondo<br/>&#160;9: Juan Moore<br/>&#160;8: Xaverie Paprika<br/>&#160;6: Portia Koop<br/>10: Misha Mache<br/>Bye<br/><br/>Please enter stack size: <span class="EmpStrong">5</span><br/>&#160;3: Betty Rocker<br/>&#160;5: Wolfgang Kibble<br/>&#160;6: Portia Koop<br/>&#160;4: Ian Flagranti<br/>&#160;8: Xaverie Paprika<br/>&#160;9: Juan Moore<br/>10: Misha Mache<br/>&#160;7: Joy Almondo<br/>&#160;2: Kiki Ishtar<br/>&#160;1: Hank Gilgamesh<br/>Bye</p>
<h6 id="ch14lev4sec1">Program Notes</h6>
<p>The strings in <a href="#ch14ex16">Listing 14.16</a> never move. Pushing a string onto the stack really creates a new pointer to an existing string. That is, it creates a pointer whose value is the address of an existing string. And popping a string off the stack copies that address value into the <code>out</code> array.</p>
<p>The program uses <code>const char *</code> as a type because the array of pointers is initialized to a set of string constants.</p>
<p><a id="page_843"/>What effect does the stack destructor have on the strings? None. The class constructor uses <code>new</code> to create an array for holding pointers. The class destructor eliminates that array, not the strings to which the array elements pointed.</p>
<h4 id="ch14lev2sec14">An Array Template Example and Non-Type Arguments</h4>
<p>Templates are frequently used for container classes because the idea of type parameters matches well with the need to apply a common storage plan to a variety of types. Indeed, the desire to provide reusable code for container classes was the main motivation for introducing templates, so let&#8217;s look at another example and explore a few more facets of template design and use. In particular, let&#8217;s look at non-type, or expression, arguments and at using an array to handle an inheritance family.</p>
<p>Let&#8217;s begin with a simple array template that lets you specify an array size. One technique, which the last version of the <code>Stack</code> template uses, is to use a dynamic array within the class and a constructor argument to provide the number of elements. Another approach is to use a template argument to provide the size for a regular array. That is what the new C++11 <code>array</code> template does. <a href="#ch14ex17">Listing 14.17</a> shows a more modest version of how this can be done.</p>
<p class="caption1"><a id="ch14ex17"/><strong>Listing 14.17. <code>arraytp.h</code></strong></p><hr/>
<p class="programlisting1">//arraytp.h&#160;&#160;-- Array Template<br/>#ifndef ARRAYTP_H_<br/>#define ARRAYTP_H_<br/><br/>#include &lt;iostream&gt;<br/>#include &lt;cstdlib&gt;<br/><br/>template &lt;class T, int n&gt;<br/>class ArrayTP<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;T ar[n];<br/>public:<br/>&#160;&#160;&#160;&#160;ArrayTP() {};<br/>&#160;&#160;&#160;&#160;explicit ArrayTP(const T &#38; v);<br/>&#160;&#160;&#160;&#160;virtual T &#38; operator[](int i);<br/>&#160;&#160;&#160;&#160;virtual T operator[](int i) const;<br/>};<br/><br/>template &lt;class T, int n&gt;<br/>ArrayTP&lt;T,n&gt;::ArrayTP(const T &#38; v)<br/>{<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; n; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ar[i] = v;<br/>}<br/><br/>template &lt;class T, int n&gt;<br/>T &#38; ArrayTP&lt;T,n&gt;::operator[](int i)<br/>{<br/>&#160;&#160;&#160;&#160;if (i &lt; 0 || i &gt;= n)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cerr &lt;&lt; "Error in array limits: " &lt;&lt; i<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " is out of range\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return ar[i];<br/>}<br/><br/>template &lt;class T, int n&gt;<br/>T ArrayTP&lt;T,n&gt;::operator[](int i) const<br/>{<br/>&#160;&#160;&#160;&#160;if (i &lt; 0 || i &gt;= n)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cerr &lt;&lt; "Error in array limits: " &lt;&lt; i<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " is out of range\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::exit(EXIT_FAILURE);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return ar[i];<br/>}<br/><br/>#endif</p><hr/>
<p><a id="page_844"/>Note the template heading in <a href="#ch14ex17">Listing 14.17</a>:</p>
<p class="programlisting">template &lt;class T, int n&gt;</p>
<p>The keyword <code>class</code> (or, equivalently in this context, <code>typename</code>) identifies <code>T</code> as a type parameter, or type argument. <code>int</code> identifies <code>n</code> as being an <code>int</code> type. This second kind of parameter, one that specifies a particular type instead of acting as a generic name for a type, is called a <em>non-type</em>, or <em>expression</em>, <em>argument</em>. Suppose you have the following declaration:</p>
<p class="programlisting">ArrayTP&lt;double, 12&gt; eggweights;</p>
<p>This causes the compiler to define a class called <code>ArrayTP&lt;double,12&gt;</code> and to create an <code>eggweights</code> object of that class. When defining the class, the compiler replaces <code>T</code> with <code>double</code> and <code>n</code> with <code>12</code>.</p>
<p>Expression arguments have some restrictions. An expression argument can be an integer type, an enumeration type, a reference, or a pointer. Thus, <code>double m</code> is ruled out, but <code>double &#38; rm</code> and <code>double * pm</code> are allowed. Also the template code can&#8217;t alter the value of the argument or take its address. Thus, in the <code>ArrayTP</code> template, expressions such as <code>n++</code> or <code>&#38;n</code> would not be allowed. Also when you instantiate a template, the value used for the expression argument should be a constant expression.</p>
<p><a id="page_845"/>This approach for sizing an array has one advantage over the constructor approach used in <code>Stack</code>. The constructor approach uses heap memory managed by <code>new</code> and <code>delete</code>, whereas the expression argument approach uses the memory stack maintained for automatic variables. This provides faster execution time, particularly if you have a lot of small arrays.</p>
<p>The main drawback to the expression argument approach is that each array size generates its own template. That is, the following declarations generate two separate class declarations:</p>
<p class="programlisting">ArrayTP&lt;double, 12&gt; eggweights;<br/>ArrayTP&lt;double, 13&gt; donuts;</p>
<p>But the following declarations generate just one class declaration, and the size information is passed to the constructor for that class:</p>
<p class="programlisting">Stack&lt;int&gt; eggs(12);<br/>Stack&lt;int&gt; dunkers(13);</p>
<p>Another difference is that the constructor approach is more versatile because the array size is stored as a class member rather than being hard-coded into the definition. This makes it possible, for example, to define assignment from an array of one size to an array of another size or to build a class that allows resizable arrays.</p>
<h4 id="ch14lev2sec15">Template Versatility</h4>
<p>You can apply the same techniques to template classes as you do to regular classes. Template classes can serve as base classes, and they can be component classes. They can themselves be type arguments to other templates. For example, you can implement a stack template by using an array template. Or you can have an array template that is used to construct an array whose elements are stacks based on a stack template. That is, you can have code along the following lines:</p>
<p class="programlisting">template &lt;typename T&gt;&#160;&#160;&#160;// or &lt;class T&gt;<br/>class Array<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;T entry;<br/>&#160;&#160;&#160;&#160;...<br/>};<br/><br/>template &lt;typename Type&gt;<br/>class GrowArray : public Array&lt;Type&gt; {...};&#160;&#160;// inheritance<br/><br/>template &lt;typename Tp&gt;<br/>class Stack<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;Array&lt;Tp&gt; ar;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use an Array&lt;&gt; as a component<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/><a id="page_846"/>};<br/>...<br/>Array &lt; Stack&lt;int&gt; &gt; asi;&#160;&#160;// an array of stacks of int</p>
<p>In the last statement, C++98 required separating the two <code>&gt;</code> symbols by at least one white space character in order to avoid confusion with the <code>&gt;&gt;</code> operator. C++11 removes this requirement.</p>
<h5 id="ch14lev3sec15">Using a Template Recursively</h5>
<p>Another example of template versatility is that you can use templates recursively. For example, given the earlier definition of an array template, you can use it as follows:</p>
<p class="programlisting">ArrayTP&lt; ArrayTP&lt;int,5&gt;, 10&gt; twodee;</p>
<p>This makes <code>twodee</code> an array of 10 elements, each of which is an array of five <code>int</code>s. The equivalent ordinary array would have this declaration:</p>
<p class="programlisting">int twodee[10][5];</p>
<p>Note that the syntax for templates presents the dimensions in the opposite order from that of the equivalent ordinary two-dimensional array. The program in <a href="#ch14ex18">Listing 14.18</a> tries this idea. It also uses the <code>ArrayTP</code> template to create one-dimensional arrays to hold the sum and average value of each of the 10 sets of five numbers. The method call <code>cout.width(2)</code> causes the next item to be displayed to use a field width of two characters, unless a larger width is needed to show the whole number.</p>
<p class="caption1"><a id="ch14ex18"/><strong>Listing 14.18. <code>twod.cpp</code></strong></p><hr/>
<p class="programlisting1">// twod.cpp -- making a 2-d array<br/>#include &lt;iostream&gt;<br/>#include "arraytp.h"<br/>int main(void)<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;ArrayTP&lt;int, 10&gt; sums;<br/>&#160;&#160;&#160;&#160;ArrayTP&lt;double, 10&gt; aves;<br/>&#160;&#160;&#160;&#160;ArrayTP&lt; ArrayTP&lt;int,5&gt;, 10&gt; twodee;<br/><br/><br/>&#160;&#160;&#160;&#160;int i, j;<br/><br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; 10; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sums[i] = 0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; 5; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;twodee[i][j] = (i + 1) * (j + 1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sums[i] += twodee[i][j];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;aves[i] = (double) sums[i] / 10;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;for (i = 0; i &lt; 10; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (j = 0; j &lt; 5; j++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(2);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; twodee[i][j] &lt;&lt; ' ';<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ": sum = ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout.width(3);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout&#160;&#160;&lt;&lt; sums[i] &lt;&lt; ", average = " &lt;&lt; aves[i] &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_847"/>The output of the program in <a href="#ch14ex18">Listing 14.18</a> has one line for each of the 10 elements of <code>twodee</code>, each of which is a five-element array. Each line shows the values, sum, and average of an element of <code>twodee</code>:</p>
<p class="programlisting">&#160;1&#160;&#160;2&#160;&#160;3&#160;&#160;4&#160;&#160;5 : sum =&#160;&#160;15, average = 1.5<br/>&#160;2&#160;&#160;4&#160;&#160;6&#160;&#160;8 10 : sum =&#160;&#160;30, average = 3<br/>&#160;3&#160;&#160;6&#160;&#160;9 12 15 : sum =&#160;&#160;45, average = 4.5<br/>&#160;4&#160;&#160;8 12 16 20 : sum =&#160;&#160;60, average = 6<br/>&#160;5 10 15 20 25 : sum =&#160;&#160;75, average = 7.5<br/>&#160;6 12 18 24 30 : sum =&#160;&#160;90, average = 9<br/>&#160;7 14 21 28 35 : sum = 105, average = 10.5<br/>&#160;8 16 24 32 40 : sum = 120, average = 12<br/>&#160;9 18 27 36 45 : sum = 135, average = 13.5<br/>10 20 30 40 50 : sum = 150, average = 15<br/>Done.</p>
<h5 id="ch14lev3sec16">Using More Than One Type Parameter</h5>
<p>You can have a template with more than one type parameter. For example, suppose you want a class that holds two kinds of values. You can create and use a <code>Pair</code> template class for holding two disparate values. (Incidentally, the STL provides a similar template called <code>pair</code>.) The short program in <a href="#ch14ex19">Listing 14.19</a> shows an example. In it, the <code>first() const</code> and <code>second() const</code> methods report the stored values, and the <code>first()</code> and <code>second()</code> methods, by virtue of returning references to the <code>Pair</code> data members, allow you to reset the stored values by using assignment.</p>
<p class="caption1"><a id="page_848"/><a id="ch14ex19"/><strong>Listing 14.19. <code>pairs.cpp</code></strong></p><hr/>
<p class="programlisting1">// pairs.cpp -- defining and using a Pair template<br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/>template &lt;class T1, class T2&gt;<br/>class Pair<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;T1 a;<br/>&#160;&#160;&#160;&#160;T2 b;<br/>public:<br/>&#160;&#160;&#160;&#160;T1 &#38; first();<br/>&#160;&#160;&#160;&#160;T2 &#38; second();<br/>&#160;&#160;&#160;&#160;T1 first() const { return a; }<br/>&#160;&#160;&#160;&#160;T2 second() const { return b; }<br/>&#160;&#160;&#160;&#160;Pair(const T1 &#38; aval, const T2 &#38; bval) : a(aval), b(bval) { }<br/>&#160;&#160;&#160;&#160;Pair() {}<br/>};<br/><br/>template&lt;class T1, class T2&gt;<br/>T1 &#38; Pair&lt;T1,T2&gt;::first()<br/>{<br/>&#160;&#160;&#160;&#160;return a;<br/>}<br/>template&lt;class T1, class T2&gt;<br/>T2 &#38; Pair&lt;T1,T2&gt;::second()<br/>{<br/>&#160;&#160;&#160;&#160;return b;<br/>}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;using std::string;<br/>&#160;&#160;&#160;&#160;Pair&lt;string, int&gt; ratings[4] =<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Pair&lt;string, int&gt;("The Purpled Duck", 5),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Pair&lt;string, int&gt;("Jaquie's Frisco Al Fresco", 4),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Pair&lt;string, int&gt;("Cafe Souffle", 5),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Pair&lt;string, int&gt;("Bertie's Eats", 3)<br/>&#160;&#160;&#160;&#160;};<br/><br/>&#160;&#160;&#160;&#160;int joints = sizeof(ratings) / sizeof (Pair&lt;string, int&gt;);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Rating:\t Eatery\n";<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; joints; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ratings[i].second() &lt;&lt; ":\t "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ratings[i].first() &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Oops! Revised rating:\n";<br/>&#160;&#160;&#160;&#160;ratings[3].first() = "Bertie's Fab Eats";<br/>&#160;&#160;&#160;&#160;ratings[3].second() = 6;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ratings[3].second() &lt;&lt; ":\t "<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ratings[3].first() &lt;&lt; endl;<br/>&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_849"/>One thing to note about <a href="#ch14ex19">Listing 14.19</a> is that in <code>main()</code>, you have to use <code>Pair&lt;string,int&gt;</code> to invoke the constructors and as an argument for <code>sizeof</code>. That&#8217;s because <code>Pair&lt;string,int&gt;</code> and not <code>Pair</code> is the class name. Also <code>Pair&lt;char *,double&gt;</code> would be the name of an entirely different class.</p>
<p>Here&#8217;s the output of the program in <a href="#ch14ex19">Listing 14.19</a>:</p>
<p class="programlisting">Rating:&#160;&#160;Eatery<br/>5:&#160;&#160;&#160;&#160;&#160;&#160;&#160;The Purpled Duck<br/>4:&#160;&#160;&#160;&#160;&#160;&#160;&#160;Jaquie's Frisco Al Fresco<br/>5:&#160;&#160;&#160;&#160;&#160;&#160;&#160;Cafe Souffle<br/>3:&#160;&#160;&#160;&#160;&#160;&#160;&#160;Bertie's Eats<br/>Oops! Revised rating:<br/>6:&#160;&#160;&#160;&#160;&#160;&#160;&#160;Bertie's Fab Eats</p>
<h5 id="ch14lev3sec17">Default Type Template Parameters</h5>
<p>Another new class template feature is that you can provide default values for type parameters:</p>
<p class="programlisting">template &lt;class T1, class T2 = int&gt; class Topo {...};</p>
<p>This causes the compiler to use <code>int</code> for the type <code>T2</code> if a value for <code>T2</code> is omitted:</p>
<p class="programlisting">Topo&lt;double, double&gt; m1; // T1 is double, T2 is double<br/>Topo&lt;double&gt; m2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// T1 is double, T2 is int</p>
<p>The STL (discussed in <a href="ch16.html#ch16">Chapter 16</a>) often uses this feature, with the default type being a class.</p>
<p>Although you can provide default values for class template type parameters, you can&#8217;t do so for function template parameters. However, you can provide default values for non-type parameters for both class and function templates.</p>
<h4 id="ch14lev2sec16">Template Specializations</h4>
<p>Class templates are like function templates in that you can have implicit instantiations, explicit instantiations, and explicit specializations, collectively known as <em>specializations</em>. <a id="page_850"/>That is, a template describes a class in terms of a general type, whereas a specialization is a class declaration generated by using a specific type.</p>
<h5 id="ch14lev3sec18">Implicit Instantiations</h5>
<p>The template examples you have seen so far in this chapter use <em>implicit instantiations</em>. That is, they declare one or more objects indicating the desired type, and the compiler generates a specialized class definition, using the recipe provided by the general template:</p>
<p class="programlisting">ArrayTP&lt;int, 100&gt; stuff; // implicit instantiation</p>
<p>The compiler doesn&#8217;t generate an implicit instantiation of the class until it needs an object:</p>
<p class="programlisting">ArrayTP&lt;double, 30&gt; * pt;&#160;&#160;&#160;&#160;&#160;// a pointer, no object needed yet<br/>pt = new ArrayTP&lt;double, 30&gt;; // now an object is needed</p>
<p>The second statement causes the compiler to generate a class definition and also an object that is created according to that definition.</p>
<h5 id="ch14lev3sec19">Explicit Instantiations</h5>
<p>The compiler generates an <em>explicit instantiation</em> of a class declaration when you declare a class by using the keyword <code>template</code> and indicating the desired type or types. The declaration should be in the same namespace as the template definition. For example, the following declaration declares <code>ArrayTP&lt;string, 100&gt;</code> to be a class:</p>
<p class="programlisting">template class ArrayTP&lt;string, 100&gt;; // generate ArrayTP&lt;string, 100&gt; class</p>
<p>In this case, the compiler generates the class definition, including method definitions, even though no object of the class has yet been created or mentioned. Just as with the implicit instantiation, the general template is used as a guide to generate the specialization.</p>
<h5 id="ch14lev3sec20">Explicit Specializations</h5>
<p>An <em>explicit specialization</em> is a definition for a particular type or types that is to be used instead of the general template. Sometimes you might need or want to modify a template to behave differently when instantiated for a particular type; in that case, you can create an explicit specialization. Suppose, for example, that you&#8217;ve defined a template for a class that represents a sorted array for which items are sorted as they are added to the array:</p>
<p class="programlisting">template &lt;typename T&gt;<br/>class SortedArray<br/>{<br/>&#160;&#160;&#160;&#160;&#160;...// details omitted<br/>};</p>
<p>Also suppose the template uses the <code>&gt;</code> operator to compare values. This works well for numbers. It will work if <code>T</code> represents a class type, too, provided that you&#8217;ve defined a <code>T::operator&gt;()</code> method. But it won&#8217;t work if <code>T</code> is a string represented by type <code>const char *</code>. Actually, the template will work, but the strings will wind up sorted by address <a id="page_851"/>rather than alphabetically. What is needed is a class definition that uses <code>strcmp()</code> instead of <code>&gt;</code>. In such a case, you can provide an explicit template specialization. This takes the form of a template defined for one specific type instead of for a general type. When faced with the choice of a specialized template and a general template that both match an instantiation request, the compiler uses the specialized version.</p>
<p>A specialized class template definition has the following form:</p>
<p class="programlisting">template &lt;&gt; class <span class="EmpItalic">Classname</span>&lt;<span class="EmpItalic">specialized-type-name</span>&gt; { ... };</p>
<p>Older compilers may only recognize the older form, which dispenses with the <code>template &lt;&gt;</code> prefix:</p>
<p class="programlisting">class <span class="EmpItalic">Classname</span>&lt;<span class="EmpItalic">specialized-type-name</span>&gt; { ... };</p>
<p>To provide a <code>SortedArray</code> template specialized for the <code>const char *</code> type, using the current notation, you would use code like the following:</p>
<p class="programlisting">template &lt;&gt; class SortedArray&lt;const char char *&gt;<br/>{<br/>&#160;&#160;&#160;&#160;&#160;...// details omitted<br/>};</p>
<p>Here the implementation code would use <code>strcmp()</code> instead of <code>&gt;</code> to compare array values. Now, requests for a <code>SortedArray</code> template of <code>const char *</code> will use this specialized definition instead of the more general template definition:</p>
<p class="programlisting">SortedArray&lt;int&gt; scores;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use general definition<br/>SortedArray&lt;const char *&gt; dates;&#160;&#160;// use specialized definition</p>
<h5 id="ch14lev3sec21">Partial Specializations</h5>
<p>C++ allows for <em>partial specializations</em>, which partially restrict the generality of a template. For example, a partial specialization can provide a specific type for one of the type parameters:</p>
<p class="programlisting">// general template<br/>&#160;&#160;&#160;&#160;template &lt;class T1, class T2&gt; class Pair {...};<br/>// specialization with T2 set to int<br/>&#160;&#160;&#160;&#160;template &lt;class T1&gt; class Pair&lt;T1, int&gt; {...};</p>
<p>The <code>&lt;&gt;</code> following the keyword <code>template</code> declares the type parameters that are still unspecialized. So the second declaration specializes <code>T2</code> to <code>int</code> but leaves <code>T1</code> open. Note that specifying all the types leads to an empty bracket pair and a complete explicit specialization:</p>
<p class="programlisting">// specialization with T1 and T2 set to int<br/>&#160;&#160;&#160;&#160;template &lt;&gt; class Pair&lt;int, int&gt; {...};</p>
<p>The compiler uses the most specialized template if there is a choice. Here&#8217;s what would happen given the preceding three templates:</p>
<p class="programlisting"><a id="page_852"/>Pair&lt;double, double&gt; p1; // use general Pair template<br/>Pair&lt;double, int&gt; p2;&#160;&#160;&#160;&#160;// use Pair&lt;T1, int&gt; partial specialization<br/>Pair&lt;int, int&gt; p3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use Pair&lt;int, int&gt; explicit specialization</p>
<p>Or you can partially specialize an existing template by providing a special version for pointers:</p>
<p class="programlisting">template&lt;class T&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// general version<br/>class Feeb { ... };<br/>template&lt;class T*&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pointer partial specialization<br/>class Feeb { ... };&#160;&#160;&#160;&#160;&#160;&#160;// modified code</p>
<p>If you provide a non-pointer type, the compiler uses the general version; if you provide a pointer, the compiler uses the pointer specialization:</p>
<p class="programlisting">Feeb&lt;char&gt; fb1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use general Feeb template, T is char<br/>Feeb&lt;char *&gt; fb2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use Feeb T* specialization, T is char</p>
<p>Without the partial specialization, the second declaration would use the general template, interpreting <code>T</code> as type <code>char *</code>. With the partial specialization, it uses the specialized template, interpreting <code>T</code> as <code>char</code>.</p>
<p>The partial specialization feature allows for making a variety of restrictions. For example, you can use the following:</p>
<p class="programlisting">// general template<br/>&#160;&#160;&#160;&#160;template &lt;class T1, class T2, class T3&gt; class Trio{...};<br/>// specialization with T3 set to T2<br/>&#160;&#160;&#160;&#160;template &lt;class T1, class T2&gt; class Trio&lt;T1, T2, T2&gt; {...};<br/>// specialization with T3 and T2 set to T1*<br/>&#160;&#160;&#160;&#160;template &lt;class T1&gt; class Trio&lt;T1, T1*, T1*&gt; {...};</p>
<p>Given these declarations, the compiler would make the following choices:</p>
<p class="programlisting">Trio&lt;int, short, char *&gt; t1; // use general template<br/>Trio&lt;int, short&gt; t2; // use Trio&lt;T1, T2, T2&gt;<br/>Trio&lt;char, char *, char *&gt; t3; use Trio&lt;T1, T1*, T1*&gt;</p>
<h4 id="ch14lev2sec17">Member Templates</h4>
<p>A template can be a member of a structure, class, or template class. The STL requires this feature to fully implement its design. <a href="#ch14ex20">Listing 14.20</a> provides a short example of a template class with a nested template class and a template function as members.</p>
<p class="caption1"><a id="ch14ex20"/><strong>Listing 14.20. <code>tempmemb.cpp</code></strong></p><hr/>
<p class="programlisting1">// tempmemb.cpp -- template members<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>using std::endl;<br/><br/>template &lt;typename T&gt;<br/>class beta<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;template &lt;typename V&gt;&#160;&#160;// nested template class member<br/>&#160;&#160;&#160;&#160;class hold<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V val;<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hold(V v&#160;&#160;= 0) : val(v) {}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void show() const { cout &lt;&lt; val &lt;&lt; endl; }<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V Value() const { return val; }<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;hold&lt;T&gt; q;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template object<br/>&#160;&#160;&#160;&#160;hold&lt;int&gt; n;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template object<br/>public:<br/>&#160;&#160;&#160;&#160;beta( T t, int i) : q(t), n(i) {}<br/>&#160;&#160;&#160;&#160;template&lt;typename U&gt;&#160;&#160;&#160;// template method<br/>&#160;&#160;&#160;&#160;U blab(U u, T t) { return (n.Value() + q.Value()) * u / t; }<br/>&#160;&#160;&#160;&#160;void Show() const { q.show(); n.show();}<br/>};<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;beta&lt;double&gt; guy(3.5, 3);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "T was set to double\n";<br/>&#160;&#160;&#160;&#160;guy.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "V was set to T, which is double, then V was set to int\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; guy.blab(10, 2.3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "U was set to int\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; guy.blab(10.0, 2.3) &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "U was set to double\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_853"/>The <code>hold</code> template is declared in the private section in <a href="#ch14ex20">Listing 14.20</a>, so it is accessible only within the <code>beta</code> class scope. The <code>beta</code> class uses the <code>hold</code> template to declare two data members:</p>
<p class="programlisting">hold&lt;T&gt; q;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template object<br/>hold&lt;int&gt; n;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// template object</p>
<p><a id="page_854"/><code>n</code> is a <code>hold</code> object based on the <code>int</code> type, and the <code>q</code> member is a <code>hold</code> object based on the <code>T</code> type (the <code>beta</code> template parameter). In <code>main()</code>, the following declaration makes <code>T</code> represent <code>double</code>, making <code>q</code> type <code>hold&lt;double&gt;</code>:</p>
<p class="programlisting">beta&lt;double&gt; guy(3.5, 3);</p>
<p>The <code>blab()</code> method has one type (<code>U</code>) that is determined implicitly by the argument value when the method is called and one type (<code>T</code>) that is determined by the instantiation type of the object. In this example, the declaration for <code>guy</code> sets <code>T</code> to type <code>double</code>, and the first argument in the method call in the following sets <code>U</code> to type <code>int</code>, matching the value <code>10</code>:</p>
<p class="programlisting">cout &lt;&lt; guy.blab(10, 2.5) &lt;&lt; endl;</p>
<p>Thus, although the automatic type conversions brought about by mixed types cause the calculation in <code>blab()</code> to be done as type <code>double</code>, the return value, being type <code>U</code>, is an <code>int</code>. Hence, it is truncated to <code>28</code>, as the following program output shows:</p>
<p class="programlisting">T was set to double<br/>3.5<br/>3<br/>V was set to T, which is double, then V was set to int<br/>28<br/>U was set to int<br/>28.2609<br/>U was set to double<br/>Done</p>
<p>Note that replacing <code>10</code> with <code>10.0</code> in the call to <code>guy.blab()</code> causes <code>U</code> to be set to <code>double</code>, making the return type <code>double</code>, which is reflected in <code>28.2609</code> being displayed.</p>
<p>As mentioned previously, the type of the second parameter is set to <code>double</code> by the declaration of the <code>guy</code> object. Unlike the first parameter, then, the type of the second parameter is not set by the function call. For instance, the following statement would still implement <code>blah()</code> as <code>blah(int, double)</code>, and the <code>3</code> would be converted to type <code>double</code> by the usual function prototype rules:</p>
<p class="programlisting">cout &lt;&lt; guy.blab(10, 3) &lt;&lt; endl;</p>
<p>You can declare the <code>hold</code> class and <code>blah</code> method in the <code>beta</code> template and define them outside the <code>beta</code> template. However, sufficiently old compilers won&#8217;t accept template members at all, and others that accept them as shown in <a href="#ch14ex20">Listing 14.20</a> don&#8217;t accept definitions outside the class. However, if your compiler is willing and able, here&#8217;s how defining the template methods outside the <code>beta</code> template would look:</p>
<p class="programlisting">template &lt;typename T&gt;<br/>class beta<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;template &lt;typename V&gt;&#160;&#160;// declaration<br/><a id="page_855"/>&#160;&#160;&#160;&#160;class hold;<br/>&#160;&#160;&#160;&#160;hold&lt;T&gt; q;<br/>&#160;&#160;&#160;&#160;hold&lt;int&gt; n;<br/>public:<br/>&#160;&#160;&#160;&#160;beta( T t, int i) : q(t), n(i) {}<br/>&#160;&#160;&#160;&#160;template&lt;typename U&gt;&#160;&#160;&#160;// declaration<br/>&#160;&#160;&#160;&#160;U blab(U u, T t);<br/>&#160;&#160;&#160;&#160;void Show() const { q.show(); n.show();}<br/>};<br/><br/>// member definition<br/>template &lt;typename T&gt;<br/>&#160;&#160;template&lt;typename V&gt;<br/>&#160;&#160;&#160;&#160;class beta&lt;T&gt;::hold<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V val;<br/>&#160;&#160;&#160;&#160;public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hold(V v&#160;&#160;= 0) : val(v) {}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;void show() const { std::cout &lt;&lt; val &lt;&lt; std::endl; }<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V Value() const { return val; }<br/>&#160;&#160;&#160;&#160;};<br/><br/>// member definition<br/>template &lt;typename T&gt;<br/>&#160;&#160;template &lt;typename U&gt;<br/>&#160;&#160;&#160;&#160;U beta&lt;T&gt;::blab(U u, T t)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return (n.Value() + q.Value()) * u / t;<br/>&#160;&#160;&#160;&#160;}</p>
<p>The definitions have to identify <code>T</code>, <code>V</code>, and <code>U</code> as template parameters. Because the templates are nested, you have to use the</p>
<p class="programlisting">template &lt;typename T&gt;<br/>&#160;&#160;template &lt;typename V&gt;</p>
<p>syntax instead of this syntax:</p>
<p class="programlisting">template&lt;typename T, typename V&gt;</p>
<p>The definitions also must indicate that <code>hold</code> and <code>blab</code> are members of the <code>beta&lt;T&gt;</code> class, and they use the scope-resolution operator to do so.</p>
<h4 id="ch14lev2sec18">Templates As Parameters</h4>
<p>You&#8217;ve seen that a template can have type parameters, such as <code>typename T</code>, and non-type parameters, such as <code>int n</code>. A template can also have a parameter that is itself a <a id="page_856"/>template. Such parameters are yet another template feature addition that is used to implement the STL.</p>
<p><a href="#ch14ex21">Listing 14.21</a> shows an example that begins with these lines:</p>
<p class="programlisting">template &lt;template &lt;typename T&gt; class Thing&gt;<br/>class Crab</p>
<p>The template parameter is <code>template &lt;typename T&gt; class Thing</code>. Here <code>template &lt;typename T&gt; class</code> is the type, and <code>Thing</code> is the parameter. What does this imply? Suppose you have this declaration:</p>
<p class="programlisting">Crab&lt;King&gt; legs;</p>
<p>For this to be accepted, the template argument <code>King</code> has to be a template class whose declaration matches that of the template parameter <code>Thing</code>:</p>
<p class="programlisting">template &lt;typename T&gt;<br/>class King {...};</p>
<p>The <code>Crab</code> declaration in <a href="#ch14ex21">Listing 14.21</a> declares two objects:</p>
<p class="programlisting">Thing&lt;int&gt; s1;<br/>Thing&lt;double&gt; s2;</p>
<p>The previous declaration for <code>legs</code> would then result in substituting <code>King&lt;int&gt;</code> for <code>Thing&lt;int&gt;</code> and <code>King&lt;double&gt;</code> for <code>Thing&lt;double&gt;</code>. However, <a href="#ch14ex21">Listing 14.21</a> has this declaration:</p>
<p class="programlisting">Crab&lt;Stack&gt; nebula;</p>
<p>Hence, in this case, <code>Thing&lt;int&gt;</code> is instantiated as <code>Stack&lt;int&gt;</code>, and <code>Thing&lt;double&gt;</code> is instantiated as <code>Stack&lt;double&gt;</code>. In short, the template parameter <code>Thing</code> is replaced by whatever template type is used as a template argument in declaring a <code>Crab</code> object.</p>
<p>The <code>Crab</code> class declaration makes three further assumptions about the template class represented by <code>Thing</code>. The class should have a <code>push()</code> method, the class should have a <code>pop()</code> method, and these methods should have a particular interface. The <code>Crab</code> class can use any template class that matches the <code>Thing</code> type declaration and that has the prerequisite <code>push()</code> and <code>pop()</code> methods. This chapter happens to have one such class, the <code>Stack</code> template defined in <code>stacktp.h</code>, so the example uses that class.</p>
<p class="caption1"><a id="ch14ex21"/><strong>Listing 14.21. <code>tempparm.cpp</code></strong></p><hr/>
<p class="programlisting1">// tempparm.cpp &#8211; templates as parameters<br/>#include &lt;iostream&gt;<br/>#include "stacktp.h"<br/><br/>template &lt;template &lt;typename T&gt; class Thing&gt;<br/>class Crab<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;Thing&lt;int&gt; s1;<br/>&#160;&#160;&#160;&#160;Thing&lt;double&gt; s2;<br/>public:<br/>&#160;&#160;&#160;&#160;Crab() {};<br/>&#160;&#160;&#160;&#160;// assumes the thing class has push() and pop() members<br/>&#160;&#160;&#160;&#160;bool push(int a, double x) { return s1.push(a) &#38;&#38; s2.push(x); }<br/>&#160;&#160;&#160;&#160;bool pop(int &#38; a, double &#38; x){ return s1.pop(a) &#38;&#38; s2.pop(x); }<br/>};<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/>&#160;&#160;&#160;&#160;Crab&lt;Stack&gt; nebula;<br/>// Stack must match template &lt;typename T&gt; class thing<br/>&#160;&#160;&#160;&#160;int ni;<br/>&#160;&#160;&#160;&#160;double nb;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter int double pairs, such as 4 3.5 (0 0 to end):\n";<br/>&#160;&#160;&#160;&#160;while (cin&gt;&gt; ni &gt;&gt; nb &#38;&#38; ni &gt; 0 &#38;&#38; nb &gt; 0)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (!nebula.push(ni, nb))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;}<br/><br/>&#160;&#160;&#160;&#160;while (nebula.pop(ni, nb))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ni &lt;&lt; ", " &lt;&lt; nb &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Done.\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_857"/>Here is a sample run of the program in <a href="#ch14ex21">Listing 14.21</a>:</p>
<p class="programlisting">Enter int double pairs, such as 4 3.5 (0 0 to end):<br/><span class="EmpStrong">50 22.48</span><br/><span class="EmpStrong">25 33.87</span><br/><span class="EmpStrong">60 19.12</span><br/><span class="EmpStrong">0 0</span><br/>60, 19.12<br/>25, 33.87<br/>50, 22.48<br/>Done.</p>
<p>You can mix template parameters with regular parameters. For example, the <code>Crab</code> class declaration could start out like this:</p>
<p class="programlisting">template &lt;template &lt;typename T&gt; class Thing, typename U, typename V&gt;<br/>class Crab<br/><a id="page_858"/>{<br/>private:<br/>&#160;&#160;&#160;&#160;Thing&lt;U&gt; s1;<br/>&#160;&#160;&#160;&#160;Thing&lt;V&gt; s2;<br/>...</p>
<p>Now the types to be stored in the members <code>s1</code> and <code>s2</code> are generic types instead of hard-coded types. This would require the declaration of <code>nebula</code> in the program to be changed to this:</p>
<p class="programlisting">Crab&lt;Stack, int, double&gt; nebula; // T=Stack, U=int, V=double</p>
<p>The <code>template</code> parameter <code>T</code> represents a template type, and the type parameters <code>U</code> and <code>V</code> represent non-template types.</p>
<h4 id="ch14lev2sec19">Template Classes and Friends</h4>
<p>Template class declarations can have friends, too. You can classify friends of templates into three categories:</p>
<p class="indenthandingB">&#8226; Non-template friends</p>
<p class="indenthandingB">&#8226; Bound template friends, meaning the type of the friend is determined by the type of the class when a class is instantiated</p>
<p class="indenthandingB">&#8226; Unbound template friends, meaning that all specializations of the friend are friends to each specialization of the class</p>
<p>Let&#8217;s look at examples of each.</p>
<h5 id="ch14lev3sec22">Non-Template Friend Functions to Template Classes</h5>
<p>Let&#8217;s declare an ordinary function in a template class as a friend:</p>
<p class="programlisting">template &lt;class T&gt;<br/>class HasFriend<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;friend void counts();&#160;&#160;&#160;&#160;&#160;// friend to all HasFriend instantiations<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>This declaration makes the <code>counts()</code> function a friend to all possible instantiations of the template. For example, it would be a friend to the <code>HasFriend&lt;int&gt;</code> class and the <code>HasFriend&lt;string&gt;</code> class.</p>
<p>The <code>counts()</code> function is not invoked by an object (it&#8217;s a friend, not a member function), and it has no object parameters, so how does it access a <code>HasFriend</code> object? There are several possibilities. It could access a global object; it could access nonglobal objects by using a global pointer; it could create its own objects; and it could access static data members of a template class, which exist separately from an object.</p>
<p><a id="page_859"/>Suppose you want to provide a template class argument to a friend function. Can you have a friend declaration like this, for example?</p>
<p class="programlisting">friend void report(HasFriend &#38;);&#160;&#160;&#160;// possible?</p>
<p>The answer is no. The reason is that there is no such thing as a <code>HasFriend</code> object. There are only particular specializations, such as <code>HasFriend&lt;short&gt;</code>. To provide a template class argument, then, you have to indicate a specialization. For example, you can use this:</p>
<p class="programlisting">template &lt;class T&gt;<br/>class HasFriend<br/>{<br/>&#160;&#160;&#160;&#160;friend void report(HasFriend&lt;T&gt; &#38;); // bound template friend<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>To understand what this does, imagine the specialization produced if you declare an object of a particular type:</p>
<p class="programlisting">HasFriend&lt;int&gt; hf;</p>
<p>The compiler would replace the template parameter <code>T</code> with <code>int</code>, giving the friend declaration this form:</p>
<p class="programlisting">class HasFriend&lt;int&gt;<br/>{<br/>&#160;&#160;&#160;&#160;friend void report(HasFriend&lt;int&gt; &#38;); // bound template friend<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p>That is, <code>report()</code> with a <code>HasFriend&lt;int&gt;</code> parameter becomes a friend to the <code>HasFriend&lt;int&gt;</code> class. Similarly, <code>report()</code> with a <code>HasFriend&lt;double&gt;</code> parameter would be an overloaded version of <code>report()</code> that is a friend to the <code>HasFriend&lt;double&gt;</code> class.</p>
<p>Note that <code>report()</code> is not itself a template function; it just has a parameter that is a template. This means that you have to define explicit specializations for the friends you plan to use:</p>
<p class="programlisting">void report(HasFriend&lt;short&gt; &#38;) {...}; // explicit specialization for short<br/>void report(HasFriend&lt;int&gt; &#38;) {...};&#160;&#160;&#160;// explicit specialization for int</p>
<p><a href="#ch14ex22">Listing 14.22</a> illustrates these points. The <code>HasFriend</code> template has a static member <code>ct</code>. Note that this means that each particular specialization of the class has its own static member. The <code>counts()</code> method, which is a friend to all <code>HasFriend</code> specializations, reports the value of <code>ct</code> for two particular specializations: <code>HasFriend&lt;int&gt;</code> and <code>HasFriend&lt;double&gt;</code>. The program also provides two <code>report()</code> functions, each of which is a friend to one particular <code>HasFriend</code> specialization.</p>
<p class="caption1"><a id="page_860"/><a id="ch14ex22"/><strong>Listing 14.22. <code>frnd2tmp.cpp</code></strong></p><hr/>
<p class="programlisting1">// frnd2tmp.cpp -- template class with non-template friends<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>using std::endl;<br/><br/>template &lt;typename T&gt;<br/>class HasFriend<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;T item;<br/>&#160;&#160;&#160;&#160;static int ct;<br/>public:<br/>&#160;&#160;&#160;&#160;HasFriend(const T &#38; i) : item(i) {ct++;}<br/>&#160;&#160;&#160;&#160;~HasFriend()&#160;&#160;{ct--; }<br/>&#160;&#160;&#160;&#160;friend void counts();<br/>&#160;&#160;&#160;&#160;friend void reports(HasFriend&lt;T&gt; &#38;); // template parameter<br/>};<br/><br/>// each specialization has its own static data member<br/>template &lt;typename T&gt;<br/>int HasFriend&lt;T&gt;::ct = 0;<br/><br/>// non-template friend to all HasFriend&lt;T&gt; classes<br/>void counts()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "int count: " &lt;&lt; HasFriend&lt;int&gt;::ct &lt;&lt; "; ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "double count: " &lt;&lt; HasFriend&lt;double&gt;::ct &lt;&lt; endl;<br/>}<br/><br/>// non-template friend to the HasFriend&lt;int&gt; class<br/>void reports(HasFriend&lt;int&gt; &#38; hf)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;"HasFriend&lt;int&gt;: " &lt;&lt; hf.item &lt;&lt; endl;<br/>}<br/><br/>// non-template friend to the HasFriend&lt;double&gt; class<br/>void reports(HasFriend&lt;double&gt; &#38; hf)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt;"HasFriend&lt;double&gt;: " &lt;&lt; hf.item &lt;&lt; endl;<br/>}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "No objects declared: ";<br/>&#160;&#160;&#160;&#160;counts();<br/>&#160;&#160;&#160;&#160;HasFriend&lt;int&gt; hfi1(10);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After hfi1 declared: ";<br/>&#160;&#160;&#160;&#160;counts();<br/>&#160;&#160;&#160;&#160;HasFriend&lt;int&gt; hfi2(20);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After hfi2 declared: ";<br/>&#160;&#160;&#160;&#160;counts();<br/>&#160;&#160;&#160;&#160;HasFriend&lt;double&gt; hfdb(10.5);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "After hfdb declared: ";<br/>&#160;&#160;&#160;&#160;counts();<br/>&#160;&#160;&#160;&#160;reports(hfi1);<br/>&#160;&#160;&#160;&#160;reports(hfi2);<br/>&#160;&#160;&#160;&#160;reports(hfdb);<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_861"/>Some compilers will warn about using a non-template friend. Here is the output of the program in <a href="#ch14ex22">Listing 14.22</a>:</p>
<p class="programlisting">No objects declared: int count: 0; double count: 0<br/>After hfi1 declared: int count: 1; double count: 0<br/>After hfi2 declared: int count: 2; double count: 0<br/>After hfdb declared: int count: 2; double count: 1<br/>HasFriend&lt;int&gt;: 10<br/>HasFriend&lt;int&gt;: 20<br/>HasFriend&lt;double&gt;: 10.5</p>
<h5 id="ch14lev3sec23">Bound Template Friend Functions to Template Classes</h5>
<p>You can modify the preceding example by making the friend functions templates themselves. In particular, you can set things up for bound template friends, so each specialization of a class gets a matching specialization for a friend. The technique is a bit more complex than for non-template friends and involves three steps.</p>
<p>For the first step, you declare each template function before the class definition:</p>
<p class="programlisting">template &lt;typename T&gt; void counts();<br/>template &lt;typename T&gt; void report(T &#38;);</p>
<p>Next, you declare the templates again as friends inside the function. These statements declare specializations based on the class template parameter type:</p>
<p class="programlisting">template &lt;typename TT&gt;<br/>class HasFriendT<br/>{<br/>...<br/>&#160;&#160;&#160;&#160;friend void counts&lt;TT&gt;();<br/>&#160;&#160;&#160;&#160;friend void report&lt;&gt;(HasFriendT&lt;TT&gt; &#38;);<br/>};</p>
<p><a id="page_862"/>The <code>&lt;&gt;</code> in the declarations identifies these as template specializations. In the case of <code>report()</code>, the <code>&lt;&gt;</code> can be left empty because the following template type argument can be deduced from the function argument:</p>
<p class="programlisting">HasFriendT&lt;TT&gt;</p>
<p>You could, however, use this instead:</p>
<p class="programlisting">report&lt;HasFriendT&lt;TT&gt; &gt;(HasFriendT&lt;TT&gt; &#38;)</p>
<p>However, the <code>counts()</code> function has no parameters, so you have to use the template argument syntax (<code>&lt;TT&gt;</code>) to indicate its specialization. Note, too, that <code>TT</code> is the parameter type for the <code>HasFriendT</code> class.</p>
<p>Again, the best way to understand these declarations is to imagine what they become when you declare an object of a particular specialization. For example, suppose you declare this object:</p>
<p class="programlisting">HasFriendT&lt;int&gt; squack;</p>
<p>Then the compiler substitutes <code>int</code> for <code>TT</code> and generates the following class definition:</p>
<p class="programlisting">class HasFriendT&lt;int&gt;<br/>{<br/>...<br/>&#160;&#160;&#160;&#160;friend void counts&lt;int&gt;();<br/>&#160;&#160;&#160;&#160;friend void report&lt;&gt;(HasFriendT&lt;int&gt; &#38;);<br/>};</p>
<p>One specialization is based on <code>TT</code>, which becomes <code>int</code>, and the other is based on <code>HasFriendT&lt;TT&gt;</code>, which becomes <code>HasFriendT&lt;int&gt;</code>. Thus, the template specializations <code>counts&lt;int&gt;()</code> and <code>report&lt;HasFriendT&lt;int&gt; &gt;()</code> are declared as friends to the <code>HasFriendT&lt;int&gt;</code> class.</p>
<p>The third requirement the program must meet is to provide template definitions for the friends. <a href="#ch14ex23">Listing 14.23</a> illustrates these three aspects. Note that <a href="#ch14ex22">Listing 14.22</a> has one <code>count()</code> function that is a friend to all <code>HasFriend</code> classes, whereas <a href="#ch14ex23">Listing 14.23</a> has two <code>count()</code> functions, one of which is a friend to each of the instantiated class types. Because the <code>count()</code> function calls have no function parameter from which the compiler can deduce the desired specialization, these calls use the <code>count&lt;int&gt;()</code> and <code>count&lt;double&gt;()</code> forms to indicate the specialization. For the calls to <code>report()</code>, however, the compiler can use the argument type to deduce the specialization. You could use the <code>&lt;&gt;</code> form to the same effect:</p>
<p class="programlisting">report&lt;HasFriendT&lt;int&gt; &gt;(hfi2);&#160;&#160;// same as report(hfi2);</p>
<p class="caption1"><a id="ch14ex23"/><strong>Listing 14.23. <code>tmp2tmp.cpp</code></strong></p><hr/>
<p class="programlisting1">// tmp2tmp.cpp -- template friends to a template class<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>using std::endl;<br/><br/><a id="page_863"/>// template prototypes<br/>template &lt;typename T&gt; void counts();<br/>template &lt;typename T&gt; void report(T &#38;);<br/><br/>// template class<br/>template &lt;typename TT&gt;<br/>class HasFriendT<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;TT item;<br/>&#160;&#160;&#160;&#160;static int ct;<br/>public:<br/>&#160;&#160;&#160;&#160;HasFriendT(const TT &#38; i) : item(i) {ct++;}<br/>&#160;&#160;&#160;&#160;~HasFriendT() { ct--; }<br/>&#160;&#160;&#160;&#160;friend void counts&lt;TT&gt;();<br/>&#160;&#160;&#160;&#160;friend void report&lt;&gt;(HasFriendT&lt;TT&gt; &#38;);<br/>};<br/><br/>template &lt;typename T&gt;<br/>int HasFriendT&lt;T&gt;::ct = 0;<br/><br/>// template friend functions definitions<br/>template &lt;typename T&gt;<br/>void counts()<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "template size: " &lt;&lt; sizeof(HasFriendT&lt;T&gt;) &lt;&lt; "; ";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "template counts(): " &lt;&lt; HasFriendT&lt;T&gt;::ct &lt;&lt; endl;<br/>}<br/><br/>template &lt;typename T&gt;<br/>void report(T &#38; hf)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; hf.item &lt;&lt; endl;<br/>}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;counts&lt;int&gt;();<br/>&#160;&#160;&#160;&#160;HasFriendT&lt;int&gt; hfi1(10);<br/>&#160;&#160;&#160;&#160;HasFriendT&lt;int&gt; hfi2(20);<br/>&#160;&#160;&#160;&#160;HasFriendT&lt;double&gt; hfdb(10.5);<br/>&#160;&#160;&#160;&#160;report(hfi1);&#160;&#160;// generate report(HasFriendT&lt;int&gt; &#38;)<br/>&#160;&#160;&#160;&#160;report(hfi2);&#160;&#160;// generate report(HasFriendT&lt;int&gt; &#38;)<br/>&#160;&#160;&#160;&#160;report(hfdb);&#160;&#160;// generate report(HasFriendT&lt;double&gt; &#38;)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "counts&lt;int&gt;() output:\n";<br/>&#160;&#160;&#160;&#160;counts&lt;int&gt;();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "counts&lt;double&gt;() output:\n";<br/>&#160;&#160;&#160;&#160;counts&lt;double&gt;();<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p><a id="page_864"/>Here is the output of the program in <a href="#ch14ex23">Listing 14.23</a>:</p>
<p class="programlisting">template size: 4; template counts(): 0<br/>10<br/>20<br/>10.5<br/>counts&lt;int&gt;() output:<br/>template size: 4; template counts(): 2<br/>counts&lt;double&gt;() output:<br/>template size: 8; template counts(): 1</p>
<p>As you can see, <code>counts&lt;double&gt;</code> reports a different template size from <code>counts&lt;int&gt;</code>, demonstrating that each <code>T</code> type now gets its own <code>count()</code> friend.</p>
<h5 id="ch14lev3sec24">Unbound Template Friend Functions to Template Classes</h5>
<p>The bound template friend functions in the preceding section are template specializations of a template declared outside a class. An <code>int</code> class specialization gets an <code>int</code> function specialization, and so on. By declaring a template inside a class, you can create unbound friend functions for which every function specialization is a friend to every class specialization. For unbound friends, the friend template type parameters are different from the template class type parameters:</p>
<p class="programlisting">template &lt;typename T&gt;<br/>class ManyFriend<br/>{<br/>...<br/>&#160;&#160;&#160;&#160;template &lt;typename C, typename D&gt; friend void show2(C &#38;, D &#38;);<br/>};</p>
<p><a href="#ch14ex24">Listing 14.24</a> shows an example that uses an unbound friend. In it, the function call <code>show2(hfi1, hfi2)</code> gets matched to the following specialization:</p>
<p class="programlisting">void show2&lt;ManyFriend&lt;int&gt; &#38;, ManyFriend&lt;int&gt; &#38;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ManyFriend&lt;int&gt; &#38; c, ManyFriend&lt;int&gt; &#38; d);</p>
<p>Because it is a friend to all specializations of <code>ManyFriend</code>, this function has access to the <code>item</code> members of all specializations. But it only uses access to <code>ManyFriend&lt;int&gt;</code> objects.</p>
<p>Similarly, <code>show2(hfd, hfi2)</code> gets matched to this specialization:</p>
<p class="programlisting">void show2&lt;ManyFriend&lt;double&gt; &#38;, ManyFriend&lt;int&gt; &#38;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(ManyFriend&lt;double&gt; &#38; c, ManyFriend&lt;int&gt; &#38; d);</p>
<p><a id="page_865"/>It, too, is a friend to all <code>ManyFriend</code> specializations, and it uses its access to the <code>item</code> member of a <code>ManyFriend&lt;int&gt;</code> object and to the <code>item</code> member of a <code>ManyFriend&lt;double&gt;</code> object.</p>
<p class="caption1"><a id="ch14ex24"/><strong>Listing 14.24. <code>manyfrnd.cpp</code></strong></p><hr/>
<p class="programlisting1">// manyfrnd.cpp -- unbound template friend to a template class<br/>#include &lt;iostream&gt;<br/>using std::cout;<br/>using std::endl;<br/><br/>template &lt;typename T&gt;<br/>class ManyFriend<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;T item;<br/>public:<br/>&#160;&#160;&#160;&#160;ManyFriend(const T &#38; i) : item(i) {}<br/>&#160;&#160;&#160;&#160;template &lt;typename C, typename D&gt; friend void show2(C &#38;, D &#38;);<br/>};<br/><br/>template &lt;typename C, typename D&gt; void show2(C &#38; c, D &#38; d)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; c.item &lt;&lt; ", " &lt;&lt; d.item &lt;&lt; endl;<br/>}<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;ManyFriend&lt;int&gt; hfi1(10);<br/>&#160;&#160;&#160;&#160;ManyFriend&lt;int&gt; hfi2(20);<br/>&#160;&#160;&#160;&#160;ManyFriend&lt;double&gt; hfdb(10.5);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "hfi1, hfi2: ";<br/>&#160;&#160;&#160;&#160;show2(hfi1, hfi2);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "hfdb, hfi2: ";<br/>&#160;&#160;&#160;&#160;show2(hfdb, hfi2);<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p><hr/>
<p>Here&#8217;s the output of the program in <a href="#ch14ex24">Listing 14.24</a>:</p>
<p class="programlisting">hfi1, hfi2: 10, 20<br/>hfdb, hfi2: 10.5, 20</p>
<h4 id="ch14lev2sec20">Template Aliases (C++11)</h4>
<p><a id="page_866"/>It can be convenient, especially in template design, to create aliases for types. You can use <code>typedef</code> to create aliases for template specializations:</p>
<p class="programlisting">// define three typedef aliases<br/>typedef std::array&lt;double, 12&gt; arrd;<br/>typedef std::array&lt;int, 12&gt; arri;<br/>typedef std::array&lt;std::string, 12&gt; arrst;<br/>arrd gallons;&#160;&#160;// gallons is type std::array&lt;double, 12&gt;<br/>arri days;&#160;&#160;&#160;&#160;&#160;// days is type std::array&lt;int, 12&gt;<br/>arrst months;&#160;&#160;// months is type std::array&lt;std::string, 12&gt;</p>
<p>But if you find yourself writing code similar to the preceding <code>typedef</code>s, over and over, you might wonder if you&#8217;ve forgotten some language feature that simplifies the task or if the language has forgotten to supply such a feature. In this case, C++11 provides a feature previously missing&#8212;a way to use a template to provide a family of aliases. Here&#8217;s what the approach looks like:</p>
<p class="programlisting">template&lt;typename T&gt;<br/>&#160;&#160;using arrtype = std::array&lt;T,12&gt;;&#160;&#160;// template to create multiple aliases</p>
<p>This makes <code>arrtype</code> a template alias that can be used as a type, as follows:</p>
<p class="programlisting">arrtype&lt;double&gt; gallons;&#160;&#160;&#160;&#160;&#160;&#160;// gallons is type std::array&lt;double, 12&gt;<br/>arrtype&lt;int&gt; days;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// days is type std::array&lt;int, 12&gt;<br/>arrtype&lt;std::string&gt; months;&#160;&#160;// months is type std::array&lt;std::string, 12&gt;</p>
<p>In short, <code>arrtype&lt;T&gt;</code> means type <code>std::array&lt;T,12&gt;</code>.</p>
<p>C++11 extends the <code>using =</code> syntax to non-templates too. In that case, it becomes equivalent to an ordinary <code>typedef</code>:</p>
<p class="programlisting">typedef const char * pc1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// typedef syntax<br/>using pc2 = const char *;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// using = syntax<br/>typedef const int *(*pa1)[10];&#160;&#160;// typedef syntax<br/>using pa2 = const int *(*)[10]; // using = syntax</p>
<p>As you get used to it, you may find the new form more readable because it separates the type name from type information more clearly.</p>
<p>Another C++11 addition to templates is the <em>variadic template</em>, which allows you to define a template class or function that can take a variable number of initializers. <a href="ch18.html#ch18">Chapter 18</a>, &#8220;<a href="ch18.html#ch18">Visiting with the New C++ Standard</a>,&#8221; looks into this topic.</p>
<h3 id="ch14lev1sec5">Summary</h3>
<p>C++ provides several means for reusing code. Public inheritance, described in <a href="ch13.html#ch13">Chapter 13</a>, &#8220;<a href="ch13.html#ch13">Class Inheritance</a>,&#8221; enables you to model <em>is-a</em> relationships, with derived classes being able to reuse the code of base classes. Private and protected inheritance also let you reuse base-class code, this time modeling <em>has-a</em> relationships. With private inheritance, public <a id="page_867"/>and protected members of the base class become private members of the derived class. With protected inheritance, public and protected members of the base class become protected members of the derived class. Thus, in either case, the public interface of the base class becomes an internal interface for the derived class. This is sometimes described as inheriting the implementation but not the interface because a derived object can&#8217;t explicitly use the base-class interface. Thus, you can&#8217;t view a derived object as a kind of base object. Because of this, a base-class pointer or reference is not allowed to refer to a derived object without an explicit type cast.</p>
<p>You can also reuse class code by developing a class with members that are themselves objects. This approach, called <em>containment</em>, <em>layering</em>, or <em>composition</em>, also models the <em>has-a</em> relationship. Containment is simpler to implement and use than private or protected inheritance, so it is usually preferred. However, private and protected inheritance have slightly different capabilities. For example, inheritance allows a derived class access to protected members of a base class. Also it allows a derived class to redefine a virtual function inherited from the base class. Because containment is not a form of inheritance, neither of these capabilities are options when you reuse class code via containment. On the other hand, containment is more suitable if you need several objects of a given class. For example, a <code>State</code> class could contain an array of <code>County</code> objects.</p>
<p>Multiple inheritance (MI) allows you to reuse code for more than one class in a class design. Private or protected MI models the <em>has-a</em> relationship, and public MI models the <em>is-a</em> relationship. MI can create problems with multidefined names and multi-inherited bases. You can use class qualifiers to resolve name ambiguities and virtual base classes to avoid multi-inherited bases. However, using virtual base classes introduces new rules for writing initialization lists for constructors and for resolving ambiguities.</p>
<p>Class templates let you create a generic class design in which a type, usually a member type, is represented by a type parameter. A typical template looks like this:</p>
<p class="programlisting">template &lt;class T&gt;<br/>class Ic<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;T v;<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;Ic(const T &#38; val) : v(val) { }<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};</p>
<p>Here <code>T</code> is the type parameter, and it acts as a stand-in for a real type to be specified at a later time. (This parameter can have any valid C++ name, but <code>T</code> and <code>Type</code> are common choices.) You can also use <code>typename</code> instead of <code>class</code> in this context:</p>
<p class="programlisting">template &lt;typename T&gt;&#160;&#160;// same as template &lt;class T&gt;<br/>class Rev {...} ;</p>
<p>Class definitions (instantiations) are generated when you declare a class object and specify a particular type. For example, the following declaration causes the compiler to <a id="page_868"/>generate a class declaration in which every occurrence of the type parameter <code>T</code> in the template is replaced by the actual type <code>short</code> in the class declaration:</p>
<p class="programlisting">class Ic&lt;short&gt; sic;&#160;&#160;&#160;&#160;// implicit instantiation</p>
<p>In this case, the class name is <code>Ic&lt;short&gt;</code>, not <code>Ic</code>. <code>Ic&lt;short&gt;</code> is termed a <em>specialization</em> of the template. In particular, it is an implicit instantiation.</p>
<p>An explicit instantiation occurs when you declare a specific specialization of the class, using the keyword <code>template</code>:</p>
<p class="programlisting">template class IC&lt;int&gt;;&#160;&#160;// explicit instantiation</p>
<p>In this situation, the compiler uses the general template to generate an <code>int</code> specialization <code>Ic&lt;int&gt;</code>, even though no objects have yet been requested of that class.</p>
<p>You can provide explicit specializations, which are specialized class declarations that override a template definition. You just define the class, starting with <code>template&lt;&gt;</code>, and then you use the template class name, followed by angle brackets containing the type for which you want a specialization. For example, you could provide a specialized <code>Ic</code> class for character pointers as follows:</p>
<p class="programlisting">template &lt;&gt; class Ic&lt;char *&gt;.<br/>{<br/>&#160;&#160;&#160;&#160;&#160;&#160;char * str;<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;Ic(const char * s) : str(s) { }<br/>&#160;&#160;&#160;&#160;&#160;&#160;...<br/>};</p>
<p>Then a declaration of the following form would use the specialized definition for <code>chic</code> rather than using the general template:</p>
<p class="programlisting">class Ic&lt;char *&gt; chic;</p>
<p>A class template can specify more than one generic type and can also have non-type parameters:</p>
<p class="programlisting">template &lt;class T, class TT, int n&gt;<br/>class Pals {...};</p>
<p>The following declaration would generate an implicit instantiation using <code>double</code> for <code>T</code>, <code>string</code> for <code>TT</code>, and <code>6</code> for <code>n</code>:</p>
<p class="programlisting">Pals&lt;double, string, 6&gt; mix;</p>
<p>A class template can also have parameters that are templates:</p>
<p class="programlisting">template &lt; template &lt;typename T&gt; class CL, typename U, int z&gt;<br/>class Trophy {...};</p>
<p>Here <code>z</code> stands for an <code>int</code> value, <code>U</code> stands for the name of a type, and <code>CL</code> stands for a class template declared using <code>template &lt;typename T&gt;</code>.</p>
<p><a id="page_869"/>Class templates can be partially specialized:</p>
<p class="programlisting">template &lt;class T&gt; Pals&lt;T, T, 10&gt; {...};<br/>template &lt;class T, class TT&gt; Pals&lt;T, TT, 100&gt; {...};<br/>template &lt;class T, int n&gt; Pals &lt;T, T*, n&gt; {...};</p>
<p>The first example here creates a specialization in which both types are the same and <code>n</code> has the value <code>6</code>. Similarly, the second creates a specialization for <code>n</code> equal to <code>100</code>, and the third creates a specialization for which the second type is a pointer to the first type.</p>
<p>Template classes can be members of other classes, structures, and templates.</p>
<p>The goal of all these methods is to allow programmers to reuse tested code without having to copy it manually. This simplifies the programming task and makes programs more reliable.</p>
<h3 id="ch14lev1sec6">Chapter Review</h3>
<p class="question"><a id="ch14qa1q1" href="app10.html#ch14qa1a1"><strong>1.</strong></a> For each of the following sets of classes, indicate whether public or private derivation is more appropriate for Column B:</p>
<p class="image"><img src="graphics/869tab01.jpg" alt="Image"/></p>
<p class="question"><a id="ch14qa1q2" href="app10.html#ch14qa1a2"><strong>2.</strong></a> Suppose you have the following definitions:</p>
<p class="programlistingB">class Frabjous {<br/>private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;char fab[20];<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;Frabjous(const char * s = "C++") : fab(s) { }<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void tell() { cout &lt;&lt; fab; }<br/>};<br/><br/>class Gloam {<br/>private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;int glip;<br/>&#160;&#160;&#160;&#160;&#160;&#160;Frabjous fb;<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;Gloam(int g = 0, const char * s = "C++");<br/>&#160;&#160;&#160;&#160;&#160;&#160;Gloam(int g, const Frabjous &#38; f);<br/>&#160;&#160;&#160;&#160;&#160;&#160;void tell();<br/>};</p>
<p class="indenthanding1"><a id="page_870"/>Given that the <code>Gloam</code> version of <code>tell()</code> should display the values of <code>glip</code> and <code>fb</code>, provide definitions for the three <code>Gloam</code> methods.</p>
<p class="question"><a id="ch14qa1q3" href="app10.html#ch14qa1a3"><strong>3.</strong></a> Suppose you have the following definitions:</p>
<p class="programlistingB">class Frabjous {<br/>private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;char fab[20];<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;Frabjous(const char * s = "C++") : fab(s) { }<br/>&#160;&#160;&#160;&#160;&#160;&#160;virtual void tell() { cout &lt;&lt; fab; }<br/>};<br/><br/>class Gloam : private Frabjous{<br/>private:<br/>&#160;&#160;&#160;&#160;&#160;&#160;int glip;<br/>public:<br/>&#160;&#160;&#160;&#160;&#160;&#160;Gloam(int g = 0, const char * s = "C++");<br/>&#160;&#160;&#160;&#160;&#160;&#160;Gloam(int g, const Frabjous &#38; f);<br/>&#160;&#160;&#160;&#160;&#160;&#160;void tell();<br/>};</p>
<p class="indenthanding1">Given that the <code>Gloam</code> version of <code>tell()</code> should display the values of <code>glip</code> and <code>fab</code>, provide definitions for the three <code>Gloam</code> methods.</p>
<p class="question"><a id="ch14qa1q4" href="app10.html#ch14qa1a4"><strong>4.</strong></a> Suppose you have the following definition, based on the <code>Stack</code> template of <a href="#ch14ex13">Listing 14.13</a> and the <code>Worker</code> class of <a href="#ch14ex10">Listing 14.10</a>:</p>
<p class="programlistingB">Stack&lt;Worker *&gt; sw;</p>
<p class="indenthanding1">Write out the class declaration that will be generated. Just do the class declaration, not the non-inline class methods.</p>
<p class="question"><a id="ch14qa1q5" href="app10.html#ch14qa1a5"><strong>5.</strong></a> Use the template definitions in this chapter to define the following:</p>
<p class="indenthandingB1">&#8226; An array of <code>string</code> objects</p>
<p class="indenthandingB1">&#8226; A stack of arrays of <code>double</code></p>
<p class="indenthandingB1">&#8226; An array of stacks of pointers to <code>Worker</code> objects</p>
<p class="indenthanding1">How many template class definitions are produced in <a href="#ch14ex18">Listing 14.18</a>?</p>
<p class="question"><a id="ch14qa1q6" href="app10.html#ch14qa1a6"><strong>6.</strong></a> Describe the differences between virtual and nonvirtual base classes.</p>
<h3 id="ch14lev1sec7">Programming Exercises</h3>
<p class="question"><a id="page_871"/><a id="ch14qa2q1"/><strong>1.</strong> The <code>Wine</code> class has a <code>string</code> class object member (see <a href="ch04.html#ch04">Chapter 4</a>) that holds the name of a wine and a <code>Pair</code> object (as discussed in this chapter) of <code>valarray&lt;int&gt;</code> objects (as discussed in this chapter). The first member of each <code>Pair</code> object holds the vintage years, and the second member holds the numbers of bottles owned for the corresponding particular vintage year. For example, the first <code>valarray</code> object of the <code>Pair</code> object might hold the years <code>1988</code>, <code>1992</code>, and <code>1996</code>, and the second <code>valarray</code> object might hold the bottle counts <code>24</code>, <code>48</code>, and <code>144</code>. It may be convenient for <code>Wine</code> to have an <code>int</code> member that stores the number of years. Also some <code>typedef</code>s might be useful to simplify the coding:</p>
<p class="programlistingB">typedef std::valarray&lt;int&gt; ArrayInt;<br/>typedef Pair&lt;ArrayInt, ArrayInt&gt; PairArray;</p>
<p class="indenthanding1">Thus, the <code>PairArray</code> type represents type <code>Pair&lt;std::valarray&lt;int&gt;, std::valarray&lt;int&gt; &gt;</code>. Implement the <code>Wine</code> class by using containment. The class should have a default constructor and at least the following constructors:</p>
<p class="programlistingB">// initialize label to l, number of years to y,<br/>// vintage years to yr[], bottles to bot[]<br/>Wine(const char * l, int y, const int yr[], const int bot[]);<br/>// initialize label to l, number of years to y,<br/>// create array objects of length y<br/>Wine(const char * l, int y);</p>
<p class="indenthanding1">The <code>Wine</code> class should have a method <code>GetBottles()</code> that, given a <code>Wine</code> object with <code>y</code> years, prompts the user to enter the corresponding number of vintage years and bottle counts. A method <code>Label()</code> should return a reference to the wine name. A method <code>sum()</code> should return the total number of bottles in the second <code>valarray&lt;int&gt;</code> object in the <code>Pair</code> object.</p>
<p class="indenthanding1">The program should prompt the user to enter a wine name, the number of elements of the array, and the year and bottle count information for each array element. The program should use this data to construct a <code>Wine</code> object and then display the information stored in the object. For guidance, here&#8217;s a sample test program:</p>
<p class="programlistingB">// pe14-1.cpp&#160;&#160;-- using Wine class with containment<br/>#include &lt;iostream&gt;<br/>#include "winec.h"<br/><br/>int main ( void )<br/>{<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter name of wine: ";<br/>&#160;&#160;&#160;&#160;char lab[50];<br/><a id="page_872"/>&#160;&#160;&#160;&#160;cin.getline(lab, 50);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter number of years: ";<br/>&#160;&#160;&#160;&#160;int yrs;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; yrs;<br/><br/>&#160;&#160;&#160;&#160;Wine holding(lab, yrs); // store label, years, give arrays yrs elements<br/>&#160;&#160;&#160;&#160;holding.GetBottles();&#160;&#160;&#160;// solicit input for year, bottle count<br/>&#160;&#160;&#160;&#160;holding.Show();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// display object contents<br/><br/>&#160;&#160;&#160;&#160;const int YRS = 3;<br/>&#160;&#160;&#160;&#160;int y[YRS] = {1993, 1995, 1998};<br/>&#160;&#160;&#160;&#160;int b[YRS] = { 48, 60, 72};<br/>&#160;&#160;&#160;&#160;// create new object, initialize using data in arrays y and b<br/>&#160;&#160;&#160;&#160;Wine more("Gushing Grape Red",YRS, y, b);<br/>&#160;&#160;&#160;&#160;more.Show();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Total bottles for " &lt;&lt; more.Label() // use Label() method<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ": " &lt;&lt; more.sum() &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// use sum() method<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Bye\n";<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="indenthanding1">And here&#8217;s some sample output:</p>
<p class="programlistingB">Enter name of wine: <span class="EmpStrong">Gully Wash</span><br/>Enter number of years: <span class="EmpStrong">4</span><br/>Enter Gully Wash data for 4 year(s):<br/>Enter year: <span class="EmpStrong">1988</span><br/>Enter bottles for that year: <span class="EmpStrong">42</span><br/>Enter year: <span class="EmpStrong">1994</span><br/>Enter bottles for that year: <span class="EmpStrong">58</span><br/>Enter year: <span class="EmpStrong">1998</span><br/>Enter bottles for that year: <span class="EmpStrong">12</span>2<br/>Enter year: <span class="EmpStrong">2001</span><br/>Enter bottles for that year: <span class="EmpStrong">144</span><br/>Wine: Gully Wash<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Year&#160;&#160;&#160;&#160;Bottles<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1988&#160;&#160;&#160;&#160;42<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1994&#160;&#160;&#160;&#160;58<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1998&#160;&#160;&#160;&#160;122<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2001&#160;&#160;&#160;&#160;144<br/>Wine: Gushing Grape Red<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Year&#160;&#160;&#160;&#160;Bottles<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1993&#160;&#160;&#160;&#160;48<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1995&#160;&#160;&#160;&#160;60<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1998&#160;&#160;&#160;&#160;72<br/>Total bottles for Gushing Grape Red: 180<br/>Bye</p>
<p class="question"><a id="page_873"/><a id="ch14qa2q2"/><strong>2.</strong> This exercise is the same as Programming Exercise 1, except that you should use private inheritance instead of containment. Again, a few <code>typedef</code>s might prove handy. Also you might contemplate the meaning of statements such as the following:</p>
<p class="programlistingB">PairArray::operator=(PairArray(ArrayInt(),ArrayInt()));<br/>cout&#160;&#160;&lt;&lt; (const string &#38;)(*this);</p>
<p class="indenthanding1">The class should work with the same test program as shown in Programming Exercise 1.</p>
<p class="question"><a id="ch14qa2q3"/><strong>3.</strong> Define a <code>QueueTp</code> template. Test it by creating a queue of pointers-to-<code>Worker</code> (as defined in <a href="#ch14ex10">Listing 14.10</a>) and using the queue in a program similar to that in <a href="#ch14ex12">Listing 14.12</a>.</p>
<p class="question"><a id="ch14qa2q4"/><strong>4.</strong> A <code>Person</code> class holds the first name and the last name of a person. In addition to its constructors, it has a <code>Show()</code> method that displays both names. A <code>Gunslinger</code> class derives virtually from the <code>Person</code> class. It has a <code>Draw()</code> member that returns a type <code>double</code> value representing a gunslinger&#8217;s draw time. The class also has an <code>int</code> member representing the number of notches on a gunslinger&#8217;s gun. Finally, it has a <code>Show()</code> function that displays all this information.</p>
<p class="indenthanding1">A <code>PokerPlayer</code> class derives virtually from the <code>Person</code> class. It has a <code>Draw()</code> member that returns a random number in the range 1 through 52, representing a card value. (Optionally, you could define a <code>Card</code> class with suit and face value members and use a <code>Card</code> return value for <code>Draw()</code>.) The <code>PokerPlayer</code> class uses the <code>Person show()</code> function. The <code>BadDude</code> class derives publicly from the <code>Gunslinger</code> and <code>PokerPlayer</code> classes. It has a <code>Gdraw()</code> member that returns a bad dude&#8217;s draw time and a <code>Cdraw()</code> member that returns the next card drawn. It has an appropriate <code>Show()</code> function. Define all these classes and methods, along with any other necessary methods (such as methods for setting object values) and test them in a simple program similar to that in <a href="#ch14ex12">Listing 14.12</a>.</p>
<p class="question"><a id="ch14qa2q5"/><strong>5.</strong> Here are some class declarations:</p>
<p class="programlistingB">// emp.h -- header file for abstr_emp class and children<br/><br/>#include &lt;iostream&gt;<br/>#include &lt;string&gt;<br/><br/>class abstr_emp<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string fname;&#160;&#160;&#160;&#160;// abstr_emp's first name<br/>&#160;&#160;&#160;&#160;std::string lname;&#160;&#160;&#160;&#160;// abstr_emp's last name<br/>&#160;&#160;&#160;&#160;std::string job;<br/><a id="page_874"/>public:<br/>&#160;&#160;&#160;&#160;abstr_emp();<br/>&#160;&#160;&#160;&#160;abstr_emp(const std::string &#38; fn, const std::string &#38;&#160;&#160;ln,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38;&#160;&#160;j);<br/>&#160;&#160;&#160;&#160;virtual void ShowAll() const;&#160;&#160;&#160;&#160;// labels and shows all data<br/>&#160;&#160;&#160;&#160;virtual void SetAll();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// prompts user for values<br/>&#160;&#160;&#160;&#160;friend std::ostream &#38;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;operator&lt;&lt;(std::ostream &#38; os, const abstr_emp &#38; e);<br/>&#160;&#160;&#160;&#160;// just displays first and last name<br/>&#160;&#160;&#160;&#160;virtual ~abstr_emp() = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// virtual base class<br/>};<br/><br/>class employee : public abstr_emp<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;employee();<br/>&#160;&#160;&#160;&#160;employee(const std::string &#38; fn, const std::string &#38;&#160;&#160;ln,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38;&#160;&#160;j);<br/>&#160;&#160;&#160;&#160;virtual void ShowAll() const;<br/>&#160;&#160;&#160;&#160;virtual void SetAll();<br/>};<br/><br/>class manager:&#160;&#160;virtual public abstr_emp<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int inchargeof;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// number of abstr_emps managed<br/>protected:<br/>&#160;&#160;&#160;&#160;int InChargeOf() const { return inchargeof; } // output<br/>&#160;&#160;&#160;&#160;int &#38; InChargeOf(){ return inchargeof; }&#160;&#160;&#160;&#160;&#160;&#160;// input<br/>public:<br/>&#160;&#160;&#160;&#160;manager();<br/>&#160;&#160;&#160;&#160;manager(const std::string &#38; fn, const std::string &#38; ln,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38; j, int ico = 0);<br/>&#160;&#160;&#160;&#160;manager(const abstr_emp &#38; e, int ico);<br/>&#160;&#160;&#160;&#160;manager(const manager &#38; m);<br/>&#160;&#160;&#160;&#160;virtual void ShowAll() const;<br/>&#160;&#160;&#160;&#160;virtual void SetAll();<br/>};<br/><br/>class fink: virtual public abstr_emp<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string reportsto;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// to whom fink reports<br/>protected:<br/>&#160;&#160;&#160;&#160;const std::string ReportsTo() const { return reportsto; }<br/>&#160;&#160;&#160;&#160;std::string &#38; ReportsTo(){ return reportsto; }<br/><a id="page_875"/>public:<br/>&#160;&#160;&#160;&#160;fink();<br/>&#160;&#160;&#160;&#160;fink(const std::string &#38; fn, const std::string &#38; ln,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38; j, const std::string &#38; rpo);<br/>&#160;&#160;&#160;&#160;fink(const abstr_emp &#38; e, const std::string &#38; rpo);<br/>&#160;&#160;&#160;&#160;fink(const fink &#38; e);<br/>&#160;&#160;&#160;&#160;virtual void ShowAll() const;<br/>&#160;&#160;&#160;&#160;virtual void SetAll();<br/>};<br/><br/>class highfink: public manager, public fink // management fink<br/>{<br/>public:<br/>&#160;&#160;&#160;&#160;highfink();<br/>&#160;&#160;&#160;&#160;highfink(const std::string &#38; fn, const std::string &#38; ln,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38; j, const std::string &#38; rpo,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int ico);<br/>&#160;&#160;&#160;&#160;highfink(const abstr_emp &#38; e, const std::string &#38; rpo, int ico);<br/>&#160;&#160;&#160;&#160;highfink(const fink &#38; f, int ico);<br/>&#160;&#160;&#160;&#160;highfink(const manager &#38; m, const std::string &#38; rpo);<br/>&#160;&#160;&#160;&#160;highfink(const highfink &#38; h);<br/>&#160;&#160;&#160;&#160;virtual void ShowAll() const;<br/>&#160;&#160;&#160;&#160;virtual void SetAll();<br/>};</p>
<p class="indenthanding1">Note that the class hierarchy uses MI with a virtual base class, so keep in mind the special rules for constructor initialization lists for that case. Also note the presence of some protected-access methods. This simplifies the code for some of the <code>highfink</code> methods. (Note, for example, that if <code>highfink::ShowAll()</code> simply calls <code>fink::ShowAll()</code> and <code>manager::ShowAll()</code>, it winds up calling <code>abstr_emp::ShowAll()</code> twice.) Provide the class method implementations and test the classes in a program. Here is a minimal test program:</p>
<p class="programlistingB">// pe14-5.cpp<br/>// useemp1.cpp -- using the abstr_emp classes<br/><br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>#include "emp.h"<br/><br/>int main(void)<br/>{<br/>&#160;&#160;&#160;&#160;employee em("Trip", "Harris", "Thumper");<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; em &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;em.ShowAll();<br/><br/><a id="page_876"/>&#160;&#160;&#160;&#160;manager ma("Amorphia", "Spindragon", "Nuancer", 5);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ma &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;ma.ShowAll();<br/><br/><br/>&#160;&#160;&#160;&#160;fink fi("Matt", "Oggs", "Oiler", "Juno Barr");<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; fi &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;fi.ShowAll();<br/>&#160;&#160;&#160;&#160;highfink hf(ma, "Curly Kew");&#160;&#160;// recruitment?<br/>&#160;&#160;&#160;&#160;hf.ShowAll();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Press a key for next phase:\n";<br/>&#160;&#160;&#160;&#160;cin.get();<br/>&#160;&#160;&#160;&#160;highfink hf2;<br/>&#160;&#160;&#160;&#160;hf2.SetAll();<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Using an abstr_emp * pointer:\n";<br/>&#160;&#160;&#160;&#160;abstr_emp&#160;&#160;* tri[4] = {&#38;em, &#38;fi, &#38;hf, &#38;hf2};<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 4; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tri[i]-&gt;ShowAll();<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="indenthanding1">Why is no assignment operator defined?</p>
<p class="indenthanding1">Why are <code>ShowAll()</code> and <code>SetAll()</code> virtual?</p>
<p class="indenthanding1">Why is <code>abstr_emp</code> a virtual base class?</p>
<p class="indenthanding1">Why does the <code>highfink</code> class have no data section?</p>
<p class="indenthanding1">Why is only one version of <code>operator&lt;&lt;()</code> needed?</p>
<p class="indenthanding1">What would happen if the end of the program were replaced with this code?</p>
<p class="programlistingB">abstr_emp&#160;&#160;tri[4] = {em, fi, hf, hf2};<br/>for (int i = 0; i &lt; 4; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;tri[i].ShowAll();</p>
</body>
</html>
