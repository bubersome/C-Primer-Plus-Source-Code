<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>J. Answers to Chapter Reviews</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="app10">J. Answers to Chapter Reviews</h2>
<h3 id="app10lev1sec1"><a id="page_1335"/>Answers to Chapter Review for Chapter 2</h3>
<p class="answer"><a id="ch02qa1a1" href="ch02.html#ch02qa1q1"><strong>1.</strong></a> They are called functions.</p>
<p class="answer"><a id="ch02qa1a2" href="ch02.html#ch02qa1q2"><strong>2.</strong></a> It causes the contents of the <code>iostream</code> file to be substituted for this directive before final compilation.</p>
<p class="answer"><a id="ch02qa1a3" href="ch02.html#ch02qa1q3"><strong>3.</strong></a> It makes definitions made in the <code>std</code> namespace available to a program.</p>
<p class="answer"><a id="ch02qa1a4" href="ch02.html#ch02qa1q4"><strong>4.</strong></a> <code>cout &lt;&lt; "Hello, world\n";</code></p>
<p class="indenthanding1">or</p>
<p class="programlistingB">cout &lt;&lt; "Hello, world" &lt;&lt; endl;</p>
<p class="answer"><a id="ch02qa1a5" href="ch02.html#ch02qa1q5"><strong>5.</strong></a> <code>int cheeses;</code></p>
<p class="answer"><a id="ch02qa1a6" href="ch02.html#ch02qa1q6"><strong>6.</strong></a> <code>cheeses = 32;</code></p>
<p class="answer"><a id="ch02qa1a7" href="ch02.html#ch02qa1q7"><strong>7.</strong></a> <code>cin &gt;&gt; cheeses;</code></p>
<p class="answer"><a id="ch02qa1a8" href="ch02.html#ch02qa1q8"><strong>8.</strong></a> <code>cout &lt;&lt; "We have " &lt;&lt; cheeses &lt;&lt; " varieties of cheese\n";</code></p>
<p class="answer"><a id="ch02qa1a9" href="ch02.html#ch02qa1q9"><strong>9.</strong></a> The function <code>froop()</code> expects to be called with one argument, which will be type <code>double</code>, and that the function will return a type <code>int</code> value. For instance, it could be used as follows:</p>
<p class="programlistingB">int gval = froop(3.14159);</p>
<p class="indenthanding1">The function <code>rattle()</code> has no return value and expects an <code>int</code> argument. For instance, it could be used as follows:</p>
<p class="programlistingB">rattle(37);</p>
<p class="indenthanding1"><a id="page_1336"/>The function <code>prune()</code> returns an <code>int</code> and expects to be used without an argument. For instance, it could be used as follows:</p>
<p class="programlistingB">int residue = prune();</p>
<p class="answer1"><a id="ch02qa1a10" href="ch02.html#ch02qa1q10"><strong>10.</strong></a> You don&#8217;t have to use <code>return</code> in a function when the function has the return type <code>void</code>. However, you can use it if you don&#8217;t give a return value:</p>
<p class="programlistingB">return;</p>
<h3 id="app10lev1sec2">Answers to Chapter Review for Chapter 3</h3>
<p class="answer"><a id="ch03qa1a1" href="ch03.html#ch03qa1q1"><strong>1.</strong></a> Having more than one integer type lets you choose the type that is best suited to a particular need. For example, you could use <code>short</code> to conserve space or <code>long</code> to guarantee storage capacity or to find that a particular type speeds up a particular calculation.</p>
<p class="answer"><a id="ch03qa1a2" href="ch03.html#ch03qa1q2"><strong>2.</strong></a></p>
<p class="programlistingB">short rbis = 80;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// or short int rbis = 80;<br/>unsigned int q = 42110;&#160;&#160;&#160;&#160;&#160;// or unsigned q = 42110;<br/>unsigned long ants = 3000000000;<br/>// or long long ants = 3000000000;</p>
<p class="indenthanding1">Note: Don&#8217;t count on <code>int</code> being large enough to hold 3,000,000,000. Also if your system supports universal list-initialization, you could use it:</p>
<p class="programlistingB">short rbis = {80};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// = is optional<br/>unsigned int q {42110};&#160;&#160;&#160;&#160;&#160;// could use = {42110}<br/>long long ants {3000000000};</p>
<p class="answer"><a id="ch03qa1a3" href="ch03.html#ch03qa1q3"><strong>3.</strong></a> C++ provides no automatic safeguards to keep you from exceeding integer limits; you can use the <code>climits</code> header file to determine what the limits are.</p>
<p class="answer"><a id="ch03qa1a4" href="ch03.html#ch03qa1q4"><strong>4.</strong></a> The constant <code>33L</code> is type <code>long</code>, whereas the constant <code>33</code> is type <code>int</code>.</p>
<p class="answer"><a id="ch03qa1a5" href="ch03.html#ch03qa1q5"><strong>5.</strong></a> The two statements are not really equivalent, although they have the same effect on some systems. Most importantly, the first statement assigns the letter A to <code>grade</code> only on a system using the ASCII code, while the second statement also works for other codes. Second, 65 is a type <code>int</code> constant, whereas <code>'A'</code> is a type <code>char</code> constant.</p>
<p class="answer"><a id="ch03qa1a6" href="ch03.html#ch03qa1q6"><strong>6.</strong></a> Here are four ways:</p>
<p class="programlistingB">char c = 88;<br/>cout &lt;&lt; c &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// char type prints as character<br/><br/>cout.put(char(88));&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// put() prints char as character<br/><br/>cout &lt;&lt; char(88) &lt;&lt; endl;&#160;&#160;&#160;&#160;// new-style type cast value to char<br/><br/>cout &lt;&lt; (char)88 &lt;&lt; endl;&#160;&#160;&#160;&#160;// old-style type cast value to char</p>
<p class="answer"><a id="page_1337"/><a id="ch03qa1a7" href="ch03.html#ch03qa1q7"><strong>7.</strong></a> The answer depends on how large the two types are. If <code>long</code> is 4 bytes, there is no loss. That&#8217;s because the largest <code>long</code> value would be about 2 billion, which is 10 digits. Because <code>double</code> provides at least 13 significant figures, no rounding would be needed. The <code>long long</code> type, on the other hand, can reach 19 digits, which exceeds the 13 significant figures guaranteed for <code>double</code>.</p>
<p class="answer"><a id="ch03qa1a8" href="ch03.html#ch03qa1q8"><strong>8.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> 8 * 9 + 2 is 72 + 2 is 74</p>
<p class="indenthandinga"><strong>b.</strong> 6 * 3 / 4 is 18 / 4 is 4</p>
<p class="indenthandinga"><strong>c.</strong> 3 / 4 * 6 is 0 * 6 is 0</p>
<p class="indenthandinga"><strong>d.</strong> 6.0 * 3 / 4 is 18.0 / 4 is 4.5</p>
<p class="indenthandinga"><strong>e.</strong> 15 % 4 is 3</p>
<p class="answer"><a id="ch03qa1a9" href="ch03.html#ch03qa1q9"><strong>9.</strong></a> Either of the following would work for the first task:</p>
<p class="programlistingB">int pos = (int) x1 + (int) x2;<br/>int pos = int(x1) + int(x2);</p>
<p class="indenthanding1">To add them as type <code>double</code> and then convert, you could do either of the following:</p>
<p class="programlistingB">int pos = (int) (x1 + x2);<br/>int pos = int(x1 + x2);</p>
<p class="answer1"><a id="ch03qa1a10" href="ch03.html#ch03qa1q10"><strong>10.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> int</p>
<p class="indenthandinga"><strong>b.</strong> <code>float</code></p>
<p class="indenthandinga"><strong>c.</strong> <code>char</code></p>
<p class="indenthandinga"><strong>d.</strong> <code>char32_t</code></p>
<p class="indenthandinga"><strong>e.</strong> <code>double</code></p>
<h3 id="app10lev1sec3">Answers to Chapter Review for Chapter 4</h3>
<p class="answer"><a id="ch04qa1a1" href="ch04.html#ch04qa1q1"><strong>1.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> <code>char actors[30];</code></p>
<p class="indenthandinga"><strong>b.</strong> <code>short betsie[100];</code></p>
<p class="indenthandinga"><strong>c.</strong> <code>float chuck[13];</code></p>
<p class="indenthandinga"><strong>d.</strong> <code>long double dipsea[64];</code></p>
<p class="answer"><a id="ch04qa1a2" href="ch04.html#ch04qa1q2"><strong>2.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> <code>array&lt;char,30&gt; actors;</code></p>
<p class="indenthandinga"><strong>b.</strong> <code>array&lt;short, 100&gt; betsie;</code></p>
<p class="indenthandinga"><strong>c.</strong> <code>array&lt;float, 13&gt; chuck;</code></p>
<p class="indenthandinga"><strong>d.</strong> <code>array&lt;long double, 64&gt; dipsea;</code></p>
<p class="answer"><a id="page_1338"/><a id="ch04qa1a3" href="ch04.html#ch04qa1q3"><strong>3.</strong></a> <code>int oddly[5] = {1, 3, 5, 7, 9};</code></p>
<p class="answer"><a id="ch04qa1a4" href="ch04.html#ch04qa1q4"><strong>4.</strong></a> <code>int even = oddly[0] + oddly[4];</code></p>
<p class="answer"><a id="ch04qa1a5" href="ch04.html#ch04qa1q5"><strong>5.</strong></a> <code>cout &lt;&lt; ideas[1] &lt;&lt; "\n"; // or &lt;&lt; endl;</code></p>
<p class="answer"><a id="ch04qa1a6" href="ch04.html#ch04qa1q6"><strong>6.</strong></a> <code>char lunch[13] = "cheeseburger"; // number of characters + 1</code></p>
<p class="indenthanding1">or</p>
<p class="programlistingB">char lunch[] = "cheeseburger";&#160;&#160;// let the compiler count elements</p>
<p class="answer"><a id="ch04qa1a7" href="ch04.html#ch04qa1q7"><strong>7.</strong></a> <code>string lunch = "Waldorf Salad";</code></p>
<p class="indenthanding1">or, if you don&#8217;t have a <code>using</code> directive,</p>
<p class="programlistingB">std::string lunch = "Waldorf Salad";</p>
<p class="answer"><a id="ch04qa1a8" href="ch04.html#ch04qa1q8"><strong>8.</strong></a></p>
<p class="programlistingB">struct fish {<br/>&#160;&#160;&#160;&#160;char kind[20];<br/>&#160;&#160;&#160;&#160;int weight;<br/>&#160;&#160;&#160;&#160;float length;<br/>};</p>
<p class="answer"><a id="ch04qa1a9" href="ch04.html#ch04qa1q9"><strong>9.</strong></a></p>
<p class="programlistingB">fish petes =<br/>{<br/>&#160;&#160;&#160;&#160;"trout",<br/>&#160;&#160;&#160;&#160;12,<br/>&#160;&#160;&#160;&#160;26.25<br/>};</p>
<p class="answer1"><a id="ch04qa1a10" href="ch04.html#ch04qa1q10"><strong>10.</strong></a> <code>enum Response {No, Yes, Maybe};</code></p>
<p class="answer1"><a id="ch04qa1a11" href="ch04.html#ch04qa1q11"><strong>11.</strong></a></p>
<p class="programlistingB">double * pd = &#38;ted;<br/>cout &lt;&lt; *pd &lt;&lt; "\n";</p>
<p class="answer1"><a id="ch04qa1a12" href="ch04.html#ch04qa1q12"><strong>12.</strong></a></p>
<p class="programlistingB">float * pf = treacle;&#160;&#160;&#160;// or = &#38;treacle[0]<br/>cout &lt;&lt; pf[0] &lt;&lt; " " &lt;&lt; pf[9] &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// or use *pf and *(pf + 9)</p>
<p class="answer1"><a id="ch04qa1a13" href="ch04.html#ch04qa1q13"><strong>13.</strong></a> This assumes that the <code>iostream</code> and <code>vector</code> header files have been included and that there is a <code>using</code> directive:</p>
<p class="programlistingB">unsigned int size;<br/>cout &lt;&lt; "Enter a positive integer: ";<br/>cin &gt;&gt; size;<br/>int * dyn = new int [size];<br/>vector&lt;int&gt; dv(size);</p>
<p class="answer1"><a id="page_1339"/><a id="ch04qa1a14" href="ch04.html#ch04qa1q14"><strong>14.</strong></a> Yes, it is valid. The expression <code>"Home of the jolly bytes"</code> is a string constant; hence it evaluates as the address of the beginning of the string. The <code>cout</code> object interprets the address of a <code>char</code> as an invitation to print a string, but the type cast <code>(int *)</code> converts the address to type pointer-to-<code>int</code>, which is then printed as an address. In short, the statement prints the address of the string, assuming the <code>int</code> type is wide enough to hold an address.</p>
<p class="answer1"><a id="ch04qa1a15" href="ch04.html#ch04qa1q15"><strong>15.</strong></a></p>
<p class="programlistingB">struct fish<br/>{<br/>&#160;&#160;&#160;&#160;char kind[20];<br/>&#160;&#160;&#160;&#160;int weight;<br/>&#160;&#160;&#160;&#160;float length;<br/>};<br/><br/>fish * pole = new fish;<br/>cout &lt;&lt; "Enter kind of fish: ";<br/>cin &gt;&gt; pole-&gt;kind;</p>
<p class="answer1"><a id="ch04qa1a16" href="ch04.html#ch04qa1q16"><strong>16.</strong></a> Using <code>cin &gt;&gt; address</code> causes a program to skip over whitespace until it finds nonwhitespace. It then reads characters until it encounters whitespace again. Thus, it will skip over the newline following the numeric input, avoiding that problem. On the other hand, it will read just a single word, not an entire line.</p>
<p class="answer1"><a id="ch04qa1a17" href="ch04.html#ch04qa1q17"><strong>17.</strong></a></p>
<p class="programlistingB">#include &lt;string&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;array&gt;<br/>const int Str_num {10};&#160;&#160;// or = 10<br/>...<br/>std::vector&lt;std::string&gt; vstr(Str_num);<br/>std::array&lt;std::string, Str_num&gt; astr;</p>
<h3 id="app10lev1sec4">Answers to Chapter Review for Chapter 5</h3>
<p class="answer"><a id="ch05qa1a1" href="ch05.html#ch05qa1q1"><strong>1.</strong></a> An entry-condition loop evaluates a test expression before entering the body of the loop. If the condition is initially <code>false</code>, the loop never executes its body. An exit-condition loop evaluates a test expression after processing the body of the loop. Thus, the loop body is executed once, even if the test expression is initially <code>false</code>. The <code>for</code> and <code>while</code> loops are entry-condition loops, and the <code>do while</code> loop is an exit-condition loop.</p>
<p class="answer"><a id="ch05qa1a2" href="ch05.html#ch05qa1q2"><strong>2.</strong></a> It would print the following:</p>
<p class="programlistingB">01234</p>
<p class="indenthanding1">Note that <code>cout &lt;&lt; endl;</code> is not part of the loop body (because there are no braces).</p>
<p class="answer"><a id="page_1340"/><a id="ch05qa1a3" href="ch05.html#ch05qa1q3"><strong>3.</strong></a> It would print the following:</p>
<p class="programlistingB">0369<br/>12</p>
<p class="answer"><a id="ch05qa1a4" href="ch05.html#ch05qa1q4"><strong>4.</strong></a> It would print the following:</p>
<p class="programlistingB">6<br/>8</p>
<p class="answer"><a id="ch05qa1a5" href="ch05.html#ch05qa1q5"><strong>5.</strong></a> It would print the following:</p>
<p class="programlistingB">k = 8</p>
<p class="answer"><a id="ch05qa1a6" href="ch05.html#ch05qa1q6"><strong>6.</strong></a> It&#8217;s simplest to use the <code>*=</code> operator:</p>
<p class="programlistingB">for (int num = 1; num &lt;= 64; num *= 2)<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; num &lt;&lt; " ";</p>
<p class="answer"><a id="ch05qa1a7" href="ch05.html#ch05qa1q7"><strong>7.</strong></a> You enclose the statements within paired braces to form a single compound statement, or block.</p>
<p class="answer"><a id="ch05qa1a8" href="ch05.html#ch05qa1q8"><strong>8.</strong></a> Yes, the first statement is valid. The expression 1,024 consists of two expressions&#8212;1 and 024&#8212;joined by a comma operator. The value is the value of the right-hand expression. This is 024, which is octal for 20, so the declaration assigns the value <code>20</code> to <code>x</code>. The second statement is also valid. However, operator precedence causes it to be evaluated as follows:</p>
<p class="programlistingB">(y = 1), 024;</p>
<p class="indenthanding1">That is, the left expression sets <code>y</code> to <code>1</code>, and the value of the entire expression, which isn&#8217;t used, is <code>024</code>, or <code>20</code>.</p>
<p class="answer"><a id="ch05qa1a9" href="ch05.html#ch05qa1q9"><strong>9.</strong></a> The <code>cin &gt;&gt; ch</code> form skips over spaces, newlines, and tabs when it encounters them. The other two forms read those characters.</p>
<h3 id="app10lev1sec5">Answers to Chapter Review for Chapter 6</h3>
<p class="answer"><a id="ch06qa1a1" href="ch06.html#ch06qa1q1"><strong>1.</strong></a> Both versions give the same answers, but the <code>if else</code> version is more efficient. Consider what happens, for example, when <code>ch</code> is a space. Version 1, after incrementing spaces, tests whether the character is a newline. This wastes time because the program has already established that <code>ch</code> is a space and hence could not be a newline. Version 2, in the same situation, skips the newline test.</p>
<p class="answer"><a id="ch06qa1a2" href="ch06.html#ch06qa1q2"><strong>2.</strong></a> Both <code>++ch</code> and <code>ch + 1</code> have the same numerical value. But <code>++ch</code> is type <code>char</code> and prints as a character, while <code>ch + 1</code>, because it adds a <code>char</code> to an <code>int</code>, is type <code>int</code> and prints as a number.</p>
<p class="answer"><a id="page_1341"/><a id="ch06qa1a3" href="ch06.html#ch06qa1q3"><strong>3.</strong></a> Because the program uses <code>ch = '$'</code> instead of <code>ch == '$'</code>, the combined input and output looks like this:</p>
<p class="programlistingB">Hi!<br/>H$i$!$<br/>$Send $10 or $20 now!<br/>S$e$n$d$ $ct1 = 9, ct2 = 9</p>
<p class="indenthanding1">Each character is converted to the <code>$</code> character before being printed the second time. Also the value of the expression <code>ch = $</code> is the code for the <code>$</code> character, hence nonzero, hence <code>true</code>; so <code>ct2</code> is incremented each time.</p>
<p class="answer"><a id="ch06qa1a4" href="ch06.html#ch06qa1q4"><strong>4.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> <code>weight &gt;= 115 &#38;&#38; weight &lt; 125</code></p>
<p class="indenthandinga"><strong>b.</strong> <code>ch == 'q' || ch == 'Q'</code></p>
<p class="indenthandinga"><strong>c.</strong> <code>x % 2 == 0 &#38;&#38; x != 26</code></p>
<p class="indenthandinga"><strong>d.</strong> <code>x % 2 == 0 &#38;&#38; !(x % 26 == 0)</code></p>
<p class="indenthandinga"><strong>e.</strong> <code>donation &gt;= 1000 &#38;&#38; donation &lt;= 2000 || guest == 1</code></p>
<p class="indenthandinga"><strong>f.</strong> <code>(ch &gt;= 'a' &#38;&#38; ch &lt;= 'z') ||(ch &gt;= 'A' &#38;&#38; ch &lt;= 'Z')</code></p>
<p class="answer"><a id="ch06qa1a5" href="ch06.html#ch06qa1q5"><strong>5.</strong></a> Not necessarily. For example, if <code>x</code> is <code>10</code>, then <code>!x</code> is <code>0</code> and <code>!!x</code> is <code>1</code>. However, if <code>x</code> is a <code>bool</code> variable, then <code>!!x</code> is <code>x</code>.</p>
<p class="answer"><a id="ch06qa1a6" href="ch06.html#ch06qa1q6"><strong>6.</strong></a> <code>(x &lt; 0)? -x : x</code></p>
<p class="indenthanding1">or</p>
<p class="programlistingB">(x &gt;= 0)? x : -x;</p>
<p class="answer"><a id="ch06qa1a7" href="ch06.html#ch06qa1q7"><strong>7.</strong></a></p>
<p class="programlistingB">switch (ch)<br/>{<br/>&#160;&#160;&#160;&#160;case 'A': a_grade++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case 'B': b_grade++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case 'C': c_grade++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;case 'D': d_grade++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;default:&#160;&#160;f_grade++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>}</p>
<p class="answer"><a id="ch06qa1a8" href="ch06.html#ch06qa1q8"><strong>8.</strong></a> If you use integer labels and the user types a noninteger such as <strong><code>q</code></strong>, the program hangs because integer input can&#8217;t process a character. But if you use character labels and the user types an integer such as <strong><code>5</code></strong>, character input will process <code>5</code> as a character. Then the default part of the switch can suggest entering another character.</p>
<p class="answer"><a id="page_1342"/><a id="ch06qa1a9" href="ch06.html#ch06qa1q9"><strong>9.</strong></a> Here is one version:</p>
<p class="programlistingB">int line = 0;<br/>char ch;<br/>while (cin.get(ch) &#38;&#38; ch != 'Q')<br/>{<br/>&#160;&#160;&#160;&#160;if (ch == '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line++;<br/>}</p>
<h3 id="app10lev1sec6">Answers to Chapter Review for Chapter 7</h3>
<p class="answer"><a id="ch07qa1a1" href="ch07.html#ch07qa1q1"><strong>1.</strong></a> The three steps are defining the function, providing a prototype, and calling the function.</p>
<p class="answer"><a id="ch07qa1a2" href="ch07.html#ch07qa1q2"><strong>2.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> <code>void igor(void); // or void igor()</code></p>
<p class="indenthandinga"><strong>b.</strong> <code>float tofu(int n); // or float tofu(int);</code></p>
<p class="indenthandinga"><strong>c.</strong> <code>double mpg(double miles, double gallons);</code></p>
<p class="indenthandinga"><strong>d.</strong> <code>long summation(long harray[], int size);</code></p>
<p class="indenthandinga"><strong>e.</strong> <code>double doctor(const char * str);</code></p>
<p class="indenthandinga"><strong>f.</strong> <code>void ofcourse(boss dude);</code></p>
<p class="indenthandinga"><strong>g.</strong> <code>char * plot(map *pmap);</code></p>
<p class="answer"><a id="ch07qa1a3" href="ch07.html#ch07qa1q3"><strong>3.</strong></a></p>
<p class="programlistingB">void set_array(int arr[], int size, int value)<br/>{<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; size; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arr[i] = value;<br/>}</p>
<p class="answer"><a id="ch07qa1a4" href="ch07.html#ch07qa1q4"><strong>4.</strong></a></p>
<p class="programlistingB">void set_array(int * begin, int * end, int value)<br/>{<br/>&#160;&#160;&#160;&#160;for (int * pt = begin; pt != end; pt++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pt* = value;<br/>}</p>
<p class="answer"><a id="ch07qa1a5" href="ch07.html#ch07qa1q5"><strong>5.</strong></a></p>
<p class="programlistingB">double biggest (const double foot[], int size)<br/>{<br/>&#160;&#160;&#160;&#160;double max;<br/>&#160;&#160;&#160;&#160;if (size &lt; 1)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Invalid array size of " &lt;&lt; size &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Returning a value of 0\n";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;<br/><a id="page_1343"/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;// not necessary because return terminates program<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max = foot[0];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 1; i &lt; size; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (foot[i] &gt; max)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max = foot[i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return max;<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<p class="answer"><a id="ch07qa1a6" href="ch07.html#ch07qa1q6"><strong>6.</strong></a> You use the <code>const</code> qualifier with pointers to protect the original pointed-to data from being altered. When a program passes a fundamental type such as an <code>int</code> or a <code>double</code>, it passes it by value so that the function works with a copy. Thus, the original data is already protected.</p>
<p class="answer"><a id="ch07qa1a7" href="ch07.html#ch07qa1q7"><strong>7.</strong></a> A string can be stored in a <code>char</code> array, it can be represented by a string constant in double quotation marks, and it can be represented by a pointer pointing to the first character of a string.</p>
<p class="answer"><a id="ch07qa1a8" href="ch07.html#ch07qa1q8"><strong>8.</strong></a></p>
<p class="programlistingB">int replace(char * str, char c1, char c2)<br/>{<br/>&#160;&#160;&#160;&#160;int count = 0;<br/>&#160;&#160;&#160;&#160;while (*str)&#160;&#160;&#160;&#160;&#160;&#160;// while not at end of string<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*str == c1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*str = c2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count++;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str++;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// advance to next character<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;return count;<br/>}</p>
<p class="answer"><a id="ch07qa1a9" href="ch07.html#ch07qa1q9"><strong>9.</strong></a> Because C++ interprets <code>"pizza"</code> as the address of its first element, applying the <code>*</code> operator yields the value of that first element, which is the character <code>p</code>. Because C++ interprets <code>"taco"</code> as the address of its first element, it interprets <code>"taco"[2]</code> as the value of the element two positions down the line&#8212;that is, as the character <code>c</code>. In other words, the string constant acts the same as an array name.</p>
<p class="answer1"><a id="ch07qa1a10" href="ch07.html#ch07qa1q10"><strong>10.</strong></a> To pass it by value, you just pass the structure name <code>glitz</code>. To pass its address, you use the address operator <code>&#38;glitz</code>. Passing by the value automatically protects the original data, but it takes time and memory. Passing by address saves time and memory but doesn&#8217;t protect the original data unless you use the <code>const</code> modifier for the function parameter. Also passing by value means you can use ordinary structure <a id="page_1344"/>member notation, but passing a pointer means you have to remember to use the indirect membership operator.</p>
<p class="answer1"><a id="ch07qa1a11" href="ch07.html#ch07qa1q11"><strong>11.</strong></a> <code>int judge (int (*pf)(const char *));</code></p>
<p class="answer1"><a id="ch07qa1a12" href="ch07.html#ch07qa1q12"><strong>12.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> Note that if <code>ap</code> is an <code>applicant</code> structure, then <code>ap.credit_ratings</code> is an array name and <code>ap.credit_ratings[i]</code> is an array element.</p>
<p class="programlistingB1">void display(applicant ap)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; ap.name &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 3; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout&#160;&#160;&lt;&lt; ap.credit_ratings[i] &lt;&lt;&#160;&#160;endl;<br/>}</p>
<p class="indenthandinga"><strong>b.</strong> Note that if <code>pa</code> is a pointer to an <code>applicant</code> structure, then <code>pa-&gt;credit_ratings</code> is an array name and <code>pa-&gt;credit_ratings[i]</code> is an array element.</p>
<p class="programlistingB1">void show(const applicant * pa)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; pa-&gt;name &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; 3; i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout&#160;&#160;&lt;&lt; pa-&gt;credit_ratings[i] &lt;&lt;&#160;&#160;endl;<br/>}</p>
<p class="answer1"><a id="ch07qa1a13" href="ch07.html#ch07qa1q13"><strong>13.</strong></a></p>
<p class="programlistingB">typedef void (*p_f1)(applicant *);<br/>p_f1 p1 = f1;<br/>typedef const char * (*p_f2)(const applicant *, const applicant *);<br/>p_f2 p2 = f2;<br/>p_f1 ap[5];<br/>p_f2 (*pa)[10];</p>
<h3 id="app10lev1sec7">Answers to Chapter Review for Chapter 8</h3>
<p class="answer"><a id="ch08qa1a1" href="ch08.html#ch08qa1q1"><strong>1.</strong></a> Short, nonrecursive functions that can fit in one line of code are good candidates for inline status.</p>
<p class="answer"><a id="ch08qa1a2" href="ch08.html#ch08qa1q2"><strong>2.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> <code>void song(const char * name, int times = 1);</code></p>
<p class="indenthandinga"><strong>b.</strong> None. Only prototypes contain the default value information.</p>
<p class="indenthandinga"><strong>c.</strong> Yes, provided that you retain the default value for <code>times</code>:</p>
<p class="programlistingB1">void song(char * name = "O, My Papa", int times = 1);</p>
<p class="answer"><a id="ch08qa1a3" href="ch08.html#ch08qa1q3"><strong>3.</strong></a> You can use either the string &#8243;\&#8243;&#8243; or the character &#8242;&#8243;&#8242; to print a quotation mark. The following functions show both methods:</p>
<p class="programlistingB">#include &lt;iostream.h&gt;<br/>void iquote(int n)<br/><a id="page_1345"/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"" &lt;&lt; n &lt;&lt; "\"";<br/>}<br/><br/>void iquote(double x)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; '"' &lt;&lt; x &lt;&lt; '"';<br/>}<br/><br/>void iquote(const char * str)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt; "\"";<br/>}</p>
<p class="answer"><a id="ch08qa1a4" href="ch08.html#ch08qa1q4"><strong>4.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> This function shouldn&#8217;t alter the structure members, so use the <code>const</code> qualifier:</p>
<p class="programlistingB1">void show_box(const box &#38; container)<br/>{<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Made by " &lt;&lt; container. maker &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Height = " &lt;&lt; container.height &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Width = " &lt;&lt; container.width &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Length = " &lt;&lt; container.length &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Volume = " &lt;&lt; container.volume &lt;&lt; endl;<br/>}</p>
<p class="indenthandinga"><strong>b.</strong></p>
<p class="programlistingB1">void set_volume(box &#38; crate)<br/>{<br/>&#160;&#160;&#160;&#160;crate.volume = crate.height * crate.width * crate.length;<br/>}</p>
<p class="answer"><a id="ch08qa1a5" href="ch08.html#ch08qa1q5"><strong>5.</strong></a> First, change the prototypes to the following:</p>
<p class="programlistingB">// function to modify array object<br/>void fill(std::array&lt;double, Seasons&gt; &#38; pa);<br/>// function that uses array object without modifying it<br/>void show(const std::array&lt;double, Seasons&gt; &#38; da);</p>
<p class="indenthanding1">Note that <code>show()</code> should use <code>const</code> to protect the object from being modified. Next, within <code>main()</code>, change the <code>fill()</code> call to this:</p>
<p class="programlistingB">fill(expenses);</p>
<p class="indenthanding1">There&#8217;s no change to the <code>show()</code> call.</p>
<p class="indenthanding1"><a id="page_1346"/>Next, the new <code>fill()</code> should look like this:</p>
<p class="programlistingB">void fill(std::array&lt;double, Seasons&gt; &#38; pa)&#160;&#160;// changed<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; Seasons; i++)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter " &lt;&lt; Snames[i] &lt;&lt; " expenses: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin &gt;&gt; pa[i];&#160;&#160;&#160;&#160;&#160;// changed<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
<p class="indenthanding1">Note that <code>(*pa)[i]</code> gets changed to the simpler <code>pa[i]</code>.</p>
<p class="indenthanding1">Finally, the only change to <code>show()</code> is to the function header:</p>
<p class="programlistingB">void show(std::array&lt;double, Seasons&gt; &#38; da)</p>
<p class="answer"><a id="ch08qa1a6" href="ch08.html#ch08qa1q6"><strong>6.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> This can be done by using a default value for the second argument:</p>
<p class="programlistingB1">double mass(double d, double v = 1.0);</p>
<p class="indenthandinga1">It can also be done by using function overloading:</p>
<p class="programlistingB1">double mass(double d, double v);<br/>double mass(double d);</p>
<p class="indenthandinga"><strong>b.</strong> You can&#8217;t use a default for the repeat value because you have to provide default values from right to left. You can use overloading:</p>
<p class="programlistingB1">void repeat(int times, const char * str);<br/>void repeat(const char * str);</p>
<p class="indenthandinga"><strong>c.</strong> You can use function overloading:</p>
<p class="programlistingB1">int average(int a, int b);<br/>double average(double x, double y);</p>
<p class="indenthandinga"><strong>d.</strong> You can&#8217;t do this because both versions would have the same signature.</p>
<p class="answer"><a id="ch08qa1a7" href="ch08.html#ch08qa1q7"><strong>7.</strong></a></p>
<p class="programlistingB">template&lt;class T&gt;<br/>T max(T t1, T t2)&#160;&#160;// or T max(const T &#38; t1, const T &#38; t2)<br/>{<br/>&#160;&#160;&#160;&#160;return t1 &gt; t2? t1 : t2;<br/>}</p>
<p class="answer"><a id="ch08qa1a8" href="ch08.html#ch08qa1q8"><strong>8.</strong></a></p>
<p class="programlistingB">template&lt;&gt; box max(box b1, box b2)<br/>{<br/>&#160;&#160;&#160;&#160;return b1.volume &gt; b2.volume? b1 : b2;<br/>}</p>
<p class="answer"><a id="page_1347"/><a id="ch08qa1a9" href="ch08.html#ch08qa1q9"><strong>9.</strong></a> <code>v1</code> is type <code>float</code>, <code>v2</code> is type <code>float &#38;</code>, <code>v3</code> is type <code>float &#38;</code>, <code>v4</code> is type <code>int</code>, and <code>v5</code> is type <code>double</code>. The literal <code>2.0</code> is type <code>double</code>, so the product <code>2.0 * m</code> is double.</p>
<h3 id="app10lev1sec8">Answers to Chapter Review for Chapter 9</h3>
<p class="answer"><a id="ch09qa1a1" href="ch09.html#ch09qa1q1"><strong>1.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> <code>homer</code> is automatically an automatic variable.</p>
<p class="indenthandinga"><strong>b.</strong> <code>secret</code> should be defined as an external variable in one file and declared using <code>extern</code> in the second file.</p>
<p class="indenthandinga"><strong>c.</strong> <code>topsecret</code> could be defined as a static variable with internal linkage by prefacing the external definition with the keyword <code>static</code>. Or it could be defined in an unnamed namespace.</p>
<p class="indenthandinga"><strong>d.</strong> <code>beencalled</code> should be defined as a local static variable by prefacing a declaration in the function with the keyword <code>static</code>.</p>
<p class="answer"><a id="ch09qa1a2" href="ch09.html#ch09qa1q2"><strong>2.</strong></a> A <code>using</code> declaration makes available a single name from a namespace, and it has the scope corresponding to the declarative region in which the <code>using</code> declaration occurs. A <code>using</code> directive makes available all the names in a namespace. When you use a <code>using</code> directive, it is as if you have declared the names in the smallest declarative region containing both the <code>using</code> declaration and the namespace itself.</p>
<p class="answer"><a id="ch09qa1a3" href="ch09.html#ch09qa1q3"><strong>3.</strong></a></p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double x;<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Enter value: ";<br/>&#160;&#160;&#160;&#160;while (! (std::cin &gt;&gt; x) )<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Bad input. Please enter a number: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::cin.clear();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (std::cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Value = " &lt;&lt; x &lt;&lt; std::endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="answer"><a id="ch09qa1a4" href="ch09.html#ch09qa1q4"><strong>4.</strong></a> Here is the revised code:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using std::cin;<br/>&#160;&#160;&#160;&#160;using std::cout;<br/>&#160;&#160;&#160;&#160;using std::endl;<br/><a id="page_1348"/>&#160;&#160;&#160;&#160;double x;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter value: ";<br/>&#160;&#160;&#160;&#160;while (! (cin &gt;&gt; x) )<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "Bad input. Please enter a number: ";<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin.clear();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cin.get() != '\n')<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Value = " &lt;&lt; x &lt;&lt; endl;<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="answer"><a id="ch09qa1a5" href="ch09.html#ch09qa1q5"><strong>5.</strong></a> You could have separate static function definitions in each file. Or each file could define the appropriate <code>average()</code> function in an unnamed namespace.</p>
<p class="answer"><a id="ch09qa1a6" href="ch09.html#ch09qa1q6"><strong>6.</strong></a></p>
<p class="programlistingB">10<br/>4<br/>0<br/>Other: 10, 1<br/>another(): 10, -4</p>
<p class="answer"><a id="ch09qa1a7" href="ch09.html#ch09qa1q7"><strong>7.</strong></a></p>
<p class="programlistingB">1<br/>4, 1, 2<br/>2<br/>2<br/>4, 1, 2<br/>2</p>
<h3 id="app10lev1sec9">Answers to Chapter Review for Chapter 10</h3>
<p class="answer"><a id="ch10qa1a1" href="ch10.html#ch10qa1q1"><strong>1.</strong></a> A class is a definition of a user-defined type. A class declaration specifies how data is to be stored, and it specifies the methods (class member functions) that can be used to access and manipulate that data.</p>
<p class="answer"><a id="ch10qa1a2" href="ch10.html#ch10qa1q2"><strong>2.</strong></a> A class represents the operations you can perform on a class object with a public interface of class methods; this is abstraction. The class can use private visibility (the default) for data members, meaning that the data can be accessed only through the member functions; this is data hiding. Details of the implementation, such as data representation and method code, are hidden; this is encapsulation.</p>
<p class="answer"><a id="ch10qa1a3" href="ch10.html#ch10qa1q3"><strong>3.</strong></a> A class defines a type, including how it can be used. An object is a variable or another data object, such as that produced by <code>new</code>, which is created and used according to the class definition. The relationship between a class and an object is the same as that between a standard type and a variable of that type.</p>
<p class="answer"><a id="page_1349"/><a id="ch10qa1a4" href="ch10.html#ch10qa1q4"><strong>4.</strong></a> If you create several objects of a given class, each object comes with storage for its own set of data. But all the objects use the one set of member functions. (Typically, methods are public and data members are private, but that&#8217;s a matter of policy, not of class requirements.)</p>
<p class="answer"><a id="ch10qa1a5" href="ch10.html#ch10qa1q5"><strong>5.</strong></a> This example use <code>char</code> arrays to hold the character data, but you could use <code>string</code> class objects instead.</p>
<p class="programlistingB">// #include &lt;cstring&gt;<br/><br/>// class definition<br/>class BankAccount<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;char name[40];&#160;&#160;&#160;&#160;&#160;// or std::string name;<br/>&#160;&#160;&#160;&#160;char acctnum[25];&#160;&#160;// or std::string acctnum;<br/>&#160;&#160;&#160;&#160;double balance;<br/>public:<br/>&#160;&#160;&#160;&#160;BankAccount(const char * client, const char * num, double bal = 0.0);<br/>//or BankAccount(const std::string &#38; client,<br/>//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38; num, double bal = 0.0);<br/><br/>&#160;&#160;&#160;&#160;void show(void) const;<br/>&#160;&#160;&#160;&#160;void deposit(double cash);<br/>&#160;&#160;&#160;&#160;void withdraw(double cash);<br/>};</p>
<p class="answer"><a id="ch10qa1a6" href="ch10.html#ch10qa1q6"><strong>6.</strong></a> A class constructor is called when you create an object of that class or when you explicitly call the constructor. A class destructor is called when the object expires.</p>
<p class="answer"><a id="ch10qa1a7" href="ch10.html#ch10qa1q7"><strong>7.</strong></a> These are two possible solutions (note that you must include <code>cstring</code> or <code>string.h</code> in order to use <code>strncpy()</code> or else you must include <code>string</code> to use the <code>string</code> class):</p>
<p class="programlistingB">BankAccount::BankAccount(const char * client, const char * num, double bal)<br/>{<br/>&#160;&#160;&#160;&#160;strncpy(name, client, 39);<br/>&#160;&#160;&#160;&#160;name[39] = '\0';<br/>&#160;&#160;&#160;&#160;strncpy(acctnum, num, 24);<br/>&#160;&#160;&#160;&#160;acctnum[24] = '\0';<br/>&#160;&#160;&#160;&#160;balance = bal;<br/>}</p>
<p class="indenthanding1">or</p>
<p class="programlistingB">BankAccount::BankAccount(const std::string &#38; client,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &#38; num, double bal)<br/>{<br/>&#160;&#160;&#160;&#160;name = client;<br/><a id="page_1350"/>&#160;&#160;&#160;&#160;acctnum = num;<br/>&#160;&#160;&#160;&#160;balance = bal;<br/>}</p>
<p class="indenthanding1">Keep in mind that default arguments go in the prototype, not in the function definition.</p>
<p class="answer"><a id="ch10qa1a8" href="ch10.html#ch10qa1q8"><strong>8.</strong></a> A default constructor either has no arguments or has defaults for all the arguments. Having a default constructor enables you to declare objects without initializing them, even if you&#8217;ve already defined an initializing constructor. It also allows you to declare arrays.</p>
<p class="answer"><a id="ch10qa1a9" href="ch10.html#ch10qa1q9"><strong>9.</strong></a></p>
<p class="programlistingB">// stock30.h<br/>#ifndef STOCK30_H_<br/>#define STOCK30_H_<br/><br/>class Stock<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;std::string company;<br/>&#160;&#160;&#160;&#160;long shares;<br/>&#160;&#160;&#160;&#160;double share_val;<br/>&#160;&#160;&#160;&#160;double total_val;<br/>&#160;&#160;&#160;&#160;void set_tot() { total_val = shares * share_val; }<br/>public:<br/>&#160;&#160;&#160;&#160;Stock();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// default constructor<br/>&#160;&#160;&#160;&#160;Stock(const std::string &#38; co, long n, double pr);<br/>&#160;&#160;&#160;&#160;~Stock() {}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// do-nothing destructor<br/>&#160;&#160;&#160;&#160;void buy(long num, double price);<br/>&#160;&#160;&#160;&#160;void sell(long num, double price);<br/>&#160;&#160;&#160;&#160;void update(double price);<br/>&#160;&#160;&#160;&#160;void show() const;<br/>&#160;&#160;&#160;&#160;const Stock &#38; topval(const Stock &#38; s) const;<br/>&#160;&#160;&#160;&#160;int numshares() const { return shares; }<br/>&#160;&#160;&#160;&#160;double shareval() const { return share_val; }<br/>&#160;&#160;&#160;&#160;double totalval() const { return total_val; }<br/>&#160;&#160;&#160;&#160;const string &#38; co_name() const { return company; }<br/>};</p>
<p class="answer1"><a id="ch10qa1a10" href="ch10.html#ch10qa1q10"><strong>10.</strong></a> The <code>this</code> pointer is available to class methods. It points to the object used to invoke the method. Thus, <code>this</code> is the address of the object, and <code>*this</code> represents the object itself.</p>
<h3 id="app10lev1sec10">Answers to Chapter Review for Chapter 11</h3>
<p class="answer"><a id="ch11qa1a1" href="ch11.html#ch11qa1q1"><strong>1.</strong></a> Here&#8217;s a prototype for the class definition file and a function definition for the methods file:</p>
<p class="programlistingB">// prototype<br/>Stonewt operator*(double mult);<br/><br/>// definition &#8212; let constructor do the work<br/>Stonewt Stonewt::operator*(double mult)<br/>{<br/>&#160;&#160;&#160;&#160;return Stonewt(mult * pounds);<br/>}</p>
<p class="answer"><a id="ch11qa1a2" href="ch11.html#ch11qa1q2"><strong>2.</strong></a> A member function is part of a class definition and is invoked by a particular object. The member function can access members of the invoking object implicitly, without using the membership operator. A friend function is not part of a class, so it&#8217;s called as a straight function call. It can&#8217;t access class members implicitly, so it must use the membership operator applied to an object passed as an argument. Compare, for instance, the answer to Review Question 1 with the answer to Review Question 4.</p>
<p class="answer"><a id="ch11qa1a3" href="ch11.html#ch11qa1q3"><strong>3.</strong></a> It must be a friend to access private members, but it doesn&#8217;t have to be a friend to access public members.</p>
<p class="answer"><a id="ch11qa1a4" href="ch11.html#ch11qa1q4"><strong>4.</strong></a> Here&#8217;s a prototype for the class definition file and a function definition for the methods file:</p>
<p class="programlistingB">// prototype<br/>friend Stonewt operator*(double mult, const Stonewt &#38; s);<br/><br/>// definition &#8212; let constructor do the work<br/>Stonewt operator*(double mult, const Stonewt &#38; s)<br/>{<br/>&#160;&#160;&#160;&#160;return Stonewt(mult * s.pounds);<br/>}</p>
<p class="answer"><a id="ch11qa1a5" href="ch11.html#ch11qa1q5"><strong>5.</strong></a> The following five operators cannot be overloaded:</p>
<p class="programlistingB">sizeof<br/>.<br/>.*<br/>::<br/>? :</p>
<p class="answer"><a id="ch11qa1a6" href="ch11.html#ch11qa1q6"><strong>6.</strong></a> These operators must be defined by using a member function.</p>
<p class="answer"><a id="page_1352"/><a id="ch11qa1a7" href="ch11.html#ch11qa1q7"><strong>7.</strong></a> Here are a possible prototype and definition:</p>
<p class="programlistingB">// prototype and inline definition<br/>operator double () {return mag;}</p>
<p class="indenthanding1">Note, however, that it makes better sense to use the <code>magval()</code> method than to define this conversion function.</p>
<h3 id="app10lev1sec11"><a id="page_1351"/>Answers to Chapter Review for Chapter 12</h3>
<p class="answer"><a id="ch12qa1a1" href="ch12.html#ch12qa1q1"><strong>1.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> The syntax is fine, but this constructor leaves the <code>str</code> pointer uninitialized. The constructor should either set the pointer to <code>NULL</code> or use <code>new []</code> to initialize the pointer.</p>
<p class="indenthandinga"><strong>b.</strong> This constructor does not create a new string; it merely copies the address of the old string. It should use <code>new []</code> and <code>strcpy()</code>.</p>
<p class="indenthandinga"><strong>c.</strong> It copies the string without allocating the space to store it. It should use <code>new char[len + 1]</code> to allocate the proper amount of memory.</p>
<p class="answer"><a id="ch12qa1a2" href="ch12.html#ch12qa1q2"><strong>2.</strong></a> First, when an object of that type expires, the data pointed to by the object&#8217;s member pointer remains in memory, using space and remaining inaccessible because the pointer has been lost. That can be fixed by having the class destructor delete memory allocated by <code>new</code> in the constructor functions. Second, after the destructor deletes such memory, it might end up trying to delete it twice if a program initializes one such object to another. That&#8217;s because the default initialization of one object to another copies pointer values but does not copy the pointed-to data, and this produces two pointers to the same data. The solution is to define a class copy constructor that causes initialization to copy the pointed-to data. Third, assigning one object to another can produce the same situation of two pointers pointing to the same data. The solution is to overload the assignment operator so that it copies the data, not the pointers.</p>
<p class="answer"><a id="ch12qa1a3" href="ch12.html#ch12qa1q3"><strong>3.</strong></a> C++ automatically provides the following member functions:</p>
<p class="indenthandingB1">&#8226; A default constructor if you define no constructors</p>
<p class="indenthandingB1">&#8226; A copy constructor if you don&#8217;t define one</p>
<p class="indenthandingB1">&#8226; An assignment operator if you don&#8217;t define one</p>
<p class="indenthandingB1">&#8226; A default destructor if you don&#8217;t define one</p>
<p class="indenthandingB1">&#8226; An address operator if you don&#8217;t define one</p>
<p class="indenthanding1">The default constructor does nothing, but it allows you to declare arrays and uninitialized objects. The default copy constructor and the default assignment operator use memberwise assignment. The default destructor does nothing. The implicit address operator returns the address of the invoking object (that is, the value of the <code>this</code> pointer).</p>
<p class="answer"><a id="page_1353"/><a id="ch12qa1a4" href="ch12.html#ch12qa1q4"><strong>4.</strong></a> The <code>personality</code> member should be declared either as a character array or as a pointer-to-<code>char</code>. Or you could make it a <code>String</code> object or a <code>string</code> object. The declaration fails to make the methods public. Then there are several small errors. Here is a possible solution, with changes (other than deletions) in boldface:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>#include &lt;cstring&gt;<br/>using namespace std;<br/>class nifty<br/>{<br/>private: // optional<br/>&#160;&#160;&#160;&#160;char personality[<span class="EmpStrong">40</span>];&#160;&#160;&#160;&#160;// provide array size<br/>&#160;&#160;&#160;&#160;int talents;<br/><span class="EmpStrong">public:</span> // needed<br/>// methods<br/>&#160;&#160;&#160;&#160;nifty();<br/>&#160;&#160;&#160;&#160;nifty(<span class="EmpStrong">const</span> char * s);<br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">friend</span> ostream &#38; operator&lt;&lt;(ostream &#38; os, <span class="EmpStrong">const</span> nifty &#38; n);<br/>}<span class="EmpStrong">;</span>&#160;&#160;&#160;&#160;// note closing semicolon<br/><br/>nifty::nifty()<br/>{<br/>&#160;&#160;&#160;&#160;personality<span class="EmpStrong">[0]</span> = <span class="EmpStrong">'\0'</span>;<br/>&#160;&#160;&#160;&#160;talents = 0;<br/>}<br/><br/>nifty::nifty(<span class="EmpStrong">const</span> char * s)<br/>{<br/>&#160;&#160;&#160;&#160;strcpy(personality, s);<br/>&#160;&#160;&#160;&#160;talents = 0;<br/>}<br/><br/>ostream &#38; operator&lt;&lt;(ostream &#38; os, <span class="EmpStrong">const</span> nifty &#38; n)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; n.personality &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;os &lt;&lt; n.talent &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p class="indenthanding1">Here is another possible solution:</p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>#include &lt;cstring&gt;<br/>using namespace std;<br/>class nifty<br/>{<br/>private: // optional<br/>&#160;&#160;&#160;&#160;char * personality;&#160;&#160;&#160;&#160;// create a pointer<br/><a id="page_1354"/>&#160;&#160;&#160;&#160;int talents;<br/>public: // needed<br/>// methods<br/>&#160;&#160;&#160;&#160;nifty();<br/>&#160;&#160;&#160;&#160;nifty(<span class="EmpStrong">const</span> char * s);<br/>&#160;&#160;&#160;&#160;nifty(<span class="EmpStrong">const</span> nifty &#38; n);<br/>&#160;&#160;&#160;&#160;~nifty() { delete [] personality; }<br/>&#160;&#160;&#160;&#160;nifty &#38; operator=(const nifty &#38; n) const;<br/>&#160;&#160;&#160;&#160;<span class="EmpStrong">friend</span> ostream &#38; operator&lt;&lt;(ostream &#38; os, <span class="EmpStrong">const</span> nifty &#38; n);<br/>};&#160;&#160;&#160;&#160;// note closing semicolon<br/><br/>nifty::nifty()<br/>{<br/>&#160;&#160;&#160;&#160;personality = NULL;<br/>&#160;&#160;&#160;&#160;talents = 0;<br/>}<br/><br/>nifty::nifty(<span class="EmpStrong">const</span> char * s)<br/>{<br/>&#160;&#160;&#160;&#160;personality = new char [strlen(s) <span class="EmpStrong">+ 1</span>];<br/>&#160;&#160;&#160;&#160;strcpy(personality, s);<br/>&#160;&#160;&#160;&#160;talents = 0;<br/>}<br/><br/>ostream &#38; operator&lt;&lt;(ostream &#38; os, <span class="EmpStrong">const</span> nifty &#38; n)<br/>{<br/>&#160;&#160;&#160;&#160;os &lt;&lt; n.personality &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;os &lt;&lt; n.talent &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;return os;<br/>}</p>
<p class="answer"><a id="ch12qa1a5" href="ch12.html#ch12qa1q5"><strong>5.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong></p>
<p class="programlistingB1">Golfer nancy; // default constructor<br/>Golfer lulu("Little Lulu"); // Golfer(const char * name, int g)<br/>Golfer roy("Roy Hobbs", 12); // Golfer(const char * name, int g)<br/>Golfer * par = new Golfer; // default constructor<br/>Golfer next = lulu; // Golfer(const Golfer &#38;g)<br/>Golfer hazard = "Weed Thwacker"; // Golfer(const char * name, int g)<br/>*par = nancy; // default assignment operator<br/>nancy = "Nancy Putter";// Golfer(const char * name, int g), then<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// the default assignment operator</p>
<p class="indenthandinga1">Note that some compilers additionally call the default assignment operator for Statements 5 and 6.</p>
<p class="indenthandinga"><strong>b.</strong> The class should define an assignment operator that copies data rather than addresses.</p>
<h3 id="app10lev1sec12">Answers to Chapter Review for Chapter 13</h3>
<p class="answer"><a id="ch13qa1a1" href="ch13.html#ch13qa1q1"><strong>1.</strong></a> The public members of the base class become public members of the derived class. The protected members of the base class become protected members of the derived class. The private members of the base class are inherited but cannot be accessed directly. The answer to Review Question 2 provides the exceptions to these general rules.</p>
<p class="answer"><a id="ch13qa1a2" href="ch13.html#ch13qa1q2"><strong>2.</strong></a> The constructor methods are not inherited, the destructor is not inherited, the assignment operator is not inherited, and friends are not inherited.</p>
<p class="answer"><a id="ch13qa1a3" href="ch13.html#ch13qa1q3"><strong>3.</strong></a> If the return type were <code>void</code>, you would still be able to use single assignment but not chain assignment:</p>
<p class="programlistingB">baseDMA magazine("Pandering to Glitz", 1);<br/>baseDMA gift1, gift2, gift3;<br/>gift1 = magazine;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ok<br/>gift 2 = gift3 = gift1;&#160;&#160;&#160;// no longer valid</p>
<p class="indenthanding1">If the method returned an object instead of a reference, the method execution would be slowed a bit because the return statement would involve copying the object.</p>
<p class="answer"><a id="ch13qa1a4" href="ch13.html#ch13qa1q4"><strong>4.</strong></a> Constructors are called in the order of derivation, with the most ancestral constructor called first. Destructors are called in the opposite order.</p>
<p class="answer"><a id="ch13qa1a5" href="ch13.html#ch13qa1q5"><strong>5.</strong></a> Yes, every class requires its own constructors. If the derived class adds no new members, the constructor can have an empty body, but it must exist.</p>
<p class="answer"><a id="ch13qa1a6" href="ch13.html#ch13qa1q6"><strong>6.</strong></a> Only the derived-class method is called. It supersedes the base-class definition. A base-class method is called only if the derived class does not redefine the method or if you use the scope-resolution operator. However, you really should declare as virtual any functions that will be redefined.</p>
<p class="answer"><a id="ch13qa1a7" href="ch13.html#ch13qa1q7"><strong>7.</strong></a> The derived class should define an assignment operator if the derived-class constructors use the <code>new</code> or <code>new []</code> operator to initialize pointers that are members of that class. More generally, the derived class should define an assignment operator if the default assignment is incorrect for derived-class members.</p>
<p class="answer"><a id="ch13qa1a8" href="ch13.html#ch13qa1q8"><strong>8.</strong></a> Yes, you can assign the address of an object of a derived class to a pointer to the base class. You can assign the address of a base-class object to a pointer to a derived class (downcasting) only by making an explicit type cast, and it is not necessarily safe to use such a pointer.</p>
<p class="answer"><a id="ch13qa1a9" href="ch13.html#ch13qa1q9"><strong>9.</strong></a> Yes, you can assign an object of a derived class to an object of the base class. Any data members that are new to the derived type are not passed to the base type, however. The program uses the base-class assignment operator. Assignment in the <a id="page_1356"/>opposite direction (base to derived) is possible only if the derived class defines a conversion operator, which is a constructor that has a reference to the base type as its sole argument, or else defines an assignment operator with a base-class parameter.</p>
<p class="answer1"><a id="ch13qa1a10" href="ch13.html#ch13qa1q10"><strong>10.</strong></a> It can do so because C++ allows a reference to a base type to refer to any type derived from that base.</p>
<p class="answer1"><a id="ch13qa1a11" href="ch13.html#ch13qa1q11"><strong>11.</strong></a> Passing an object by value invokes the copy constructor. Because the formal argument is a base-class object, the base-class copy constructor is invoked. The copy constructor has as its argument a reference to the base class, and this reference can refer to the derived object passed as an argument. The net result is that a new base-class object whose members correspond to the base class portion of the derived object is produced.</p>
<p class="answer1"><a id="ch13qa1a12" href="ch13.html#ch13qa1q12"><strong>12.</strong></a> Passing an object by reference instead of by value enables the function to avail itself of virtual functions. Also passing an object by reference instead of by value may use less memory and time, particularly for large objects. The main advantage of passing by value is that it protects the original data, but you can accomplish the same end by passing the reference as a <code>const</code> type.</p>
<p class="answer1"><a id="ch13qa1a13" href="ch13.html#ch13qa1q13"><strong>13.</strong></a> If <code>head()</code> is a regular method, then <code>ph-&gt;head()</code> invokes <code>Corporation::head()</code>. If <code>head()</code> is a virtual function, then <code>ph-&gt;head()</code> invokes <code>PublicCorporation::head()</code>.</p>
<p class="answer1"><a id="ch13qa1a14" href="ch13.html#ch13qa1q14"><strong>14.</strong></a> First, the situation does not fit the <em>is-a</em> model, so public inheritance is not appropriate. Second, the definition of <code>area()</code> in <code>House</code> hides the <code>Kitchen</code> version of <code>area()</code> because the two methods have different signatures.</p>
<h3 id="app10lev1sec13"><a id="page_1355"/>Answers to Chapter Review for Chapter 14</h3>
<p class="answer"><a id="ch14qa1a1" href="ch14.html#ch14qa1q1"><strong>1.</strong></a></p>
<p class="image"><img src="graphics/1356tab01.jpg" alt="Image"/></p>
<p class="answer"><a id="page_1357"/><a id="ch14qa1a2" href="ch14.html#ch14qa1q2"><strong>2.</strong></a></p>
<p class="programlistingB">Gloam::Gloam(int g, const char * s) : glip(g), fb(s) { }<br/>Gloam::Gloam(int g, const Frabjous &#38; fr) : glip(g), fb(fr) { }<br/>// note: the above uses the default Frabjous copy constructor<br/>void Gloam::tell()<br/>{<br/>&#160;&#160;&#160;&#160;fb.tell();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; glip &lt;&lt; endl;<br/>}</p>
<p class="answer"><a id="ch14qa1a3" href="ch14.html#ch14qa1q3"><strong>3.</strong></a></p>
<p class="programlistingB">Gloam::Gloam(int g, const char * s)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: glip(g), Frabjous(s) { }<br/>Gloam::Gloam(int g, const Frabjous &#38; fr)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: glip(g), Frabjous(fr) { }<br/>// note: the above uses the default Frabjous copy constructor<br/>void Gloam::tell()<br/>{<br/>&#160;&#160;&#160;&#160;Frabjous::tell();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; glip &lt;&lt; endl;<br/>}</p>
<p class="answer"><a id="ch14qa1a4" href="ch14.html#ch14qa1q4"><strong>4.</strong></a></p>
<p class="programlistingB">class Stack&lt;Worker *&gt;<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;enum {MAX = 10};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// constant specific to class<br/>&#160;&#160;&#160;&#160;Worker * items[MAX];&#160;&#160;&#160;&#160;// holds stack items<br/>&#160;&#160;&#160;&#160;int top;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// index for top stack item<br/>public:<br/>&#160;&#160;&#160;&#160;Stack();<br/>&#160;&#160;&#160;&#160;Boolean isempty();<br/>&#160;&#160;&#160;&#160;Boolean isfull();<br/>&#160;&#160;&#160;&#160;Boolean push(const Worker * &#38; item); // add item to stack<br/>&#160;&#160;&#160;&#160;Boolean pop(Worker * &#38; item);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// pop top into item<br/>};</p>
<p class="answer"><a id="ch14qa1a5" href="ch14.html#ch14qa1q5"><strong>5.</strong></a></p>
<p class="programlistingB">ArrayTP&lt;string&gt; sa;<br/>StackTP&lt; ArrayTP&lt;double&gt; &gt; stck_arr_db;<br/>ArrayTP&lt; StackTP&lt;Worker *&gt; &gt; arr_stk_wpr;</p>
<p class="indenthanding1"><a href="ch14.html#ch14ex18">Listing 14.18</a> generates four templates: <code>ArrayTP&lt;int, 10&gt;</code>, <code>ArrayTP&lt;double, 10&gt;</code>, <code>ArrayTP&lt;int,5&gt;</code>, and <code>Array&lt; ArrayTP&lt;int,5&gt;, 10&gt;</code>.</p>
<p class="answer"><a id="ch14qa1a6" href="ch14.html#ch14qa1q6"><strong>6.</strong></a> If two lines of inheritance for a class share a common ancestor, the class winds up having two copies of the ancestor&#8217;s members. Making the ancestor class a virtual base class to its immediate descendants solves that problem.</p>
<h3 id="app10lev1sec14">Answers to Chapter Review for Chapter 15</h3>
<p class="answer"><a id="ch15qa1a1" href="ch15.html#ch15qa1q1"><strong>1.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong> The friend declaration should be as follows:</p>
<p class="programlistingB1">friend class clasp;</p>
<p class="indenthandinga"><strong>b.</strong> This needs a forward declaration so that the compiler can interpret <code>void snip(muff &#38;)</code>:</p>
<p class="programlistingB1">class muff;&#160;&#160;&#160;&#160;// forward declaration<br/>class cuff {<br/>public:<br/>&#160;&#160;&#160;&#160;void snip(muff &#38;) { ... }<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>class muff {<br/>&#160;&#160;&#160;&#160;friend void cuff::snip(muff &#38;);<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p class="indenthandinga"><strong>c.</strong> First, the <code>cuff</code> class declaration should precede the <code>muff</code> class so that the compiler can understand the term <code>cuff::snip()</code>. Second, the compiler needs a forward declaration of <code>muff</code> so that it can understand <code>snip(muff &#38;)</code>:</p>
<p class="programlistingB1">class muff;&#160;&#160;&#160;&#160;// forward declaration<br/>class cuff {<br/>public:<br/>&#160;&#160;&#160;&#160;void snip(muff &#38;) { ... }<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>class muff {<br/>&#160;&#160;&#160;&#160;friend void cuff::snip(muff &#38;);<br/>&#160;&#160;&#160;&#160;...<br/>};</p>
<p class="answer"><a id="ch15qa1a2" href="ch15.html#ch15qa1q2"><strong>2.</strong></a> No. For Class <code>A</code> to have a friend that&#8217;s a member function of Class <code>B</code>, the <code>B</code> declaration must precede the <code>A</code> declaration. A forward declaration is not enough because it would tell <code>A</code> that <code>B</code> is a class, but it wouldn&#8217;t reveal the names of the class members. Similarly, if <code>B</code> has a friend that&#8217;s a member function of <code>A</code>, the complete <code>A</code> declaration must precede the <code>B</code> declaration. These two requirements are mutually exclusive.</p>
<p class="answer"><a id="ch15qa1a3" href="ch15.html#ch15qa1q3"><strong>3.</strong></a> The only access to a class is through its public interface, which means the only thing you can do with a <code>Sauce</code> object is call the constructor to create one. The other members (<code>soy</code> and <code>sugar</code>) are private by default.</p>
<p class="answer"><a id="ch15qa1a4" href="ch15.html#ch15qa1q4"><strong>4.</strong></a> Suppose the function <code>f1()</code> calls the function <code>f2()</code>. A return statement in <code>f2()</code> causes program execution to resume at the next statement following the <code>f2()</code> function call in function <code>f1()</code>. A <code>throw</code> statement causes the program to back up <a id="page_1359"/>through the current sequence of function calls until it finds a <code>try</code> block that directly or indirectly contains the call to <code>f2()</code>. This might be in <code>f1()</code> or in a function that called <code>f1()</code>, and so on. Once there, execution goes to the next matching <code>catch</code> block, not to the first statement after the function call.</p>
<p class="answer"><a id="ch15qa1a5" href="ch15.html#ch15qa1q5"><strong>5.</strong></a> You should arrange the <code>catch</code> blocks in order, from most derived class to least derived.</p>
<p class="answer"><a id="ch15qa1a6" href="ch15.html#ch15qa1q6"><strong>6.</strong></a> For Sample #1, the <code>if</code> condition is <code>true</code> if <code>pg</code> points to a <code>Superb</code> object or to an object of any class descended from <code>Superb</code>. In particular, it is also <code>true</code> if <code>pg</code> points to a <code>Magnificent</code> object. In Sample #2, the <code>if</code> condition is <code>true</code> only for a <code>Superb</code> object, not for objects derived from <code>Superb</code>.</p>
<p class="answer"><a id="ch15qa1a7" href="ch15.html#ch15qa1q7"><strong>7.</strong></a> The <code>dynamic_cast</code> operator only allows upcasting in a class hierarchy, whereas a <code>static_cast</code> operator allows both upcasting and downcasting. The <code>static_cast</code> operator also allows conversions from enumeration types to integer types, and vice versa, and between various numeric types.</p>
<h3 id="app10lev1sec15"><a id="page_1358"/>Answers to Chapter Review for Chapter 16</h3>
<p class="answer"><a id="ch16qa1a1" href="ch16a.html#ch16qa1q1"><strong>1.</strong></a></p>
<p class="programlistingB">#include &lt;string&gt;<br/>using namespace std;<br/>class RQ1<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;string st;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// a string object<br/>public:<br/>&#160;&#160;&#160;&#160;RQ1() : st("") {}<br/>&#160;&#160;&#160;&#160;RQ1(const char * s) : st(s) {}<br/>&#160;&#160;&#160;&#160;~RQ1() {};<br/>// more stuff<br/>};</p>
<p class="indenthanding1">The explicit copy constructor, destructor, and assignment operator are no longer needed because the <code>string</code> object provides its own memory management.</p>
<p class="answer"><a id="ch16qa1a2" href="ch16a.html#ch16qa1q2"><strong>2.</strong></a> You can assign one <code>string</code> object to another. A <code>string</code> object provides its own memory management so that you normally don&#8217;t have to worry about a string exceeding the capacity of its holder.</p>
<p class="answer"><a id="ch16qa1a3" href="ch16a.html#ch16qa1q3"><strong>3.</strong></a></p>
<p class="programlistingB">#include &lt;string&gt;<br/>#include &lt;cctype&gt;<br/>using namespace std;<br/>void ToUpper(string &#38; str)<br/><a id="page_1360"/>{<br/>&#160;&#160;&#160;&#160;for (int i = 0; i &lt; str.size(); i++)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str[i] = toupper(str[i]);<br/>}</p>
<p class="answer"><a id="ch16qa1a4" href="ch16a.html#ch16qa1q4"><strong>4.</strong></a></p>
<p class="programlistingB">auto_ptr&lt;int&gt; pia= new int[20];&#160;&#160;// wrong, use with new, not new[]<br/>auto_ptr&lt;string&gt;(new string);&#160;&#160;&#160;&#160;// wrong, no name for pointer<br/>int rigue = 7;<br/>auto_ptr&lt;int&gt;(&#38;rigue);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// wrong, memory not allocated by new<br/>auto_ptr dbl (new double);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// wrong, omits &lt;double&gt;</p>
<p class="answer"><a id="ch16qa1a5" href="ch16a.html#ch16qa1q5"><strong>5.</strong></a> The LIFO aspect of a stack means you might have to remove a lot of clubs before reaching the one you need.</p>
<p class="answer"><a id="ch16qa1a6" href="ch16a.html#ch16qa1q6"><strong>6.</strong></a> The set will store just one copy of each value, so, say, five scores of <code>5</code> would be stored as a single <code>5</code>.</p>
<p class="answer"><a id="ch16qa1a7" href="ch16a.html#ch16qa1q7"><strong>7.</strong></a> Using iterators allows you to use objects with a pointer-like interface to move through data that is organized in some fashion other than an array (for example, data in a doubly linked list).</p>
<p class="answer"><a id="ch16qa1a8" href="ch16a.html#ch16qa1q8"><strong>8.</strong></a> The STL approach allows STL functions to be used with ordinary pointers to ordinary arrays as well as with iterators to STL container classes, thus increasing generality.</p>
<p class="answer"><a id="ch16qa1a9" href="ch16a.html#ch16qa1q9"><strong>9.</strong></a> You can assign one <code>vector</code> object to another. A <code>vector</code> manages its own memory, so you can insert items into a vector and have it resize itself automatically. By using the <code>at()</code> method, you can get automatic bounds checking.</p>
<p class="answer1"><a id="ch16qa1a10" href="ch16a.html#ch16qa1q10"><strong>10.</strong></a> The two <code>sort()</code> functions and the <code>random_shuffle()</code> function require a random access iterator, whereas a <code>list</code> object just has a bidirectional iterator. You can use the list template class <code>sort()</code> member functions (see <a href="app07.html#app07">Appendix G</a>, &#8220;The STL Methods and Functions&#8221;) instead of the general-purpose functions to do the sorting, but there is no member function equivalent to <code>random_shuffle()</code>. However, you could copy the list to a vector, shuffle the vector, and copy the results back to the list.</p>
<h3 id="app10lev1sec16">Answers to Chapter Review for Chapter 17</h3>
<p class="answer"><a id="ch17qa1a1" href="ch17.html#ch17qa1q1"><strong>1.</strong></a> The <code>iostream</code> file defines the classes, constants, and manipulators used to manage input and output. These objects manage the streams and buffers used to handle I/O. The file also creates standard objects (<code>cin</code>, <code>cout</code>, <code>cerr</code>, and <code>clog</code> and their wide-character equivalents) used to handle the standard input and output streams connected to every program.</p>
<p class="answer"><a id="page_1361"/><a id="ch17qa1a2" href="ch17.html#ch17qa1q2"><strong>2.</strong></a> Keyboard entry generates a series of characters. Typing <strong><code>121</code></strong> generates three characters, each represented by a 1-byte binary code. If the value is to be stored as type <code>int</code>, these three characters have to be converted to a single binary representation of the value 121.</p>
<p class="answer"><a id="ch17qa1a3" href="ch17.html#ch17qa1q3"><strong>3.</strong></a> By default, both the standard output and the standard error send output to the standard output device, typically a monitor. If you have the operating system redirect output to a file, however, the standard output connects to the file instead of to the screen, but the standard error continues to be connected to the screen.</p>
<p class="answer"><a id="ch17qa1a4" href="ch17.html#ch17qa1q4"><strong>4.</strong></a> The <code>ostream</code> class defines a version of the <code>operator&lt;&lt;()</code> function for each basic C++ type. The compiler interprets an expression like</p>
<p class="programlistingB">cout &lt;&lt; spot</p>
<p class="indenthanding1">as the following:</p>
<p class="programlistingB">cout.operator&lt;&lt;(spot)</p>
<p class="indenthanding1">It can then match this method call to the function prototype that has the same argument type.</p>
<p class="answer"><a id="ch17qa1a5" href="ch17.html#ch17qa1q5"><strong>5.</strong></a> You can concatenate output methods that return type <code>ostream &#38;</code>. This causes the invoking of a method with an object to return that object. The returned object can then invoke the next method in a sequence.</p>
<p class="answer"><a id="ch17qa1a6" href="ch17.html#ch17qa1q6"><strong>6.</strong></a></p>
<p class="programlistingB">//rq17-6.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;iomanip&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter an integer: ";<br/>&#160;&#160;&#160;&#160;int n;<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; n;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; setw(15) &lt;&lt; "base ten" &lt;&lt; setw(15)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "base sixteen" &lt;&lt; setw(15) &lt;&lt; "base eight" &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout.setf(ios::showbase);&#160;&#160;&#160;&#160;// or cout &lt;&lt; showbase;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; setw(15) &lt;&lt; n &lt;&lt; hex &lt;&lt; setw(15) &lt;&lt; n<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; oct &lt;&lt; setw(15) &lt;&lt; n &lt;&lt; "\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="answer"><a id="page_1362"/><a id="ch17qa1a7" href="ch17.html#ch17qa1q7"><strong>7.</strong></a></p>
<p class="programlistingB">//rq17-7.cpp<br/>#include &lt;iostream&gt;<br/>#include &lt;iomanip&gt;<br/><br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;using namespace std;<br/>&#160;&#160;&#160;&#160;char name[20];<br/>&#160;&#160;&#160;&#160;float hourly;<br/>&#160;&#160;&#160;&#160;float hours;<br/><br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your name: ";<br/>&#160;&#160;&#160;&#160;cin.get(name, 20).get();<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter your hourly wages: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; hourly;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Enter number of hours worked: ";<br/>&#160;&#160;&#160;&#160;cin &gt;&gt; hours;<br/><br/>&#160;&#160;&#160;&#160;cout.setf(ios::showpoint);<br/>&#160;&#160;&#160;&#160;cout.setf(ios::fixed, ios::floatfield);<br/>&#160;&#160;&#160;&#160;cout.setf(ios::right, ios::adjustfield);<br/>// or cout &lt;&lt; showpoint &lt;&lt; fixed &lt;&lt; right;<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "First format:\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; setw(30) &lt;&lt; name &lt;&lt; ": $" &lt;&lt; setprecision(2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setw(10) &lt;&lt; hourly &lt;&lt; ":" &lt;&lt; setprecision(1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setw(5) &lt;&lt; hours &lt;&lt; "\n";<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; "Second format:\n";<br/>&#160;&#160;&#160;&#160;cout.setf(ios::left, ios::adjustfield);<br/>&#160;&#160;&#160;&#160;cout &lt;&lt; setw(30) &lt;&lt; name &lt;&lt; ": $" &lt;&lt; setprecision(2)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setw(10) &lt;&lt; hourly &lt;&lt; ":" &lt;&lt; setprecision(1)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; setw(5) &lt;&lt; hours &lt;&lt; "\n";<br/><br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="answer"><a id="ch17qa1a8" href="ch17.html#ch17qa1q8"><strong>8.</strong></a> Here is the output:</p>
<p class="programlistingB">ct1 = 5; ct2 = 9</p>
<p class="indenthanding1">The first part of the program ignores spaces and newline characters; the second part doesn&#8217;t. Note that the second part of the program begins reading at the newline character following the first <code>q</code>, and it counts that newline character as part of its total.</p>
<p class="answer"><a id="ch17qa1a9" href="ch17.html#ch17qa1q9"><strong>9.</strong></a> The <code>ignore()</code> form falters if the input line exceeds 80 characters. In that case, it skips only the first 80 characters.</p>
<h3 id="app10lev1sec17"><a id="page_1363"/>Answers to Chapter Review for Chapter 18</h3>
<p class="answer"><a id="ch18qa1a1" href="ch18.html#ch18qa1q1"><strong>1.</strong></a></p>
<p class="programlistingB">class Z200<br/>{<br/>private:<br/>&#160;&#160;&#160;&#160;int j;<br/>&#160;&#160;&#160;&#160;char ch;<br/>&#160;&#160;&#160;&#160;double z;<br/>public:<br/>&#160;&#160;&#160;&#160;Z200(int jv, char chv, zv) : j(jv), ch(chv), z(zv) {}<br/>...<br/>};<br/><br/>double x {8.8};&#160;&#160;// or = {8.8}<br/>std::string s {"What a bracing effect!"};<br/>int k{99};<br/>Z200 zip{200,'Z',0.67});<br/>std::vector&lt;int&gt; ai {3, 9, 4, 7, 1};</p>
<p class="answer"><a id="ch18qa1a2" href="ch18.html#ch18qa1q2"><strong>2.</strong></a> <code>r1(w)</code> is valid, and the argument <code>rx</code> refers to <code>w</code>.</p>
<p class="indenthanding1"><code>r1(w+1)</code> is valid, and the argument <code>rx</code> refers to a temporary initialized to the value of <code>w+1</code>.</p>
<p class="indenthanding1"><code>r1(up(w))</code> is valid, and the argument <code>rx</code> refers to a temporary initialized to the return value of <code>up(w)</code>.</p>
<p class="indenthanding1">In general, if an lvalue is passed to a <code>const</code> lvalue reference parameter, the parameter is initialized to the lvalue. If an rvalue is passed to the function, a <code>const</code> lvalue reference parameter refers to a temporary copy of the value.</p>
<p class="indenthanding1"><code>r2(w)</code> is valid, and the argument <code>rx</code> refers to <code>w</code>.</p>
<p class="indenthanding1"><code>r2(w+1)</code> is an error because <code>w+1</code> is an rvalue.</p>
<p class="indenthanding1"><code>r2(up(w))</code> is an error because the return value of <code>up(w)</code> is an rvalue.</p>
<p class="indenthanding1">In general, if an lvalue is passed to a non-<code>const</code> lvalue reference parameter, the parameter is initialized to the lvalue. But a non-<code>const</code> lvalue reference parameter can&#8217;t accept an rvalue function argument.</p>
<p class="indenthanding1"><code>r3(w)</code> is an error because an rvalue reference cannot refer to an lvalue, such as <code>w</code>.</p>
<p class="indenthanding1"><code>r3(w+1)</code> is valid, and <code>rx</code> refers to the temporary value of the expression <code>w+1</code>.</p>
<p class="indenthanding1"><code>r3(up(w))</code> is valid, and <code>rx</code> refers to the temporary return value of <code>up(w)</code></p>
<p class="answer"><a id="ch18qa1a3" href="ch18.html#ch18qa1q3"><strong>3.</strong></a></p>
<p class="indenthandinga"><strong>a.</strong></p>
<p class="programlistingB1">double &#38; rx<br/>const double &#38; rx<br/>const double &#38; rx</p>
<p class="indenthanding1"><a id="page_1364"/>The non-<code>const</code> lvalue reference matches the lvalue argument <code>w</code>. The other two arguments are rvalues, and the <code>const</code> lvalue reference can refer to copies of them.</p>
<p class="indenthandinga"><strong>b.</strong></p>
<p class="programlistingB1">double &#38; rx<br/>double &#38;&#38; rx<br/>double &#38;&#38; rx</p>
<p class="indenthanding1">The lvalue reference matches the lvalue argument <code>w</code>, and the rvalue references matches the two rvalue arguments.</p>
<p class="indenthandinga"><strong>c.</strong></p>
<p class="programlistingB1">const double &#38; rx<br/>double &#38;&#38; rx<br/>double &#38;&#38; rx</p>
<p class="indenthanding1">The <code>const</code> lvalue reference matches the lvalue argument <code>w</code>, and the rvalue reference matches the two rvalues.</p>
<p class="indenthanding1">In short, a non-<code>const</code> lvalue parameter matches an lvalue argument, a non-<code>const</code> rvalue parameter matches an rvalue argument, and a <code>const</code> lvalue parameter can match either an lvalue or an rvalue argument, but the compiler will prefer the first two choices, if available.</p>
<p class="answer"><a id="ch18qa1a4" href="ch18.html#ch18qa1q4"><strong>4.</strong></a> They are the default constructor, the copy constructor, the move constructor, the destructor, the copy assignment operator, and the move assignment operator. They are special because the compiler can automatically provide defaulted versions of these functions, depending on the context.</p>
<p class="answer"><a id="ch18qa1a5" href="ch18.html#ch18qa1q5"><strong>5.</strong></a> A move constructor can be used when it makes sense to transfer ownership of data instead of copying it, but there is no mechanism for transferring ownership of a standard array. If the <code>Fizzle</code> class used a pointer and dynamic memory allocation, then one can transfer ownership by reassigning the address of the data to a new pointer.</p>
<p class="answer"><a id="ch18qa1a6" href="ch18.html#ch18qa1q6"><strong>6.</strong></a></p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>#include &lt;algorithm&gt;<br/>template&lt;typename T&gt;<br/>&#160;&#160;void show2(double x, T fp) {std::cout &lt;&lt; x &lt;&lt; " -&gt; " &lt;&lt; fp(x) &lt;&lt; '\n';}<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;show2(18.0, [](double x){return 1.8*x + 32;});<br/>&#160;&#160;&#160;&#160;return 0;<br/>}</p>
<p class="answer"><a id="page_1365"/><a id="ch18qa1a7" href="ch18.html#ch18qa1q7"><strong>7.</strong></a></p>
<p class="programlistingB">#include &lt;iostream&gt;<br/>#include &lt;array&gt;<br/>#include &lt;algorithm&gt;<br/>const int Size = 5;<br/>template&lt;typename T&gt;<br/>&#160;&#160;void sum(std::array&lt;double,Size&gt; a, T&#38; fp);<br/>int main()<br/>{<br/>&#160;&#160;&#160;&#160;double total = 0.0;<br/>&#160;&#160;&#160;&#160;std::array&lt;double, Size&gt; temp_c = {32.1, 34.3, 37.8, 35.2, 34.7};<br/>&#160;&#160;&#160;&#160;sum(temp_c, [&#38;total](double w){total += w;});<br/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "total: " &lt;&lt; total &lt;&lt; '\n';<br/>&#160;&#160;&#160;&#160;std::cin.get();<br/>&#160;&#160;&#160;&#160;return 0;<br/>}<br/>template&lt;typename T&gt;<br/>&#160;&#160;void sum(std::array&lt;double,Size&gt; a, T&#38; fp)<br/>{<br/>&#160;&#160;&#160;&#160;for(auto pt = a.begin(); pt != a.end(); ++pt)<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fp(*pt);<br/>&#160;&#160;&#160;&#160;}<br/>}</p>
</body>
</html>
