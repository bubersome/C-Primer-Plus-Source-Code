<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>G. The Standard Template Library Methods and Functions</title>
<link rel="stylesheet" type="text/css" href="0132781174.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="app07">G. The Standard Template Library Methods and Functions</h2>
<p><a id="page_1271"/>The Standard Template Library (STL) aims to provide efficient implementations of common algorithms. It expresses these algorithms in general functions that can be used with any container that satisfies the requirements for the particular algorithm and in methods that can be used with instantiations of particular container classes. This appendix assumes that you have some familiarity with the STL, such as might be gained from reading <a href="ch16.html#ch16">Chapter 16</a>, &#8220;The <code>string</code> Class and the Standard Template Library.&#8221; For example, this chapter assumes that you know about iterators and constructors.</p>
<h3 id="app07lev1sec1">The STL and C++11</h3>
<p>Just as the changes brought by C++11 to the C++ language are too extensive to cover completely in this book, so are the changes to the STL too extensive to cover completely in this appendix. However, we can summarize many of the additions.</p>
<p>C++11 brings several new elements to the STL. First, it adds several new containers. Second, it adds a few new features to the old containers. Third, it adds a few new template functions to its family of algorithms. All these changes are incorporated into this appendix, but you may find an overview of the first two categories helpful.</p>
<h4 id="app07lev2sec1">New Containers</h4>
<p>C++11 adds the following containers: <code>array</code>, <code>forward_list</code>, <code>unordered_set</code>, and the unordered associative containers <code>unordered_multiset</code>, <code>unordered_map</code>, and <code>unordered_multimap</code>.</p>
<p>An <code>array</code> container, once declared, is fixed in size and uses static or stack memory rather than dynamically allocated memory. It&#8217;s intended as a substitute for the built-in array type; it&#8217;s more limited than <code>vector</code>, but more efficient.</p>
<p>The <code>list</code> container is a bidirectional linked list, with each item, other than the two ends, linked to the item before it and the one after. The <code>forward_list</code> is a singly linked <a id="page_1272"/>list, with each item, other than the last, linked to the next item. It provides a more compact, but more limited, alternative for <code>list</code>.</p>
<p>Like <code>set</code> and the other associative containers, the unordered associative containers allow fast data retrieval through the use of keys. The difference is that the associative containers use trees as the underlying data structure, whereas the unordered associative containers use hash tables.</p>
<h4 id="app07lev2sec2">Changes to C++98 Containers</h4>
<p>C++11 brings three main changes to the container class methods.</p>
<p>First, the addition of rvalue references makes it possible to provide move semantics (<a href="ch18.html#ch18">Chapter 18</a>, &#8220;<a href="ch18.html#ch18">Visiting with the New C++ Standard</a>&#8221;) for containers. Accordingly, the STL now provides move constructors and move assignment operators for containers. These methods take an rvalue reference argument.</p>
<p>Second, the addition of the <code>initializer_list</code> template class (<a href="ch18.html#ch18">Chapter 18</a>) has led to constructors and assignment operators that accept an <code>initializer_list</code> argument. This makes code like the following possible:</p>
<p class="programlisting">vector&lt;int&gt; vi{100, 99, 97, 98};<br/>vi = {96, 99, 94, 95, 102};</p>
<p>Third, the addition of variadic templates and function parameter packs (<a href="ch18.html#ch18">Chapter 18</a>) makes emplacement methods possible. What does this mean? Like move semantics, emplacement is a means to increase efficiency. Consider the following code snippets:</p>
<p class="programlisting">class Items<br/>{<br/>&#160;&#160;&#160;&#160;double x;<br/>&#160;&#160;&#160;&#160;double y;<br/>&#160;&#160;&#160;&#160;int m;<br/>public:<br/>&#160;&#160;&#160;&#160;Items();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// #1<br/>&#160;&#160;&#160;&#160;Items (double xx, double yy, int mm); // #2<br/>&#160;&#160;&#160;&#160;...<br/>};<br/>...<br/>vector&lt;Items&gt; vt(10);<br/>...<br/>vt.push_back(Items(8.2, 2.8, 3));&#160;&#160;//</p>
<p>The call to <code>insert()</code> causes the memory allocation function to create a default <code>Items</code> object at the end of <code>vt</code>. Next, the <code>Items()</code> constructor creates a temporary <code>Items</code> object; this object is copied to a location at the front of the vector <code>vt</code> and then the temporary object is deleted. With C++11, you can do this instead:</p>
<p class="programlisting">vi.emplace_back(8.2, 2.8, 3);</p>
<p><a id="page_1273"/>The <code>emplace_back()</code> method is a variadic template with a function parameter pack as its argument:</p>
<p class="programlisting">template &lt;class... Args&gt; void emplace_back(Args&#38;&#38;... args);</p>
<p>The three arguments 8.2, 2.8, and 3 are packed into the <code>args</code> parameter. These parameters are passed along to the allocation function, which then can unpack the parameters and use the <code>Items</code> constructor with three arguments (#2) instead of the default constructor (#1). That is, it can use <code>Items(args...)</code>, which, in this example, expands to <code>Items(8.2, 2.8, 3)</code>. Thus, the desired object is constructed in place in the vector rather than at a temporary location and then copied to the vector.</p>
<p>The STL uses this technique with several emplacement methods.</p>
<h3 id="app07lev1sec2">Members Common to All or Most Containers</h3>
<p>All containers define the types in <a href="#app07table01">Table G.1</a>. In this table, <code>X</code> is a container type, such as <code>vector&lt;int&gt;</code>, and <code>T</code> is the type stored in the container, such as <code>int</code>. The examples following the table clarify the meanings.</p>
<p class="caption"><a id="app07table01"/><strong>Table G.1. Types Defined for All Containers</strong></p>
<p class="image"><img src="graphics/app-g-tab01.jpg" alt="Image"/></p>
<p>The class definition uses a <code>typedef</code> to define these members. You can use these types to declare suitable variables. For example, the following code uses a roundabout way to replace the first occurrence of <code>"bonus"</code> in a vector of <code>string</code> objects with <code>"bogus"</code> in order to show how you can use member types to declare variables:</p>
<p class="programlisting">using namespace std;<br/>vector&lt;string&gt; input;<br/>string temp;<br/>while (cin &gt;&gt; temp &#38;&#38; temp != "quit")<br/>&#160;&#160;&#160;&#160;input.push_back(temp);<br/>vector&lt;string&gt;::iterator want=<br/><a id="page_1274"/>&#160;&#160;&#160;&#160;find(input.begin(), input.end(), string("bonus"));<br/>if (want != input.end())<br/>{<br/>&#160;&#160;&#160;&#160;vector&lt;string&gt;::reference r = *want;<br/>&#160;&#160;&#160;&#160;r = "bogus";<br/>}</p>
<p>This code makes <code>r</code> a reference to the element in <code>input</code> to which <code>want</code> points. Similarly, continuing with the preceding example, you can write code like the following:</p>
<p class="programlisting">vector&lt;string&gt;::value_type s1 = input[0];&#160;&#160;// s1 is type string<br/>vector&lt;string&gt;::reference s2 = input[1];&#160;&#160;&#160;// s2 is type string &#38;</p>
<p>This results in <code>s1</code> being a new <code>string</code> object that&#8217;s a copy of <code>input[0]</code> and in <code>s2</code> being a reference to <code>input[1]</code>. In this example, given that you already know that the template is based on the <code>string</code> type, it would be simpler to write the following code, which is equivalent in its effect:</p>
<p class="programlisting">string s1 = input[0];&#160;&#160;&#160;&#160;&#160;// s1 is type string<br/>string &#38; s2 = input[1];&#160;&#160;&#160;// s2 is type string &#38;</p>
<p>However, the more elaborate types from <a href="#app07table01">Table G.1</a> can also be used in more general code in which the type of container and element are generic. For example, suppose you want a <code>min()</code> function that takes as its argument a reference to a container and returns the smallest item in the container. This assumes that the <code>&lt;</code> operator is defined for the value type used to instantiate the template and that you don&#8217;t want to use the STL <code>min_element()</code> algorithm, which uses an iterator interface. Because the argument could be <code>vector&lt;int&gt;</code> or <code>list&lt;string&gt;</code> or <code>deque&lt;double&gt;</code>, you use a template with a template parameter, such as <code>Bag</code>, to represent the container. (That is, <code>Bag</code> is a template type that might be instantiated as <code>vector&lt;int&gt;</code>, <code>list&lt;string&gt;</code>, or some other container type.) So the argument type for the function is <code>const Bag &#38; b</code>. What about the return type? It should be the value type for the container&#8212;that is, <code>Bag::value_type</code>. However, at this point, <code>Bag</code> is just a template parameter, and the compiler has no way of knowing that the <code>value_type</code> member is actually a type. But you can use the <code>typename</code> keyword to clarify that a class member is a <code>typedef</code>:</p>
<p class="programlisting">vector&lt;string&gt;::value_type st;&#160;&#160;&#160;&#160;// vector&lt;string&gt; a defined class<br/>typename Bag::value_type m;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Bag an as yet undefined type</p>
<p>For the first definition here, the compiler has access to the <code>vector</code> template definition, which states that <code>value_type</code> is a <code>typedef</code>. For the second definition, the <code>typename</code> keyword promises that, whatever <code>Bag</code> may turn out to be, the combination <code>Bag::value_type</code> is the name of a type. These considerations lead to the following definition:</p>
<p class="programlisting">template&lt;typename Bag&gt;<br/>typename Bag::value_type min(const Bag &#38; b)<br/>{<br/>&#160;&#160;&#160;&#160;typename Bag::const_iterator it;<br/>&#160;&#160;&#160;&#160;typename Bag::value_type m = *b.begin();<br/><a id="page_1275"/>&#160;&#160;&#160;&#160;for (it = b.begin(); it != b.end(); ++it)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (*it &lt; m)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;m = *it;<br/>&#160;&#160;&#160;&#160;return m;<br/>}</p>
<p>You then could use this template function as follows:</p>
<p class="programlisting">vector&lt;int&gt; temperatures;<br/>// input temperature values into the vector<br/>int coldest = min(temperatures);</p>
<p>The <code>temperatures</code> parameter would cause <code>Bag</code> to be evaluated as <code>vector&lt;int&gt;</code> and <code>typename Bag::value_type</code> to be evaluated as <code>vector&lt;int&gt;::value_type</code>, which, in turn, is <code>int</code>.</p>
<p>All containers also contain the member functions or operations listed in <a href="#app07table02">Table G.2</a>. Again, <code>X</code> is a container type, such as <code>vector&lt;int&gt;</code>, and <code>T</code> is the type stored in the container, such as <code>int</code>. Also <code>a</code> and <code>b</code> are values of type <code>X</code>, <code>u</code> is an identifier, <code>r</code> is a non-<code>const</code> value of type <code>X</code>, and <code>rv</code> is a non-<code>const</code> rvalue of type <code>X</code>. The move operations were added by C++11.</p>
<p class="caption"><a id="app07table02"/><strong>Table G.2. Operations Defined for All Containers</strong></p>
<p class="image"><img src="graphics/app-g-tab02.jpg" alt="Image"/></p>
<p><a id="page_1276"/>Containers that use a bi-directional or random iterator (<code>vector</code>, <code>list</code>, <code>deque</code>, <code>queue</code>, <code>array</code>, <code>set</code>, and <code>map</code>) are reversible and provide the methods in <a href="#app07table03">Table G.3</a>.</p>
<p class="caption"><a id="app07table03"/><strong>Table G.3. Types and Operations Defined for Reversible Containers</strong></p>
<p class="image"><img src="graphics/app-g-tab03.jpg" alt="Image"/></p>
<p>The unordered set and unordered map containers are not required to support the optional container operations in <a href="#app07table04">Table G.4</a>, but the remaining containers do support them.</p>
<p class="caption"><a id="app07table04"/><strong>Table G.4. Optional Container Operations</strong></p>
<p class="image"><img src="graphics/app-g-tab04.jpg" alt="Image"/></p>
<p>The <code>&gt;</code> operator for a container assumes that the <code>&gt;</code> operator is defined for the value type. A lexicographic comparison is a generalization of alphabetical sorting. It compares two containers, element-by-element, until it encounters an element in one container that doesn&#8217;t equal the corresponding element in the other container. In that case, the containers are considered to be in the same order as the noncorresponding pair of elements. For example, if two containers are identical through the first 10 elements, but the 11th element in the first container is less than the 11th element in the second container, the first <a id="page_1277"/>container precedes the second. If two containers compare equally until one runs out of elements, the shorter container precedes the longer.</p>
<h3 id="app07lev1sec3">Additional Members for Sequence Containers</h3>
<p>The <code>vector</code>, <code>forward_list</code>, <code>list</code>, <code>deque,</code> and <code>array</code> template classes are all sequence containers, and they all have the methods listed previously, with the exception that <code>forward_list</code> isn&#8217;t reversible and doesn&#8217;t support the methods of <a href="#app07table03">Table G.3</a>. A sequence container, not surprisingly, holds a homogeneous set of items in linear order. If the sequence has a fixed number of elements, <code>array</code> is the usual choice. Otherwise, <code>vector</code>, which combines the random access of <code>array</code> with the ability to add and delete items should be your first recourse. However, if there are frequent additions in the middle of the sequence, consider using <code>list</code> or <code>forward_list</code>. And if additions and deletions primarily occur at the two ends of the sequence, consider <code>deque</code>.</p>
<p>The fixed size of an <code>array</code> object prevents <code>array</code> from using many of the sequence methods. <a href="#app07table05">Table G.5</a> lists additional methods available for sequence containers other than <code>array</code>. (<code>forward_list</code> has somewhat different definitions for <code>resize()</code>.) Again, <code>X</code> is a container type, such as <code>vector&lt;int&gt;</code>, and <code>T</code> is the type stored in the container, such as <code>int</code>. <code>a</code> is a value of type <code>X</code>. <code>t</code> is an lvalue or <code>const</code> rvalue of <code>type X::value_type</code>. <code>rv</code> is a non-<code>const</code> rvalue of that same type. <code>i</code> and <code>j</code> are input iterators. [<code>i</code>, <code>j</code>) is a valid range. <code>il</code> is an object of type <code>initializer_list&lt;value_type&gt;</code>. <code>p</code> is a valid <code>const</code> iterator to <code>a</code>. <code>q</code> is a valid dereferenceable <code>const</code> iterator to <code>a</code>. <code>[q1,q2)</code> is a valid range of const iterators. <code>n</code> is an integer of <code>X::size_type</code>. <code>Args</code> is a template parameter pack, and <code>args</code> is a function parameter pack with the pattern <code>Args&#38;&#38;</code>.</p>
<p class="caption"><a id="app07table05"/><strong>Table G.5. Additional Operations Defined for Sequence Containers</strong></p>
<p class="image"><img src="graphics/app-g-tab05.jpg" alt="Image"/></p>
<p class="image"><img src="graphics/app-g-tab05a.jpg" alt="Image"/></p>
<p><a id="page_1278"/><a href="#app07table06">Table G.6</a> lists methods common to some of the sequence classes (<code>vector</code>, <code>forward_list</code>, <code>list</code>, and <code>deque</code>).</p>
<p class="caption"><a id="app07table06"/><strong>Table G.6. Operations Defined for Some Sequences</strong></p>
<p class="image"><img src="graphics/app-g-tab06.jpg" alt="Image"/></p>
<p><a id="page_1279"/>The <code>vector</code> template additionally has the methods in <a href="#app07table07">Table G.7</a>. Here, <code>a</code> is a <code>vector</code> container and <code>n</code> is an integer of <code>X::size_type</code>.</p>
<p class="caption"><a id="app07table07"/><strong>Table G.7. Additional Operations for Vectors</strong></p>
<p class="image"><img src="graphics/app-g-tab07.jpg" alt="Image"/></p>
<p>The <code>list</code> template additionally has the methods in <a href="#app07table08">Table G.8</a>. Here, <code>a</code> and <code>b</code> are <code>list</code> containers, and <code>T</code> is the type stored in the list, such as <code>int</code>, <code>t</code> is a value of type <code>T</code>, <code>i</code> and <code>j</code> are input iterators, <code>q2</code> and <code>p</code> are iterators, <code>q</code> and <code>q1</code> are dereferenceable iterators, and <code>n</code> is an integer of <code>X::size_type</code>. The table uses the standard STL notation [<code>i</code>, <code>j</code>), meaning the range from <code>i</code> up to, but not including, <code>j</code>.</p>
<p class="caption"><a id="page_1280"/><a id="app07table08"/><strong>Table G.8. Additional Operations for Lists</strong></p>
<p class="image"><img src="graphics/app-g-tab08.jpg" alt="Image"/></p>
<p>The <code>forward-list</code> operations are similar. However, because a <code>forward_list</code> template class iterator can&#8217;t go backwards, some methods have to be adjusted. Thus, the <code>insert()</code>, <code>erase()</code>, and <code>splice()</code> methods are replaced with the <code>insert_after()</code>, <code>erase_after()</code>, and <code>splice_after()</code> methods, all of which operate on the position following an iterator position rather than preceding it.</p>
<h3 id="app07lev1sec4">Additional Operations for Sets and Maps</h3>
<p><a id="page_1281"/>Associative containers, of which sets and maps are models, have a <code>Key</code> template parameter and a <code>Compare</code> template parameter, which indicate, respectively, the type of the <code>key</code> used to order the contents and the function object, termed a <em>comparison object</em>, used to compare key values. For the <code>set</code> and <code>multiset</code> containers, the stored keys are the stored values, so the key type is the same as the value type. For the <code>map</code> and <code>multimap</code> containers, the stored values of one type (template parameter <code>T</code>) are associated with a key type (template parameter <code>Key</code>), and the value type is <code>pair&lt;const Key, T&gt;</code>. Associative containers have additional members to describe these features, as listed in <a href="#app07table09">Table G.9</a>.</p>
<p class="caption"><a id="app07table09"/><strong>Table G.9. Types Defined for Associative Containers</strong></p>
<p class="image"><img src="graphics/app-g-tab09.jpg" alt="Image"/></p>
<p>Associative containers provide the methods listed in <a href="#app07table10">Table G.10</a>. In general, the comparison object need not require that values with the same key be identical; the term <em>equivalent keys</em> means that two values, which may or may not be equal, have the same key. In the table, <code>X</code> is a container class, and <code>a</code> is an object of type <code>X</code>. If <code>X</code> uses unique keys (that is, is <code>set</code> or <code>map</code>), <code>a_uniq</code> is an object of type <code>X</code>. If <code>X</code> uses multiple keys (that is, is <code>multiset</code> or <code>multimap</code>), <code>a_eq</code> is an object of type <code>X</code>. As before, <code>i</code> and <code>j</code> are input iterators referring to elements of <code>value_type</code>, [<code>i</code>, <code>j</code>) is a valid range, <code>p</code> and <code>q2</code> are iterators to <code>a</code>, <code>q</code> and <code>q1</code> are dereferenceable iterators to <code>a</code>, [<code>q1</code>, <code>q2</code>) is a valid range, <code>t</code> is a value of <code>X::value_type</code> (which may be a pair), and <code>k</code> is a value of <code>X::key_type</code>. Also <code>il</code> is an <code>initializer_list&lt;value_type&gt;</code> object.</p>
<p class="caption"><a id="page_1282"/><a id="app07table10"/><strong>Table G.10. Operations Defined for Sets, Multisets, Maps, and Multimaps</strong></p>
<p class="image"><img src="graphics/app-g-tab10.jpg" alt="Image"/></p>
<p class="image"><img src="graphics/app-g-tab10a.jpg" alt="Image"/></p>
<h3 id="app07lev1sec5">Unordered Associative Containers (C++11)</h3>
<p><a id="page_1283"/>As mentioned earlier, the unordered associative containers (<code>unordered_set</code>, <code>unordered_multiset</code>, <code>unordered_map</code>, and <code>unordered_multimap</code>) use keys and hash tables to provide rapid access to data. Let&#8217;s take a simple look at these concepts. A <em>hash function</em> converts a key to an index value. For example, if the key were a <code>string</code>, the hash function could sum the numeric codes for the characters in the <code>string</code> and take that sum modulus 13, thus giving an index in the range 0&#8211;12. The unordered container would use 13 <em>buckets</em> to store <code>string</code>s. Any <code>string</code> with, say, an index of 4 would be placed in bucket 4. If you wished to search the container for a key, you would apply the hash function to the key and just search the bucket with the corresponding index. Ideally, you would have enough buckets that each one would contain only a few <code>string</code>s.</p>
<p>The C++11 library provides a <code>hash&lt;Key&gt;</code> template that the unordered associative containers use by default. Specializations are defined for the various integer and floating-point types, for pointers, and for some template classes, such as <code>string</code>.</p>
<p><a href="#app07table11">Table G.11</a> lists types used for these containers.</p>
<p class="caption"><a id="app07table11"/><strong>Table G.11. Types Defined for Unordered Associative Containers</strong></p>
<p class="image"><img src="graphics/app-g-tab11.jpg" alt="Image"/></p>
<p>The interface for the unordered associative containers is similar to that of the associative containers. In particular, <a href="#app07table10">Table G.10</a> also applies to the unordered associative containers with the following exceptions: The <code>lower_bound()</code> and <code>upper_bound()</code> methods are not required, nor is the <code>X(i,j,c)</code> constructor. The fact that the regular associative containers are ordered allows them to use a comparison predicate that expresses the &#8220;less <a id="page_1284"/>than&#8221; concept. Such a comparison doesn&#8217;t apply to unordered associative containers, so, instead, they use a comparison predicate that is based on the &#8220;is equivalent to&#8221; concept.</p>
<p>In addition to the <a href="#app07table10">Table G.10</a> methods, the unordered associative containers require several more methods, as listed in <a href="#app07table12">Table G.12</a>. In this table, <code>X</code> is an unordered associative container class, <code>a</code> is an object of type <code>X</code>, <code>b</code> is a possibly constant object of type <code>X</code>, <code>a_uniq</code> is an object of type <code>unordered_set</code> or <code>unordered_map</code>, <code>a_eq</code> is an object of type <code>unordered_multiset</code> or <code>unordered_multimap</code>, <code>hf</code> is a value of type <code>hasher</code>, <code>eq</code> is a value of type <code>key_equal</code>, <code>n</code> is a value of type <code>size_type</code>, and <code>z</code> is a value of type <code>float</code>. As before, <code>i</code> and <code>j</code> are input iterators referring to elements of <code>value_type</code>, [<code>i</code>, <code>j</code>) is a valid range, <code>p</code> and <code>q2</code> are iterators to <code>a</code>, <code>q</code> and <code>q1</code> are dereferenceable iterators to <code>a</code>, [<code>q1</code>, <code>q2</code>) is a valid range, <code>t</code> is a value of <code>X::value_type</code> (which may be a pair), and <code>k</code> is a value of <code>X::key_type</code>. Also <code>il</code> is an <code>initializer_list&lt;value_type&gt;</code> object.</p>
<p class="caption"><a id="page_1285"/><a id="app07table12"/><strong>Table G.12. Additional Operations Defined for Unordered Sets, Multisets, Maps, and Multimaps</strong></p>
<p class="image"><img src="graphics/app-g-tab12.jpg" alt="Image"/></p>
<p class="image"><img src="graphics/app-g-tab12a.jpg" alt="Image"/></p>
<h3 id="app07lev1sec6">STL Functions</h3>
<p><a id="page_1286"/>The STL algorithm library, supported by the <code>algorithm</code> and <code>numeric</code> header files, provides a large number of nonmember, iterator-based template functions. As discussed in <a href="ch16.html#ch16">Chapter 16</a>, the template parameter names are chosen to indicate what concept particular parameters should model. For example, <code>ForwardIterator</code> is used to indicate that a parameter should, at the minimum, model the requirements of a forward iterator, and <code>Predicate</code> is used to indicate a parameter that should be a function object with one argument and a <code>bool</code> return value. The C++ Standard divides the algorithms into four groups: nonmodifying sequence operations, mutating sequence operations, sorting and related operators, and numeric operations. (C++11 moves numeric operations from the STL to the numeric library, but that doesn&#8217;t affect how they are used.) The term <em>sequence operation</em> indicates that the function takes a pair of iterators as arguments to define a range, or sequence, to be operated on. The term <em>mutating</em> means the function is allowed to alter the container.</p>
<h4 id="app07lev2sec3">Nonmodifying Sequence Operations</h4>
<p><a href="#app07table13">Table G.13</a> summarizes the nonmodifying sequence operations. Arguments are not shown, and overloaded functions are listed just once. A fuller description, including the prototypes, follows the table. Thus, you can scan the table to get an idea of what a function does and then look up the details if you find the function appealing.</p>
<p class="caption"><a id="app07table13"/><strong>Table G.13. Nonmodifying Sequence Operations</strong></p>
<p class="image"><img src="graphics/app-g-tab13.jpg" alt="Image"/></p>
<p class="image"><img src="graphics/app-g-tab13a.jpg" alt="Image"/></p>
<p><a id="page_1287"/>Now let&#8217;s take a more detailed look at these nonmodifying sequence operations. For each function, the discussion shows the prototype(s), followed by a brief explanation. Pairs of iterators indicate ranges, with the chosen template parameter name indicating the type of iterator. As usual a range in the form [<code>first</code>, <code>last</code>) goes from <code>first</code> up to, but not including, <code>last</code>. Some functions take two ranges, which need not be in the same kind of container. For example, you can use <code>equal()</code> to compare a list to a vector. Functions passed as arguments are function objects, which can be pointers (of which function names are an example) or objects for which the <code>()</code> operation is defined. As in <a href="ch16.html#ch16">Chapter 16</a>, a predicate is a Boolean function with one argument, and a binary predicate is a Boolean function with two arguments. (The functions need not be type <code>bool</code>, as long as they return <code>0</code> for <code>false</code> and a nonzero value for <code>true</code>.)</p>
<h5 id="app07lev3sec1"><code>all_of()</code> (C++11)</h5>
<p class="programlisting"><a id="page_1288"/>template&lt;class InputIterator, class Predicate&gt;<br/>bool all_of(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>all_of()</code> function returns <code>true</code> if <code>pred(*i)</code> is <code>true</code> for every iterator in the range <code>[first,last)</code> or if the range is empty. Otherwise the function returns <code>false</code>.</p>
<h5 id="app07lev3sec2"><code>any_of()</code> (C++11)</h5>
<p class="programlisting">template&lt;class InputIterator, class Predicate&gt;<br/>bool any_of(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>any_of()</code> function returns <code>false</code> if <code>pred(*i)</code> is <code>false</code> for every iterator in the range <code>[first,last)</code> or if the range is empty. Otherwise the function returns <code>true</code>.</p>
<h5 id="app07lev3sec3"><code>none_of()</code> (C++11)</h5>
<p class="programlisting">template&lt;class InputIterator, class Predicate&gt;<br/>bool none_of(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>none_of()</code> function returns <code>true</code> if <code>pred(*i)</code> is <code>false</code> for every iterator in the range <code>[first,last)</code> or if the range is empty. Otherwise the function returns <code>false</code>.</p>
<h5 id="app07lev3sec4"><code>for_each()</code></h5>
<p class="programlisting"><a id="page_1289"/>template&lt;class InputIterator, class Function&gt;<br/>Function for_each(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Function f);</p>
<p>The <code>for_each()</code> function applies function object <code>f</code> to each element in the range [<code>first</code>, <code>last</code>). It also returns <code>f</code>.</p>
<h5 id="app07lev3sec5"><code>find()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class T&gt;<br/>InputIterator find(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; value);</p>
<p>The <code>find()</code> function returns an iterator to the first element in the range [<code>first</code>, <code>last</code>) that has the value <code>value</code>; it returns <code>last</code> if the item is not found.</p>
<h5 id="app07lev3sec6"><code>find_if()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class Predicate&gt;<br/>InputIterator find_if(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>find_if()</code> function returns an iterator <code>it</code> to the first element in the range [<code>first</code>, <code>last</code>) for which the function object call <code>pred(*i)</code> is <code>true</code>; it returns <code>last</code> if the item is not found.</p>
<h5 id="app07lev3sec7"><code>find_if_not()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class Predicate&gt;<br/>InputIterator find_if_not(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>find_if_not()</code> function returns an iterator, <code>it</code>, to the first element in the range [<code>first</code>, <code>last</code>) for which the function object call <code>pred(*i)</code> is <code>false</code>; it returns <code>last</code> if the item is not found.</p>
<h5 id="app07lev3sec8"><code>find_end()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator1, class ForwardIterator2&gt;<br/>ForwardIterator1 find_end(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator1 first1, ForwardIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator2 first2, ForwardIterator2 last2);<br/><br/>template&lt;class ForwardIterator1, class ForwardIterator2,<br/>&#160;&#160;&#160;&#160;class BinaryPredicate&gt;<br/>ForwardIterator1 find_end(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator1 first1, ForwardIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator2 first2, ForwardIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryPredicate pred);</p>
<p><a id="page_1290"/>The <code>find_end()</code> function returns an iterator <code>it</code> to the last element in the range [<code>first1</code>, <code>last1</code>) that marks the beginning of a subsequence that matches the contents of the range [<code>first2</code>, <code>last2</code>). The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>. Both return <code>last1</code> if the item is not found.</p>
<h5 id="app07lev3sec9"><code>find_first_of()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator1, class ForwardIterator2&gt;<br/>ForwardIterator1 find_first_of(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator1 first1, ForwardIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator2 first2, ForwardIterator2 last2);<br/><br/>template&lt;class ForwardIterator1, class ForwardIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class BinaryPredicate&gt;<br/>ForwardIterator1 find_first_of(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator1 first1, ForwardIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator2 first2, ForwardIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryPredicate pred);</p>
<p>The <code>find_first_of()</code> function returns an iterator <code>it</code> to the first element in the range [<code>first1</code>, <code>last1</code>) that matches any element of the range [<code>first2</code>, <code>last2</code>). The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>. Both return <code>last1</code> if the item is not found.</p>
<h5 id="app07lev3sec10"><code>adjacent_find()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator&gt;<br/>ForwardIterator adjacent_find(ForwardIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator last);<br/><br/>template&lt;class ForwardIterator, class BinaryPredicate&gt;<br/>ForwardIterator adjacent_find(ForwardIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator last, BinaryPredicate pred);</p>
<p>The <code>adjacent_find()</code> function returns an iterator <code>it</code> to the first element in the range [<code>first1</code>, <code>last1</code>) such that the element matches the following element. The function returns <code>last</code> if no such pair is found. The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>.</p>
<h5 id="app07lev3sec11"><code>count()</code></h5>
<p class="programlisting"><a id="page_1291"/>template&lt;class InputIterator, class T&gt;<br/>&#160;typename iterator_traits&lt;InputIterator&gt;::difference_type<br/>&#160;&#160;count(InputIterator first, InputIterator last, const T&#38; value);</p>
<p>The <code>count()</code> function returns the number of elements in the range [<code>first</code>, <code>last</code>) that match the value <code>value</code>. The <code>==</code> operator for the value type is used to compare values. The return type is an integer type that is large enough to contain the maximum number of items the container can hold.</p>
<h5 id="app07lev3sec12"><code>count_if()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class Predicate&gt;<br/>&#160;typename iterator_traits&lt;InputIterator&gt;::difference_type<br/>&#160;&#160;count_if(InputIterator first, InputIterator last, Predicate pred);</p>
<p>The <code>count if()</code> function returns the number of elements in the range [<code>first</code>, <code>last</code>) for which the function object <code>pred</code> returns a <code>true</code> value when passed the element as an argument.</p>
<h5 id="app07lev3sec13"><code>mismatch()</code></h5>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2&gt;<br/>&#160;&#160;pair&lt;InputIterator1, InputIterator2&gt;<br/>&#160;&#160;&#160;mismatch(InputIterator1 first1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator1 last1, InputIterator2 first2);<br/><br/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class BinaryPredicate&gt;<br/>&#160;&#160;pair&lt;InputIterator1, InputIterator2&gt;<br/>&#160;&#160;&#160;&#160;mismatch(InputIterator1 first1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator1 last1, InputIterator2 first2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryPredicate pred);</p>
<p>Each of the <code>mismatch()</code> functions finds the first element in the range [<code>first1</code>, <code>last1</code>) that doesn&#8217;t match the corresponding element in the range beginning at <code>first2</code> and returns a pair holding iterators to the two mismatching elements. If no mismatch is found, the return value is <code>pair&lt;last1, first2 + (last1 - first1)&gt;</code>. The first version uses the <code>==</code> operator to test matching. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> don&#8217;t match if <code>pred(*it1, *it2)</code> is <code>false</code>.</p>
<h5 id="app07lev3sec14"><code>equal()</code></h5>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2&gt;<br/>bool equal(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2);<br/><a id="page_1292"/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class BinaryPredicate&gt;<br/>bool equal(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, BinaryPredicate pred);</p>
<p>The <code>equal()</code> function returns <code>true</code> if each element in the range [<code>first1</code>, <code>last1</code>) matches the corresponding element in the sequence beginning at <code>first2</code> and <code>false</code> otherwise. The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>.</p>
<h5 id="app07lev3sec15"><code>is_permutation()</code> (C++11)</h5>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2&gt;<br/>bool equal(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2);<br/><br/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class BinaryPredicate&gt;<br/>bool equal(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, BinaryPredicate pred);</p>
<p>The <code>is_permutation()</code> function returns <code>true</code> if each element in the range [<code>first1</code>, <code>last1</code>) matches the corresponding element in some permutation of the equal-length sequence beginning at <code>first2</code>; it returns <code>false</code> otherwise. The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>.</p>
<h5 id="app07lev3sec16"><code>search()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator1, class ForwardIterator2&gt;<br/>ForwardIterator1 search(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator1 first1, ForwardIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator2 first2, ForwardIterator2 last2);<br/><br/>template&lt;class ForwardIterator1, class ForwardIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class BinaryPredicate&gt;<br/>ForwardIterator1 search(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator1 first1, ForwardIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator2 first2, ForwardIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryPredicate pred);</p>
<p>The <code>search()</code> function finds the first occurrence in the range [<code>first1</code>, <code>last1</code>) that matches the corresponding sequence found in the range [<code>first2</code>, <code>last2</code>). It returns <code>last1</code> if no such sequence is found. The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <a id="page_1293"/><code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>.</p>
<h5 id="app07lev3sec17"><code>search_n()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator, class Size, class T&gt;<br/>ForwardIterator&#160;&#160;search_n(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Size count, const T&#38; value);<br/><br/>template&lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;<br/>ForwardIterator search_n(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Size count, const T&#38; value, BinaryPredicate pred);</p>
<p>The <code>search_n()</code> function finds the first occurrence in the range [<code>first1</code>, <code>last1</code>) that matches the sequence consisting of <code>count</code> consecutive occurrences of <code>value</code>. It returns <code>last1</code> if no such sequence is found. The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>.</p>
<h4 id="app07lev2sec4">Mutating Sequence Operations</h4>
<p><a href="#app07table14">Table G.14</a> summarizes the mutating sequence operations. Arguments are not shown, and overloaded functions are listed just once. A fuller description, including the prototypes, follows the table. Thus, you can scan the table to get an idea of what a function does and then look up the details if you find the function appealing.</p>
<p class="caption"><a id="app07table14"/><strong>Table G.14. Mutating Sequence Operations</strong></p>
<p class="image"><img src="graphics/app-g-tab14.jpg" alt="Image"/></p>
<p class="image"><img src="graphics/app-g-tab14a.jpg" alt="Image"/></p>
<p class="image"><img src="graphics/app-g-tab14b.jpg" alt="Image"/></p>
<p>Now let&#8217;s take a more detailed look at these mutating sequence operations. For each function, the discussion shows the prototype(s), followed by a brief explanation. As you saw earlier, pairs of iterators indicate ranges, with the chosen template parameter name indicating the type of iterator. As usual, a range in the form [<code>first</code>, <code>last</code>) goes from <code>first</code> up to, but not including, <code>last</code>. Functions passed as arguments are function objects, which can be function pointers or objects for which the <code>()</code> operation is defined. As in <a href="ch16.html#ch16">Chapter 16</a>, a predicate is a Boolean function with one argument, and a binary predicate is a Boolean function with two arguments. (The functions need not be type <code>bool</code>, as long as they return <code>0</code> for <code>false</code> and a nonzero value for <code>true</code>.) Also as in <a href="ch16.html#ch16">Chapter 16</a>, a unary function object is one that takes a single argument, and a binary function object is one that takes two arguments.</p>
<h5 id="app07lev3sec18"><code>copy()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator&gt;<br/>OutputIterator copy(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);</p>
<p>The <code>copy()</code> function copies the elements in the range [<code>first</code>, <code>last</code>) into the range [<code>result</code>, <code>result + (last - first)</code>). It returns <code>result + (last - first)</code>&#8212;that is, an <a id="page_1294"/>iterator pointing one past the last copied-to location. The function requires that <code>result</code> not be in the range [<code>first</code>, <code>last</code>)&#8212;that is, the target can&#8217;t overlap the source.<a id="page_1295"/></p>
<h5 id="app07lev3sec19"><code>copy_n()</code> (C++11)</h5>
<p class="programlisting"><a id="page_1296"/>template&lt;class InputIterator, class Size class OutputIterator&gt;<br/>OutputIterator copy(InputIterator first, Size n,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);</p>
<p>The <code>copy_n()</code> function copies <code>n</code> elements, staring from the location <code>first</code>, into the range [<code>result</code>, <code>result + n</code>). It returns <code>result + n</code>&#8212;that is, an iterator pointing one past the last copied-to location. The function does not require that the target can&#8217;t overlap the source.</p>
<h5 id="app07lev3sec20"><code>copy_if()</code> (C++11)</h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class Predicate&gt;<br/>OutputIterator copy_if(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result, Predicate pred);</p>
<p>The <code>copy_if()</code> function copies those elements referred to by the iterator <code>i</code> in the range [<code>first</code>, <code>last</code>), for which <code>pred(*i)</code> is <code>true</code>, into the range [<code>result</code>, <code>result + (last - first)</code>). It returns <code>result + (last - first)</code>&#8212;that is, an iterator pointing one past the last copied-to location. The function requires that <code>result</code> not be in the range [<code>first</code>, <code>last</code>)&#8212;that is, the target can&#8217;t overlap the source.</p>
<h5 id="app07lev3sec21"><code>copy_backward()</code></h5>
<p class="programlisting">template&lt;class BidirectionalIterator1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class BidirectionalIterator2&gt;<br/>BidirectionalIterator2 copy_backward(BidirectionalIterator1 first,<br/><br/>BidirectionalIterator1 last, BidirectionalIterator2 result);</p>
<p>The <code>copy_backward()</code> function copies the elements in the range [<code>first</code>, <code>last</code>) into the range [<code>result -(last - first)</code>, <code>result</code>). Copying begins with the element at <code>last -1</code> being copied to location <code>result - 1</code> and proceeds backward from there to <code>first</code>. It returns <code>result - (last - first)</code>&#8212;that is, an iterator pointing one past the last copied-to location. The function requires that <code>result</code> not be in the range [<code>first</code>, <code>last</code>). However, because copying is done backward, it is possible for the target and source to overlap.</p>
<h5 id="app07lev3sec22"><code>move()</code> (C++11)</h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator&gt;<br/>OutputIterator copy(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);</p>
<p>The <code>move()</code> function uses <code>std::move()</code> to move the elements in the range [<code>first</code>, <code>last</code>) into the range [<code>result</code>, <code>result + (last - first)</code>). It returns <code>result + (last - first)</code>&#8212;that is, an iterator pointing one past the last copied-to location. The function <a id="page_1297"/>requires that <code>result</code> not be in the range [<code>first</code>, <code>last</code>)&#8212;that is, the target can&#8217;t overlap the source.</p>
<h5 id="app07lev3sec23"><code>move_backward()</code> (C++11)</h5>
<p class="programlisting">template&lt;class BidirectionalIterator1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class BidirectionalIterator2&gt;<br/>BidirectionalIterator2 copy_backward(BidirectionalIterator1 first,<br/><br/>BidirectionalIterator1 last, BidirectionalIterator2 result);</p>
<p>The <code>move_backward()</code> function uses <code>std::move()</code> to move the elements in the range [<code>first</code>, <code>last</code>) into the range [<code>result -(last - first)</code>, <code>result</code>). Copying begins with the element at <code>last -1</code> being copied to location <code>result - 1</code> and proceeds backward from there to <code>first</code>. It returns <code>result - (last - first)</code>&#8212;that is, an iterator pointing one past the last copied-to location. The function requires that <code>result</code> not be in the range [<code>first</code>, <code>last</code>). However, because copying is done backward, it is possible for the target and source to overlap.</p>
<h6 id="app07lev4sec1"><code>swap()</code></h6>
<p class="programlisting">template&lt;class T&gt; void swap(T&#38; a, T&#38; b);</p>
<p>The <code>swap()</code> function exchanges values stored at two locations specified by references. (C++ moves this function to the <code>utility</code> header file.)</p>
<h5 id="app07lev3sec24"><code>swap_ranges()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator1, class ForwardIterator2&gt;<br/>ForwardIterator2 swap_ranges(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator1 first1, ForwardIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator2 first2);</p>
<p>The <code>swap_ranges()</code> function exchanges values in the range [<code>first1</code>, <code>last1</code>) with the corresponding values in the range beginning at <code>first2</code>. The two ranges should not overlap.</p>
<h5 id="app07lev3sec25"><code>iter_swap()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator1, class ForwardIterator2&gt;<br/>void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</p>
<p>The <code>iter_swap()</code> function exchanges values stored at two locations specified by iterators.</p>
<h5 id="app07lev3sec26"><code>transform()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;<br/>OutputIterator transform(InputIterator first, InputIterator last,<br/>OutputIterator result, UnaryOperation op);<br/><a id="page_1298"/>template&lt;class InputIterator1, class InputIterator2, class OutputIterator,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class BinaryOperation&gt;<br/>OutputIterator transform(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, OutputIterator result,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryOperation binary_op);</p>
<p>The first version of <code>transform()</code> applies the unary function object <code>op</code> to each element in the range [<code>first</code>, <code>last</code>) and assigns the return value to the corresponding element in the range beginning at <code>result</code>. So <code>*result</code> is set to <code>op(*first)</code>, and so on. It returns <code>result + (last - first)</code>&#8212;that is, the past-the-end value for the target range.</p>
<p>The second version of <code>transform()</code> applies the binary function object <code>op</code> to each element in the range [<code>first1</code>, <code>last1</code>) and to each element in the range [<code>first2</code>, <code>last2</code>) and assigns the return value to the corresponding element in the range beginning at <code>result</code>. So <code>*result</code> is set to <code>op(*first1, *first2)</code>, and so on. It returns <code>result + (last - first)</code>, the past-the-end value for the target range.</p>
<h5 id="app07lev3sec27"><code>replace()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator, class T&gt;<br/>void replace(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; old_value, const T&#38; new_value);</p>
<p>The <code>replace()</code> function replaces each occurrence of the value <code>old_value</code> in the range [<code>first</code>, <code>last</code>) with the value <code>new_value</code>.</p>
<h5 id="app07lev3sec28"><code>replace_if()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator, class Predicate, class T&gt;<br/>void replace_if(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred, const T&#38; new_value);</p>
<p>The <code>replace()_if</code> function replaces each value <code>old</code> in the range [<code>first</code>, <code>last</code>) for which <code>pred(old)</code> is <code>true</code> with the value <code>new_value</code>.</p>
<h5 id="app07lev3sec29"><code>replace_copy()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator, class T&gt;<br/>OutputIterator replace_copy(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;OutputIterator result,const T&#38; old_ value, const T&#38; new_ value);</p>
<p>The <code>replace_copy()</code> function copies the elements in the range [<code>first</code>, <code>last</code>) to a range beginning at <code>result</code> but substituting <code>new_value</code> for each occurrence of <code>old_value</code>. It returns <code>result + (last - first)</code>, the past-the-end value for the target range.</p>
<h5 id="app07lev3sec30"><code>replace_copy_if()</code></h5>
<p class="programlisting">template&lt;class Iterator, class OutputIterator, class Predicate, class T&gt;<br/>OutputIterator replace_copy_if(Iterator first, Iterator last,<br/>&#160;&#160;&#160;&#160;OutputIterator result, Predicate pred, const T&#38; new_ value);</p>
<p><a id="page_1299"/>The <code>replace_copy_if()</code> function copies the elements in the range [<code>first</code>, <code>last</code>) to a range beginning at <code>result</code> but substituting <code>new_value</code> for each value <code>old</code> for which <code>pred(old)</code> is true. It returns <code>result + (last - first)</code>, the past-the-end value for the target range.</p>
<h5 id="app07lev3sec31"><code>fill()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator, class T&gt;<br/>void fill(ForwardIterator first, ForwardIterator last, const T&#38; value);</p>
<p>The <code>fill()</code> function sets each element in the range [<code>first</code>, <code>last</code>) to <code>value</code>.</p>
<h5 id="app07lev3sec32"><code>fill_n()</code></h5>
<p class="programlisting">template&lt;class OutputIterator, class Size, class T&gt;<br/>void fill_n(OutputIterator first, Size n, const T&#38; value);</p>
<p>The <code>fill_n()</code> function sets each of the first <code>n</code> elements beginning at location <code>first</code> to <code>value</code>.</p>
<h5 id="app07lev3sec33"><code>generate()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator, class Generator&gt;<br/>void generate(ForwardIterator first, ForwardIterator last, Generator gen);</p>
<p>The <code>generate()</code> function sets each element in the range [<code>first</code>, <code>last</code>) to <code>gen()</code>, where <code>gen</code> is a generator function object&#8212;that is, one that takes no arguments. For example, <code>gen</code> can be a pointer to <code>rand()</code>.</p>
<h5 id="app07lev3sec34"><code>generate_n()</code></h5>
<p class="programlisting">template&lt;class OutputIterator, class Size, class Generator&gt;<br/>void generate_n(OutputIterator first, Size n, Generator gen);</p>
<p>The <code>generate_n()</code> function sets each of the first <code>n</code> elements in the range beginning at <code>first</code> to <code>gen()</code>, where <code>gen</code> is a generator function object&#8212;that is, one that takes no arguments. For example, <code>gen</code> can be a pointer to <code>rand()</code>.</p>
<h5 id="app07lev3sec35"><code>remove()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator, class T&gt;<br/>ForwardIterator remove(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; value);</p>
<p>The <code>remove()</code> function removes all occurrences of <code>value</code> from the range [<code>first</code>, <code>last</code>) and returns a past-the-end iterator for the resulting range. The function is stable, meaning that the order of the unremoved elements is unaltered.</p>
<div class="note"><hr/>
<p class="title"><a id="app07note01"/><a id="page_1300"/>Note</p>
<p class="notepara">Because the various <code>remove()</code> and <code>unique()</code> functions are not member functions, and also because they aren&#8217;t restricted to STL containers, they can&#8217;t reset the size of a container. Instead, they return an iterator that indicates the new past-the-end location. Typically, the removed items are simply shifted to the end of the container. However, for STL containers, you can use the returned iterator and one of the <code>erase()</code> methods to reset <code>end()</code>.</p>
<hr/></div>
<h5 id="app07lev3sec36"><code>remove_if()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator, class Predicate&gt;<br/>ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>remove_if()</code> function removes all occurrences of values <code>val</code> for which <code>pred(val)</code> is <code>true</code> from the range [<code>first</code>, <code>last</code>) and returns a past-the-end iterator for the resulting range. The function is stable, meaning that the order of the unremoved elements is unaltered.</p>
<h5 id="app07lev3sec37"><code>remove_copy()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator, class T&gt;<br/>OutputIterator remove_copy(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result, const T&#38; value);</p>
<p>The <code>remove_copy()</code> function copies values from the range [<code>first</code>, <code>last</code>) to the range beginning at <code>result</code>, skipping instances of <code>value</code> as it copies. It returns a past-the-end iterator for the resulting range. The function is stable, meaning that the order of the unremoved elements is unaltered.</p>
<h5 id="app07lev3sec38"><code>remove_copy_if()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator, class Predicate&gt;<br/>OutputIterator remove_copy_if(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result, Predicate pred);</p>
<p>The <code>remove_copy_if()</code> function copies values from the range [<code>first</code>, <code>last</code>) to the range beginning at <code>result</code>, skipping instances of <code>val</code> for which <code>pred(val)</code> is <code>true</code> as it copies. It returns a past-the-end iterator for the resulting range. The function is stable, meaning that the order of the unremoved elements is unaltered.</p>
<h5 id="app07lev3sec39"><code>unique()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator&gt;<br/>ForwardIterator unique(ForwardIterator first, ForwardIterator last);<br/><br/>template&lt;class ForwardIterator, class BinaryPredicate&gt;<br/>ForwardIterator unique(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryPredicate pred);</p>
<p><a id="page_1301"/>The <code>unique()</code> function reduces each sequence of two or more equivalent elements in the range [<code>first</code>, <code>last</code>) to a single element and returns a past-the-end iterator for the new range. The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>.</p>
<h5 id="app07lev3sec40"><code>unique_copy()</code></h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator&gt;<br/>OutputIterator unique_copy(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);<br/><br/>template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;<br/>OutputIterator unique_copy(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result, BinaryPredicate pred);</p>
<p>The <code>unique_copy()</code> function copies elements from the range [<code>first</code>, <code>last</code>) to the range beginning at <code>result</code>, reducing each sequence of two or more identical elements to a single element. It returns a past-the-end iterator for the new range. The first version uses the <code>==</code> operator for the value type to compare elements. The second version uses the binary predicate function object <code>pred</code> to compare elements. That is, elements pointed to by <code>it1</code> and <code>it2</code> match if <code>pred(*it1, *it2)</code> is <code>true</code>.</p>
<h5 id="app07lev3sec41"><code>reverse()</code></h5>
<p class="programlisting">template&lt;class BidirectionalIterator&gt;<br/>void reverse(BidirectionalIterator first, BidirectionalIterator last);</p>
<p>The <code>reverse()</code> function reverses the elements in the range [<code>first</code>, <code>last</code>) by invoking <code>swap(first, last - 1)</code>, and so on.</p>
<h5 id="app07lev3sec42"><code>reverse_copy()</code></h5>
<p class="programlisting">template&lt;class BidirectionalIterator, class OutputIterator&gt;<br/>OutputIterator reverse_copy(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BidirectionalIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);</p>
<p>The <code>reverse copy()</code> function copies the elements in the range [<code>first</code>, <code>last</code>) to the range beginning at <code>result</code> in reverse order. The two ranges should not overlap.</p>
<h5 id="app07lev3sec43"><code>rotate()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator&gt;<br/>void rotate(ForwardIterator first, ForwardIterator middle,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator last);</p>
<p>The <code>rotate()</code> function performs a left rotation on the elements in the range [<code>first</code>, <code>last</code>). The element at <code>middle</code> is moved to <code>first</code>, the element at <code>middle + 1</code> is moved to <a id="page_1302"/><code>first + 1</code>, and so on. The elements preceding <code>middle</code> are wrapped around to the end of the container so that the element at <code>first</code> follows the element formerly at <code>last - 1</code>.</p>
<h5 id="app07lev3sec44"><code>rotate_copy()</code></h5>
<p class="programlisting">template&lt;class ForwardIterator, class OutputIterator&gt;<br/>OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator last, OutputIterator result);</p>
<p>The <code>rotate_copy()</code> function copies the elements in the range [<code>first</code>, <code>last</code>) to the range beginning at <code>result</code>, using the rotated sequence described for <code>rotate()</code>.</p>
<h5 id="app07lev3sec45"><code>random_shuffle()</code></h5>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void random_shuffle(RandomAccessIterator first, RandomAccessIterator last);</p>
<p>This version of the <code>random_shuffle()</code> function shuffles the elements in the range [<code>first</code>, <code>last</code>). The distribution is uniform; that is, each possible permutation of the original order is equally likely.</p>
<h5 id="app07lev3sec46"><code>random_shuffle()</code></h5>
<p class="programlisting">template&lt;class RandomAccessIterator, class RandomNumberGenerator&gt;<br/>void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomNumberGenerator&#38;&#38; random);</p>
<p>This version of the <code>random_shuffle()</code> function shuffles the elements in the range [<code>first</code>, <code>last</code>). The function object <code>random</code> determines the distribution. Given <code>n</code> elements, the expression <code>random(n)</code> should return a value in the range [<code>0</code>,<code>n</code>). In C++98, the <code>random</code> argument was an lvalue reference; in C++11, it is an rvalue reference.</p>
<h5 id="app07lev3sec47"><code>shuffle()</code></h5>
<p class="programlisting">template&lt;class RandomAccessIterator, class Uniform RandomNumberGenerator&gt;<br/>void shuffle(RandomAccessIterator first, RandomAccessIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;UniformRandomNumberGenerator&#38;&#38; rgen);</p>
<p>This version of the <code>random_shuffle()</code> function shuffles the elements in the range [<code>first</code>, <code>last</code>). The type of the function object <code>rgen</code> should match the requirements of a uniform random number generator as defined in the C++11 standard. It (<code>rgen</code>) determines the distribution. Given <code>n</code> elements, the expression <code>rgen(n)</code> should return a value in the range [<code>0</code>,<code>n</code>).</p>
<h5 id="app07lev3sec48"><code>is</code>_<code>partitioned()</code> (C++11)</h5>
<p class="programlisting">template&lt;class InputIterator, class Predicate&gt;<br/>bool is_partitioned(InputIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator last, Predicate pred);</p>
<p><a id="page_1303"/>The <code>is</code>_<code>partitioned()</code> function returns <code>true</code> if the range is empty or if it is partitioned by <code>pred</code>&#8212;that is, arranged so that all elements satisfying <code>pred</code> precede all those that do not. Otherwise, the function returns <code>false</code>.</p>
<h5 id="app07lev3sec49"><code>partition()</code></h5>
<p class="programlisting">template&lt;class BidirectionalIterator, class Predicate&gt;<br/>BidirectionalIterator partition(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BidirectionalIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>partition()</code> function places each element whose value <code>val</code> is such that <code>pred(val)</code> is <code>true</code> before all elements that don&#8217;t meet that test. It returns an iterator to the position following the last position holding a value for which the predicate object function was <code>true</code>.</p>
<h5 id="app07lev3sec50"><code>stable_partition()</code></h5>
<p class="programlisting">template&lt;class BidirectionalIterator, class Predicate&gt;<br/>BidirectionalIterator stable_partition(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BidirectionalIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>stable_partition()</code> function places each element whose value <code>val</code> is such that <code>pred(val)</code> is <code>true</code> before all elements that don&#8217;t meet that test. This function preserves the relative ordering within each of the two groups. It returns an iterator to the position following the last position holding a value for which the predicate object function was <code>true</code>.</p>
<h5 id="app07lev3sec51"><code>partition_copy()</code> (C++11)</h5>
<p class="programlisting">template&lt;class InputIterator, class OutputIterator1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;classs OutputIterator2, class Predicate&gt;<br/>pair&lt;OutputIterator1, OutputIterator2&gt; partition_copy(<br/>&#160;&#160;&#160;&#160;&#160;InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;OutputIterator1 out_true, OutputIterator2 out_false<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p>The <code>partition_copy()</code> function copies each element whose value <code>val</code> is such that <code>pred(val)</code> is <code>true</code> to the range beginning with <code>out_true</code> and the remaining elements to the range beginning with <code>out_false</code>. It returns a <code>pair</code> object containing an iterator to the end of the range that begins with <code>out_true</code> and an iterator to the end of the range that begins with <code>out_false</code>.</p>
<h5 id="app07lev3sec52"><code>partition_point()</code> (C++11)</h5>
<p class="programlisting">template&lt;class ForwardIterator, class Predicate&gt;<br/>ForewardIterator partition_point(ForwardIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Predicate pred);</p>
<p><a id="page_1304"/>The <code>partition_point()</code> function requires that the range be partitioned by <code>pred</code>. It returns an iterator to the position following the last position holding a value for which the predicate object function was <code>true</code>.</p>
<h4 id="app07lev2sec5">Sorting and Related Operations</h4>
<p><a href="#app07table15">Table G.15</a> summarizes the sorting and related operations. Arguments are not shown, and overloaded functions are listed just once. Each function has a version that uses <code>&lt;</code> for ordering elements and a version that uses a comparison function object for ordering elements. A fuller description, including the prototypes, follows the table. Thus, you can scan the table to get an idea of what a function does and then look up the details if you find the function appealing.</p>
<p class="caption"><a id="page_1305"/><a id="app07table15"/><strong>Table G.15. Sorting and Related Operations</strong></p>
<p class="image"><img src="graphics/app-g-tab15.jpg" alt="Image"/></p>
<p class="image"><img src="graphics/app-g-tab15a.jpg" alt="Image"/></p>
<p class="image"><img src="graphics/app-g-tab15b.jpg" alt="Image"/></p>
<p><a id="page_1306"/>The functions in this section determine the order of two elements by using the <code>&lt;</code> operator defined for the elements or by using a comparison object designated by the template type <code>Compare</code>. If <code>comp</code> is an object of type <code>Compare</code>, then <code>comp(a,b)</code> is a generalization of <code>a &lt; b</code> and returns <code>true</code> if <code>a</code> precedes <code>b</code> in the ordering scheme. If <code>a &lt; b</code> is <code>false</code> and <code>b &lt; a</code> is also <code>false</code>, <code>a</code> and <code>b</code> are equivalent. A comparison object must provide at least <em>strict weak ordering</em>. This means the following:</p>
<p class="indenthandingB">&#8226; The expression <code>comp(a,a)</code> must be <code>false</code>, a generalization of the fact that a value can&#8217;t be less than itself. (This is the strict part.)</p>
<p class="indenthandingB">&#8226; If <code>comp(a,b)</code> is <code>true</code> and <code>comp(b,c)</code> is <code>true</code>, then <code>comp(a,c)</code> is <code>true</code> (that is, comparison is a transitive relationship).</p>
<p class="indenthandingB">&#8226; If <code>a</code> is equivalent to <code>b</code> and <code>b</code> is equivalent to <code>c</code>, then <code>a</code> is equivalent to <code>c</code> (that is, equivalency is a transitive relationship).</p>
<p>If you think of applying <code>&lt;</code> to integers, then equivalency implies equality, but this doesn&#8217;t have to hold for more general cases. For example, you could define a structure with several members describing a mailing address and define a <code>comp</code> comparison object that orders the structures according to zip code. Then any two addresses with the same zip code would be equivalent but not equal.</p>
<p>Now let&#8217;s take a more detailed look at these sorting and related operations. For each function, the discussion shows the prototype(s), followed by a brief explanation. This section is divided into several subsections. As you saw earlier, pairs of iterators indicate ranges, with the chosen template parameter name indicating the type of iterator. As usual, a range in the form [<code>first</code>, <code>last</code>) goes from <code>first</code> up to, but not including, <code>last</code>. Functions passed as arguments are function objects, which can be pointers or objects for which the <code>()</code> operation is defined. As you learned in <a href="ch16.html#ch16">Chapter 16</a>, a predicate is a Boolean function with one argument, and a binary predicate is a Boolean function with two arguments. (The functions need not be type <code>bool</code>, as long as they return <code>0</code> for <code>false</code> and a nonzero value for <code>true</code>.) Also as in <a href="ch16.html#ch16">Chapter 16</a>, a unary function object is one that takes a single argument, and a binary function object is one that takes two arguments.</p>
<h5 id="app07lev3sec53">Sorting</h5>
<p><a id="page_1307"/>First, let&#8217;s examine the sorting algorithms.</p>
<h6 id="app07lev4sec2"><code>sort()</code></h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void sort(RandomAccessIterator first, RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>void sort(RandomAccessIterator first, RandomAccessIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>sort()</code> function sorts the range [<code>first</code>, <code>last</code>) in increasing order, using the value type <code>&lt;</code> operator for comparison. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec3"><code>stable_sort()</code></h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void stable_sort(RandomAccessIterator first, RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>void stable_sort(RandomAccessIterator first, RandomAccessIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>stable_sort()</code> function sorts the range [<code>first</code>, <code>last</code>), preserving the relative order of equivalent elements. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec4"><code>partial_sort()</code></h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,<br/>RandomAccessIterator last, Compare comp);</p>
<p>The <code>partial_sort()</code> function partially sorts the range [<code>first</code>, <code>last</code>). The first <code>middle - first</code> elements of the sorted range are placed in the range [<code>first</code>, <code>middle</code>), and the remaining elements are unsorted. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec5"><code>partial_sort_copy()</code></h6>
<p class="programlisting">template&lt;class InputIterator, class RandomAccessIterator&gt;<br/>RandomAccessIterator partial_sort_copy(InputIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator last,<br/><a id="page_1308"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomAccessIterator result_first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomAccessIterator result_last);<br/><br/>template&lt;class InputIterator, class RandomAccessIterator, class Compare&gt;<br/>RandomAccessIterator<br/>partial_sort_copy(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomAccessIterator result_first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomAccessIterator result_last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>partial_sort_copy()</code> function copies the first <em>n</em> elements of the sorted range [<code>first</code>, <code>last</code>) to the range [<code>result_first</code>, <code>result_first + n</code>). The value of <code>n</code> is the lesser of <code>last - first</code> and <code>result_last - result_first</code>. The function returns <code>result_first + n</code>. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec6"><code>is_sorted()</code> (C++11)</h6>
<p class="programlisting">template&lt;class ForwardIterator&gt;<br/>bool is_sorted(ForwardIterator first, ForwardIterator last);<br/><br/>template&lt;class ForwardIterator, class Compare&gt;<br/>bool is_sorted(ForwardIterator first, ForwardIterator last<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>is_sorted()</code> function returns <code>true</code> if the range [<code>first</code>, <code>last</code>) is sorted and <code>false</code> otherwise. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec7"><code>is_sorted_until()</code> (C++11)</h6>
<p class="programlisting">template&lt;class ForwardIterator&gt;<br/>ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last);<br/><br/>template&lt;class ForwardIterator, class Compare&gt;<br/>ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>is_sorted_until()</code> function returns <code>last</code> if the range [<code>first</code>, <code>last</code>) has fewer than two elements. Otherwise, it returns the last iterator, <code>it</code>, for which the range [<code>first</code>, <code>it</code>) is sorted. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec8"><code>nth_element()</code></h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void nth_element(RandomAccessIterator first, RandomAccessIterator nth,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomAccessIterator last);<br/><a id="page_1309"/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>void nth_element(RandomAccessIterator first, RandomAccessIterator nth,<br/>RandomAccessIterator last, Compare comp);</p>
<p>The <code>nth_element()</code> function finds the element in the range [<code>first</code>, <code>last</code>) that would be at position <code>nth</code> were the range sorted, and it places that element at position <code>nth</code>. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h5 id="app07lev3sec54">Binary Searching</h5>
<p>The algorithms in the binary searching group assume that the range is sorted. They only require a forward iterator but are most efficient for random-access iterators.</p>
<h6 id="app07lev4sec9"><code>lower_bound()</code></h6>
<p class="programlisting">template&lt;class ForwardIterator, class T&gt;<br/>ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; value);<br/><br/>template&lt;class ForwardIterator, class T, class Compare&gt;<br/>ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; value, Compare comp);</p>
<p>The <code>lower_bound()</code> function finds the first position the a sorted range [<code>first</code>, <code>last</code>) in front of which <code>value</code> can be inserted without violating the order. It returns an iterator that points to this position. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec10"><code>upper_bound()</code></h6>
<p class="programlisting">template&lt;class ForwardIterator, class T&gt;<br/>ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; value);<br/><br/>template&lt;class ForwardIterator, class T, class Compare&gt;<br/>ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,<br/>const T&#38; value, Compare comp);</p>
<p>The <code>upper_bound()</code> function finds the last position in the sorted range [<code>first</code>, <code>last</code>) in front of which <code>value</code> can be inserted without violating the order. It returns an iterator that points to this position. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec11"><code>equal_range()</code></h6>
<p class="programlisting">template&lt;class ForwardIterator, class T&gt;<br/>pair&lt;ForwardIterator, ForwardIterator&gt; equal_range(<br/>&#160;&#160;&#160;&#160;ForwardIterator first, ForwardIterator last, const T&#38; value);<br/><a id="page_1310"/>template&lt;class ForwardIterator, class T, class Compare&gt;<br/>pair&lt;ForwardIterator, ForwardIterator&gt; equal_range(<br/>&#160;&#160;&#160;&#160;ForwardIterator first, ForwardIterator last, const T&#38; value,<br/>&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>equal_range()</code> function finds the largest subrange [<code>it1</code>, <code>it2</code>) in the sorted range [<code>first</code>, <code>last</code>) such that <code>value</code> can be inserted in front of any iterator in this range without violating the order. The function returns a <code>pair</code> formed of <code>it1</code> and <code>it2</code>. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec12"><code>binary_search()</code></h6>
<p class="programlisting">template&lt;class ForwardIterator, class T&gt;<br/>bool binary_search(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; value);<br/><br/>template&lt;class ForwardIterator, class T, class Compare&gt;<br/>bool binary_search(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const T&#38; value, Compare comp);</p>
<p>The <code>binary_search()</code> function returns <code>true</code> if the equivalent of <code>value</code> is found in the sorted range [<code>first</code>, <code>last</code>); it returns <code>false</code> otherwise. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<div class="note"><hr/>
<p class="title"><a id="app07note02"/>Note</p>
<p class="notepara">Recall that if <code>&lt;</code> is used for ordering, the values <code>a</code> and <code>b</code> are equivalent if both <code>a &lt; b</code> and <code>b &lt; a</code> are <code>false</code>. For ordinary numbers, equivalency implies equality, but this is not the case for structures sorted on the basis of just one member. Thus, there may be more than one location where a new value can be inserted and still keep the data ordered. Similarly, if the comparison object <code>comp</code> is used for ordering, equivalency means both <code>comp(a,b)</code> and <code>comp(b,a)</code> are <code>false</code>. (This is a generalization of the statement that <code>a</code> and <code>b</code> are equivalent if <code>a</code> is not less than <code>b</code> and <code>b</code> is not less than <code>a</code>.)</p>
<hr/></div>
<h5 id="app07lev3sec55">Merging</h5>
<p>The merging functions assume that ranges are sorted.</p>
<h6 id="app07lev4sec13"><code>merge()</code></h6>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator&gt;<br/>OutputIterator merge(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);<br/><br/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator,<br/><a id="page_1311"/>class Compare&gt;<br/>OutputIterator merge(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result, Compare comp);</p>
<p>The <code>merge()</code> function merges elements from the sorted range [<code>first1</code>, <code>last1</code>) and from the sorted range [<code>first2</code>, <code>last2</code>), placing the result in a range starting at <code>result</code>. The target range should not overlap either of the merged ranges. When equivalent elements are found in both ranges, elements from the first range precede elements of the second. The return value is the past-the-end iterator for the resulting merge. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec14"><code>inplace_merge()</code></h6>
<p class="programlisting">template&lt;class BidirectionalIterator&gt;<br/>void inplace_merge(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;BidirectionalIterator middle, BidirectionalIterator last);<br/><br/>template&lt;class BidirectionalIterator, class Compare&gt;<br/>void inplace_merge(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;BidirectionalIterator middle, BidirectionalIterator last,<br/>&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>inplace_merge()</code> function merges two consecutive sorted ranges&#8212;[<code>first</code>, <code>middle</code>) and [<code>middle</code>, <code>last</code>)&#8212;into a single sorted sequence stored in the range [<code>first</code>, <code>last</code>). Elements from the first range precede equivalent elements from the second range. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h5 id="app07lev3sec56">Working with Sets</h5>
<p>Set operations work with all sorted sequences, including <code>set</code> and <code>multiset</code>. For containers that hold more than one instance of a value, such as <code>multiset</code>, definitions are generalized. A union of two multisets contains the larger number of occurrences of each element, and an intersection contains the lesser number of occurrences of each element. For example, suppose Multiset <code>A</code> contains the string <code>"apple"</code> seven times and Multiset <code>B</code> contains the same string four times. Then the union of <code>A</code> and <code>B</code> will contain seven instances of <code>"apple"</code>, and the intersection will contain four instances.</p>
<h6 id="app07lev4sec15"><code>includes()</code></h6>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2&gt;<br/>bool includes(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2);<br/><br/>template&lt;class InputIterator1, class InputIterator2, class Compare&gt;<br/>bool includes(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2, Compare comp);</p>
<p><a id="page_1312"/>The <code>includes()</code> function returns <code>true</code> if every element in the range [<code>first2</code>, <code>last2</code>) is also found in the range [<code>first1</code>, <code>last1</code>); it returns <code>false</code> otherwise. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec16"><code>set_union()</code></h6>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator&gt;<br/>OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);<br/><br/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator, class Compare&gt;<br/>OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result, Compare comp);</p>
<p>The <code>set_union()</code> function constructs the set that is the union of the ranges [<code>first1</code>, <code>last1</code>) and [<code>first2</code>, <code>last2</code>) and copies the result to the location pointed to by <code>result</code>. The resulting range should not overlap either of the original ranges. The function returns a past-the-end iterator for the constructed range. The union is the set that contains all elements found in either or both sets. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec17"><code>set_intersection()</code></h6>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator&gt;<br/>OutputIterator set_intersection(InputIterator1 first1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;InputIterator1 last1,InputIterator2 first2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 last2, OutputIterator result);<br/><br/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator, class Compare&gt;<br/>OutputIterator set_intersection(InputIterator1 first1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;InputIterator1 last1, InputIterator2 first2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 last2, OutputIterator result,<br/>&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>set_intersection()</code> function constructs the set that is the intersection of the ranges [<code>first1</code>, <code>last1</code>) and [<code>first2</code>, <code>last2</code>) and copies the result to the location pointed to by <code>result</code>. The resulting range should not overlap either of the original ranges. The function returns a past-the-end iterator for the constructed range. The intersection is the set that contains the elements that are common to both sets. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec18"><code>set_difference()</code></h6>
<p class="programlisting"><a id="page_1313"/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator&gt;<br/>OutputIterator set_difference(InputIterator1 first1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;InputIterator1 last1, InputIterator2 first2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 last2, OutputIterator result);<br/><br/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator, class Compare&gt;<br/>OutputIterator set_difference(InputIterator1 first1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;InputIterator1 last1, InputIterator2 first2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 last2, OutputIterator result,<br/>&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>set_difference()</code> function constructs the set that is the difference between the ranges [<code>first1</code>, <code>last1</code>) and [<code>first2</code>, <code>last2</code>) and copies the result to the location pointed to by <code>result</code>. The resulting range should not overlap either of the original ranges. The function returns a past-the-end iterator for the constructed range. The difference is the set that contains the elements found in the first set but not in the second. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator&gt;<br/>OutputIterator set_symmetric_difference(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);<br/><br/>template&lt;class InputIterator1, class InputIterator2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class OutputIterator, class Compare&gt;<br/>OutputIterator set_symmetric_difference(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result, Compare comp);</p>
<p>The <code>set_symmetric_difference()</code> function constructs the set that is the symmetric difference between the ranges [<code>first1</code>, <code>last1</code>) and [<code>first2</code>, <code>last2</code>) and copies the result to the location pointed to by <code>result</code>. The resulting range should not overlap either of the original ranges. The function returns a past-the-end iterator for the constructed range. The symmetric difference is the set that contains the elements found in the first set but not in the second and the elements found in the second set but not the first. It&#8217;s the same as the difference between the union and the intersection. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h5 id="app07lev3sec57">Working with Heaps</h5>
<p><a id="page_1314"/>A <em>heap</em> is a common data form with the property that the first element in a heap is the largest. Whenever the first element is removed or any element is added, the heap may have to be rearranged to maintain that property. A heap is designed so that these two operations are done efficiently.</p>
<h6 id="app07lev4sec19"><code>make_heap()</code></h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void make_heap(RandomAccessIterator first, RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>void make_heap(RandomAccessIterator first, RandomAccessIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>make_heap()</code> function makes a heap of the range [<code>first</code>, <code>last</code>). The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec20"><code>push_heap()</code></h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void push_heap(RandomAccessIterator first, RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>void push_heap(RandomAccessIterator first, RandomAccessIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>push_heap()</code> function assumes that the range [<code>first</code>, <code>last - 1</code>) is a valid heap, and it adds the value at location <code>last - 1</code> (that is, one past the end of the heap that is assumed to be valid) into the heap, making [<code>first</code>, <code>last</code>) a valid heap. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec21"><code>pop_heap()</code></h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>void pop_heap(RandomAccessIterator first, RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>void pop_heap(RandomAccessIterator first, RandomAccessIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>pop_heap()</code> function assumes that the range [<code>first</code>, <code>last</code>) is a valid heap. It swaps the value at location <code>last - 1</code> with the value at <code>first</code> and makes the range [<code>first</code>, <code>last - 1</code>) a valid heap. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec22"><code>sort_heap()</code></h6>
<p class="programlisting"><a id="page_1315"/>template&lt;class RandomAccessIterator&gt;<br/>void sort_heap(RandomAccessIterator first, RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>void sort_heap(RandomAccessIterator first, RandomAccessIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>sort_heap()</code> function assumes that the range [<code>first</code>, <code>last</code>) is a heap and sorts it. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec23"><code>is_heap()</code> (C++11)</h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>bool is_heap(RandomAccessIterator first, RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>bool is_heap(RandomAccessIterator first, RandomAccessIterator last<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>is_heap()</code> function returns <code>true</code> if the range [<code>first</code>, <code>last</code>) is a heap and <code>false</code> otherwise. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h6 id="app07lev4sec24"><code>is_heap_until()</code> (C++11)</h6>
<p class="programlisting">template&lt;class RandomAccessIterator&gt;<br/>RandomAccessIterator is_heap_until(RandomAccessIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomAccessIterator last);<br/><br/>template&lt;class RandomAccessIterator, class Compare&gt;<br/>RandomAccessIterator is_heap_until(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RandomAccessIterator first, RandomAccessIterator last<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>is_heap_until()</code> function returns <code>last</code> if the range [<code>first</code>, <code>last</code>) has fewer than two elements. Otherwise, it returns the last iterator, <code>it</code>, for which the range [<code>first</code>, <code>it</code>) is a heap. The first version uses <code>&lt;</code>, and the second version uses the comparison object <code>comp</code> to determine the order.</p>
<h5 id="app07lev3sec58">Finding Minimum and Maximum Values</h5>
<p>The minimum and maximum functions return the minimum and maximum values of pairs of values and of sequences of values.</p>
<h6 id="app07lev4sec25"><code>min()</code></h6>
<p class="programlisting"><a id="page_1316"/>template&lt;class T&gt; const T&#38; min(const T&#38; a, const T&#38; b);<br/><br/>template&lt;class T, class Compare&gt;<br/>const T&#38; min(const T&#38; a, const T&#38; b, Compare comp);</p>
<p>These versions of the <code>min()</code> function return the lesser of two values. If the two values are equivalent, they return the first value. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<p class="programlisting">template&lt;class T&gt; T min(initializer_list&lt;T&gt; t);<br/><br/>template&lt;class T, class Compare&gt;<br/>T min(initializer_list&lt;T&gt; t), Compare comp);</p>
<p>These versions of <code>min()</code> function (C++11) return the smallest value in the initializer list <code>t</code>. If the two or more values are equivalent, they return a copy of the first-occurring item having that value. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec26"><code>max()</code></h6>
<p class="programlisting">template&lt;class T&gt; const T&#38; max(const T&#38; a, const T&#38; b);<br/><br/>template&lt;class T, class Compare&gt;<br/>const T&#38; max(const T&#38; a, const T&#38; b, Compare comp);</p>
<p>These versions of the <code>max()</code> function return the greater of two values. If the two values are equivalent, they return the first value. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<p class="programlisting">template&lt;class T&gt; T max(initializer_list&lt;T&gt; t);<br/><br/>template&lt;class T, class Compare&gt;<br/>T max(initializer_list&lt;T&gt; t), Compare comp);</p>
<p>These versions of <code>max()</code> function (C++11) return the largest value in the initializer list <code>t</code>. If the two or more values are equivalent, they return a copy of the first-occurring item having that value. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec27"><code>minmax()</code> (C++11)</h6>
<p class="programlisting">template&lt;class T&gt;<br/>&#160;&#160;pair&lt;const T&#38;,const T&#38;&gt; minmax(const T&#38; a, const T&#38; b);<br/><br/>template&lt;class T, class Compare&gt;<br/>&#160;&#160;pair&lt;const T&#38;,const T&#38;&gt; minmax(const T&#38; a, const T&#38; b,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p><a id="page_1317"/>These versions of the <code>minmax()</code> function return the pair (<code>b</code>,<code>a</code>) if <code>b</code> is less than <code>a</code>, and the pair (<code>a</code>,<code>b</code>) otherwise. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<p class="programlisting">template&lt;class T&gt; pair&lt;T,T&gt; minmax(initializer_list&lt;T&gt; t);<br/><br/>template&lt;class T, class Compare&gt;<br/>pair&lt;T,T&gt; minmax(initializer_list&lt;T&gt; t), Compare comp);</p>
<p>These versions of <code>minmax()</code> function return copies of the smallest element and largest element in the initializer list <code>t</code>. If several elements are equivalent to the smallest, the first-occurring is returned. If several elements are equivalent to the largest, the last-occurring is returned. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec28"><code>min_element()</code></h6>
<p class="programlisting">template&lt;class ForwardIterator&gt;<br/>ForwardIterator min_element(ForwardIterator first, ForwardIterator last);<br/><br/>template&lt;class ForwardIterator, class Compare&gt;<br/>ForwardIterator min_element(ForwardIterator first, ForwardIterator last,<br/>Compare comp);</p>
<p>The <code>min_element()</code> function returns the first iterator <code>it</code> in the range [<code>first</code>, <code>last</code>) such that no element in the range is less than <code>*it</code>. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec29"><code>max_element()</code></h6>
<p class="programlisting">template&lt;class ForwardIterator&gt;<br/>ForwardIterator max_element(ForwardIterator first, ForwardIterator last);<br/><br/>template&lt;class ForwardIterator, class Compare&gt;<br/>ForwardIterator max_element(ForwardIterator first, ForwardIterator last,<br/>Compare comp);</p>
<p>The <code>max_element()</code> function returns the first iterator <code>it</code> in the range [<code>first</code>, <code>last</code>) such that there is no element that <code>*it</code> is less than. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec30"><code>minmax_element()</code> (C++11)</h6>
<p class="programlisting">template&lt;class ForwardIterator&gt;<br/>&#160;&#160;pair&lt;ForwardIterator,ForwardIterator&gt;<br/>&#160;&#160;&#160;&#160;&#160;minmax_element(ForwardIterator first, ForwardIterator last);<br/><br/>template&lt;class ForwardIterator, class Compare&gt;<br/>&#160;&#160;pair&lt;ForwardIterator,ForwardIterator&gt;<br/>&#160;&#160;&#160;&#160;minmax_element(ForwardIterator first, ForwardIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p><a id="page_1318"/>The <code>max_element()</code> function returns a <code>pair</code> object containing the first iterator, <code>it1</code>, in the range [<code>first</code>, <code>last</code>), such that there is no element that <code>*it1</code> is less than, and the last iterator, <code>it2</code>, in the range [<code>first</code>, <code>last</code>), such that there is no element that <code>*it2</code> is less than. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec31"><code>lexicographical_compare()</code></h6>
<p class="programlisting">template&lt;class InputIterator1, class InputIterator2&gt;<br/>bool lexicographical_compare(<br/>&#160;&#160;&#160;&#160;&#160;InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2);<br/><br/>template&lt;class InputIterator1, class InputIterator2, class Compare&gt;<br/>bool lexicographical_compare(<br/>&#160;&#160;&#160;&#160;&#160;InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, InputIterator2 last2,<br/>&#160;&#160;&#160;&#160;&#160;Compare comp);</p>
<p>The <code>lexicographical_compare()</code> function returns <code>true</code> if the sequence of elements in the range [<code>first1</code>, <code>last1</code>) is lexicographically less than the sequence of elements in the range [<code>first2</code>, <code>last2</code>); it returns <code>false</code> otherwise. A lexicographic comparison compares the first element of one sequence to the first of the second&#8212;that is, it compares <code>*first1</code> to <code>*first2</code>. If <code>*first1</code> is less than <code>*first2</code>, the function returns <code>true</code>. If <code>*first2</code> is less than <code>*first1</code>, the function returns <code>false</code>. If the two are equivalent, comparison proceeds to the next element in each sequence. This process continues until two corresponding elements are not equivalent or until the end of a sequence is reached. If two sequences are equivalent until the end of one is reached, the shorter sequence is less. If the two sequences are equivalent and of the same length, neither is less, so the function returns <code>false</code>. The first version of the function uses <code>&lt;</code> to compare elements, and the second version uses the <code>comp</code> comparison object. The lexicographic comparison is a generalization of an alphabetic comparison.</p>
<h5 id="app07lev3sec59">Working with Permutations</h5>
<p>A <em>permutation</em> of a sequence is a reordering of the elements. For example, a sequence of three elements has six possible orderings because you have a choice of three elements for the first element. Choosing a particular element for the first position leaves a choice of two for the second, and one for the third. For example, the six permutations of the digits 1, 2, 3 are as follows:</p>
<p class="indenthanding">123 132 213 232 312 321</p>
<p>In general, a sequence of <em>n</em> elements has <em>n</em> &#215; (<em>n</em>-1) &#215; ... &#215; 1, or <em>n</em>! possible permutations.</p>
<p>The permutation functions assume that the set of all possible permutations can be arranged in lexicographic order, as in the previous example of six permutations. That <a id="page_1319"/>means, in general, that there is a specific permutation that precedes and follows each permutation. For example, 213 immediately precedes 232, and 312 immediately follows it. However, the first permutation (123 in the example) has no predecessor, and the last permutation (321 in the example) has no follower.</p>
<h6 id="app07lev4sec32"><code>next_permutation()</code></h6>
<p class="programlisting">template&lt;class BidirectionalIterator&gt;<br/>bool next_permutation(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BidirectionalIterator last);<br/><br/>template&lt;class BidirectionalIterator, class Compare&gt;<br/>bool next_permutation(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BidirectionalIterator last, Compare comp);</p>
<p>The <code>next_permutation()</code> function transforms the sequence in the range [<code>first</code>, <code>last</code>) to the next permutation in lexicographic order. If the next permutation exists, the function returns <code>true</code>. If it doesn&#8217;t exist (that is, the range contains the last permutation in lexicographic order), the function returns <code>false</code> and transforms the range to the first permutation in lexicographic order. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h6 id="app07lev4sec33"><code>prev_permutation()</code></h6>
<p class="programlisting">template&lt;class BidirectionalIterator&gt;<br/>bool prev_permutation(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BidirectionalIterator last);<br/><br/>template&lt;class BidirectionalIterator, class Compare&gt;<br/>bool prev_permutation(BidirectionalIterator first,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BidirectionalIterator last, Compare comp);</p>
<p>The <code>previous_permutation()</code> function transforms the sequence in the range [<code>first</code>, <code>last</code>) to the previous permutation in lexicographic order. If the previous permutation exists, the function returns <code>true</code>. If it doesn&#8217;t exist (that is, the range contains the first permutation in lexicographic order), the function returns <code>false</code> and transforms the range to the last permutation in lexicographic order. The first version uses <code>&lt;</code> to determine the ordering, and the second version uses the <code>comp</code> comparison object.</p>
<h4 id="app07lev2sec6">Numeric Operations</h4>
<p><a href="#app07table16">Table G.16</a> summarizes the numeric operations, which are described by the <code>numeric</code> header file. Arguments are not shown, and overloaded functions are listed just once. Each function has a version that uses <code>&lt;</code> for ordering elements and a version that uses a comparison function object for ordering elements. A fuller description, including the prototypes, follows the table. Thus, you can scan the table to get an idea of what a function does and then look up the details if you find the function appealing.</p>
<p class="caption"><a id="page_1320"/><a id="app07table16"/><strong>Table G.16. Sorting and Related Operations</strong></p>
<p class="image"><img src="graphics/app-g-tab16.jpg" alt="Image"/></p>
<p>Now let&#8217;s take a more detailed look at these numeric operations. For each function, the discussion shows the prototype(s), followed by a brief explanation.</p>
<h5 id="app07lev3sec60"><code>accumulate()</code></h5>
<p class="programlisting">template &lt;class InputIterator, class T&gt;<br/>T accumulate(InputIterator first, InputIterator last, T init);<br/><br/>template &lt;class InputIterator, class T, class BinaryOperation&gt;<br/>T accumulate(InputIterator first, InputIterator last, T init,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryOperation binary_op);</p>
<p>The <code>accumulate()</code> function initializes a value <code>acc</code> to <code>init</code>; then it performs the operation <code>acc = acc + *i</code> (first version) or <code>acc = binary_op(acc, *i)</code> (second version) for each iterator <code>i</code> in the range [<code>first</code>, <code>last</code>), in order. It then returns the resulting value of <code>acc</code>.</p>
<h5 id="app07lev3sec61"><code>inner_product()</code></h5>
<p class="programlisting">template &lt;class InputIterator1, class InputIterator2, class T&gt;<br/>T inner_product(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, T init);<br/><br/>template &lt;class InputIterator1, class InputIterator2, class T,<br/>class BinaryOperation1, class BinaryOperation2&gt;<br/>T inner_product(InputIterator1 first1, InputIterator1 last1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;InputIterator2 first2, T init,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);</p>
<p>The <code>inner_product()</code> function initializes a value <code>acc</code> to <code>init</code>; then it performs the operation <code>acc = *i * *j</code> (first version) or <code>acc = binary_op(*i, *j)</code> (second version) for each iterator <code>i</code> in the range [<code>first1</code>, <code>last1</code>), in order, and each corresponding iterator <code>j</code> <a id="page_1321"/>in the range [<code>first2</code>, <code>first2 + (last1 - first1)</code>). That is, it calculates a value from the first elements from each sequence, then from the second elements of each sequence, and so on, until it reaches the end of the first sequence. (Hence the second sequence should be at least as long as the first.) The function then returns the resulting value of <code>acc</code>.</p>
<h5 id="app07lev3sec62"><code>partial_sum()</code></h5>
<p class="programlisting">template &lt;class InputIterator, class OutputIterator&gt;<br/>OutputIterator partial_sum(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);<br/><br/>template &lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;<br/>OutputIterator partial_sum(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryOperation binary_op);</p>
<p>The <code>partial_sum()</code> function assigns <code>*first</code> to <code>*result</code> or <code>*first + *(first + 1)</code> to <code>*(result + 1)</code> (first version) or it assigns <code>binary_op(*first, *(first + 1))</code> to <code>*(result + 1)</code> (second version), and so on. That is, the <code>n</code>th element of the sequence beginning at <code>result</code> contains the sum (or <code>binary_op</code> equivalent) of the first <code>n</code> elements of the sequence beginning at <code>first</code>. The function returns the past-the-end iterator for the result. The algorithm allows <code>result</code> to be <code>first</code>&#8212;that is, it allows the result to be copied over the original sequence, if desired.</p>
<h5 id="app07lev3sec63"><code>adjacent_difference()</code></h5>
<p class="programlisting">template &lt;class InputIterator, class OutputIterator&gt;<br/>OutputIterator adjacent_difference(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result);<br/><br/>template &lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;<br/>OutputIterator adjacent_difference(InputIterator first, InputIterator last,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;OutputIterator result,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryOperation binary_op);</p>
<p>The <code>adjacent_difference()</code> function assigns <code>*first</code> to the location <code>result</code> (<code>*result = *first</code>). Subsequent locations in the target range are assigned the differences (or <code>binary_op</code> equivalent) of adjacent locations in the source range. That is, the next location in the target range (<code>result + 1</code>) is assigned <code>*(first + 1) - *first</code> (first version) or <code>binary_op(*(first + 1), *first)</code> (second version), and so on. The function returns the past-the-end iterator for the result. The algorithm allows <code>result</code> to be <code>first</code>&#8212;that is, it allows the result to be copied over the original sequence, if desired.</p>
<h5 id="app07lev3sec64"><code>iota()</code> (C++11)</h5>
<p class="programlisting"><a id="page_1322"/>template &lt;class ForwardIterator, class T&gt;<br/>void iota(ForwardIterator first, ForwardIterator last,T value);</p>
<p>The <code>iota()</code> function assigns <code>value</code> to <code>*first</code>, increases <code>value</code> as if by <code>++value</code>, assigns the new <code>value</code> to the next element in the range, and so on until the last element.</p>
</body>
</html>
